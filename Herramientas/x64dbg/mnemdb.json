{
  "__github_x86-64": "https://github.com/nologic/idaref/blob/master/x86-64.sql", 
  "__license_x86-64": "GPLv2", 
  "_github_x86-64-brief": "https://github.com/radare/radare2/blob/master/libr/asm/d/x86", 
  "_license_x86-64-brief": "GPLv3", 
  "x86-64": [
    {
      "description": "\nAAA - ASCII Adjust After Addition:\n| Opcode| Instruction| Op/En| 64-bit Mode| Compat/Leg Mode| Description                    \n| 37    | AAA        | NP   | Invalid    | Valid          | ASCII adjust AL after addition.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nAdjusts the sum of two unpacked BCD values to create an unpacked BCD result.\nThe AL register is the implied source and destination operand for this instruction.\nThe AAA instruction is only useful when it follows an ADD instruction that adds\n(binary addition) two unpacked BCD values and stores a byte result in the AL\nregister. The AAA instruction then adjusts the contents of the AL register to\ncontain the correct 1-digit unpacked BCD result.\n\nIf the addition produces a decimal carry, the AH register increments by 1, and\nthe CF and AF flags are set. If there was no decimal carry, the CF and AF flags\nare cleared and the AH register is unchanged. In either case, bits 4 through\n7 of the AL register are set to 0.\n\nThis instruction executes as described in compatibility mode and legacy mode.\nIt is not valid in 64-bit mode.\n\nOperation:\n\nIF 64-Bit Mode\n  THEN\n     #UD;\n  ELSE\n     IF ((AL AND 0FH) > 9) or (AF = 1)\n       THEN\n          AL <- AL + 6;\n          AH <- AH + 1;\n          AF <- 1;\n          CF <- 1;\n          AL <- AL AND 0FH;\n       ELSE\n          AF <- 0;\n          CF <- 0;\n          AL <- AL AND 0FH;\n     FI;\nFI;\n\nFlags Affected:\nThe AF and CF flags are set to 1 if the adjustment results in a decimal carry;\notherwise they are set to 0. The OF, SF, ZF, and PF flags are undefined.\n\n\nProtected Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nReal-Address Mode Exceptions:\nSame exceptions as protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as protected mode.\n\n\n64-Bit Mode Exceptions:\n| #UD| If in 64-bit mode.\n", 
      "mnem": "AAA"
    }, 
    {
      "description": "\nAAD - ASCII Adjust AX Before Division:\n| Opcode| Instruction| Op/En| 64-bit Mode| Compat/Leg Mode| Description                        \n| D5 0A | AAD        | NP   | Invalid    | Valid          | ASCII adjust AX before division.   \n| D5 ib | AAD imm8   | NP   | Invalid    | Valid          | Adjust AX before division to number\n|       |            |      |            |                | base imm8.                         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nAdjusts two unpacked BCD digits (the least-significant digit in the AL register\nand the most-significant digit in the AH register) so that a division operation\nperformed on the result will yield a correct unpacked BCD value. The AAD instruction\nis only useful when it precedes a DIV instruction that divides (binary division)\nthe adjusted value in the AX register by an unpacked BCD value.\n\nThe AAD instruction sets the value in the AL register to (AL + (10 * AH)), and\nthen clears the AH register to 00H. The value in the AX register is then equal\nto the binary equivalent of the original unpacked two-digit (base 10) number\nin registers AH and AL.\n\nThe generalized version of this instruction allows adjustment of two unpacked\ndigits of any number base (see the \u201cOperation\u201d section below), by setting the\nimm8 byte to the selected number base (for example, 08H for octal, 0AH for decimal,\nor 0CH for base 12 numbers). The AAD mnemonic is interpreted by all assemblers\nto mean adjust ASCII (base 10) values. To adjust values in another number base,\nthe instruction must be hand coded in machine code (D5 imm8).\n\nThis instruction executes as described in compatibility mode and legacy mode.\nIt is not valid in 64-bit mode.\n\nOperation:\n\nIF 64-Bit Mode\n  THEN\n     #UD;\n  ELSE\n     tempAL <- AL;\n     tempAH <- AH;\n     AL <- (tempAL + (tempAH * imm8)) AND FFH;\n     (* imm8 is set to 0AH for the AAD mnemonic.*)\n     AH <- 0;\nFI;\nThe immediate value (imm8) is taken from the second byte of the instruction.\n\nFlags Affected:\nThe SF, ZF, and PF flags are set according to the resulting binary value in\nthe AL register; the OF, AF, and CF flags are undefined.\n\n\nProtected Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nReal-Address Mode Exceptions:\nSame exceptions as protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as protected mode.\n\n\n64-Bit Mode Exceptions:\n| #UD| If in 64-bit mode.\n", 
      "mnem": "AAD"
    }, 
    {
      "description": "\nAAM - ASCII Adjust AX After Multiply:\n| Opcode| Instruction| Op/En| 64-bit Mode| Compat/Leg Mode| Description                            \n| D4 0A | AAM        | NP   | Invalid    | Valid          | ASCII adjust AX after multiply.        \n| D4 ib | AAM imm8   | NP   | Invalid    | Valid          | Adjust AX after multiply to number base\n|       |            |      |            |                | imm8.                                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nAdjusts the result of the multiplication of two unpacked BCD values to create\na pair of unpacked (base 10) BCD values. The AX register is the implied source\nand destination operand for this instruction. The AAM instruction is only useful\nwhen it follows an MUL instruction that multiplies (binary multiplication) two\nunpacked BCD values and stores a word result in the AX register. The AAM instruction\nthen adjusts the contents of the AX register to contain the correct 2-digit\nunpacked (base 10) BCD result.\n\nThe generalized version of this instruction allows adjustment of the contents\nof the AX to create two unpacked digits of any number base (see the \u201cOperation\u201d\nsection below). Here, the imm8 byte is set to the selected number base (for\nexample, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAM\nmnemonic is interpreted by all assemblers to mean adjust to ASCII (base 10)\nvalues. To adjust to values in another number base, the instruction must be\nhand coded in machine code (D4 imm8).\n\nThis instruction executes as described in compatibility mode and legacy mode.\nIt is not valid in 64-bit mode.\n\nOperation:\n\nIF 64-Bit Mode\n  THEN\n     #UD;\n  ELSE\n     tempAL <- AL;\n     AH <- tempAL / imm8; (* imm8 is set to 0AH for the AAM mnemonic *)\n     AL <- tempAL MOD imm8;\nFI;\nThe immediate value (imm8) is taken from the second byte of the instruction.\n\nFlags Affected:\nThe SF, ZF, and PF flags are set according to the resulting binary value in\nthe AL register. The OF, AF, and CF flags are undefined.\n\n\nProtected Mode Exceptions:\n| #DE| If an immediate value of 0 is used.\n| #UD| If the LOCK prefix is used.        \n\nReal-Address Mode Exceptions:\nSame exceptions as protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as protected mode.\n\n\n64-Bit Mode Exceptions:\n| #UD| If in 64-bit mode.\n", 
      "mnem": "AAM"
    }, 
    {
      "description": "\nAAS - ASCII Adjust AL After Subtraction:\n| Opcode| Instruction| Op/En| 64-bit Mode| Compat/Leg Mode| Description                       \n| 3F    | AAS        | NP   | Invalid    | Valid          | ASCII adjust AL after subtraction.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nAdjusts the result of the subtraction of two unpacked BCD values to create a\nunpacked BCD result. The AL register is the implied source and destination operand\nfor this instruction. The AAS instruction is only useful when it follows a SUB\ninstruction that subtracts (binary subtraction) one unpacked BCD value from\nanother and stores a byte result in the AL register. The AAA instruction then\nadjusts the contents of the AL register to contain the correct 1digit unpacked\nBCD result.\n\nIf the subtraction produced a decimal carry, the AH register decrements by 1,\nand the CF and AF flags are set. If no decimal carry occurred, the CF and AF\nflags are cleared, and the AH register is unchanged. In either case, the AL\nregister is left with its top four bits set to 0.\n\nThis instruction executes as described in compatibility mode and legacy mode.\nIt is not valid in 64-bit mode.\n\nOperation:\n\nIF 64-bit mode\n  THEN\n     #UD;\n  ELSE\n     IF ((AL AND 0FH) > 9) or (AF = 1)\n       THEN\n          AX <- AX - 6;\n          AH <- AH - 1;\n          AF <- 1;\n          CF <- 1;\n          AL <- AL AND 0FH;\n       ELSE\n          CF <- 0;\n          AF <- 0;\n          AL <- AL AND 0FH;\n     FI;\nFI;\n\nFlags Affected:\nThe AF and CF flags are set to 1 if there is a decimal borrow; otherwise, they\nare cleared to 0. The OF, SF, ZF, and PF flags are undefined.\n\n\nProtected Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nReal-Address Mode Exceptions:\nSame exceptions as protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as protected mode.\n\n\n64-Bit Mode Exceptions:\n| #UD| If in 64-bit mode.\n", 
      "mnem": "AAS"
    }, 
    {
      "description": "\nADC - Add with Carry:\n| Opcode          | Instruction     | Op/En| 64-bit Mode| Compat/Leg Mode| Description                               \n| 14 ib           | ADC AL, imm8    | I    | Valid      | Valid          | Add with carry imm8 to AL.                \n| 15 iw           | ADC AX, imm16   | I    | Valid      | Valid          | Add with carry imm16 to AX.               \n| 15 id           | ADC EAX, imm32  | I    | Valid      | Valid          | Add with carry imm32 to EAX.              \n| REX.W + 15 id   | ADC RAX, imm32  | I    | Valid      | N.E.           | Add with carry imm32 sign extended to     \n|                 |                 |      |            |                | 64bits to RAX.                            \n| 80 /2 ib        | ADC r/m8, imm8  | MI   | Valid      | Valid          | Add with carry imm8 to r/m8.              \n| REX + 80 /2 ib  | ADC r/m8*, imm8 | MI   | Valid      | N.E.           | Add with carry imm8 to r/m8.              \n| 81 /2 iw        | ADC r/m16, imm16| MI   | Valid      | Valid          | Add with carry imm16 to r/m16.            \n| 81 /2 id        | ADC r/m32, imm32| MI   | Valid      | Valid          | Add with CF imm32 to r/m32.               \n| REX.W + 81 /2 id| ADC r/m64, imm32| MI   | Valid      | N.E.           | Add with CF imm32 sign extended to 64-bits\n|                 |                 |      |            |                | to r/m64.                                 \n| 83 /2 ib        | ADC r/m16, imm8 | MI   | Valid      | Valid          | Add with CF sign-extended imm8 to r/m16.  \n| 83 /2 ib        | ADC r/m32, imm8 | MI   | Valid      | Valid          | Add with CF sign-extended imm8 into       \n|                 |                 |      |            |                | r/m32.                                    \n| REX.W + 83 /2 ib| ADC r/m64, imm8 | MI   | Valid      | N.E.           | Add with CF sign-extended imm8 into       \n|                 |                 |      |            |                | r/m64.                                    \n| 10 /r           | ADC r/m8, r8    | MR   | Valid      | Valid          | Add with carry byte register to r/m8.     \n| REX + 10 /r     | ADC r/m8*, r8*  | MR   | Valid      | N.E.           | Add with carry byte register to r/m64.    \n| 11 /r           | ADC r/m16, r16  | MR   | Valid      | Valid          | Add with carry r16 to r/m16.              \n| 11 /r           | ADC r/m32, r32  | MR   | Valid      | Valid          | Add with CF r32 to r/m32.                 \n| REX.W + 11 /r   | ADC r/m64, r64  | MR   | Valid      | N.E.           | Add with CF r64 to r/m64.                 \n| 12 /r           | ADC r8, r/m8    | RM   | Valid      | Valid          | Add with carry r/m8 to byte register.     \n| REX + 12 /r     | ADC r8*, r/m8*  | RM   | Valid      | N.E.           | Add with carry r/m64 to byte register.    \n| 13 /r           | ADC r16, r/m16  | RM   | Valid      | Valid          | Add with carry r/m16 to r16.              \n| 13 /r           | ADC r32, r/m32  | RM   | Valid      | Valid          | Add with CF r/m32 to r32.                 \n| REX.W + 13 /r   | ADC r64, r/m64  | RM   | Valid      | N.E.           | Add with CF r/m64 to r64.                 \nNotes: *In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA       | NA       \n| MR   | ModRM:r/m (r, w)| ModRM:reg (r)| NA       | NA       \n| MI   | ModRM:r/m (r, w)| imm8         | NA       | NA       \n| I    | AL/AX/EAX/RAX   | imm8         | NA       | NA       \n\nDescription:\nAdds the destination operand (first operand), the source operand (second operand),\nand the carry (CF) flag and stores the result in the destination operand. The\ndestination operand can be a register or a memory location; the source operand\ncan be an immediate, a register, or a memory location. (However, two memory\noperands cannot be used in one instruction.) The state of the CF flag represents\na carry from a previous addition. When an immediate value is used as an operand,\nit is sign-extended to the length of the destination operand format.\n\nThe ADC instruction does not distinguish between signed or unsigned operands.\nInstead, the processor evaluates the result for both data types and sets the\nOF and CF flags to indicate a carry in the signed or unsigned result, respectively.\nThe SF flag indicates the sign of the signed result.\n\nThe ADC instruction is usually executed as part of a multibyte or multiword\naddition in which an ADD instruction is followed by an ADC instruction.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nOperation:\n\nDEST <- DEST + SRC + CF;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ADC:           | extern unsigned char _addcarry_u8(unsigned \n|                | char c_in, unsigned char src1, unsigned    \n|                | char src2, unsigned char *sum_out);        \n| ADC: *sum_out);| extern unsigned char _addcarry_u16(unsigned\n|                | char c_in, unsigned short src1, unsigned   \n|                | short src2, unsigned short                 \n| ADC:           | extern unsigned char _addcarry_u32(unsigned\n|                | char c_in, unsigned int src1, unsigned     \n|                | char int, unsigned int *sum_out);          \n| ADC: *sum_out);| extern unsigned char _addcarry_u64(unsigned\n|                | char c_in, unsigned __int64 src1, unsigned \n|                | __int64 src2, unsigned __int64             \n\nFlags Affected:\nThe OF, SF, ZF, AF, CF, and PF flags are set according to the result.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register is used to access           \n|                | memory and it contains a NULL segment          \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used but the destination \n|                | is not a memory operand.                       \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "ADC"
    }, 
    {
      "description": "\nADD - Add:\n| Opcode          | Instruction     | Op/En| 64-bit Mode| Compat/Leg Mode| Description                          \n| 04 ib           | ADD AL, imm8    | I    | Valid      | Valid          | Add imm8 to AL.                      \n| 05 iw           | ADD AX, imm16   | I    | Valid      | Valid          | Add imm16 to AX.                     \n| 05 id           | ADD EAX, imm32  | I    | Valid      | Valid          | Add imm32 to EAX.                    \n| REX.W + 05 id   | ADD RAX, imm32  | I    | Valid      | N.E.           | Add imm32 sign-extended to 64-bits to\n|                 |                 |      |            |                | RAX.                                 \n| 80 /0 ib        | ADD r/m8, imm8  | MI   | Valid      | Valid          | Add imm8 to r/m8.                    \n| REX + 80 /0 ib  | ADD r/m8*, imm8 | MI   | Valid      | N.E.           | Add sign-extended imm8 to r/m64.     \n| 81 /0 iw        | ADD r/m16, imm16| MI   | Valid      | Valid          | Add imm16 to r/m16.                  \n| 81 /0 id        | ADD r/m32, imm32| MI   | Valid      | Valid          | Add imm32 to r/m32.                  \n| REX.W + 81 /0 id| ADD r/m64, imm32| MI   | Valid      | N.E.           | Add imm32 sign-extended to 64-bits to\n|                 |                 |      |            |                | r/m64.                               \n| 83 /0 ib        | ADD r/m16, imm8 | MI   | Valid      | Valid          | Add sign-extended imm8 to r/m16.     \n| 83 /0 ib        | ADD r/m32, imm8 | MI   | Valid      | Valid          | Add sign-extended imm8 to r/m32.     \n| REX.W + 83 /0 ib| ADD r/m64, imm8 | MI   | Valid      | N.E.           | Add sign-extended imm8 to r/m64.     \n| 00 /r           | ADD r/m8, r8    | MR   | Valid      | Valid          | Add r8 to r/m8.                      \n| REX + 00 /r     | ADD r/m8*, r8*  | MR   | Valid      | N.E.           | Add r8 to r/m8.                      \n| 01 /r           | ADD r/m16, r16  | MR   | Valid      | Valid          | Add r16 to r/m16.                    \n| 01 /r           | ADD r/m32, r32  | MR   | Valid      | Valid          | Add r32 to r/m32.                    \n| REX.W + 01 /r   | ADD r/m64, r64  | MR   | Valid      | N.E.           | Add r64 to r/m64.                    \n| 02 /r           | ADD r8, r/m8    | RM   | Valid      | Valid          | Add r/m8 to r8.                      \n| REX + 02 /r     | ADD r8*, r/m8*  | RM   | Valid      | N.E.           | Add r/m8 to r8.                      \n| 03 /r           | ADD r16, r/m16  | RM   | Valid      | Valid          | Add r/m16 to r16.                    \n| 03 /r           | ADD r32, r/m32  | RM   | Valid      | Valid          | Add r/m32 to r32.                    \n| REX.W + 03 /r   | ADD r64, r/m64  | RM   | Valid      | N.E.           | Add r/m64 to r64.                    \nNotes: *In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA       | NA       \n| MR   | ModRM:r/m (r, w)| ModRM:reg (r)| NA       | NA       \n| MI   | ModRM:r/m (r, w)| imm8         | NA       | NA       \n| I    | AL/AX/EAX/RAX   | imm8         | NA       | NA       \n\nDescription:\nAdds the destination operand (first operand) and the source operand (second\noperand) and then stores the result in the destination operand. The destination\noperand can be a register or a memory location; the source operand can be an\nimmediate, a register, or a memory location. (However, two memory operands cannot\nbe used in one instruction.) When an immediate value is used as an operand,\nit is sign-extended to the length of the destination operand format.\n\nThe ADD instruction performs integer addition. It evaluates the result for both\nsigned and unsigned integer operands and sets the OF and CF flags to indicate\na carry (overflow) in the signed or unsigned result, respectively. The SF flag\nindicates the sign of the signed result.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX a REX prefix in the form of REX.W promotes operation to 64 bits.\nSee the summary chart at the beginning of this section for encoding data and\nlimits.\n\nOperation:\n\nDEST <- DEST + SRC;\n\nFlags Affected:\nThe OF, SF, ZF, AF, CF, and PF flags are set according to the result.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register is used to access           \n|                | memory and it contains a NULL segment          \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used but the destination \n|                | is not a memory operand.                       \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "ADD"
    }, 
    {
      "description": "\nADDPD - Add Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                               \n| 66 0F 58 /r ADDPD xmm1, xmm2/m128            | RM   | V/V           | SSE2              | Add packed double-precision floating-point\n|                                              |      |               |                   | values from xmm2/m128 to xmm1.            \n| VEX.NDS.128.66.0F.WIG 58 /r VADDPD xmm1,xmm2,| RVM  | V/V           | AVX               | Add packed double-precision floating-point\n| xmm3/m128                                    |      |               |                   | values from xmm3/mem to xmm2 and stores   \n|                                              |      |               |                   | result in xmm1.                           \n| VEX.NDS.256.66.0F.WIG 58 /r VADDPD ymm1,     | RVM  | V/V           | AVX               | Add packed double-precision floating-point\n| ymm2, ymm3/m256                              |      |               |                   | values from ymm3/mem to ymm2 and stores   \n|                                              |      |               |                   | result in ymm1.                           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD add of the two packed double-precision floating-point values\nfrom the source operand (second operand) and the destination operand (first\noperand), and stores the packed double-precision floating-point results in the\ndestination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit\nmemory location. The destination is not distinct from the first source XMM register\nand the upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. See Chapter 11 in the Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1, for an overview of SIMD double-precision floating-point\noperation.\n\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit\nmemory location. The destination operand is an XMM register. The upper bits\n(VLMAX-1:128) of the corresponding YMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second\nsource operand can be a YMM register or a 256-bit memory location. The destination\noperand is a YMM register.\n\nOperation:\n\nADDPD (128-bit Legacy SSE version)\nDEST[63:0] <- DEST[63:0] + SRC[63:0];\nDEST[127:64] <- DEST[127:64] + SRC[127:64];\nDEST[VLMAX-1:128] (Unmodified)\nVADDPD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0] + SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] + SRC2[127:64]\nDEST[VLMAX-1:128] <- 0\nVADDPD (VEX.256 encoded version)\nDEST[63:0] <- SRC1[63:0] + SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] + SRC2[127:64]\nDEST[191:128] <- SRC1[191:128] + SRC2[191:128]\nDEST[255:192] <- SRC1[255:192] + SRC2[255:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ADDPD: | __m128d _mm_add_pd (__m128d a, __m128d   \n|        | b)                                       \n| VADDPD:| __m256d _mm256_add_pd (__m256d a, __m256d\n|        | b)                                       \n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "ADDPD"
    }, 
    {
      "description": "\nADDPS - Add Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                               \n| 0F 58 /r ADDPS xmm1, xmm2/m128            | RM   | V/V           | SSE               | Add packed single-precision floating-point\n|                                           |      |               |                   | values from xmm2/m128 to xmm1 and stores  \n|                                           |      |               |                   | result in xmm1.                           \n| VEX.NDS.128.0F.WIG 58 /r VADDPS xmm1,xmm2,| RVM  | V/V           | AVX               | Add packed single-precision floating-point\n| xmm3/m128                                 |      |               |                   | values from xmm3/mem to xmm2 and stores   \n|                                           |      |               |                   | result in xmm1.                           \n| VEX.NDS.256.0F.WIG 58 /r VADDPS ymm1,     | RVM  | V/V           | AVX               | Add packed single-precision floating-point\n| ymm2, ymm3/m256                           |      |               |                   | values from ymm3/mem to ymm2 and stores   \n|                                           |      |               |                   | result in ymm1.                           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3     | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA            | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r))| NA       \n\nDescription:\nPerforms a SIMD add of the four packed single-precision floating-point values\nfrom the source operand (second operand) and the destination operand (first\noperand), and stores the packed single-precision floating-point results in the\ndestination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit\nmemory location. The destination is not distinct from the first source XMM register\nand the upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. See Chapter 10 in the Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1, for an overview of SIMD single-precision floating-point\noperation. VEX.128 encoded version: the first source operand is an XMM register\nor 128-bit memory location. The destination operand is an XMM register. The\nupper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second\nsource operand can be a YMM register or a 256-bit memory location. The destination\noperand is a YMM register.\n\nOperation:\n\nADDPS (128-bit Legacy SSE version)\nDEST[31:0] <- DEST[31:0] + SRC[31:0];\nDEST[63:32] <- DEST[63:32] + SRC[63:32];\nDEST[95:64] <- DEST[95:64] + SRC[95:64];\nDEST[127:96] <- DEST[127:96] + SRC[127:96];\nDEST[VLMAX-1:128] (Unmodified)\nVADDPS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0] + SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] + SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] + SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] + SRC2[127:96]\nDEST[VLMAX-1:128] <- 0\nVADDPS (VEX.256 encoded version)\nDEST[31:0] <- SRC1[31:0] + SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] + SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] + SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] + SRC2[127:96]\nDEST[159:128] <- SRC1[159:128] + SRC2[159:128]\nDEST[191:160]<- SRC1[191:160] + SRC2[191:160]\nDEST[223:192] <- SRC1[223:192] + SRC2[223:192]\nDEST[255:224] <- SRC1[255:224] + SRC2[255:224]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ADDPS: | __m128 _mm_add_ps(__m128 a, __m128 b) \n| VADDPS:| __m256 _mm256_add_ps (__m256 a, __m256\n|        | b)                                    \n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "ADDPS"
    }, 
    {
      "description": "\nADDSD - Add Scalar Double-Precision Floating-Point Values:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| F2 0F 58 /r ADDSD xmm1, xmm2/m64        | RM   | V/V           | SSE2              | Add the low double-precision floating-point\n|                                         |      |               |                   | value from xmm2/m64 to xmm1.               \n| VEX.NDS.LIG.F2.0F.WIG 58 /r VADDSD xmm1,| RVM  | V/V           | AVX               | Add the low double-precision floating-point\n| xmm2, xmm3/m64                          |      |               |                   | value from xmm3/mem to xmm2 and store      \n|                                         |      |               |                   | the result in xmm1.                        \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3     | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA            | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r))| NA       \n\nDescription:\nAdds the low double-precision floating-point values from the source operand\n(second operand) and the destination operand (first operand), and stores the\ndouble-precision floating-point result in the destination operand.\n\nThe source operand can be an XMM register or a 64-bit memory location. The destination\noperand is an XMM register. See Chapter 11 in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1, for an overview of a scalar double-precision\nfloating-point operation.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: Bits\n(VLMAX-1:64) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (127:64) of the XMM register destination are copied\nfrom corresponding bits in the first source operand. Bits (VLMAX-1:128) of the\ndestination YMM register are zeroed.\n\nOperation:\n\nADDSD (128-bit Legacy SSE version)\nDEST[63:0] <- DEST[63:0] + SRC[63:0]\nDEST[VLMAX-1:64] (Unmodified)\nVADDSD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0] + SRC2[63:0]\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ADDSD:| __m128d _mm_add_sd (m128d a, m128d b)\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "ADDSD"
    }, 
    {
      "description": "\nADDSS - Add Scalar Single-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| F3 0F 58 /r ADDSS xmm1, xmm2/m32             | RM   | V/V           | SSE               | Add the low single-precision floating-point\n|                                              |      |               |                   | value from xmm2/m32 to xmm1.               \n| VEX.NDS.LIG.F3.0F.WIG 58 /r VADDSS xmm1,xmm2,| RVM  | V/V           | AVX               | Add the low single-precision floating-point\n| xmm3/m32                                     |      |               |                   | value from xmm3/mem to xmm2 and store      \n|                                              |      |               |                   | the result in xmm1.                        \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nAdds the low single-precision floating-point values from the source operand\n(second operand) and the destination operand (first operand), and stores the\nsingle-precision floating-point result in the destination operand.\n\nThe source operand can be an XMM register or a 32-bit memory location. The destination\noperand is an XMM register. See Chapter 10 in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1, for an overview of a scalar single-precision\nfloating-point operation.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: Bits\n(VLMAX-1:32) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (127:32) of the XMM register destination are copied\nfrom corresponding bits in the first source operand. Bits (VLMAX-1:128) of the\ndestination YMM register are zeroed.\n\nOperation:\n\nADDSS DEST, SRC (128-bit Legacy SSE version)\nDEST[31:0] <- DEST[31:0] + SRC[31:0];\nDEST[VLMAX-1:32] (Unmodified)\nVADDSS DEST, SRC1, SRC2 (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0] + SRC2[31:0]\nDEST[127:32] <- SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ADDSS:| __m128 _mm_add_ss(__m128 a, __m128 b)\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "ADDSS"
    }, 
    {
      "description": "\nADDSUBPD - Packed Double-FP Add/Subtract:\n| Opcode/Instruction                   | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                 \n| 66 0F D0 /r ADDSUBPD xmm1, xmm2/m128 | RM   | V/V           | SSE3              | Add/subtract double-precision floating-point\n|                                      |      |               |                   | values from xmm2/m128 to xmm1.              \n| VEX.NDS.128.66.0F.WIG D0 /r VADDSUBPD| RVM  | V/V           | AVX               | Add/subtract packed double-precision        \n| xmm1, xmm2, xmm3/m128                |      |               |                   | floating-point values from xmm3/mem         \n|                                      |      |               |                   | to xmm2 and stores result in xmm1.          \n| VEX.NDS.256.66.0F.WIG D0 /r VADDSUBPD| RVM  | V/V           | AVX               | Add / subtract packed double-precision      \n| ymm1, ymm2, ymm3/m256                |      |               |                   | floating-point values from ymm3/mem         \n|                                      |      |               |                   | to ymm2 and stores result in ymm1.          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nAdds odd-numbered double-precision floating-point values of the first source\noperand (second operand) with the corresponding double-precision floating-point\nvalues from the second source operand (third operand); stores the result in\nthe odd-numbered values of the destination operand (first operand). Subtracts\nthe even-numbered double-precision floating-point values from the second source\noperand from the corresponding double-precision floating values in the first\nsource operand; stores the result into the even-numbered values of the destination\noperand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. See Figure 3-3.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit\nmemory location. The destination operand is an XMM register. The upper bits\n(VLMAX-1:128) of the corresponding YMM register destination are zeroed. VEX.256\nencoded version: The first source operand is a YMM register. The second source\noperand can be a YMM register or a 256-bit memory location. The destination\noperand is a YMM register.\n\nADDSUBPD xmm1, xmm2/m128\n\n| [127:64]| [63:0]| xmm2/m128\nRESULT:\n\n| xmm1[127:64] + xmm2/m128[127:64]| xmm1[63:0] - xmm2/m128[63:0]xmm1      \n| [127:64]                        | [63:0]                                \n| Figure 3-3.                     | ADDSUBPD - Packed Double-FP Add/Subtract\nOperation:\n\nADDSUBPD (128-bit Legacy SSE version)\nDEST[63:0] <- DEST[63:0] - SRC[63:0]\nDEST[127:64] <- DEST[127:64] + SRC[127:64]\nDEST[VLMAX-1:128] (Unmodified)\nVADDSUBPD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0] - SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] + SRC2[127:64]\nDEST[VLMAX-1:128] <- 0\nVADDSUBPD (VEX.256 encoded version)\nDEST[63:0] <- SRC1[63:0] - SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] + SRC2[127:64]\nDEST[191:128] <- SRC1[191:128] - SRC2[191:128]\nDEST[255:192] <- SRC1[255:192] + SRC2[255:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ADDSUBPD: | __m128d _mm_addsub_pd(__m128d a, __m128d\n|           | b)                                      \n| VADDSUBPD:| __m256d _mm256_addsub_pd (__m256d a,    \n|           | __m256d b)                              \n\nExceptions:\nWhen the source operand is a memory operand, it must be aligned on a 16-byte\nboundary or a general-protection exception (#GP) will be generated.\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "ADDSUBPD"
    }, 
    {
      "description": "\nADDSUBPS - Packed Single-FP Add/Subtract:\n| Opcode/Instruction                   | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                   \n| F2 0F D0 /r ADDSUBPS xmm1, xmm2/m128 | RM   | V/V           | SSE3              | Add/subtract single-precision floating-point  \n|                                      |      |               |                   | values from xmm2/m128 to xmm1.                \n| VEX.NDS.128.F2.0F.WIG D0 /r VADDSUBPS| RVM  | V/V           | AVX               | Add/subtract single-precision floating-point  \n| xmm1, xmm2, xmm3/m128                |      |               |                   | values from xmm3/mem to xmm2 and stores       \n|                                      |      |               |                   | result in xmm1.                               \n| VEX.NDS.256.F2.0F.WIG D0 /r VADDSUBPS| RVM  | V/V           | AVX               | Add / subtract single-precision floating-point\n| ymm1, ymm2, ymm3/m256                |      |               |                   | values from ymm3/mem to ymm2 and stores       \n|                                      |      |               |                   | result in ymm1.                               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nAdds odd-numbered single-precision floating-point values of the first source\noperand (second operand) with the corresponding single-precision floating-point\nvalues from the second source operand (third operand); stores the result in\nthe odd-numbered values of the destination operand (first operand). Subtracts\nthe even-numbered single-precision floating-point values from the second source\noperand from the corresponding single-precision floating values in the first\nsource operand; stores the result into the even-numbered values of the destination\noperand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. See Figure 3-4.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit\nmemory location. The destination operand is an XMM register. The upper bits\n(VLMAX-1:128) of the corresponding YMM register destination are zeroed. VEX.256\nencoded version: The first source operand is a YMM register. The second source\noperand can be a YMM register or a 256-bit memory location. The destination\noperand is a YMM register.\n\nADDSUBPS xmm1, xmm2/m128\n\nxmm2/\n\n| [127:96]| [95:64]xmm1[95:64] - xmm2/m128[95:64]| [63:32]xmm1[63:32] +xmm2/m128[63:32]| [31:0]m128 RESULT: xmm1\n| [127:96]| [95:64]                              | [63:32]                             | [31:0]                 \nOM15992\n\n| Figure 3-4.| ADDSUBPS - Packed Single-FP Add/Subtract\nOperation:\n\nADDSUBPS (128-bit Legacy SSE version)\nDEST[31:0] <- DEST[31:0] - SRC[31:0]\nDEST[63:32] <- DEST[63:32] + SRC[63:32]\nDEST[95:64] <- DEST[95:64] - SRC[95:64]\nDEST[127:96] <- DEST[127:96] + SRC[127:96]\nDEST[VLMAX-1:128] (Unmodified)\nVADDSUBPS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0] - SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] + SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] - SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] + SRC2[127:96]\nDEST[VLMAX-1:128] <- 0\nVADDSUBPS (VEX.256 encoded version)\nDEST[31:0] <- SRC1[31:0] - SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] + SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] - SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] + SRC2[127:96]\nDEST[159:128] <- SRC1[159:128] - SRC2[159:128]\nDEST[191:160]<- SRC1[191:160] + SRC2[191:160]\nDEST[223:192] <- SRC1[223:192] - SRC2[223:192]\nDEST[255:224] <- SRC1[255:224] + SRC2[255:224].\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ADDSUBPS: | __m128 _mm_addsub_ps(__m128 a, __m128    \n|           | b)                                       \n| VADDSUBPS:| __m256 _mm256_addsub_ps (__m256 a, __m256\n|           | b)                                       \n\nExceptions:\nWhen the source operand is a memory operand, the operand must be aligned on\na 16-byte boundary or a generalprotection exception (#GP) will be generated.\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "ADDSUBPS"
    }, 
    {
      "description": "\nAESDEC - Perform One Round of an AES Decryption Flow:\n| Opcode/Instruction                   | Op/En| 64/32-bit Mode| CPUID Feature Flag    | Description                               \n| 66 0F 38 DE /r AESDEC xmm1, xmm2/m128| RM   | V/V           | AES                   | Perform one round of an AES decryption    \n|                                      |      |               |                       | flow, using the Equivalent Inverse Cipher,\n|                                      |      |               |                       | operating on a 128-bit data (state)       \n|                                      |      |               |                       | from xmm1 with a 128-bit round key from   \n|                                      |      |               |                       | xmm2/m128.                                \n| VEX.NDS.128.66.0F38.WIG DE /r VAESDEC| RVM  | V/V           | Both AES and AVX flags| Perform one round of an AES decryption    \n| xmm1, xmm2, xmm3/m128                |      |               |                       | flow, using the Equivalent Inverse Cipher,\n|                                      |      |               |                       | operating on a 128-bit data (state)       \n|                                      |      |               |                       | from xmm2 with a 128-bit round key from   \n|                                      |      |               |                       | xmm3/m128; store the result in xmm1.      \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand2     | Operand3     | Operand4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA      \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA      \n\nDescription:\nThis instruction performs a single round of the AES decryption flow using the\nEquivalent Inverse Cipher, with the round key from the second source operand,\noperating on a 128-bit data (state) from the first source operand, and store\nthe result in the destination operand. Use the AESDEC instruction for all but\nthe last decryption round. For the last decryption round, use the AESDECCLAST\ninstruction. 128-bit Legacy SSE version: The first source operand and the destination\noperand are the same and must be an XMM register. The second source operand\ncan be an XMM register or a 128-bit memory location. Bits (VLMAX1:128) of the\ncorresponding YMM destination register remain unchanged. VEX.128 encoded version:\nThe first source operand and the destination operand are XMM registers. The\nsecond source operand can be an XMM register or a 128-bit memory location. Bits\n(VLMAX-1:128) of the destination YMM register are zeroed.\n\nOperation:\n\nAESDEC\nSTATE <- SRC1;\nRoundKey <- SRC2;\nSTATE <- InvShiftRows( STATE );\nSTATE <- InvSubBytes( STATE );\nSTATE <- InvMixColumns( STATE );\nDEST[127:0] <- STATE XOR RoundKey;\nDEST[VLMAX-1:128] (Unmodified)\nVAESDEC\nSTATE <- SRC1;\nRoundKey <- SRC2;\nSTATE <- InvShiftRows( STATE );\nSTATE <- InvSubBytes( STATE );\nSTATE <- InvMixColumns( STATE );\nDEST[127:0] <- STATE XOR RoundKey;\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)AESDEC:| __m128i _mm_aesdec (__m128i, __m128i)\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "AESDEC"
    }, 
    {
      "description": "\nAESDECLAST - Perform Last Round of an AES Decryption Flow:\n| Opcode/Instruction                       | Op/En| 64/32-bit Mode| CPUID Feature Flag    | Description                                \n| 66 0F 38 DF /r AESDECLAST xmm1, xmm2/m128| RM   | V/V           | AES                   | Perform the last round of an AES decryption\n|                                          |      |               |                       | flow, using the Equivalent Inverse Cipher, \n|                                          |      |               |                       | operating on a 128-bit data (state)        \n|                                          |      |               |                       | from xmm1 with a 128-bit round key from    \n|                                          |      |               |                       | xmm2/m128.                                 \n| VEX.NDS.128.66.0F38.WIG DF /r VAESDECLAST| RVM  | V/V           | Both AES and AVX flags| Perform the last round of an AES decryption\n| xmm1, xmm2, xmm3/m128                    |      |               |                       | flow, using the Equivalent Inverse Cipher, \n|                                          |      |               |                       | operating on a 128-bit data (state)        \n|                                          |      |               |                       | from xmm2 with a 128-bit round key from    \n|                                          |      |               |                       | xmm3/m128; store the result in xmm1.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand2     | Operand3     | Operand4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA      \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA      \n\nDescription:\nThis instruction performs the last round of the AES decryption flow using the\nEquivalent Inverse Cipher, with the round key from the second source operand,\noperating on a 128-bit data (state) from the first source operand, and store\nthe result in the destination operand. 128-bit Legacy SSE version: The first\nsource operand and the destination operand are the same and must be an XMM register.\nThe second source operand can be an XMM register or a 128-bit memory location.\nBits (VLMAX1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source operand and the destination operand\nare XMM registers. The second source operand can be an XMM register or a 128-bit\nmemory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nOperation:\n\nAESDECLAST\nSTATE <- SRC1;\nRoundKey <- SRC2;\nSTATE <- InvShiftRows( STATE );\nSTATE <- InvSubBytes( STATE );\nDEST[127:0] <- STATE XOR RoundKey;\nDEST[VLMAX-1:128] (Unmodified)\nVAESDECLAST\nSTATE <- SRC1;\nRoundKey <- SRC2;\nSTATE <- InvShiftRows( STATE );\nSTATE <- InvSubBytes( STATE );\nDEST[127:0] <- STATE XOR RoundKey;\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)AESDECLAST:| __m128i _mm_aesdeclast (__m128i, __m128i)\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "AESDECLAST"
    }, 
    {
      "description": "\nAESENC - Perform One Round of an AES Encryption Flow:\n| Opcode/Instruction                   | Op/En| 64/32-bit Mode| CPUID Feature Flag    | Description                              \n| 66 0F 38 DC /r AESENC xmm1, xmm2/m128| RM   | V/V           | AES                   | Perform one round of an AES encryption   \n|                                      |      |               |                       | flow, operating on a 128-bit data (state)\n|                                      |      |               |                       | from xmm1 with a 128-bit round key from  \n|                                      |      |               |                       | xmm2/m128.                               \n| VEX.NDS.128.66.0F38.WIG DC /r VAESENC| RVM  | V/V           | Both AES and AVX flags| Perform one round of an AES encryption   \n| xmm1, xmm2, xmm3/m128                |      |               |                       | flow, operating on a 128-bit data (state)\n|                                      |      |               |                       | from xmm2 with a 128-bit round key from  \n|                                      |      |               |                       | the xmm3/m128; store the result in xmm1. \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand2     | Operand3     | Operand4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA      \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA      \n\nDescription:\nThis instruction performs a single round of an AES encryption flow using a round\nkey from the second source operand, operating on 128-bit data (state) from the\nfirst source operand, and store the result in the destination operand. Use the\nAESENC instruction for all but the last encryption rounds. For the last encryption\nround, use the AESENCCLAST instruction. 128-bit Legacy SSE version: The first\nsource operand and the destination operand are the same and must be an XMM register.\nThe second source operand can be an XMM register or a 128-bit memory location.\nBits (VLMAX1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source operand and the destination operand\nare XMM registers. The second source operand can be an XMM register or a 128-bit\nmemory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nOperation:\n\nAESENC\nSTATE <- SRC1;\nRoundKey <- SRC2;\nSTATE <- ShiftRows( STATE );\nSTATE <- SubBytes( STATE );\nSTATE <- MixColumns( STATE );\nDEST[127:0] <- STATE XOR RoundKey;\nDEST[VLMAX-1:128] (Unmodified)\nVAESENC\nSTATE <- SRC1;\nRoundKey <- SRC2;\nSTATE <- ShiftRows( STATE );\nSTATE <- SubBytes( STATE );\nSTATE <- MixColumns( STATE );\nDEST[127:0] <- STATE XOR RoundKey;\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)AESENC:| __m128i _mm_aesenc (__m128i, __m128i)\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "AESENC"
    }, 
    {
      "description": "\nAESENCLAST - Perform Last Round of an AES Encryption Flow:\n| Opcode/Instruction                       | Op/En| 64/32-bit Mode| CPUID Feature Flag    | Description                                \n| 66 0F 38 DD /r AESENCLAST xmm1, xmm2/m128| RM   | V/V           | AES                   | Perform the last round of an AES encryption\n|                                          |      |               |                       | flow, operating on a 128-bit data (state)  \n|                                          |      |               |                       | from xmm1 with a 128-bit round key from    \n|                                          |      |               |                       | xmm2/m128.                                 \n| VEX.NDS.128.66.0F38.WIG DD /r VAESENCLAST| RVM  | V/V           | Both AES and AVX flags| Perform the last round of an AES encryption\n| xmm1, xmm2, xmm3/m128                    |      |               |                       | flow, operating on a 128-bit data (state)  \n|                                          |      |               |                       | from xmm2 with a 128 bit round key from    \n|                                          |      |               |                       | xmm3/m128; store the result in xmm1.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand2     | Operand3     | Operand4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA      \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA      \n\nDescription:\nThis instruction performs the last round of an AES encryption flow using a round\nkey from the second source operand, operating on 128-bit data (state) from the\nfirst source operand, and store the result in the destination operand. 128-bit\nLegacy SSE version: The first source operand and the destination operand are\nthe same and must be an XMM register. The second source operand can be an XMM\nregister or a 128-bit memory location. Bits (VLMAX1:128) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: The first\nsource operand and the destination operand are XMM registers. The second source\noperand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)\nof the destination YMM register are zeroed.\n\nOperation:\n\nAESENCLAST\nSTATE <- SRC1;\nRoundKey <- SRC2;\nSTATE <- ShiftRows( STATE );\nSTATE <- SubBytes( STATE );\nDEST[127:0] <- STATE XOR RoundKey;\nDEST[VLMAX-1:128] (Unmodified)\nVAESENCLAST\nSTATE <- SRC1;\nRoundKey <- SRC2;\nSTATE <- ShiftRows( STATE );\nSTATE <- SubBytes( STATE );\nDEST[127:0] <- STATE XOR RoundKey;\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)AESENCLAST:| __m128i _mm_aesenclast (__m128i, __m128i)\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "AESENCLAST"
    }, 
    {
      "description": "\nAESIMC - Perform the AES InvMixColumn Transformation:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag    | Description                            \n| 66 0F 38 DB /r AESIMC xmm1, xmm2/m128  | RM   | V/V           | AES                   | Perform the InvMixColumn transformation\n|                                        |      |               |                       | on a 128-bit round key from xmm2/m128  \n|                                        |      |               |                       | and store the result in xmm1.          \n| VEX.128.66.0F38.WIG DB /r VAESIMC xmm1,| RM   | V/V           | Both AES and AVX flags| Perform the InvMixColumn transformation\n| xmm2/m128                              |      |               |                       | on a 128-bit round key from xmm2/m128  \n|                                        |      |               |                       | and store the result in xmm1.          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand2     | Operand3| Operand4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA      | NA      \n\nDescription:\nPerform the InvMixColumns transformation on the source operand and store the\nresult in the destination operand. The destination operand is an XMM register.\nThe source operand can be an XMM register or a 128-bit memory location. Note:\nthe AESIMC instruction should be applied to the expanded AES round keys (except\nfor the first and last round key) in order to prepare them for decryption using\nthe \u201cEquivalent Inverse Cipher\u201d (defined in FIPS 197).\n\n128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128) of the\ndestination YMM register are zeroed.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise\ninstructions will #UD.\n\nOperation:\n\nAESIMC\nDEST[127:0] <- InvMixColumns( SRC );\nDEST[VLMAX-1:128] (Unmodified)\nVAESIMC\nDEST[127:0] <- InvMixColumns( SRC );\nDEST[VLMAX-1:128] <- 0;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)AESIMC:| __m128i _mm_aesimc (__m128i)\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "AESIMC"
    }, 
    {
      "description": "\nAESKEYGENASSIST - AES Round Key Generation Assist:\n| Opcode/Instruction                           | Op/En| 64/32-bit Mode| CPUID Feature Flag    | Description                              \n| 66 0F 3A DF /r ib AESKEYGENASSIST xmm1,      | RMI  | V/V           | AES                   | Assist in AES round key generation using \n| xmm2/m128, imm8                              |      |               |                       | an 8 bits Round Constant (RCON) specified\n|                                              |      |               |                       | in the immediate byte, operating on      \n|                                              |      |               |                       | 128 bits of data specified in xmm2/m128  \n|                                              |      |               |                       | and stores the result in xmm1.           \n| VEX.128.66.0F3A.WIG DF /r ib VAESKEYGENASSIST| RMI  | V/V           | Both AES and AVX flags| Assist in AES round key generation using \n| xmm1, xmm2/m128, imm8                        |      |               |                       | 8 bits Round Constant (RCON) specified   \n|                                              |      |               |                       | in the immediate byte, operating on      \n|                                              |      |               |                       | 128 bits of data specified in xmm2/m128  \n|                                              |      |               |                       | and stores the result in xmm1.           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand2     | Operand3| Operand4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8    | NA      \n\nDescription:\nAssist in expanding the AES cipher key, by computing steps towards generating\na round key for encryption, using 128-bit data specified in the source operand\nand an 8-bit round constant specified as an immediate, store the result in the\ndestination operand. The destination operand is an XMM register. The source\noperand can be an XMM register or a 128-bit memory location.\n\n128-bit Legacy SSE version:Bits (VLMAX-1:128) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128) of the\ndestination YMM register are zeroed.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise\ninstructions will #UD.\n\nOperation:\n\nAESKEYGENASSIST\nX3[31:0] <- SRC [127: 96];\nX2[31:0] <- SRC [95: 64];\nX1[31:0] <- SRC [63: 32];\nX0[31:0] <- SRC [31: 0];\nRCON[31:0] <- ZeroExtend(Imm8[7:0]);\nDEST[31:0] <- SubWord(X1);\nDEST[63:32 ] <- RotWord( SubWord(X1) ) XOR RCON;\nDEST[95:64] <- SubWord(X3);\nDEST[127:96] <- RotWord( SubWord(X3) ) XOR RCON;\nDEST[VLMAX-1:128] (Unmodified)\nVAESKEYGENASSIST\nX3[31:0] <- SRC [127: 96];\nX2[31:0] <- SRC [95: 64];\nX1[31:0] <- SRC [63: 32];\nX0[31:0] <- SRC [31: 0];\nRCON[31:0] <- ZeroExtend(Imm8[7:0]);\nDEST[31:0] <- SubWord(X1);\nDEST[63:32 ] <- RotWord( SubWord(X1) ) XOR RCON;\nDEST[95:64] <- SubWord(X3);\nDEST[127:96] <- RotWord( SubWord(X3) ) XOR RCON;\nDEST[VLMAX-1:128] <- 0;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)AESKEYGENASSIST:| __m128i _mm_aesimc (__m128i, const int)\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "AESKEYGENASSIST"
    }, 
    {
      "description": "\nAND - Logical AND:\n| Opcode          | Instruction     | Op/En| 64-bit Mode| Compat/Leg Mode| Description                              \n| 24 ib           | AND AL, imm8    | I    | Valid      | Valid          | AL AND imm8.                             \n| 25 iw           | AND AX, imm16   | I    | Valid      | Valid          | AX AND imm16.                            \n| 25 id           | AND EAX, imm32  | I    | Valid      | Valid          | EAX AND imm32.                           \n| REX.W + 25 id   | AND RAX, imm32  | I    | Valid      | N.E.           | RAX AND imm32 sign-extended to 64-bits.  \n| 80 /4 ib        | AND r/m8, imm8  | MI   | Valid      | Valid          | r/m8 AND imm8.                           \n| REX + 80 /4 ib  | AND r/m8*, imm8 | MI   | Valid      | N.E.           | r/m8 AND imm8.                           \n| 81 /4 iw        | AND r/m16, imm16| MI   | Valid      | Valid          | r/m16 AND imm16.                         \n| 81 /4 id        | AND r/m32, imm32| MI   | Valid      | Valid          | r/m32 AND imm32.                         \n| REX.W + 81 /4 id| AND r/m64, imm32| MI   | Valid      | N.E.           | r/m64 AND imm32 sign extended to 64-bits.\n| 83 /4 ib        | AND r/m16, imm8 | MI   | Valid      | Valid          | r/m16 AND imm8 (sign-extended).          \n| 83 /4 ib        | AND r/m32, imm8 | MI   | Valid      | Valid          | r/m32 AND imm8 (sign-extended).          \n| REX.W + 83 /4 ib| AND r/m64, imm8 | MI   | Valid      | N.E.           | r/m64 AND imm8 (sign-extended).          \n| 20 /r           | AND r/m8, r8    | MR   | Valid      | Valid          | r/m8 AND r8.                             \n| REX + 20 /r     | AND r/m8*, r8*  | MR   | Valid      | N.E.           | r/m64 AND r8 (sign-extended).            \n| 21 /r           | AND r/m16, r16  | MR   | Valid      | Valid          | r/m16 AND r16.                           \n| 21 /r           | AND r/m32, r32  | MR   | Valid      | Valid          | r/m32 AND r32.                           \n| REX.W + 21 /r   | AND r/m64, r64  | MR   | Valid      | N.E.           | r/m64 AND r32.                           \n| 22 /r           | AND r8, r/m8    | RM   | Valid      | Valid          | r8 AND r/m8.                             \n| REX + 22 /r     | AND r8*, r/m8*  | RM   | Valid      | N.E.           | r/m64 AND r8 (sign-extended).            \n| 23 /r           | AND r16, r/m16  | RM   | Valid      | Valid          | r16 AND r/m16.                           \n| 23 /r           | AND r32, r/m32  | RM   | Valid      | Valid          | r32 AND r/m32.                           \n| REX.W + 23 /r   | AND r64, r/m64  | RM   | Valid      | N.E.           | r64 AND r/m64.                           \nNotes: *In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA       | NA       \n| MR   | ModRM:r/m (r, w)| ModRM:reg (r)| NA       | NA       \n| MI   | ModRM:r/m (r, w)| imm8         | NA       | NA       \n| I    | AL/AX/EAX/RAX   | imm8         | NA       | NA       \n\nDescription:\nPerforms a bitwise AND operation on the destination (first) and source (second)\noperands and stores the result in the destination operand location. The source\noperand can be an immediate, a register, or a memory location; the destination\noperand can be a register or a memory location. (However, two memory operands\ncannot be used in one instruction.) Each bit of the result is set to 1 if both\ncorresponding bits of the first and second operands are 1; otherwise, it is\nset to 0.\n\nThis instruction can be used with a LOCK prefix to allow the it to be executed\natomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nOperation:\n\nDEST <- DEST AND SRC;\n\nFlags Affected:\nThe OF and CF flags are cleared; the SF, ZF, and PF flags are set according\nto the result. The state of the AF flag is undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination operand points to          \n|                | a non-writable segment. If a memory           \n|                | operand effective address is outside          \n|                | the CS, DS, ES, FS, or GS segment limit.      \n|                | If the DS, ES, FS, or GS register contains    \n|                | a NULL segment selector.                      \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "AND"
    }, 
    {
      "description": "\nANDN  -  Logical AND NOT:\n| Opcode/Instruction                  | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                             \n| VEX.NDS.LZ.0F38.W0 F2 /r ANDN r32a, | RVM  | V/V            | BMI1              | Bitwise AND of inverted r32b with r/m32,\n| r32b, r/m32                         |      |                |                   | store result in r32a.                   \n| VEX.NDS.LZ. 0F38.W1 F2 /r ANDN r64a,| RVM  | V/NE           | BMI1              | Bitwise AND of inverted r64b with r/m64,\n| r64b, r/m64                         |      |                |                   | store result in r64a.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2   | Operand 3    | Operand 4\n| RVM  | ModRM:reg (w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a bitwise logical AND of inverted second operand (the first source\noperand) with the third operand (the second source operand). The result is stored\nin the first operand (destination operand). This instruction is not supported\nin real mode and virtual-8086 mode. The operand size is always 32 bits if not\nin 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored\nin non-64-bit modes. An attempt to execute this instruction with VEX.L not equal\nto 0 will cause #UD.\n\nOperation:\n\nDEST <- (NOT SRC1) bitwiseAND SRC2;\nSF <- DEST[OperandSize -1];\nZF <- (DEST = 0);\n\nFlags Affected:\nSF and ZF are updated based on result. OF and CF flags are cleared. AF and PF\nflags are undefined.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nAuto-generated from high-level language.\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Section 2.5.1, \u201cException Conditions for VEX-Encoded GPR Instructions\u201d,\nTable 2-29; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "ANDN"
    }, 
    {
      "description": "\nANDNPD - Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                           \n| 66 0F 55 /r ANDNPD xmm1, xmm2/m128      | RM   | V/V           | SSE2              | Bitwise logical AND NOT of xmm2/m128  \n|                                         |      |               |                   | and xmm1.                             \n| VEX.NDS.128.66.0F.WIG 55 /r VANDNPD     | RVM  | V/V           | AVX               | Return the bitwise logical AND NOT of \n| xmm1, xmm2, xmm3/m128                   |      |               |                   | packed double-precision floating-point\n|                                         |      |               |                   | values in xmm2 and xmm3/mem.          \n| VEX.NDS.256.66.0F.WIG 55/r VANDNPD ymm1,| RVM  | V/V           | AVX               | Return the bitwise logical AND NOT of \n| ymm2, ymm3/m256                         |      |               |                   | packed double-precision floating-point\n|                                         |      |               |                   | values in ymm2 and ymm3/mem.          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a bitwise logical AND NOT of the two or four packed double-precision\nfloating-point values from the first source operand and the second source operand,\nand stores the result in the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed. VEX.256 encoded version:\nThe first source operand is a YMM register. The second source operand can be\na YMM register or a 256-bit memory location. The destination operand is a YMM\nregister.\n\nOperation:\n\nANDNPD (128-bit Legacy SSE version)\nDEST[63:0] <- (NOT(DEST[63:0])) BITWISE AND SRC[63:0]\nDEST[127:64] <- (NOT(DEST[127:64])) BITWISE AND SRC[127:64]\nDEST[VLMAX-1:128] (Unmodified)\nVANDNPD (VEX.128 encoded version)\nDEST[63:0] <- (NOT(SRC1[63:0])) BITWISE AND SRC2[63:0]\nDEST[127:64] <- (NOT(SRC1[127:64])) BITWISE AND SRC2[127:64]\nDEST[VLMAX-1:128] <- 0\nVANDNPD (VEX.256 encoded version)\nDEST[63:0] <- (NOT(SRC1[63:0])) BITWISE AND SRC2[63:0]\nDEST[127:64] <- (NOT(SRC1[127:64])) BITWISE AND SRC2[127:64]\nDEST[191:128] <- (NOT(SRC1[191:128])) BITWISE AND SRC2[191:128]\nDEST[255:192] <- (NOT(SRC1[255:192])) BITWISE AND SRC2[255:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ANDNPD: | __m128d _mm_andnot_pd(__m128d a, __m128d\n|         | b)                                      \n| VANDNPD:| __m256d _mm256_andnot_pd (__m256d a,    \n|         | __m256d b)                              \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "ANDNPD"
    }, 
    {
      "description": "\nANDNPS - Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                    | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                           \n| 0F 55 /r ANDNPS xmm1, xmm2/m128       | RM   | V/V           | SSE               | Bitwise logical AND NOT of xmm2/m128  \n|                                       |      |               |                   | and xmm1.                             \n| VEX.NDS.128.0F.WIG 55 /r VANDNPS xmm1,| RVM  | V/V           | AVX               | Return the bitwise logical AND NOT of \n| xmm2, xmm3/m128                       |      |               |                   | packed single-precision floating-point\n|                                       |      |               |                   | values in xmm2 and xmm3/mem.          \n| VEX.NDS.256.0F.WIG 55 /r VANDNPS ymm1,| RVM  | V/V           | AVX               | Return the bitwise logical AND NOT of \n| ymm2, ymm3/m256                       |      |               |                   | packed single-precision floating-point\n|                                       |      |               |                   | values in ymm2 and ymm3/mem.          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nInverts the bits of the four packed single-precision floating-point values in\nthe destination operand (first operand), performs a bitwise logical AND of the\nfour packed single-precision floating-point values in the source operand (second\noperand) and the temporary inverted result, and stores the result in the destination\noperand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed. VEX.256 encoded version:\nThe first source operand is a YMM register. The second source operand can be\na YMM register or a 256-bit memory location. The destination operand is a YMM\nregister.\n\nOperation:\n\nANDNPS (128-bit Legacy SSE version)\nDEST[31:0] <- (NOT(DEST[31:0])) BITWISE AND SRC[31:0]\nDEST[63:32] <- (NOT(DEST[63:32])) BITWISE AND SRC[63:32]\nDEST[95:64] <- (NOT(DEST[95:64])) BITWISE AND SRC[95:64]\nDEST[127:96] <- (NOT(DEST[127:96])) BITWISE AND SRC[127:96]\nDEST[VLMAX-1:128] (Unmodified)\nVANDNPS (VEX.128 encoded version)\nDEST[31:0] <- (NOT(SRC1[31:0])) BITWISE AND SRC2[31:0]\nDEST[63:32] <- (NOT(SRC1[63:32])) BITWISE AND SRC2[63:32]\nDEST[95:64] <- (NOT(SRC1[95:64])) BITWISE AND SRC2[95:64]\nDEST[127:96] <- (NOT(SRC1[127:96])) BITWISE AND SRC2[127:96]\nDEST[VLMAX-1:128] <- 0\nVANDNPS (VEX.256 encoded version)\nDEST[31:0] <- (NOT(SRC1[31:0])) BITWISE AND SRC2[31:0]\nDEST[63:32] <- (NOT(SRC1[63:32])) BITWISE AND SRC2[63:32]\nDEST[95:64] <- (NOT(SRC1[95:64])) BITWISE AND SRC2[95:64]\nDEST[127:96] <- (NOT(SRC1[127:96])) BITWISE AND SRC2[127:96]\nDEST[159:128] <- (NOT(SRC1[159:128])) BITWISE AND SRC2[159:128]\nDEST[191:160]<- (NOT(SRC1[191:160])) BITWISE AND SRC2[191:160]\nDEST[223:192] <- (NOT(SRC1[223:192])) BITWISE AND SRC2[223:192]\nDEST[255:224] <- (NOT(SRC1[255:224])) BITWISE AND SRC2[255:224].\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ANDNPS: | __m128 _mm_andnot_ps(__m128 a, __m128    \n|         | b)                                       \n| VANDNPS:| __m256 _mm256_andnot_ps (__m256 a, __m256\n|         | b)                                       \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "ANDNPS"
    }, 
    {
      "description": "\nANDPD - Bitwise Logical AND of Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                             \n| 66 0F 54 /r ANDPD xmm1, xmm2/m128       | RM   | V/V           | SSE2              | Return the bitwise logical AND of packed\n|                                         |      |               |                   | double-precision floating-point values  \n|                                         |      |               |                   | in xmm1 and xmm2/m128.                  \n| VEX.NDS.128.66.0F.WIG 54 /r VANDPD xmm1,| RVM  | V/V           | AVX               | Return the bitwise logical AND of packed\n| xmm2, xmm3/m128                         |      |               |                   | double-precision floating-point values  \n|                                         |      |               |                   | in xmm2 and xmm3/mem.                   \n| VEX.NDS.256.66.0F.WIG 54 /r VANDPD ymm1,| RVM  | V/V           | AVX               | Return the bitwise logical AND of packed\n| ymm2, ymm3/m256                         |      |               |                   | double-precision floating-point values  \n|                                         |      |               |                   | in ymm2 and ymm3/mem.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a bitwise logical AND of the two packed double-precision floating-point\nvalues from the source operand (second operand) and the destination operand\n(first operand), and stores the result in the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed. VEX.256 encoded version:\nThe first source operand is a YMM register. The second source operand can be\na YMM register or a 256-bit memory location. The destination operand is a YMM\nregister.\n\nOperation:\n\nANDPD (128-bit Legacy SSE version)\nDEST[63:0] <- DEST[63:0] BITWISE AND SRC[63:0]\nDEST[127:64] <- DEST[127:64] BITWISE AND SRC[127:64]\nDEST[VLMAX-1:128] (Unmodified)\nVANDPD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0] BITWISE AND SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] BITWISE AND SRC2[127:64]\nDEST[VLMAX-1:128] <- 0\nVANDPD (VEX.256 encoded version)\nDEST[63:0] <- SRC1[63:0] BITWISE AND SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] BITWISE AND SRC2[127:64]\nDEST[191:128] <- SRC1[191:128] BITWISE AND SRC2[191:128]\nDEST[255:192] <- SRC1[255:192] BITWISE AND SRC2[255:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ANDPD: | __m128d _mm_and_pd(__m128d a, __m128d    \n|        | b)                                       \n| VANDPD:| __m256d _mm256_and_pd (__m256d a, __m256d\n|        | b)                                       \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "ANDPD"
    }, 
    {
      "description": "\nANDPS - Bitwise Logical AND of Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                             \n| 0F 54 /r ANDPS xmm1, xmm2/m128            | RM   | V/V           | SSE               | Bitwise logical AND of xmm2/m128 and    \n|                                           |      |               |                   | xmm1.                                   \n| VEX.NDS.128.0F.WIG 54 /r VANDPS xmm1,xmm2,| RVM  | V/V           | AVX               | Return the bitwise logical AND of packed\n| xmm3/m128                                 |      |               |                   | single-precision floating-point values  \n|                                           |      |               |                   | in xmm2 and xmm3/mem.                   \n| VEX.NDS.256.0F.WIG 54 /r VANDPS ymm1,     | RVM  | V/V           | AVX               | Return the bitwise logical AND of packed\n| ymm2, ymm3/m256                           |      |               |                   | single-precision floating-point values  \n|                                           |      |               |                   | in ymm2 and ymm3/mem.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a bitwise logical AND of the four or eight packed single-precision\nfloating-point values from the first source operand and the second source operand,\nand stores the result in the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed. VEX.256 encoded version:\nThe first source operand is a YMM register. The second source operand can be\na YMM register or a 256-bit memory location. The destination operand is a YMM\nregister.\n\nOperation:\n\nANDPS (128-bit Legacy SSE version)\nDEST[31:0] <- DEST[31:0] BITWISE AND SRC[31:0]\nDEST[63:32] <- DEST[63:32] BITWISE AND SRC[63:32]\nDEST[95:64] <- DEST[95:64] BITWISE AND SRC[95:64]\nDEST[127:96] <- DEST[127:96] BITWISE AND SRC[127:96]\nDEST[VLMAX-1:128] (Unmodified)\nVANDPS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0] BITWISE AND SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] BITWISE AND SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] BITWISE AND SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] BITWISE AND SRC2[127:96]\nDEST[VLMAX-1:128] <- 0\nVANDPS (VEX.256 encoded version)\nDEST[31:0] <- SRC1[31:0] BITWISE AND SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] BITWISE AND SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] BITWISE AND SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] BITWISE AND SRC2[127:96]\nDEST[159:128] <- SRC1[159:128] BITWISE AND SRC2[159:128]\nDEST[191:160]<- SRC1[191:160] BITWISE AND SRC2[191:160]\nDEST[223:192] <- SRC1[223:192] BITWISE AND SRC2[223:192]\nDEST[255:224] <- SRC1[255:224] BITWISE AND SRC2[255:224].\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ANDPS: | __m128 _mm_and_ps(__m128 a, __m128 b) \n| VANDPS:| __m256 _mm256_and_ps (__m256 a, __m256\n|        | b)                                    \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "ANDPS"
    }, 
    {
      "description": "\nARPL - Adjust RPL Field of Segment Selector:\n| Opcode| Instruction    | Op/En| 64-bit Mode| Compat/Leg Mode| Description                         \n| 63 /r | ARPL r/m16, r16| NP   | N. E.      | Valid          | Adjust RPL of r/m16 to not less than\n|       |                |      |            |                | RPL of r16.                         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| NP   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nCompares the RPL fields of two segment selectors. The first operand (the destination\noperand) contains one segment selector and the second operand (source operand)\ncontains the other. (The RPL field is located in bits 0 and 1 of each operand.)\nIf the RPL field of the destination operand is less than the RPL field of the\nsource operand, the ZF flag is set and the RPL field of the destination operand\nis increased to match that of the source operand. Otherwise, the ZF flag is\ncleared and no change is made to the destination operand. (The destination operand\ncan be a word register or a memory location; the source operand must be a word\nregister.)\n\nThe ARPL instruction is provided for use by operating-system procedures (however,\nit can also be used by applications). It is generally used to adjust the RPL\nof a segment selector that has been passed to the operating system by an application\nprogram to match the privilege level of the application program. Here the segment\nselector passed to the operating system is placed in the destination operand\nand segment selector for the application program's code segment is placed in\nthe source operand. (The RPL field in the source operand represents the privilege\nlevel of the application program.) Execution of the ARPL instruction then ensures\nthat the RPL of the segment selector received by the operating system is no\nlower (does not have a higher privilege) than the privilege level of the application\nprogram (the segment selector for the application program's code segment can\nbe read from the stack following a procedure call).\n\nThis instruction executes as described in compatibility mode and legacy mode.\nIt is not encodable in 64-bit mode.\n\nSee \u201cChecking Caller Access Privileges\u201d in Chapter 3, \u201cProtected-Mode Memory\nManagement,\u201d of the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 3A, for more information about the use of this instruction.\n\nOperation:\n\nIF 64-BIT MODE\n  THEN\n     See MOVSXD;\n  ELSE\n     IF DEST[RPL) < SRC[RPL)\n       THEN\n          ZF <- 1;\n          DEST[RPL) <- SRC[RPL);\n       ELSE\n          ZF <- 0;\n     FI;\nFI;\n\nFlags Affected:\nThe ZF flag is set to 1 if the RPL field of the destination operand is less\nthan that of the source operand; otherwise, it is set to 0.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register is used to access           \n|                | memory and it contains a NULL segment          \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #UD| The ARPL instruction is not recognized  \n|    | in real-address mode. If the LOCK prefix\n|    | is used.                                \n\nVirtual-8086 Mode Exceptions:\n| #UD| The ARPL instruction is not recognized  \n|    | in virtual-8086 mode. If the LOCK prefix\n|    | is used.                                \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nNot applicable.\n\n", 
      "mnem": "ARPL"
    }, 
    {
      "description": "\nBEXTR  -  Bit Field Extract:\n| Opcode/Instruction                   | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                          \n| VEX.NDS1.LZ.0F38.W0 F7 /r BEXTR r32a,| RMV  | V/V            | BMI1              | Contiguous bitwise extract from r/m32\n| r/m32, r32b                          |      |                |                   | using r32b as control; store result  \n|                                      |      |                |                   | in r32a.                             \n| VEX.NDS1.LZ.0F38.W1 F7 /r BEXTR r64a,| RMV  | V/N.E.         | BMI1              | Contiguous bitwise extract from r/m64\n| r/m64, r64b                          |      |                |                   | using r64b as control; store result  \n|                                      |      |                |                   | in r64a                              \nNotes: 1. ModRM:r/m is used to encode the first source operand (second operand)\nand VEX.vvvv encodes the second source operand (third operand).\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3   | Operand 4\n| RMV  | ModRM:reg (w)| ModRM:r/m (r)| VEX.vvvv (r)| NA       \n\nDescription:\nExtracts contiguous bits from the first source operand (the second operand)\nusing an index value and length value specified in the second source operand\n(the third operand). Bit 7:0 of the second source operand specifies the starting\nbit position of bit extraction. A START value exceeding the operand size will\nnot extract any bits from the second source operand. Bit 15:8 of the second\nsource operand specifies the maximum number of bits (LENGTH) beginning at the\nSTART position to extract. Only bit positions up to (OperandSize -1) of the\nfirst source operand are extracted. The extracted bits are written to the destination\nregister, starting from the least significant bit. All higher order bits in\nthe destination operand (starting at bit position LENGTH) are zeroed. The destination\nregister is cleared if no bits are extracted. This instruction is not supported\nin real mode and virtual-8086 mode. The operand size is always 32 bits if not\nin 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored\nin non-64-bit modes. An attempt to execute this instruction with VEX.L not equal\nto 0 will cause #UD.\n\nOperation:\n\nSTART <- SRC2[7:0];\nLEN <- SRC2[15:8];\nTEMP <- ZERO_EXTEND_TO_512 (SRC1 );\nDEST <- ZERO_EXTEND(TEMP[START+LEN -1: START]);\nZF <- (DEST = 0);\n\nFlags Affected:\nZF is updated based on the result. AF, SF, and PF are undefined. All other flags\nare cleared.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| BEXTR:| unsigned __int32 _bextr_u32(unsigned\n|       | __int32 src, unsigned __int32 start.\n|       | unsigned __int32 len);              \n| BEXTR:| unsigned __int64 _bextr_u64(unsigned\n|       | __int64 src, unsigned __int32 start.\n|       | unsigned __int32 len);              \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Section 2.5.1, \u201cException Conditions for VEX-Encoded GPR Instructions\u201d,\nTable 2-29; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "BEXTR"
    }, 
    {
      "description": "\nBLENDPD  -  Blend Packed Double Precision Floating-Point Values:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                  \n| 66 0F 3A 0D /r ib BLENDPD xmm1, xmm2/m128,| RMI  | V/V           | SSE4_1            | Select packed DP-FP values from xmm1         \n| imm8                                      |      |               |                   | and xmm2/m128 from mask specified in         \n|                                           |      |               |                   | imm8 and store the values into xmm1.         \n| VEX.NDS.128.66.0F3A.WIG 0D /r ib VBLENDPD | RVMI | V/V           | AVX               | Select packed double-precision floating-point\n| xmm1, xmm2, xmm3/m128, imm8               |      |               |                   | Values from xmm2 and xmm3/m128 from          \n|                                           |      |               |                   | mask in imm8 and store the values in         \n|                                           |      |               |                   | xmm1.                                        \n| VEX.NDS.256.66.0F3A.WIG 0D /r ib VBLENDPD | RVMI | V/V           | AVX               | Select packed double-precision floating-point\n| ymm1, ymm2, ymm3/m256, imm8               |      |               |                   | Values from ymm2 and ymm3/m256 from          \n|                                           |      |               |                   | mask in imm8 and store the values in         \n|                                           |      |               |                   | ymm1.                                        \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8[3:0]\n\nDescription:\nDouble-precision floating-point values from the second source operand (third\noperand) are conditionally merged with values from the first source operand\n(second operand) and written to the destination operand (first operand). The\nimmediate bits [3:0] determine whether the corresponding double-precision floating-point\nvalue in the destination is copied from the second source or first source. If\na bit in the mask, corresponding to a word, is \u201c1\", then the double-precision\nfloating-point value in the second source operand is copied, else the value\nin the first source operand is copied. 128-bit Legacy SSE version: The second\nsource can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register. The second source operand\nis an XMM register or 128-bit memory location. The destination operand is an\nXMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register\ndestination are zeroed. VEX.256 encoded version: The first source operand is\na YMM register. The second source operand can be a YMM register or a 256-bit\nmemory location. The destination operand is a YMM register.\n\nOperation:\n\nBLENDPD (128-bit Legacy SSE version)\nIF (IMM8[0] = 0)THEN DEST[63:0] <- DEST[63:0]\n     ELSE DEST [63:0] <- SRC[63:0] FI\nIF (IMM8[1] = 0) THEN DEST[127:64] <- DEST[127:64]\n     ELSE DEST [127:64] <- SRC[127:64] FI\nDEST[VLMAX-1:128] (Unmodified)\nVBLENDPD (VEX.128 encoded version)\nIF (IMM8[0] = 0)THEN DEST[63:0] <- SRC1[63:0]\n     ELSE DEST [63:0] <- SRC2[63:0] FI\nIF (IMM8[1] = 0) THEN DEST[127:64] <- SRC1[127:64]\n     ELSE DEST [127:64] <- SRC2[127:64] FI\nDEST[VLMAX-1:128] <- 0\nVBLENDPD (VEX.256 encoded version)\nIF (IMM8[0] = 0)THEN DEST[63:0] <- SRC1[63:0]\n     ELSE DEST [63:0] <- SRC2[63:0] FI\nIF (IMM8[1] = 0) THEN DEST[127:64] <- SRC1[127:64]\n     ELSE DEST [127:64] <- SRC2[127:64] FI\nIF (IMM8[2] = 0) THEN DEST[191:128] <- SRC1[191:128]\n     ELSE DEST [191:128] <- SRC2[191:128] FI\nIF (IMM8[3] = 0) THEN DEST[255:192] <- SRC1[255:192]\n     ELSE DEST [255:192] <- SRC2[255:192] FI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| BLENDPD: | __m128d _mm_blend_pd (__m128d v1, __m128d\n|          | v2, const int mask);                     \n| VBLENDPD:| __m256d _mm256_blend_pd (__m256d a,      \n|          | __m256d b, const int mask);              \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "BLENDPD"
    }, 
    {
      "description": "\nBLENDPS  -  Blend Packed Single Precision Floating-Point Values:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                  \n| 66 0F 3A 0C /r ib BLENDPS xmm1, xmm2/m128,| RMI  | V/V           | SSE4_1            | Select packed single precision floating-point\n| imm8                                      |      |               |                   | values from xmm1 and xmm2/m128 from          \n|                                           |      |               |                   | mask specified in imm8 and store the         \n|                                           |      |               |                   | values into xmm1.                            \n| VEX.NDS.128.66.0F3A.WIG 0C /r ib VBLENDPS | RVMI | V/V           | AVX               | Select packed single-precision floating-point\n| xmm1, xmm2, xmm3/m128, imm8               |      |               |                   | values from xmm2 and xmm3/m128 from          \n|                                           |      |               |                   | mask in imm8 and store the values in         \n|                                           |      |               |                   | xmm1.                                        \n| VEX.NDS.256.66.0F3A.WIG 0C /r ib VBLENDPS | RVMI | V/V           | AVX               | Select packed single-precision floating-point\n| ymm1, ymm2, ymm3/m256, imm8               |      |               |                   | values from ymm2 and ymm3/m256 from          \n|                                           |      |               |                   | mask in imm8 and store the values in         \n|                                           |      |               |                   | ymm1.                                        \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nPacked single-precision floating-point values from the second source operand\n(third operand) are conditionally merged with values from the first source operand\n(second operand) and written to the destination operand (first operand). The\nimmediate bits [7:0] determine whether the corresponding single precision floating-point\nvalue in the destination is copied from the second source or first source. If\na bit in the mask, corresponding to a word, is \u201c1\", then the single-precision\nfloating-point value in the second source operand is copied, else the value\nin the first source operand is copied. 128-bit Legacy SSE version: The second\nsource can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: The first source operand an XMM register. The second source operand\nis an XMM register or 128-bit memory location. The destination operand is an\nXMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register\ndestination are zeroed. VEX.256 encoded version: The first source operand is\na YMM register. The second source operand can be a YMM register or a 256-bit\nmemory location. The destination operand is a YMM register.\n\nOperation:\n\nBLENDPS (128-bit Legacy SSE version)\nIF (IMM8[0] = 0) THEN DEST[31:0] <-DEST[31:0]\n     ELSE DEST [31:0] <- SRC[31:0] FI\nIF (IMM8[1] = 0) THEN DEST[63:32] <- DEST[63:32]\n     ELSE DEST [63:32] <- SRC[63:32] FI\nIF (IMM8[2] = 0) THEN DEST[95:64] <- DEST[95:64]\n     ELSE DEST [95:64] <- SRC[95:64] FI\nIF (IMM8[3] = 0) THEN DEST[127:96] <- DEST[127:96]\n     ELSE DEST [127:96] <- SRC[127:96] FI\nDEST[VLMAX-1:128] (Unmodified)\nVBLENDPS (VEX.128 encoded version)\nIF (IMM8[0] = 0) THEN DEST[31:0] <-SRC1[31:0]\n     ELSE DEST [31:0] <- SRC2[31:0] FI\nIF (IMM8[1] = 0) THEN DEST[63:32] <- SRC1[63:32]\n     ELSE DEST [63:32] <- SRC2[63:32] FI\nIF (IMM8[2] = 0) THEN DEST[95:64] <- SRC1[95:64]\n     ELSE DEST [95:64] <- SRC2[95:64] FI\nIF (IMM8[3] = 0) THEN DEST[127:96] <- SRC1[127:96]\n     ELSE DEST [127:96] <- SRC2[127:96] FI\nDEST[VLMAX-1:128] <- 0\nVBLENDPS (VEX.256 encoded version)\nIF (IMM8[0] = 0) THEN DEST[31:0] <-SRC1[31:0]\n     ELSE DEST [31:0] <- SRC2[31:0] FI\nIF (IMM8[1] = 0) THEN DEST[63:32] <- SRC1[63:32]\n     ELSE DEST [63:32] <- SRC2[63:32] FI\nIF (IMM8[2] = 0) THEN DEST[95:64] <- SRC1[95:64]\n     ELSE DEST [95:64] <- SRC2[95:64] FI\nIF (IMM8[3] = 0) THEN DEST[127:96] <- SRC1[127:96]\n     ELSE DEST [127:96] <- SRC2[127:96] FI\nIF (IMM8[4] = 0) THEN DEST[159:128] <- SRC1[159:128]\n     ELSE DEST [159:128] <- SRC2[159:128] FI\nIF (IMM8[5] = 0) THEN DEST[191:160] <- SRC1[191:160]\n     ELSE DEST [191:160] <- SRC2[191:160] FI\nIF (IMM8[6] = 0) THEN DEST[223:192] <- SRC1[223:192]\n     ELSE DEST [223:192] <- SRC2[223:192] FI\nIF (IMM8[7] = 0) THEN DEST[255:224] <- SRC1[255:224]\n     ELSE DEST [255:224] <- SRC2[255:224] FI.\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| BLENDPS: | __m128 _mm_blend_ps (__m128 v1, __m128  \n|          | v2, const int mask);                    \n| VBLENDPS:| __m256 _mm256_blend_ps (__m256 a, __m256\n|          | b, const int mask);                     \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "BLENDPS"
    }, 
    {
      "description": "\nBLENDVPD  -  Variable Blend Packed Double Precision Floating-Point Values:\n| Opcode/Instruction                         | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| 66 0F 38 15 /r BLENDVPD xmm1, xmm2/m128    | RM0  | V/V           | SSE4_1            | Select packed DP FP values from xmm1       \n| , <XMM0>                                   |      |               |                   | and xmm2 from mask specified in XMM0       \n|                                            |      |               |                   | and store the values in xmm1.              \n| VEX.NDS.128.66.0F3A.W0 4B /r /is4 VBLENDVPD| RVMR | V/V           | AVX               | Conditionally copy double-precision        \n| xmm1, xmm2, xmm3/m128, xmm4                |      |               |                   | floatingpoint values from xmm2 or xmm3/m128\n|                                            |      |               |                   | to xmm1, based on mask bits in the mask    \n|                                            |      |               |                   | operand, xmm4.                             \n| VEX.NDS.256.66.0F3A.W0 4B /r /is4 VBLENDVPD| RVMR | V/V           | AVX               | Conditionally copy double-precision        \n| ymm1, ymm2, ymm3/m256, ymm4                |      |               |                   | floatingpoint values from ymm2 or ymm3/m256\n|                                            |      |               |                   | to ymm1, based on mask bits in the mask    \n|                                            |      |               |                   | operand, ymm4.                             \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM0  | ModRM:reg (r, w)| ModRM:r/m (r)| implicit XMM0| NA       \n| RVMR | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8[7:4]\n\nDescription:\nConditionally copy each quadword data element of double-precision floating-point\nvalue from the second source operand and the first source operand depending\non mask bits defined in the mask register operand. The mask bits are the most\nsignificant bit in each quadword element of the mask register. Each quadword\nelement of the destination operand is copied from:\n\n - the corresponding quadword element in the second source operand, If a mask bit\nis \u201c1\"; or\n - the corresponding quadword element in the first source operand, If a mask bit\nis \u201c0\"\n\nThe register assignment of the implicit mask operand for BLENDVPD is defined\nto be the architectural register XMM0. 128-bit Legacy SSE version: The first\nsource operand and the destination operand is the same. Bits (VLMAX-1:128) of\nthe corresponding YMM destination register remain unchanged. The mask register\noperand is implicitly defined to be the architectural register XMM0. An attempt\nto execute BLENDVPD with a VEX prefix will cause #UD. VEX.128 encoded version:\nThe first source operand and the destination operand are XMM registers. The\nsecond source operand is an XMM register or 128-bit memory location. The mask\noperand is the third source register, and encoded in bits[7:4] of the immediate\nbyte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored.\nThe upper bits (VLMAX-1:128) of the corresponding YMM register (destination\nregister) are zeroed. VEX.W must be 0, otherwise, the instruction will #UD.\nVEX.256 encoded version: The first source operand and destination operand are\nYMM registers. The second source operand can be a YMM register or a 256-bit\nmemory location. The mask operand is the third source register, and encoded\nin bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored.\nIn 32-bit mode, imm8[7] is ignored. VEX.W must be 0, otherwise, the instruction\nwill #UD. VBLENDVPD permits the mask to be any XMM or YMM register. In contrast,\nBLENDVPD treats XMM0 implicitly as the mask and do not support non-destructive\ndestination operation.\n\nOperation:\n\nBLENDVPD (128-bit Legacy SSE version)\nMASK <- XMM0\nIF (MASK[63] = 0) THEN DEST[63:0] <- DEST[63:0]\n     ELSE DEST [63:0] <- SRC[63:0] FI\nIF (MASK[127] = 0) THEN DEST[127:64] <- DEST[127:64]\n     ELSE DEST [127:64] <- SRC[127:64] FI\nDEST[VLMAX-1:128] (Unmodified)\nVBLENDVPD (VEX.128 encoded version)\nMASK <- SRC3\nIF (MASK[63] = 0) THEN DEST[63:0] <- SRC1[63:0]\n     ELSE DEST [63:0] <- SRC2[63:0] FI\nIF (MASK[127] = 0) THEN DEST[127:64] <- SRC1[127:64]\n     ELSE DEST [127:64] <- SRC2[127:64] FI\nDEST[VLMAX-1:128] <- 0\nVBLENDVPD (VEX.256 encoded version)\nMASK <- SRC3\nIF (MASK[63] = 0) THEN DEST[63:0] <- SRC1[63:0]\n     ELSE DEST [63:0] <- SRC2[63:0] FI\nIF (MASK[127] = 0) THEN DEST[127:64] <- SRC1[127:64]\n     ELSE DEST [127:64] <- SRC2[127:64] FI\nIF (MASK[191] = 0) THEN DEST[191:128] <- SRC1[191:128]\n     ELSE DEST [191:128] <- SRC2[191:128] FI\nIF (MASK[255] = 0) THEN DEST[255:192] <- SRC1[255:192]\n     ELSE DEST [255:192] <- SRC2[255:192] FI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| BLENDVPD: | __m128d _mm_blendv_pd(__m128d v1, __m128d\n|           | v2, __m128d v3);                         \n| VBLENDVPD:| __m128 _mm_blendv_pd (__m128d a, __m128d \n|           | b, __m128d mask);                        \n| VBLENDVPD:| __m256 _mm256_blendv_pd (__m256d a,      \n|           | __m256d b, __m256d mask);                \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "BLENDVPD"
    }, 
    {
      "description": "\nBLENDVPS  -  Variable Blend Packed Single Precision Floating-Point Values:\n| Opcode/Instruction                         | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                  \n| 66 0F 38 14 /r BLENDVPS xmm1, xmm2/m128,   | RM0  | V/V           | SSE4_1            | Select packed single precision floating-point\n| <XMM0>                                     |      |               |                   | values from xmm1 and xmm2/m128 from          \n|                                            |      |               |                   | mask specified in XMM0 and store the         \n|                                            |      |               |                   | values into xmm1.                            \n| VEX.NDS.128.66.0F3A.W0 4A /r /is4 VBLENDVPS| RVMR | V/V           | AVX               | Conditionally copy single-precision          \n| xmm1, xmm2, xmm3/m128, xmm4                |      |               |                   | floatingpoint values from xmm2 or xmm3/m128  \n|                                            |      |               |                   | to xmm1, based on mask bits in the specified \n|                                            |      |               |                   | mask operand, xmm4.                          \n| VEX.NDS.256.66.0F3A.W0 4A /r /is4 VBLENDVPS| RVMR | V/V           | AVX               | Conditionally copy single-precision          \n| ymm1, ymm2, ymm3/m256, ymm4                |      |               |                   | floatingpoint values from ymm2 or ymm3/m256  \n|                                            |      |               |                   | to ymm1, based on mask bits in the specified \n|                                            |      |               |                   | mask register, ymm4.                         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM0  | ModRM:reg (r, w)| ModRM:r/m (r)| implicit XMM0| NA       \n| RVMR | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8[7:4]\n\nDescription:\nConditionally copy each dword data element of single-precision floating-point\nvalue from the second source operand and the first source operand depending\non mask bits defined in the mask register operand. The mask bits are the most\nsignificant bit in each dword element of the mask register. Each quadword element\nof the destination operand is copied from:\n\n - the corresponding dword element in the second source operand, If a mask bit\nis \u201c1\"; or\n - the corresponding dword element in the first source operand, If a mask bit is\n\u201c0\"\n\nThe register assignment of the implicit mask operand for BLENDVPS is defined\nto be the architectural register XMM0. 128-bit Legacy SSE version: The first\nsource operand and the destination operand is the same. Bits (VLMAX-1:128) of\nthe corresponding YMM destination register remain unchanged. The mask register\noperand is implicitly defined to be the architectural register XMM0. An attempt\nto execute BLENDVPS with a VEX prefix will cause #UD. VEX.128 encoded version:\nThe first source operand and the destination operand are XMM registers. The\nsecond source operand is an XMM register or 128-bit memory location. The mask\noperand is the third source register, and encoded in bits[7:4] of the immediate\nbyte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored.\nThe upper bits (VLMAX-1:128) of the corresponding YMM register (destination\nregister) are zeroed. VEX.W must be 0, otherwise, the instruction will #UD.\nVEX.256 encoded version: The first source operand and destination operand are\nYMM registers. The second source operand can be a YMM register or a 256-bit\nmemory location. The mask operand is the third source register, and encoded\nin bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored.\nIn 32-bit mode, imm8[7] is ignored. VEX.W must be 0, otherwise, the instruction\nwill #UD. VBLENDVPS permits the mask to be any XMM or YMM register. In contrast,\nBLENDVPS treats XMM0 implicitly as the mask and do not support non-destructive\ndestination operation.\n\nOperation:\n\nBLENDVPS (128-bit Legacy SSE version)\nMASK <- XMM0\nIF (MASK[31] = 0) THEN DEST[31:0] <- DEST[31:0]\n     ELSE DEST [31:0] <- SRC[31:0] FI\nIF (MASK[63] = 0) THEN DEST[63:32] <- DEST[63:32]\n     ELSE DEST [63:32] <- SRC[63:32] FI\nIF (MASK[95] = 0) THEN DEST[95:64] <- DEST[95:64]\n     ELSE DEST [95:64] <- SRC[95:64] FI\nIF (MASK[127] = 0) THEN DEST[127:96] <- DEST[127:96]\n     ELSE DEST [127:96] <- SRC[127:96] FI\nDEST[VLMAX-1:128] (Unmodified)\nVBLENDVPS (VEX.128 encoded version)\nMASK <- SRC3\nIF (MASK[31] = 0) THEN DEST[31:0] <- SRC1[31:0]\n     ELSE DEST [31:0] <- SRC2[31:0] FI\nIF (MASK[63] = 0) THEN DEST[63:32] <- SRC1[63:32]\n     ELSE DEST [63:32] <- SRC2[63:32] FI\nIF (MASK[95] = 0) THEN DEST[95:64] <- SRC1[95:64]\n     ELSE DEST [95:64] <- SRC2[95:64] FI\nIF (MASK[127] = 0) THEN DEST[127:96] <- SRC1[127:96]\n     ELSE DEST [127:96] <- SRC2[127:96] FI\nDEST[VLMAX-1:128] <- 0\nVBLENDVPS (VEX.256 encoded version)\nMASK <- SRC3\nIF (MASK[31] = 0) THEN DEST[31:0] <- SRC1[31:0]\n     ELSE DEST [31:0] <- SRC2[31:0] FI\nIF (MASK[63] = 0) THEN DEST[63:32] <- SRC1[63:32]\n     ELSE DEST [63:32] <- SRC2[63:32] FI\nIF (MASK[95] = 0) THEN DEST[95:64] <- SRC1[95:64]\n     ELSE DEST [95:64] <- SRC2[95:64] FI\nIF (MASK[127] = 0) THEN DEST[127:96] <- SRC1[127:96]\n     ELSE DEST [127:96] <- SRC2[127:96] FI\nIF (MASK[159] = 0) THEN DEST[159:128] <- SRC1[159:128]\n     ELSE DEST [159:128] <- SRC2[159:128] FI\nIF (MASK[191] = 0) THEN DEST[191:160] <- SRC1[191:160]\n     ELSE DEST [191:160] <- SRC2[191:160] FI\nIF (MASK[223] = 0) THEN DEST[223:192] <- SRC1[223:192]\n     ELSE DEST [223:192] <- SRC2[223:192] FI\nIF (MASK[255] = 0) THEN DEST[255:224] <- SRC1[255:224]\n     ELSE DEST [255:224] <- SRC2[255:224] FI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| BLENDVPS: | __m128 _mm_blendv_ps(__m128 v1, __m128   \n|           | v2, __m128 v3);                          \n| VBLENDVPS:| __m128 _mm_blendv_ps (__m128 a, __m128   \n|           | b, __m128 mask);                         \n| VBLENDVPS:| __m256 _mm256_blendv_ps (__m256 a, __m256\n|           | b, __m256 mask);                         \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "BLENDVPS"
    }, 
    {
      "description": "\nBLSI  -  Extract Lowest Set Isolated Bit:\n| Opcode/Instruction                      | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                           \n| VEX.NDD.LZ.0F38.W0 F3 /3 BLSI r32, r/m32| VM   | V/V            | BMI1              | Extract lowest set bit from r/m32 and \n|                                         |      |                |                   | set that bit in r32.                  \n| VEX.NDD.LZ.0F38.W1 F3 /3 BLSI r64, r/m64| VM   | V/N.E.         | BMI1              | Extract lowest set bit from r/m64, and\n|                                         |      |                |                   | set that bit in r64.                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1   | Operand 2    | Operand 3| Operand 4\n| VM   | VEX.vvvv (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nExtracts the lowest set bit from the source operand and set the corresponding\nbit in the destination register. All other bits in the destination operand are\nzeroed. If no bits are set in the source operand, BLSI sets all the bits in\nthe destination to 0 and sets ZF and CF. This instruction is not supported in\nreal mode and virtual-8086 mode. The operand size is always 32 bits if not in\n64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored\nin non-64-bit modes. An attempt to execute this instruction with VEX.L not equal\nto 0 will cause #UD.\n\nOperation:\n\ntemp <- (-SRC) bitwiseAND (SRC);\nSF <- temp[OperandSize -1];\nZF <- (temp = 0);\nIF SRC = 0\n  CF <- 0;\nELSE\n  CF <- 1;\nFI\nDEST <- temp;\n\nFlags Affected:\nZF and SF are updated based on the result. CF is set if the source is not zero.\nOF flags are cleared. AF and PF flags are undefined.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| BLSI:| unsigned __int32 _blsi_u32(unsigned\n|      | __int32 src);                      \n| BLSI:| unsigned __int64 _blsi_u64(unsigned\n|      | __int64 src);                      \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Section 2.5.1, \u201cException Conditions for VEX-Encoded GPR Instructions\u201d,\nTable 2-29; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "BLSI"
    }, 
    {
      "description": "\nBLSMSK  -  Get Mask Up to Lowest Set Bit:\n| Opcode/Instruction                  | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                              \n| VEX.NDD.LZ.0F38.W0 F3 /2 BLSMSK r32,| VM   | V/V            | BMI1              | Set all lower bits in r32 to \u201c1\u201d starting\n| r/m32                               |      |                |                   | from bit 0 to lowest set bit in r/m32.   \n| VEX.NDD.LZ.0F38.W1 F3 /2 BLSMSK r64,| VM   | V/N.E.         | BMI1              | Set all lower bits in r64 to \u201c1\u201d starting\n| r/m64                               |      |                |                   | from bit 0 to lowest set bit in r/m64.   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1   | Operand 2    | Operand 3| Operand 4\n| VM   | VEX.vvvv (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nSets all the lower bits of the destination operand to \u201c1\u201d up to and including\nlowest set bit (=1) in the source operand. If source operand is zero, BLSMSK\nsets all bits of the destination operand to 1 and also sets CF to 1. This instruction\nis not supported in real mode and virtual-8086 mode. The operand size is always\n32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1.\nVEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction\nwith VEX.L not equal to 0 will cause #UD.\n\nOperation:\n\ntemp <- (SRC-1) XOR (SRC) ;\nSF <- temp[OperandSize -1];\nZF <- 0;\nIF SRC = 0\n  CF <- 1;\nELSE\n  CF <- 0;\nFI\nDEST <- temp;\n\nFlags Affected:\nSF is updated based on the result. CF is set if the source if zero. ZF and OF\nflags are cleared. AF and PF flag are undefined.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| BLSMSK:| unsigned __int32 _blsmsk_u32(unsigned\n|        | __int32 src);                        \n| BLSMSK:| unsigned __int64 _blsmsk_u64(unsigned\n|        | __int64 src);                        \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Section 2.5.1, \u201cException Conditions for VEX-Encoded GPR Instructions\u201d,\nTable 2-29; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "BLSMSK"
    }, 
    {
      "description": "\nBLSR  -  Reset Lowest Set Bit:\n| Opcode/Instruction                      | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                             \n| VEX.NDD.LZ.0F38.W0 F3 /1 BLSR r32, r/m32| VM   | V/V            | BMI1              | Reset lowest set bit of r/m32, keep     \n|                                         |      |                |                   | all other bits of r/m32 and write result\n|                                         |      |                |                   | to r32.                                 \n| VEX.NDD.LZ.0F38.W1 F3 /1 BLSR r64, r/m64| VM   | V/N.E.         | BMI1              | Reset lowest set bit of r/m64, keep     \n|                                         |      |                |                   | all other bits of r/m64 and write result\n|                                         |      |                |                   | to r64.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1   | Operand 2    | Operand 3| Operand 4\n| VM   | VEX.vvvv (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nCopies all bits from the source operand to the destination operand and resets\n(=0) the bit position in the destination operand that corresponds to the lowest\nset bit of the source operand. If the source operand is zero BLSR sets CF. This\ninstruction is not supported in real mode and virtual-8086 mode. The operand\nsize is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64\nrequires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute\nthis instruction with VEX.L not equal to 0 will cause #UD.\n\nOperation:\n\ntemp <- (SRC-1) bitwiseAND ( SRC );\nSF <- temp[OperandSize -1];\nZF <- (temp = 0);\nIF SRC = 0\n  CF <- 1;\nELSE\n  CF <- 0;\nFI\nDEST <- temp;\n\nFlags Affected:\nZF and SF flags are updated based on the result. CF is set if the source is\nzero. OF flag is cleared. AF and PF flags are undefined.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| BLSR:| unsigned __int32 _blsr_u32(unsigned\n|      | __int32 src);                      \n| BLSR:| unsigned __int64 _blsr_u64(unsigned\n|      | __int64 src);                      \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Section 2.5.1, \u201cException Conditions for VEX-Encoded GPR Instructions\u201d,\nTable 2-29; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "BLSR"
    }, 
    {
      "description": "\nBOUND - Check Array Index Against Bounds:\n| Opcode| Instruction      | Op/En| 64-bit Mode| Compat/Leg Mode| Description                         \n| 62 /r | BOUND r16, m16&16| RM   | Invalid    | Valid          | Check if r16 (array index) is within\n|       |                  |      |            |                | bounds specified by m16&16.         \n| 62 /r | BOUND r32, m32&32| RM   | Invalid    | Valid          | Check if r32 (array index) is within\n|       |                  |      |            |                | bounds specified by m16&16.         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nBOUND determines if the first operand (array index) is within the bounds of\nan array specified the second operand (bounds operand). The array index is a\nsigned integer located in a register. The bounds operand is a memory location\nthat contains a pair of signed doubleword-integers (when the operand-size attribute\nis 32) or a pair of signed word-integers (when the operand-size attribute is\n16). The first doubleword (or word) is the lower bound of the array and the\nsecond doubleword (or word) is the upper bound of the array. The array index\nmust be greater than or equal to the lower bound and less than or equal to the\nupper bound plus the operand size in bytes. If the index is not within bounds,\na BOUND range exceeded exception (#BR) is signaled. When this exception is generated,\nthe saved return instruction pointer points to the BOUND instruction.\n\nThe bounds limit data structure (two words or doublewords containing the lower\nand upper limits of the array) is usually placed just before the array itself,\nmaking the limits addressable via a constant offset from the beginning of the\narray. Because the address of the array already will be present in a register,\nthis practice avoids extra bus cycles to obtain the effective address of the\narray bounds.\n\nThis instruction executes as described in compatibility mode and legacy mode.\nIt is not valid in 64-bit mode.\n\nOperation:\n\nIF 64bit Mode\n  THEN\n     #UD;\n  ELSE\n     IF (ArrayIndex < LowerBound OR ArrayIndex > UpperBound)\n     (* Below lower bound or above upper bound *)\n       THEN #BR; FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #BR            | If the bounds test fails.                  \n| #UD            | If second operand is not a memory location.\n|                | If the LOCK prefix is used.                \n| #GP(0)         | If a memory operand effective address      \n|                | is outside the CS, DS, ES, FS, or GS       \n|                | segment limit. If the DS, ES, FS, or       \n|                | GS register contains a NULL segment        \n|                | selector.                                  \n| #SS(0)         | If a memory operand effective address      \n|                | is outside the SS segment limit.           \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n\nReal-Address Mode Exceptions:\n| #BR| If the bounds test fails.                  \n| #UD| If second operand is not a memory location.\n|    | If the LOCK prefix is used.                \n| #GP| If a memory operand effective address      \n|    | is outside the CS, DS, ES, FS, or GS       \n|    | segment limit.                             \n| #SS| If a memory operand effective address      \n|    | is outside the SS segment limit.           \n\nVirtual-8086 Mode Exceptions:\n| #BR            | If the bounds test fails.                  \n| #UD            | If second operand is not a memory location.\n|                | If the LOCK prefix is used.                \n| #GP(0)         | If a memory operand effective address      \n|                | is outside the CS, DS, ES, FS, or GS       \n|                | segment limit.                             \n| #SS(0)         | If a memory operand effective address      \n|                | is outside the SS segment limit.           \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made.     \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #UD| If in 64-bit mode.\n", 
      "mnem": "BOUND"
    }, 
    {
      "description": "\nBSF - Bit Scan Forward:\n| Opcode          | Instruction   | Op/En| 64-bit Mode| Compat/Leg Mode| Description               \n| 0F BC /r        | BSF r16, r/m16| RM   | Valid      | Valid          | Bit scan forward on r/m16.\n| 0F BC /r        | BSF r32, r/m32| RM   | Valid      | Valid          | Bit scan forward on r/m32.\n| REX.W + 0F BC /r| BSF r64, r/m64| RM   | Valid      | N.E.           | Bit scan forward on r/m64.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nSearches the source operand (second operand) for the least significant set bit\n(1 bit). If a least significant 1 bit is found, its bit index is stored in the\ndestination operand (first operand). The source operand can be a register or\na memory location; the destination operand is a register. The bit index is an\nunsigned offset from bit 0 of the source operand. If the content of the source\noperand is 0, the content of the destination operand is undefined.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nOperation:\n\nIF SRC = 0\n  THEN\n     ZF <- 1;\n     DEST is undefined;\n  ELSE\n     ZF <- 0;\n     temp <- 0;\n     WHILE Bit(SRC, temp) = 0\n     DO\n       temp <- temp + 1;\n     OD;\n     DEST <- temp;\nFI;\n\nFlags Affected:\nThe ZF flag is set to 1 if all the source operand is 0; otherwise, the ZF flag\nis cleared. The CF, OF, SF, AF, and PF, flags are undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "BSF"
    }, 
    {
      "description": "\nBSR - Bit Scan Reverse:\n| Opcode          | Instruction   | Op/En| 64-bit Mode| Compat/Leg Mode| Description               \n| 0F BD /r        | BSR r16, r/m16| RM   | Valid      | Valid          | Bit scan reverse on r/m16.\n| 0F BD /r        | BSR r32, r/m32| RM   | Valid      | Valid          | Bit scan reverse on r/m32.\n| REX.W + 0F BD /r| BSR r64, r/m64| RM   | Valid      | N.E.           | Bit scan reverse on r/m64.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nSearches the source operand (second operand) for the most significant set bit\n(1 bit). If a most significant 1 bit is found, its bit index is stored in the\ndestination operand (first operand). The source operand can be a register or\na memory location; the destination operand is a register. The bit index is an\nunsigned offset from bit 0 of the source operand. If the content source operand\nis 0, the content of the destination operand is undefined.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nOperation:\n\nIF SRC = 0\n  THEN\n     ZF <- 1;\n     DEST is undefined;\n  ELSE\n     ZF <- 0;\n     temp <- OperandSize - 1;\n     WHILE Bit(SRC, temp) = 0\n     DO\n       temp <- temp - 1;\n     OD;\n     DEST <- temp;\nFI;\n\nFlags Affected:\nThe ZF flag is set to 1 if all the source operand is 0; otherwise, the ZF flag\nis cleared. The CF, OF, SF, AF, and PF, flags are undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "BSR"
    }, 
    {
      "description": "\nBSWAP - Byte Swap:\n| Opcode          | Instruction| Op/En| 64-bit Mode| Compat/Leg Mode| Description                        \n| 0F C8+rd        | BSWAP r32  | O    | Valid*     | Valid          | Reverses the byte order of a 32-bit\n|                 |            |      |            |                | register.                          \n| REX.W + 0F C8+rd| BSWAP r64  | O    | Valid      | N.E.           | Reverses the byte order of a 64-bit\n|                 |            |      |            |                | register.                          \nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1         | Operand 2| Operand 3| Operand 4\n| O    | opcode + rd (r, w)| NA       | NA       | NA       \n\nDescription:\nReverses the byte order of a 32-bit or 64-bit (destination) register. This instruction\nis provided for converting littleendian values to big-endian format and vice\nversa. To swap bytes in a word value (16-bit register), use the XCHG instruction.\nWhen the BSWAP instruction references a 16-bit register, the result is undefined.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\n\nIA-32 Architecture Legacy Compatibility:\nThe BSWAP instruction is not supported on IA-32 processors earlier than the\nIntel486\u2122 processor family. For compatibility with this instruction, software\nshould include functionally equivalent code for execution on Intel processors\nearlier than the Intel486 processor family.\n\nOperation:\n\nTEMP <- DEST\nIF 64-bit mode AND OperandSize = 64\n  THEN\n     DEST[7:0] <- TEMP[63:56];\n     DEST[15:8] <- TEMP[55:48];\n     DEST[23:16] <- TEMP[47:40];\n     DEST[31:24] <- TEMP[39:32];\n     DEST[39:32] <- TEMP[31:24];\n     DEST[47:40] <- TEMP[23:16];\n     DEST[55:48] <- TEMP[15:8];\n     DEST[63:56] <- TEMP[7:0];\n  ELSE\n     DEST[7:0] <- TEMP[31:24];\n     DEST[15:8] <- TEMP[23:16];\n     DEST[23:16] <- TEMP[15:8];\n     DEST[31:24] <- TEMP[7:0];\nFI;\n\nFlags Affected:\nNone.\n\n\nExceptions (All Operating Modes):\n| #UD| If the LOCK prefix is used.\n", 
      "mnem": "BSWAP"
    }, 
    {
      "description": "\nBT - Bit Test:\n| Opcode             | Instruction   | Op/En| 64-bit Mode| Compat/Leg Mode| Description                   \n| 0F A3 /r           | BT r/m16, r16 | MR   | Valid      | Valid          | Store selected bit in CF flag.\n| 0F A3 /r           | BT r/m32, r32 | MR   | Valid      | Valid          | Store selected bit in CF flag.\n| REX.W + 0F A3 /r   | BT r/m64, r64 | MR   | Valid      | N.E.           | Store selected bit in CF flag.\n| 0F BA /4 ib        | BT r/m16, imm8| MI   | Valid      | Valid          | Store selected bit in CF flag.\n| 0F BA /4 ib        | BT r/m32, imm8| MI   | Valid      | Valid          | Store selected bit in CF flag.\n| REX.W + 0F BA /4 ib| BT r/m64, imm8| MI   | Valid      | N.E.           | Store selected bit in CF flag.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (r)| ModRM:reg (r)| NA       | NA       \n| MI   | ModRM:r/m (r)| imm8         | NA       | NA       \n\nDescription:\nSelects the bit in a bit string (specified with the first operand, called the\nbit base) at the bit-position designated by the bit offset (specified by the\nsecond operand) and stores the value of the bit in the CF flag. The bit base\noperand can be a register or a memory location; the bit offset operand can be\na register or an immediate value:\n\n - If the bit base operand specifies a register, the instruction takes the modulo\n16, 32, or 64 of the bit offset operand (modulo size depends on the mode and\nregister size; 64-bit operands are available only in 64-bit mode).\n - If the bit base operand specifies a memory location, the operand represents\nthe address of the byte in memory that contains the bit base (bit 0 of the specified\nbyte) of the bit string. The range of the bit position that can be referenced\nby the offset operand depends on the operand size.\n\nSee also: Bit(BitBase, BitOffset) on page 3-10.\n\nSome assemblers support immediate bit offsets larger than 31 by using the immediate\nbit offset field in combination with the displacement field of the memory operand.\nIn this case, the low-order 3 or 5 bits (3 for 16-bit operands, 5 for 32-bit\noperands) of the immediate bit offset are stored in the immediate bit offset\nfield, and the highorder bits are shifted and combined with the byte displacement\nin the addressing mode by the assembler. The processor will ignore the high\norder bits if they are not zero.\n\nWhen accessing a bit in memory, the processor may access 4 bytes starting from\nthe memory address for a 32-bit operand size, using by the following relationship:\n\nEffective Address + (4 * (BitOffset DIV 32))\n\nOr, it may access 2 bytes starting from the memory address for a 16-bit operand,\nusing this relationship:\n\nEffective Address + (2 * (BitOffset DIV 16))\n\nIt may do so even when only a single byte needs to be accessed to reach the\ngiven bit. When using this bit addressing mechanism, software should avoid referencing\nareas of memory close to address space holes. In particular, it should avoid\nreferences to memory-mapped I/O registers. Instead, software should use the\nMOV instructions to load from or store to these addresses, and use the register\nform of these instructions to manipulate the data.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bit operands.\nSee the summary chart at the beginning of this section for encoding data and\nlimits.\n\nOperation:\n\nCF <- Bit(BitBase, BitOffset);\n\nFlags Affected:\nThe CF flag contains the value of the selected bit. The ZF flag is unaffected.\nThe OF, SF, AF, and PF flags are undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "BT"
    }, 
    {
      "description": "\nBTC - Bit Test and Complement:\n| Opcode             | Instruction    | Op/En| 64-bit Mode| Compat/Leg Mode| Description                                  \n| 0F BB /r           | BTC r/m16, r16 | MR   | Valid      | Valid          | Store selected bit in CF flag and complement.\n| 0F BB /r           | BTC r/m32, r32 | MR   | Valid      | Valid          | Store selected bit in CF flag and complement.\n| REX.W + 0F BB /r   | BTC r/m64, r64 | MR   | Valid      | N.E.           | Store selected bit in CF flag and complement.\n| 0F BA /7 ib        | BTC r/m16, imm8| MI   | Valid      | Valid          | Store selected bit in CF flag and complement.\n| 0F BA /7 ib        | BTC r/m32, imm8| MI   | Valid      | Valid          | Store selected bit in CF flag and complement.\n| REX.W + 0F BA /7 ib| BTC r/m64, imm8| MI   | Valid      | N.E.           | Store selected bit in CF flag and complement.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (r, w)| ModRM:reg (r)| NA       | NA       \n| MI   | ModRM:r/m (r, w)| imm8         | NA       | NA       \n\nDescription:\nSelects the bit in a bit string (specified with the first operand, called the\nbit base) at the bit-position designated by the bit offset operand (second operand),\nstores the value of the bit in the CF flag, and complements the selected bit\nin the bit string. The bit base operand can be a register or a memory location;\nthe bit offset operand can be a register or an immediate value:\n\n - If the bit base operand specifies a register, the instruction takes the modulo\n16, 32, or 64 of the bit offset operand (modulo size depends on the mode and\nregister size; 64-bit operands are available only in 64-bit mode). This allows\nany bit position to be selected.\n - If the bit base operand specifies a memory location, the operand represents\nthe address of the byte in memory that contains the bit base (bit 0 of the specified\nbyte) of the bit string. The range of the bit position that can be referenced\nby the offset operand depends on the operand size.\n\nSee also: Bit(BitBase, BitOffset) on page 3-10.\n\nSome assemblers support immediate bit offsets larger than 31 by using the immediate\nbit offset field in combination with the displacement field of the memory operand.\nSee \u201cBT - Bit Test\u201d in this chapter for more information on this addressing mechanism.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nOperation:\n\nCF <- Bit(BitBase, BitOffset);\nBit(BitBase, BitOffset) <- NOT Bit(BitBase, BitOffset);\n\nFlags Affected:\nThe CF flag contains the value of the selected bit before it is complemented.\nThe ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination operand points to          \n|                | a non-writable segment. If a memory           \n|                | operand effective address is outside          \n|                | the CS, DS, ES, FS, or GS segment limit.      \n|                | If the DS, ES, FS, or GS register contains    \n|                | a NULL segment selector.                      \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "BTC"
    }, 
    {
      "description": "\nBTR - Bit Test and Reset:\n| Opcode             | Instruction    | Op/En| 64-bit Mode| Compat/Leg Mode| Description                             \n| 0F B3 /r           | BTR r/m16, r16 | MR   | Valid      | Valid          | Store selected bit in CF flag and clear.\n| 0F B3 /r           | BTR r/m32, r32 | MR   | Valid      | Valid          | Store selected bit in CF flag and clear.\n| REX.W + 0F B3 /r   | BTR r/m64, r64 | MR   | Valid      | N.E.           | Store selected bit in CF flag and clear.\n| 0F BA /6 ib        | BTR r/m16, imm8| MI   | Valid      | Valid          | Store selected bit in CF flag and clear.\n| 0F BA /6 ib        | BTR r/m32, imm8| MI   | Valid      | Valid          | Store selected bit in CF flag and clear.\n| REX.W + 0F BA /6 ib| BTR r/m64, imm8| MI   | Valid      | N.E.           | Store selected bit in CF flag and clear.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (r, w)| ModRM:reg (r)| NA       | NA       \n| MI   | ModRM:r/m (r, w)| imm8         | NA       | NA       \n\nDescription:\nSelects the bit in a bit string (specified with the first operand, called the\nbit base) at the bit-position designated by the bit offset operand (second operand),\nstores the value of the bit in the CF flag, and clears the selected bit in the\nbit string to 0. The bit base operand can be a register or a memory location;\nthe bit offset operand can be a register or an immediate value:\n\n - If the bit base operand specifies a register, the instruction takes the modulo\n16, 32, or 64 of the bit offset operand (modulo size depends on the mode and\nregister size; 64-bit operands are available only in 64-bit mode). This allows\nany bit position to be selected.\n - If the bit base operand specifies a memory location, the operand represents\nthe address of the byte in memory that contains the bit base (bit 0 of the specified\nbyte) of the bit string. The range of the bit position that can be referenced\nby the offset operand depends on the operand size.\n\nSee also: Bit(BitBase, BitOffset) on page 3-10.\n\nSome assemblers support immediate bit offsets larger than 31 by using the immediate\nbit offset field in combination with the displacement field of the memory operand.\nSee \u201cBT - Bit Test\u201d in this chapter for more information on this addressing mechanism.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nOperation:\n\nCF <- Bit(BitBase, BitOffset);\nBit(BitBase, BitOffset) <- 0;\n\nFlags Affected:\nThe CF flag contains the value of the selected bit before it is cleared. The\nZF flag is unaffected. The OF, SF, AF, and PF flags are undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination operand points to          \n|                | a non-writable segment. If a memory           \n|                | operand effective address is outside          \n|                | the CS, DS, ES, FS, or GS segment limit.      \n|                | If the DS, ES, FS, or GS register contains    \n|                | a NULL segment selector.                      \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "BTR"
    }, 
    {
      "description": "\nBTS - Bit Test and Set:\n| Opcode             | Instruction    | Op/En| 64-bit Mode| Compat/Leg Mode| Description                           \n| 0F AB /r           | BTS r/m16, r16 | MR   | Valid      | Valid          | Store selected bit in CF flag and set.\n| 0F AB /r           | BTS r/m32, r32 | MR   | Valid      | Valid          | Store selected bit in CF flag and set.\n| REX.W + 0F AB /r   | BTS r/m64, r64 | MR   | Valid      | N.E.           | Store selected bit in CF flag and set.\n| 0F BA /5 ib        | BTS r/m16, imm8| MI   | Valid      | Valid          | Store selected bit in CF flag and set.\n| 0F BA /5 ib        | BTS r/m32, imm8| MI   | Valid      | Valid          | Store selected bit in CF flag and set.\n| REX.W + 0F BA /5 ib| BTS r/m64, imm8| MI   | Valid      | N.E.           | Store selected bit in CF flag and set.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (r, w)| ModRM:reg (r)| NA       | NA       \n| MI   | ModRM:r/m (r, w)| imm8         | NA       | NA       \n\nDescription:\nSelects the bit in a bit string (specified with the first operand, called the\nbit base) at the bit-position designated by the bit offset operand (second operand),\nstores the value of the bit in the CF flag, and sets the selected bit in the\nbit string to 1. The bit base operand can be a register or a memory location;\nthe bit offset operand can be a register or an immediate value:\n\n - If the bit base operand specifies a register, the instruction takes the modulo\n16, 32, or 64 of the bit offset operand (modulo size depends on the mode and\nregister size; 64-bit operands are available only in 64-bit mode). This allows\nany bit position to be selected.\n - If the bit base operand specifies a memory location, the operand represents\nthe address of the byte in memory that contains the bit base (bit 0 of the specified\nbyte) of the bit string. The range of the bit position that can be referenced\nby the offset operand depends on the operand size.\n\nSee also: Bit(BitBase, BitOffset) on page 3-10.\n\nSome assemblers support immediate bit offsets larger than 31 by using the immediate\nbit offset field in combination with the displacement field of the memory operand.\nSee \u201cBT - Bit Test\u201d in this chapter for more information on this addressing mechanism.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nOperation:\n\nCF <- Bit(BitBase, BitOffset);\nBit(BitBase, BitOffset) <- 1;\n\nFlags Affected:\nThe CF flag contains the value of the selected bit before it is set. The ZF\nflag is unaffected. The OF, SF, AF, and PF flags are undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination operand points to          \n|                | a non-writable segment. If a memory           \n|                | operand effective address is outside          \n|                | the CS, DS, ES, FS, or GS segment limit.      \n|                | If the DS, ES, FS, or GS register contains    \n|                | a NULL segment selector.                      \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP            | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS            | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "BTS"
    }, 
    {
      "description": "\nBZHI  -  Zero High Bits Starting with Specified Bit Position:\n| Opcode/Instruction                  | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                            \n| VEX.NDS1.LZ.0F38.W0 F5 /r BZHI r32a,| RMV  | V/V            | BMI2              | Zero bits in r/m32 starting with the   \n| r/m32, r32b                         |      |                |                   | position in r32b, write result to r32a.\n| VEX.NDS1.LZ.0F38.W1 F5 /r BZHI r64a,| RMV  | V/N.E.         | BMI2              | Zero bits in r/m64 starting with the   \n| r/m64, r64b                         |      |                |                   | position in r64b, write result to r64a.\nNotes: 1. ModRM:r/m is used to encode the first source operand (second operand)\nand VEX.vvvv encodes the second source operand (third operand).\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3   | Operand 4\n| RMV  | ModRM:reg (w)| ModRM:r/m (r)| VEX.vvvv (r)| NA       \n\nDescription:\nBZHI copies the bits of the first source operand (the second operand) into the\ndestination operand (the first operand) and clears the higher bits in the destination\naccording to the INDEX value specified by the second source operand (the third\noperand). The INDEX is specified by bits 7:0 of the second source operand. The\nINDEX value is saturated at the value of OperandSize -1. CF is set, if the number\ncontained in the 8 low bits of the third operand is greater than OperandSize\n-1. This instruction is not supported in real mode and virtual-8086 mode. The\noperand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand\nsize 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to\nexecute this instruction with VEX.L not equal to 0 will cause #UD.\n\nOperation:\n\nN <- SRC2[7:0]\nDEST <- SRC1\nIF (N < OperandSize)\n  DEST[OperandSize-1:N] <- 0\nFI\nIF (N > OperandSize - 1)\n  CF <- 1\nELSE\n  CF <- 0\nFI\n\nFlags Affected:\nZF, CF and SF flags are updated based on the result. OF flag is cleared. AF\nand PF flags are undefined.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| BZHI:| unsigned __int32 _bzhi_u32(unsigned  \n|      | __int32 src, unsigned __int32 index);\n| BZHI:| unsigned __int64 _bzhi_u64(unsigned  \n|      | __int64 src, unsigned __int32 index);\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Section 2.5.1, \u201cException Conditions for VEX-Encoded GPR Instructions\u201d,\nTable 2-29; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "BZHI"
    }, 
    {
      "description": "\nCALL - Call Procedure:\n| Opcode       | Instruction  | Op/En| 64-bit Mode| Compat/Leg Mode| Description                                    \n| E8 cw        | CALL rel16   | M    | N.S.       | Valid          | Call near, relative, displacement relative     \n|              |              |      |            |                | to next instruction.                           \n| E8 cd        | CALL rel32   | M    | Valid      | Valid          | Call near, relative, displacement relative     \n|              |              |      |            |                | to next instruction. 32-bit displacement       \n|              |              |      |            |                | sign extended to 64-bits in 64-bit mode.       \n| FF /2        | CALL r/m16   | M    | N.E.       | Valid          | Call near, absolute indirect, address          \n|              |              |      |            |                | given in r/m16.                                \n| FF /2        | CALL r/m32   | M    | N.E.       | Valid          | Call near, absolute indirect, address          \n|              |              |      |            |                | given in r/m32.                                \n| FF /2        | CALL r/m64   | M    | Valid      | N.E.           | Call near, absolute indirect, address          \n|              |              |      |            |                | given in r/m64.                                \n| 9A cd        | CALL ptr16:16| D    | Invalid    | Valid          | Call far, absolute, address given in           \n|              |              |      |            |                | operand.                                       \n| 9A cp        | CALL ptr16:32| D    | Invalid    | Valid          | Call far, absolute, address given in           \n|              |              |      |            |                | operand.                                       \n| FF /3        | CALL m16:16  | M    | Valid      | Valid          | Call far, absolute indirect address            \n|              |              |      |            |                | given in m16:16. In 32-bit mode: if            \n|              |              |      |            |                | selector points to a gate, then RIP            \n|              |              |      |            |                | = 32-bit zero extended displacement            \n|              |              |      |            |                | taken from gate; else RIP = zero extended      \n|              |              |      |            |                | 16bit offset from far pointer referenced       \n|              |              |      |            |                | in the instruction.                            \n| FF /3        | CALL m16:32  | M    | Valid      | Valid          | In 64-bit mode: If selector points to          \n|              |              |      |            |                | a gate, then RIP = 64-bit displacement         \n|              |              |      |            |                | taken from gate; else RIP = zero extended      \n|              |              |      |            |                | 32-bit offset from far pointer referenced      \n|              |              |      |            |                | in the instruction.                            \n| REX.W + FF /3| CALL m16:64  | M    | Valid      | N.E.           | In 64-bit mode: If selector points to          \n|              |              |      |            |                | a gate, then RIP = 64-bit displacement         \n|              |              |      |            |                | taken from gate; else RIP = 64-bit offset      \n|              |              |      |            |                | from far pointer referenced in the instruction.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| D    | Offset       | NA       | NA       | NA       \n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nSaves procedure linking information on the stack and branches to the called\nprocedure specified using the target operand. The target operand specifies the\naddress of the first instruction in the called procedure. The operand can be\nan immediate value, a general-purpose register, or a memory location.\n\nThis instruction can be used to execute four types of calls:\n\n - Near Call  - A call to a procedure in the current code segment (the segment currently\npointed to by the CS register), sometimes referred to as an intra-segment call.\n - Far Call  -  A call to a procedure located in a different segment than the current\ncode segment, sometimes referred to as an inter-segment call.\n - Inter-privilege-level far call  -  A far call to a procedure in a segment at a\ndifferent privilege level than that of the currently executing program or procedure.\n - Task switch  -  A call to a procedure located in a different task.\n\nThe latter two call types (inter-privilege-level call and task switch) can only\nbe executed in protected mode. See \u201cCalling Procedures Using Call and RET\u201d in\nChapter 6 of the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 1, for additional information on near, far, and inter-privilege-level\ncalls. See Chapter 7, \u201cTask Management,\u201d in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 3A, for information on performing task switches\nwith the CALL instruction.\n\nNear Call. When executing a near call, the processor pushes the value of the\nEIP register (which contains the offset of the instruction following the CALL\ninstruction) on the stack (for use later as a return-instruction pointer). The\nprocessor then branches to the address in the current code segment specified\nby the target operand. The target operand specifies either an absolute offset\nin the code segment (an offset from the base of the code segment) or a relative\noffset (a signed displacement relative to the current value of the instruction\npointer in the EIP register; this value points to the instruction following\nthe CALL instruction). The CS register is not changed on near calls.\n\nFor a near call absolute, an absolute offset is specified indirectly in a general-purpose\nregister or a memory location (r/m16, r/m32, or r/m64). The operand-size attribute\ndetermines the size of the target operand (16, 32 or 64 bits). When in 64-bit\nmode, the operand size for near call (and all near branches) is forced to 64-bits.\nAbsolute offsets are loaded directly into the EIP(RIP) register. If the operand\nsize attribute is 16, the upper two bytes of the EIP register are cleared, resulting\nin a maximum instruction pointer size of 16 bits. When accessing an absolute\noffset indirectly using the stack pointer [ESP] as the base register, the base\nvalue used is the value of the ESP before the instruction executes.\n\nA relative offset (rel16 or rel32) is generally specified as a label in assembly\ncode. But at the machine code level, it is encoded as a signed, 16- or 32-bit\nimmediate value. This value is added to the value in the EIP(RIP) register.\nIn 64-bit mode the relative offset is always a 32-bit immediate value which\nis sign extended to 64-bits before it is added to the value in the RIP register\nfor the target calculation. As with absolute offsets, the operand-size attribute\ndetermines the size of the target operand (16, 32, or 64 bits). In 64-bit mode\nthe target operand will always be 64bits because the operand size is forced\nto 64-bits for near branches.\n\nFar Calls in Real-Address or Virtual-8086 Mode. When executing a far call in\nreal- address or virtual-8086 mode, the processor pushes the current value of\nboth the CS and EIP registers on the stack for use as a return-instruction pointer.\nThe processor then performs a \u201cfar branch\u201d to the code segment and offset specified\nwith the target operand for the called procedure. The target operand specifies\nan absolute far address either directly with a pointer (ptr16:16 or ptr16:32)\nor indirectly with a memory location (m16:16 or m16:32). With the pointer method,\nthe segment and offset of the called procedure is encoded in the instruction\nusing a 4-byte (16-bit operand size) or 6byte (32-bit operand size) far address\nimmediate. With the indirect method, the target operand specifies a memory location\nthat contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size)\nfar address. The operand-size attribute determines the size of the offset (16\nor 32 bits) in the far address. The far address is loaded directly into the\nCS and EIP registers. If the operand-size attribute is 16, the upper two bytes\nof the EIP register are cleared.\n\nFar Calls in Protected Mode. When the processor is operating in protected mode,\nthe CALL instruction can be used to perform the following types of far calls:\n\n - Far call to the same privilege level\n - Far call to a different privilege level (inter-privilege level call)\n - Task switch (far call to another task)\n\nIn protected mode, the processor always uses the segment selector part of the\nfar address to access the corresponding descriptor in the GDT or LDT. The descriptor\ntype (code segment, call gate, task gate, or TSS) and access rights determine\nthe type of call operation to be performed.\n\nIf the selected descriptor is for a code segment, a far call to a code segment\nat the same privilege level is performed. (If the selected code segment is at\na different privilege level and the code segment is non-conforming, a general-protection\nexception is generated.) A far call to the same privilege level in protected\nmode is very similar to one carried out in real-address or virtual-8086 mode.\nThe target operand specifies an absolute far address either directly with a\npointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16\nor m16:32). The operand- size attribute determines the size of the offset (16\nor 32 bits) in the far address. The new code segment selector and its descriptor\nare loaded into CS register; the offset from the instruction is loaded into\nthe EIP register.\n\nA call gate (described in the next paragraph) can also be used to perform a\nfar call to a code segment at the same privilege level. Using this mechanism\nprovides an extra level of indirection and is the preferred method of making\ncalls between 16-bit and 32-bit code segments.\n\nWhen executing an inter-privilege-level far call, the code segment for the procedure\nbeing called must be accessed through a call gate. The segment selector specified\nby the target operand identifies the call gate. The target\n\noperand can specify the call gate segment selector either directly with a pointer\n(ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32).\nThe processor obtains the segment selector for the new code segment and the\nnew instruction pointer (offset) from the call gate descriptor. (The offset\nfrom the target operand is ignored when a call gate is used.)\n\nOn inter-privilege-level calls, the processor switches to the stack for the\nprivilege level of the called procedure. The segment selector for the new stack\nsegment is specified in the TSS for the currently running task. The branch to\nthe new code segment occurs after the stack switch. (Note that when using a\ncall gate to perform a far call to a segment at the same privilege level, no\nstack switch occurs.) On the new stack, the processor pushes the segment selector\nand stack pointer for the calling procedure's stack, an optional set of parameters\nfrom the calling procedures stack, and the segment selector and instruction\npointer for the calling procedure's code segment. (A value in the call gate\ndescriptor determines how many parameters to copy to the new stack.) Finally,\nthe processor branches to the address of the procedure being called within the\nnew code segment.\n\nExecuting a task switch with the CALL instruction is similar to executing a\ncall through a call gate. The target operand specifies the segment selector\nof the task gate for the new task activated by the switch (the offset in the\ntarget operand is ignored). The task gate in turn points to the TSS for the\nnew task, which contains the segment selectors for the task's code and stack\nsegments. Note that the TSS also contains the EIP value for the next instruction\nthat was to be executed before the calling task was suspended. This instruction\npointer value is loaded into the EIP register to re-start the calling task.\n\nThe CALL instruction can also specify the segment selector of the TSS directly,\nwhich eliminates the indirection of the task gate. See Chapter 7, \u201cTask Management,\u201d\nin the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n3A, for information on the mechanics of a task switch.\n\nWhen you execute at task switch with a CALL instruction, the nested task flag\n(NT) is set in the EFLAGS register and the new TSS's previous task link field\nis loaded with the old task's TSS selector. Code is expected to suspend this\nnested task by executing an IRET instruction which, because the NT flag is set,\nautomatically uses the previous task link to return to the calling task. (See\n\u201cTask Linking\u201d in Chapter 7 of the Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 3A, for information on nested tasks.) Switching tasks\nwith the CALL instruction differs in this regard from JMP instruction. JMP does\nnot set the NT flag and therefore does not expect an IRET instruction to suspend\nthe task.\n\nMixing 16-Bit and 32-Bit Calls. When making far calls between 16-bit and 32-bit\ncode segments, use a call gate. If the far call is from a 32-bit code segment\nto a 16-bit code segment, the call should be made from the first 64 KBytes of\nthe 32-bit code segment. This is because the operand-size attribute of the instruction\nis set to 16, so only a 16-bit return address offset can be saved. Also, the\ncall should be made using a 16-bit call gate so that 16-bit values can be pushed\non the stack. See Chapter 21, \u201cMixing 16-Bit and 32-Bit Code,\u201d in the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 3B, for more\ninformation.\n\nFar Calls in Compatibility Mode. When the processor is operating in compatibility\nmode, the CALL instruction can be used to perform the following types of far\ncalls:\n\n - Far call to the same privilege level, remaining in compatibility mode\n - Far call to the same privilege level, transitioning to 64-bit mode\n - Far call to a different privilege level (inter-privilege level call), transitioning\nto 64-bit mode\n\nNote that a CALL instruction can not be used to cause a task switch in compatibility\nmode since task switches are not supported in IA-32e mode.\n\nIn compatibility mode, the processor always uses the segment selector part of\nthe far address to access the corresponding descriptor in the GDT or LDT. The\ndescriptor type (code segment, call gate) and access rights determine the type\nof call operation to be performed.\n\nIf the selected descriptor is for a code segment, a far call to a code segment\nat the same privilege level is performed. (If the selected code segment is at\na different privilege level and the code segment is non-conforming, a general-protection\nexception is generated.) A far call to the same privilege level in compatibility\nmode is very similar to one carried out in protected mode. The target operand\nspecifies an absolute far address either directly with a pointer (ptr16:16 or\nptr16:32) or indirectly with a memory location (m16:16 or m16:32). The operand-size\nattribute determines the size of the offset (16 or 32 bits) in the far address.\nThe new code segment selector and its descriptor are loaded into CS register\nand the offset from the instruction is loaded into the EIP register. The difference\nis that 64-bit mode may be entered. This specified by the L bit in the new code\nsegment descriptor.\n\nNote that a 64-bit call gate (described in the next paragraph) can also be used\nto perform a far call to a code segment at the same privilege level. However,\nusing this mechanism requires that the target code segment descriptor have the\nL bit set, causing an entry to 64-bit mode.\n\nWhen executing an inter-privilege-level far call, the code segment for the procedure\nbeing called must be accessed through a 64-bit call gate. The segment selector\nspecified by the target operand identifies the call gate. The target operand\ncan specify the call gate segment selector either directly with a pointer (ptr16:16\nor ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The processor\nobtains the segment selector for the new code segment and the new instruction\npointer (offset) from the 16-byte call gate descriptor. (The offset from the\ntarget operand is ignored when a call gate is used.)\n\nOn inter-privilege-level calls, the processor switches to the stack for the\nprivilege level of the called procedure. The segment selector for the new stack\nsegment is set to NULL. The new stack pointer is specified in the TSS for the\ncurrently running task. The branch to the new code segment occurs after the\nstack switch. (Note that when using a call gate to perform a far call to a segment\nat the same privilege level, an implicit stack switch occurs as a result of\nentering 64-bit mode. The SS selector is unchanged, but stack segment accesses\nuse a segment base of 0x0, the limit is ignored, and the default stack size\nis 64-bits. The full value of RSP is used for the offset, of which the upper\n32-bits are undefined.) On the new stack, the processor pushes the segment selector\nand stack pointer for the calling procedure's stack and the segment selector\nand instruction pointer for the calling procedure's code segment. (Parameter\ncopy is not supported in IA-32e mode.) Finally, the processor branches to the\naddress of the procedure being called within the new code segment.\n\nNear/(Far) Calls in 64-bit Mode. When the processor is operating in 64-bit mode,\nthe CALL instruction can be used to perform the following types of far calls:\n\n - Far call to the same privilege level, transitioning to compatibility mode\n - Far call to the same privilege level, remaining in 64-bit mode\n - Far call to a different privilege level (inter-privilege level call), remaining\nin 64-bit mode\n\nNote that in this mode the CALL instruction can not be used to cause a task\nswitch in 64-bit mode since task switches are not supported in IA-32e mode.\n\nIn 64-bit mode, the processor always uses the segment selector part of the far\naddress to access the corresponding descriptor in the GDT or LDT. The descriptor\ntype (code segment, call gate) and access rights determine the type of call\noperation to be performed.\n\nIf the selected descriptor is for a code segment, a far call to a code segment\nat the same privilege level is performed. (If the selected code segment is at\na different privilege level and the code segment is non-conforming, a general-protection\nexception is generated.) A far call to the same privilege level in 64-bit mode\nis very similar to one carried out in compatibility mode. The target operand\nspecifies an absolute far address indirectly with a memory location (m16:16,\nm16:32 or m16:64). The form of CALL with a direct specification of absolute\nfar address is not defined in 64-bit mode. The operand-size attribute determines\nthe size of the offset (16, 32, or 64 bits) in the far address. The new code\nsegment selector and its descriptor are loaded into the CS register; the offset\nfrom the instruction is loaded into the EIP register. The new code segment may\nspecify entry either into compatibility or 64-bit mode, based on the L bit value.\n\nA 64-bit call gate (described in the next paragraph) can also be used to perform\na far call to a code segment at the same privilege level. However, using this\nmechanism requires that the target code segment descriptor have the L bit set.\n\nWhen executing an inter-privilege-level far call, the code segment for the procedure\nbeing called must be accessed through a 64-bit call gate. The segment selector\nspecified by the target operand identifies the call gate. The target operand\ncan only specify the call gate segment selector indirectly with a memory location\n(m16:16, m16:32 or m16:64). The processor obtains the segment selector for the\nnew code segment and the new instruction pointer (offset) from the 16-byte call\ngate descriptor. (The offset from the target operand is ignored when a call\ngate is used.)\n\nOn inter-privilege-level calls, the processor switches to the stack for the\nprivilege level of the called procedure. The segment selector for the new stack\nsegment is set to NULL. The new stack pointer is specified in the TSS for the\ncurrently running task. The branch to the new code segment occurs after the\nstack switch.\n\nNote that when using a call gate to perform a far call to a segment at the same\nprivilege level, an implicit stack switch occurs as a result of entering 64-bit\nmode. The SS selector is unchanged, but stack segment accesses use a segment\nbase of 0x0, the limit is ignored, and the default stack size is 64-bits. (The\nfull value of RSP is used for the\n\noffset.) On the new stack, the processor pushes the segment selector and stack\npointer for the calling procedure's stack and the segment selector and instruction\npointer for the calling procedure's code segment. (Parameter copy is not supported\nin IA-32e mode.) Finally, the processor branches to the address of the procedure\nbeing called within the new code segment.\n\nOperation:\n\nIF near call\n  THEN IF near relative call\n     THEN\n       IF OperandSize = 64\n          THEN\n             tempDEST <- SignExtend(DEST); (* DEST is rel32 *)\n             tempRIP <- RIP + tempDEST;\n             IF stack not large enough for a 8-byte return address\n               THEN #SS(0); FI;\n             Push(RIP);\n             RIP <- tempRIP;\n       FI;\n       IF OperandSize = 32\n          THEN\n             tempEIP <- EIP + DEST; (* DEST is rel32 *)\n             IF tempEIP is not within code segment limit THEN #GP(0); FI;\n             IF stack not large enough for a 4-byte return address\n               THEN #SS(0); FI;\n             Push(EIP);\n             EIP <- tempEIP;\n       FI;\n       IF OperandSize = 16\n          THEN\n             tempEIP <- (EIP + DEST) AND 0000FFFFH; (* DEST is rel16 *)\n             IF tempEIP is not within code segment limit THEN #GP(0); FI;\n             IF stack not large enough for a 2-byte return address\n               THEN #SS(0); FI;\n             Push(IP);\n             EIP <- tempEIP;\n       FI;\n     ELSE (* Near absolute call *)\n       IF OperandSize = 64\n          THEN\n             tempRIP <- DEST; (* DEST is r/m64 *)\n             IF stack not large enough for a 8-byte return address\n               THEN #SS(0); FI;\n             Push(RIP);\n             RIP <- tempRIP;\n       FI;\n       IF OperandSize = 32\n          THEN\n             tempEIP <- DEST; (* DEST is r/m32 *)\n             IF tempEIP is not within code segment limit THEN #GP(0); FI;\n             IF stack not large enough for a 4-byte return address\n               THEN #SS(0); FI;\n             Push(EIP);\n             EIP <- tempEIP;\n       FI;\n       IF OperandSize = 16\n          THEN\n             tempEIP <- DEST AND 0000FFFFH; (* DEST is r/m16 *)\n             IF tempEIP is not within code segment limit THEN #GP(0); FI;\n             IF stack not large enough for a 2-byte return address\n               THEN #SS(0); FI;\n             Push(IP);\n             EIP <- tempEIP;\n       FI;\n  FI;rel/abs\nFI; near\nIF far call and (PE = 0 or (PE = 1 and VM = 1)) (* Real-address or virtual-8086 mode *)\n  THEN\n     IF OperandSize = 32\n       THEN\n          IF stack not large enough for a 6-byte return address\n             THEN #SS(0); FI;\n          IF DEST[31:16] is not zero THEN #GP(0); FI;\n          Push(CS); (* Padded with 16 high-order bits *)\n          Push(EIP);\n          CS <- DEST[47:32]; (* DEST is ptr16:32 or [m16:32] *)\n          EIP <- DEST[31:0]; (* DEST is ptr16:32 or [m16:32] *)\n       ELSE (* OperandSize = 16 *)\n          IF stack not large enough for a 4-byte return address\n             THEN #SS(0); FI;\n          Push(CS);\n          Push(IP);\n          CS <- DEST[31:16]; (* DEST is ptr16:16 or [m16:16] *)\n          EIP <- DEST[15:0]; (* DEST is ptr16:16 or [m16:16]; clear upper 16 bits *)\n     FI;\nFI;\nIF far call and (PE = 1 and VM = 0) (* Protected mode or IA-32e Mode, not virtual-8086 mode*)\n  THEN\n     IF segment selector in target operand NULL\n       THEN #GP(0); FI;\n     IF segment selector index not within descriptor table limits\n       THEN #GP(new code segment selector); FI;\n     Read type and access rights of selected segment descriptor;\n     IF IA32_EFER.LMA = 0\n       THEN\n          IF segment type is not a conforming or nonconforming code segment, call\n          gate, task gate, or TSS\n             THEN #GP(segment selector); FI;\n       ELSE\n          IF segment type is not a conforming or nonconforming code segment or\n          64-bit call gate,\n             THEN #GP(segment selector); FI;\n     FI;\n     Depending on type and access rights:\n       GO TO CONFORMING-CODE-SEGMENT;\n       GO TO NONCONFORMING-CODE-SEGMENT;\n       GO TO CALL-GATE;\n       GO TO TASK-GATE;\n       GO TO TASK-STATE-SEGMENT;\nFI;\nCONFORMING-CODE-SEGMENT:\n  IF L bit = 1 and D bit = 1 and IA32_EFER.LMA = 1\n     THEN GP(new code segment selector); FI;\n  IF DPL > CPL\n     THEN #GP(new code segment selector); FI;\n  IF segment not present\n     THEN #NP(new code segment selector); FI;\n  IF stack not large enough for return address\n     THEN #SS(0); FI;\n  tempEIP <- DEST(Offset);\n  IF OperandSize = 16\n     THEN\n       tempEIP <- tempEIP AND 0000FFFFH; FI; (* Clear upper 16 bits *)\n  IF (EFER.LMA = 0 or target mode = Compatibility mode) and (tempEIP outside new code\n  segment limit)\n     THEN #GP(0); FI;\n  IF tempEIP is non-canonical\n     THEN #GP(0); FI;\n  IF OperandSize = 32\n     THEN\n       Push(CS); (* Padded with 16 high-order bits *)\n       Push(EIP);\n       CS <- DEST(CodeSegmentSelector);\n       (* Segment descriptor information also loaded *)\n       CS(RPL) <- CPL;\n       EIP <- tempEIP;\n     ELSE\n       IF OperandSize = 16\n          THEN\n             Push(CS);\n             Push(IP);\n             CS <- DEST(CodeSegmentSelector);\n             (* Segment descriptor information also loaded *)\n             CS(RPL) <- CPL;\n             EIP <- tempEIP;\n          ELSE (* OperandSize = 64 *)\n             Push(CS); (* Padded with 48 high-order bits *)\n             Push(RIP);\n             CS <- DEST(CodeSegmentSelector);\n             (* Segment descriptor information also loaded *)\n             CS(RPL) <- CPL;\n             RIP <- tempEIP;\n       FI;\n  FI;\nEND;\nNONCONFORMING-CODE-SEGMENT:\n  IF L-Bit = 1 and D-BIT = 1 and IA32_EFER.LMA = 1\n     THEN GP(new code segment selector); FI;\n  IF (RPL > CPL) or (DPL != CPL)\n     THEN #GP(new code segment selector); FI;\n  IF segment not present\n     THEN #NP(new code segment selector); FI;\n  IF stack not large enough for return address\n     THEN #SS(0); FI;\n  tempEIP <- DEST(Offset);\n  IF OperandSize = 16\n     THEN tempEIP <- tempEIP AND 0000FFFFH; FI; (* Clear upper 16 bits *)\n  IF (EFER.LMA = 0 or target mode = Compatibility mode) and (tempEIP outside new code\n  segment limit)\n     THEN #GP(0); FI;\n  IF tempEIP is non-canonical\n     THEN #GP(0); FI;\n  IF OperandSize = 32\n     THEN\n       Push(CS); (* Padded with 16 high-order bits *)\n       Push(EIP);\n       CS <- DEST(CodeSegmentSelector);\n       (* Segment descriptor information also loaded *)\n       CS(RPL) <- CPL;\n       EIP <- tempEIP;\n     ELSE\n       IF OperandSize = 16\n          THEN\n             Push(CS);\n             Push(IP);\n             CS <- DEST(CodeSegmentSelector);\n             (* Segment descriptor information also loaded *)\n             CS(RPL) <- CPL;\n             EIP <- tempEIP;\n          ELSE (* OperandSize = 64 *)\n             Push(CS); (* Padded with 48 high-order bits *)\n             Push(RIP);\n             CS <- DEST(CodeSegmentSelector);\n             (* Segment descriptor information also loaded *)\n             CS(RPL) <- CPL;\n             RIP <- tempEIP;\n       FI;\n  FI;\nEND;\nCALL-GATE:\n  IF call gate (DPL < CPL) or (RPL > DPL)\n     THEN #GP(call-gate selector); FI;\n  IF call gate not present\n     THEN #NP(call-gate selector); FI;\n  IF call-gate code-segment selector is NULL\n     THEN #GP(0); FI;\n  IF call-gate code-segment selector index is outside descriptor table limits\n     THEN #GP(call-gate code-segment selector); FI;\n  Read call-gate code-segment descriptor;\n  IF call-gate code-segment descriptor does not indicate a code segment\n  or call-gate code-segment descriptor DPL > CPL\n     THEN #GP(call-gate code-segment selector); FI;\n  IF IA32_EFER.LMA = 1 AND (call-gate code-segment descriptor is\n  not a 64-bit code segment or call-gate code-segment descriptor has both L-bit and D-bit set)\n     THEN #GP(call-gate code-segment selector); FI;\n  IF call-gate code segment not present\n     THEN #NP(call-gate code-segment selector); FI;\n  IF call-gate code segment is non-conforming and DPL < CPL\n     THEN go to MORE-PRIVILEGE;\n     ELSE go to SAME-PRIVILEGE;\n  FI;\nEND;\nMORE-PRIVILEGE:\n  IF current TSS is 32-bit\n     THEN\n       TSSstackAddress <- (new code-segment DPL * 8) + 4;\n       IF (TSSstackAddress + 5) > current TSS limit\n          THEN #TS(current TSS selector); FI;\n       NewSS <- 2 bytes loaded from (TSS base + TSSstackAddress + 4);\n       NewESP <- 4 bytes loaded from (TSS base + TSSstackAddress);\n     ELSE\n       IF current TSS is 16-bit\n          THEN\n             TSSstackAddress <- (new code-segment DPL * 4) + 2\n             IF (TSSstackAddress + 3) > current TSS limit\n               THEN #TS(current TSS selector); FI;\n             NewSS <- 2 bytes loaded from (TSS base + TSSstackAddress + 2);\n             NewESP <- 2 bytes loaded from (TSS base + TSSstackAddress);\n          ELSE (* current TSS is 64-bit *)\n             TSSstackAddress <- (new code-segment DPL * 8) + 4;\n             IF (TSSstackAddress + 7) > current TSS limit\n               THEN #TS(current TSS selector); FI;\n             NewSS <- new code-segment DPL; (* NULL selector with RPL = new CPL *)\n             NewRSP <- 8 bytes loaded from (current TSS base + TSSstackAddress);\n       FI;\n  FI;\n  IF IA32_EFER.LMA = 0 and NewSS is NULL\n     THEN #TS(NewSS); FI;\n  Read new code-segment descriptor and new stack-segment descriptor;\n  IF IA32_EFER.LMA = 0 and (NewSS RPL != new code-segment DPL\n  or new stack-segment DPL != new code-segment DPL or new stack segment is not a\n  writable data segment)\n     THEN #TS(NewSS); FI\n  IF IA32_EFER.LMA = 0 and new stack segment not present\n     THEN #SS(NewSS); FI;\n  IF CallGateSize = 32\n     THEN\n       IF new stack does not have room for parameters plus 16 bytes\n          THEN #SS(NewSS); FI;\n       IF CallGate(InstructionPointer) not within new code-segment limit\n          THEN #GP(0); FI;\n       SS <- newSS; (* Segment descriptor information also loaded *)\n       ESP <- newESP;\n       CS:EIP <- CallGate(CS:InstructionPointer);\n       (* Segment descriptor information also loaded *)\n       Push(oldSS:oldESP); (* From calling procedure *)\n       temp <- parameter count from call gate, masked to 5 bits;\n       Push(parameters from calling procedure's stack, temp)\n       Push(oldCS:oldEIP); (* Return address to calling procedure *)\n     ELSE\n       IF CallGateSize = 16\n          THEN\n             IF new stack does not have room for parameters plus 8 bytes\n               THEN #SS(NewSS); FI;\n             IF (CallGate(InstructionPointer) AND FFFFH) not in new code-segment limit\n               THEN #GP(0); FI;\n             SS <- newSS; (* Segment descriptor information also loaded *)\n             ESP <- newESP;\n             CS:IP <- CallGate(CS:InstructionPointer);\n             (* Segment descriptor information also loaded *)\n             Push(oldSS:oldESP); (* From calling procedure *)\n             temp <- parameter count from call gate, masked to 5 bits;\n             Push(parameters from calling procedure's stack, temp)\n             Push(oldCS:oldEIP); (* Return address to calling procedure *)\n          ELSE (* CallGateSize = 64 *)\n             IF pushing 32 bytes on the stack would use a non-canonical address\n               THEN #SS(NewSS); FI;\n             IF (CallGate(InstructionPointer) is non-canonical)\n               THEN #GP(0); FI;\n             SS <- NewSS; (* NewSS is NULL)\n             RSP <- NewESP;\n             CS:IP <- CallGate(CS:InstructionPointer);\n             (* Segment descriptor information also loaded *)\n             Push(oldSS:oldESP); (* From calling procedure *)\n             Push(oldCS:oldEIP); (* Return address to calling procedure *)\n       FI;\n  FI;\n  CPL <- CodeSegment(DPL)\n  CS(RPL) <- CPL\nEND;\nSAME-PRIVILEGE:\n  IF CallGateSize = 32\n     THEN\n       IF stack does not have room for 8 bytes\n          THEN #SS(0); FI;\n       IF CallGate(InstructionPointer) not within code segment limit\n          THEN #GP(0); FI;\n       CS:EIP <- CallGate(CS:EIP) (* Segment descriptor information also loaded *)\n       Push(oldCS:oldEIP); (* Return address to calling procedure *)\n     ELSE\n       If CallGateSize = 16\n          THEN\n             IF stack does not have room for 4 bytes\n               THEN #SS(0); FI;\n             IF CallGate(InstructionPointer) not within code segment limit\n               THEN #GP(0); FI;\n             CS:IP <- CallGate(CS:instruction pointer);\n             (* Segment descriptor information also loaded *)\n             Push(oldCS:oldIP); (* Return address to calling procedure *)\n          ELSE (* CallGateSize = 64)\n             IF pushing 16 bytes on the stack touches non-canonical addresses\n               THEN #SS(0); FI;\n             IF RIP non-canonical\n               THEN #GP(0); FI;\n             CS:IP <- CallGate(CS:instruction pointer);\n             (* Segment descriptor information also loaded *)\n             Push(oldCS:oldIP); (* Return address to calling procedure *)\n       FI;\n  FI;\n  CS(RPL) <- CPL\nEND;\nTASK-GATE:\n  IF task gate DPL < CPL or RPL\n     THEN #GP(task gate selector); FI;\n  IF task gate not present\n     THEN #NP(task gate selector); FI;\n  Read the TSS segment selector in the task-gate descriptor;\n  IF TSS segment selector local/global bit is set to local\n  or index not within GDT limits\n     THEN #GP(TSS selector); FI;\n  Access TSS descriptor in GDT;\n  IF TSS descriptor specifies that the TSS is busy (low-order 5 bits set to 00001)\n     THEN #GP(TSS selector); FI;\n  IF TSS not present\n     THEN #NP(TSS selector); FI;\n  SWITCH-TASKS (with nesting) to TSS;\n  IF EIP not within code segment limit\n     THEN #GP(0); FI;\nEND;\nTASK-STATE-SEGMENT:\n  IF TSS DPL < CPL or RPL\n  or TSS descriptor indicates TSS not available\n     THEN #GP(TSS selector); FI;\n  IF TSS is not present\n     THEN #NP(TSS selector); FI;\n  SWITCH-TASKS (with nesting) to TSS;\n  IF EIP not within code segment limit\n     THEN #GP(0); FI;\nEND;\n\nFlags Affected:\nAll flags are affected if a task switch occurs; no flags are affected if a task\nswitch does not occur.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the target offset in destination   \n|       | operand is beyond the new code segment\n|       | limit. If the segment selector in the \n|       | destination operand is NULL. If the   \n|       | code segment selector in the gate is  \n|       | NULL.                                 \nIf a memory operand effective address is outside the CS, DS, ES, FS, or GS segment\nlimit. If the DS, ES, FS, or GS register is used to access memory and it contains\na NULL segment selector.\n\n| #GP(selector)  | If a code segment or gate or TSS selector   \n|                | index is outside descriptor table limits.   \n|                | If the segment descriptor pointed to        \n|                | by the segment selector in the destination  \n|                | operand is not for a conforming-code        \n|                | segment, nonconforming-code segment,        \n|                | call gate, task gate, or task state         \n|                | segment. If the DPL for a nonconforming-code\n|                | segment is not equal to the CPL or the      \n|                | RPL for the segment's segment selector      \n|                | is greater than the CPL. If the DPL         \n|                | for a conforming-code segment is greater    \n|                | than the CPL. If the DPL from a call-gate,  \n|                | task-gate, or TSS segment descriptor        \n|                | is less than the CPL or than the RPL        \n|                | of the call-gate, task-gate, or TSS's       \n|                | segment selector. If the segment descriptor \n|                | for a segment selector from a call gate     \n|                | does not indicate it is a code segment.     \n|                | If the segment selector from a call         \n|                | gate is beyond the descriptor table         \n|                | limits. If the DPL for a code-segment       \n|                | obtained from a call gate is greater        \n|                | than the CPL. If the segment selector       \n|                | for a TSS has its local/global bit set      \n|                | for local. If a TSS segment descriptor      \n|                | specifies that the TSS is busy or not       \n|                | available.                                  \n| #SS(0)         | If pushing the return address, parameters,  \n|                | or stack segment pointer onto the stack     \n|                | exceeds the bounds of the stack segment,    \n|                | when no stack switch occurs. If a memory    \n|                | operand effective address is outside        \n|                | the SS segment limit.                       \n| #SS(selector)  | If pushing the return address, parameters,  \n|                | or stack segment pointer onto the stack     \n|                | exceeds the bounds of the stack segment,    \n|                | when a stack switch occurs. If the SS       \n|                | register is being loaded as part of         \n|                | a stack switch and the segment pointed      \n|                | to is marked not present. If stack segment  \n|                | does not have room for the return address,  \n|                | parameters, or stack segment pointer,       \n|                | when stack switch occurs.                   \n| #NP(selector)  | If a code segment, data segment, stack      \n|                | segment, call gate, task gate, or TSS       \n|                | is not present.                             \n| #TS(selector)  | If the new stack segment selector and       \n|                | ESP are beyond the end of the TSS. If       \n|                | the new stack segment selector is NULL.     \n|                | If the RPL of the new stack segment         \n|                | selector in the TSS is not equal to         \n|                | the DPL of the code segment being accessed. \n|                | If DPL of the stack segment descriptor      \n|                | for the new stack segment is not equal      \n|                | to the DPL of the code segment descriptor.  \n|                | If the new stack segment is not a writable  \n|                | data segment. If segment-selector index     \n|                | for stack segment is outside descriptor     \n|                | table limits.                               \n| #PF(fault-code)| If a page fault occurs.                     \n| #AC(0)         | If alignment checking is enabled and        \n|                | an unaligned memory reference is made       \n|                | while the current privilege level is        \n|                | 3.                                          \n| #UD            | If the LOCK prefix is used.                 \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit. If the target offset  \n|    | is beyond the code segment limit.    \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit. If the target offset   \n|                | is beyond the code segment limit.     \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n| #GP(selector)| If a memory address accessed by the    \n|              | selector is in non-canonical space.    \n| #GP(0)       | If the target offset in the destination\n|              | operand is non-canonical.              \n\n64-Bit Mode Exceptions:\n| #GP(0)         | If a memory address is non-canonical.      \n|                | If target offset in destination operand    \n|                | is non-canonical. If the segment selector  \n|                | in the destination operand is NULL.        \n|                | If the code segment selector in the        \n|                | 64-bit gate is NULL.                       \n| #GP(selector)  | If code segment or 64-bit call gate        \n|                | is outside descriptor table limits.        \n|                | If code segment or 64-bit call gate        \n|                | overlaps non-canonical space. If the       \n|                | segment descriptor pointed to by the       \n|                | segment selector in the destination        \n|                | operand is not for a conforming-code       \n|                | segment, nonconforming-code segment,       \n|                | or 64-bit call gate. If the segment        \n|                | descriptor pointed to by the segment       \n|                | selector in the destination operand        \n|                | is a code segment and has both the D-bit   \n|                | and the L- bit set. If the DPL for a       \n|                | nonconforming-code segment is not equal    \n|                | to the CPL, or the RPL for the segment's   \n|                | segment selector is greater than the       \n|                | CPL. If the DPL for a conforming-code      \n|                | segment is greater than the CPL. If        \n|                | the DPL from a 64-bit call-gate is less    \n|                | than the CPL or than the RPL of the        \n|                | 64-bit call-gate. If the upper type        \n|                | field of a 64-bit call gate is not 0x0.    \n|                | If the segment selector from a 64-bit      \n|                | call gate is beyond the descriptor table   \n|                | limits. If the DPL for a code-segment      \n|                | obtained from a 64-bit call gate is        \n|                | greater than the CPL. If the code segment  \n|                | descriptor pointed to by the selector      \n|                | in the 64-bit gate doesn't have the        \n|                | L-bit set and the D-bit clear. If the      \n|                | segment descriptor for a segment selector  \n|                | from the 64-bit call gate does not indicate\n|                | it is a code segment.                      \n| #SS(0)         | If pushing the return offset or CS selector\n|                | onto the stack exceeds the bounds of       \n|                | the stack segment when no stack switch     \n|                | occurs. If a memory operand effective      \n|                | address is outside the SS segment limit.   \n|                | If the stack address is in a non-canonical \n|                | form.                                      \n| #SS(selector)  | If pushing the old values of SS selector,  \n|                | stack pointer, EFLAGS, CS selector,        \n|                | offset, or error code onto the stack       \n|                | violates the canonical boundary when       \n|                | a stack switch occurs.                     \n| #NP(selector)  | If a code segment or 64-bit call gate      \n|                | is not present.                            \n| #TS(selector)  | If the load of the new RSP exceeds the     \n|                | limit of the TSS.                          \n| #UD            | (64-bit mode only) If a far call is        \n|                | direct to an absolute address in memory.   \n|                | If the LOCK prefix is used.                \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n", 
      "mnem": "CALL"
    }, 
    {
      "description": "\nCBW/CWDE/CDQE - Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword:\n| Opcode    | Instruction| Op/En| 64-bit Mode| Compat/Leg Mode| Description              \n| 98        | CBW        | NP   | Valid      | Valid          | AX \u2190 sign-extend of AL.  \n| 98        | CWDE       | NP   | Valid      | Valid          | EAX \u2190 sign-extend of AX. \n| REX.W + 98| CDQE       | NP   | Valid      | N.E.           | RAX \u2190 sign-extend of EAX.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nDouble the size of the source operand by means of sign extension. The CBW (convert\nbyte to word) instruction copies the sign (bit 7) in the source operand into\nevery bit in the AH register. The CWDE (convert word to doubleword) instruction\ncopies the sign (bit 15) of the word in the AX register into the high 16 bits\nof the EAX register.\n\nCBW and CWDE reference the same opcode. The CBW instruction is intended for\nuse when the operand-size attribute is 16; CWDE is intended for use when the\noperand-size attribute is 32. Some assemblers may force the operand size. Others\nmay treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of\nthe operand-size attribute to determine the size of values to be converted.\n\nIn 64-bit mode, the default operation size is the size of the destination register.\nUse of the REX.W prefix promotes this instruction (CDQE when promoted) to operate\non 64-bit operands. In which case, CDQE copies the sign (bit 31) of the doubleword\nin the EAX register into the high 32 bits of RAX.\n\nOperation:\n\nIF OperandSize = 16 (* Instruction = CBW *)\n  THEN\n     AX <- SignExtend(AL);\n  ELSE IF (OperandSize = 32, Instruction = CWDE)\n     EAX <- SignExtend(AX); FI;\n  ELSE (* 64-Bit Mode, OperandSize = 64, Instruction = CDQE*)\n     RAX <- SignExtend(EAX);\nFI;\n\nFlags Affected:\nNone.\n\n\nExceptions (All Operating Modes):\n| #UD| If the LOCK prefix is used.\n", 
      "mnem": "CBW"
    }, 
    {
      "description": "-R:CWD", 
      "mnem": "CDQ"
    }, 
    {
      "description": "-R:CBW", 
      "mnem": "CDQE"
    }, 
    {
      "description": "\nCLC - Clear Carry Flag:\n| Opcode| Instruction| Op/En| 64-bit Mode| Compat/Leg Mode| Description   \n| F8    | CLC        | NP   | Valid      | Valid          | Clear CF flag.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nClears the CF flag in the EFLAGS register. Operation is the same in all non-64-bit\nmodes and 64-bit mode.\n\nOperation:\n\nCF <- 0;\n\nFlags Affected:\nThe CF flag is set to 0. The OF, ZF, SF, AF, and PF flags are unaffected.\n\n\nExceptions (All Operating Modes):\n| #UD| If the LOCK prefix is used.\n", 
      "mnem": "CLC"
    }, 
    {
      "description": "\nCLD - Clear Direction Flag:\n| Opcode| Instruction| Op/En| 64-bit Mode| Compat/Leg Mode| Description   \n| FC    | CLD        | NP   | Valid      | Valid          | Clear DF flag.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nClears the DF flag in the EFLAGS register. When the DF flag is set to 0, string\noperations increment the index registers (ESI and/or EDI). Operation is the\nsame in all non-64-bit modes and 64-bit mode.\n\nOperation:\n\nDF <- 0;\n\nFlags Affected:\nThe DF flag is set to 0. The CF, OF, ZF, SF, AF, and PF flags are unaffected.\n\n\nExceptions (All Operating Modes):\n| #UD| If the LOCK prefix is used.\n", 
      "mnem": "CLD"
    }, 
    {
      "description": "\nCLFLUSH - Flush Cache Line:\n| Opcode  | Instruction| Op/En| 64-bit Mode| Compat/Leg Mode| Description                      \n| 0F AE /7| CLFLUSH m8 | M    | Valid      | Valid          | Flushes cache line containing m8.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nInvalidates the cache line that contains the linear address specified with the\nsource operand from all levels of the processor cache hierarchy (data and instruction).\nThe invalidation is broadcast throughout the cache coherence domain. If, at\nany level of the cache hierarchy, the line is inconsistent with memory (dirty)\nit is written to memory before invalidation. The source operand is a byte memory\nlocation.\n\nThe availability of CLFLUSH is indicated by the presence of the CPUID feature\nflag CLFSH (bit 19 of the EDX register, see \u201cCPUID - CPU Identification\u201d in this\nchapter). The aligned cache line size affected is also indicated with the CPUID\ninstruction (bits 8 through 15 of the EBX register when the initial value in\nthe EAX register is 1).\n\nThe memory attribute of the page containing the affected line has no effect\non the behavior of this instruction. It should be noted that processors are\nfree to speculatively fetch and cache data from system memory regions assigned\na memory-type allowing for speculative reads (such as, the WB, WC, and WT memory\ntypes). PREFETCHh instructions can be used to provide the processor with hints\nfor this speculative behavior. Because this speculative fetching can occur at\nany time and is not tied to instruction execution, the CLFLUSH instruction is\nnot ordered with respect to PREFETCHh instructions or any of the speculative\nfetching mechanisms (that is, data can be speculatively loaded into a cache\nline just before, during, or after the execution of a CLFLUSH instruction that\nreferences the cache line).\n\nCLFLUSH is only ordered by the MFENCE instruction. It is not guaranteed to be\nordered by any other fencing or serializing instructions or by another CLFLUSH\ninstruction. For example, software can use an MFENCE instruction to ensure that\nprevious stores are included in the write-back.\n\nThe CLFLUSH instruction can be used at all privilege levels and is subject to\nall permission checking and faults associated with a byte load (and in addition,\na CLFLUSH instruction is allowed to flush a linear address in an executeonly\nsegment). Like a load, the CLFLUSH instruction sets the A bit but not the D\nbit in the page tables. The CLFLUSH instruction was introduced with the SSE2\nextensions; however, because it has its own CPUID feature flag, it can be implemented\nin IA-32 processors that do not include the SSE2 extensions. Also, detecting\nthe presence of the SSE2 extensions with the CPUID instruction does not guarantee\nthat the CLFLUSH instruction is implemented in the processor.\n\nCLFLUSH operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nFlush_Cache_Line(SRC);\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| CLFLUSH:| void _mm_clflush(void const *p)\n\nProtected Mode Exceptions:\n| #GP(0)         | For an illegal memory operand effective  \n|                | address in the CS, DS, ES, FS or GS      \n|                | segments.                                \n| #SS(0)         | For an illegal address in the SS segment.\n| #PF(fault-code)| For a page fault.                        \n| #UD            | If CPUID.01H:EDX.CLFSH[bit 19] = 0.      \n|                | If the LOCK prefix is used.              \nIf instruction prefix is 66H, F2H or F3H.\n\n\nReal-Address Mode Exceptions:\n| #GP| If any part of the operand lies outside   \n|    | the effective address space from 0 to     \n|    | FFFFH.                                    \n| #UD| If CPUID.01H:EDX.CLFSH[bit 19] = 0.       \n|    | If the LOCK prefix is used. If instruction\n|    | prefix is 66H, F2H or F3H.                \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in real address mode.\n\n| #PF(fault-code)| For a page fault.\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| For a page fault.                          \n| #UD            | If CPUID.01H:EDX.CLFSH[bit 19] = 0.        \n|                | If the LOCK prefix is used. If instruction \n|                | prefix is 66H, F2H or F3H.                 \n", 
      "mnem": "CLFLUSH"
    }, 
    {
      "description": "\nCLI  -  Clear Interrupt Flag:\n| Opcode| Instruction| Op/En| 64-bit Mode| Compat/Leg Mode| Description                              \n| FA    | CLI        | NP   | Valid      | Valid          | Clear interrupt flag; interrupts disabled\n|       |            |      |            |                | when interrupt flag cleared.             \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nIf protected-mode virtual interrupts are not enabled, CLI clears the IF flag\nin the EFLAGS register. No other flags are affected. Clearing the IF flag causes\nthe processor to ignore maskable external interrupts. The IF flag and the CLI\nand STI instruction have no affect on the generation of exceptions and NMI interrupts.\n\nWhen protected-mode virtual interrupts are enabled, CPL is 3, and IOPL is less\nthan 3; CLI clears the VIF flag in the EFLAGS register, leaving IF unaffected.\nTable 3-6 indicates the action of the CLI instruction depending on the processor\noperating mode and the CPL/IOPL of the running program or procedure.\n\nCLI operation is the same in non-64-bit modes and 64-bit mode.\n\n\nTable 3-6. Decision Table for CLI Results:\n| PE| VM| IOPL | CPL| PVI| VIP| VME| CLI Result\n| 0 | X | X    | X  | X  | X  | X  | IF = 0    \n| 1 | 0 | \u2265 CPL| X  | X  | X  | X  | IF = 0    \n| 1 | 0 | < CPL| 3  | 1  | X  | X  | VIF = 0   \n| 1 | 0 | < CPL| < 3| X  | X  | X  | GP Fault  \n| 1 | 0 | < CPL| X  | 0  | X  | X  | GP Fault  \n| 1 | 1 | 3    | X  | X  | X  | X  | IF = 0    \n| 1 | 1 | < 3  | X  | X  | X  | 1  | VIF = 0   \n| 1 | 1 | < 3  | X  | X  | X  | 0  | GP Fault  \nNotes: * X = This setting has no impact.\n\nOperation:\n\nIF PE = 0\n  THEN\n     IF <- 0; (* Reset Interrupt Flag *)\n  ELSE\n     IF VM = 0;\n       THEN\n          IF IOPL \u2265 CPL\n             THEN\n               IF <- 0; (* Reset Interrupt Flag *)\n          ELSE\n             IF ((IOPL < CPL) and (CPL = 3) and (PVI = 1))\n               THEN\n                  VIF <- 0; (* Reset Virtual Interrupt Flag *)\n               ELSE\n                  #GP(0);\n             FI;\n          FI;\n       ELSE (* VM = 1 *)\n          IF IOPL = 3\n             THEN\n               IF <- 0; (* Reset Interrupt Flag *)\n             ELSE\n               IF (IOPL < 3) AND (VME = 1)\n                  THEN\n                     VIF <- 0; (* Reset Virtual Interrupt Flag *)\n                  ELSE\n                     #GP(0);\n               FI;\n          FI;\n     FI;\nFI;\n\nFlags Affected:\nIf protected-mode virtual interrupts are not enabled, IF is set to 0 if the\nCPL is equal to or less than the IOPL; otherwise, it is not affected. The other\nflags in the EFLAGS register are unaffected.\n\nWhen protected-mode virtual interrupts are enabled, CPL is 3, and IOPL is less\nthan 3; CLI clears the VIF flag in the EFLAGS register, leaving IF unaffected.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the CPL is greater (has less privilege)\n|       | than the IOPL of the current program      \n|       | or procedure.                             \n| #UD   | If the LOCK prefix is used.               \n\nReal-Address Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| If the CPL is greater (has less privilege)\n|       | than the IOPL of the current program      \n|       | or procedure.                             \n| #UD   | If the LOCK prefix is used.               \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)| If the CPL is greater (has less privilege)\n|       | than the IOPL of the current program      \n|       | or procedure.                             \n| #UD   | If the LOCK prefix is used.               \n", 
      "mnem": "CLI"
    }, 
    {
      "description": "\nCLTS - Clear Task-Switched Flag in CR0:\n| Opcode| Instruction| Op/En| 64-bit Mode| Compat/Leg Mode| Description           \n| 0F 06 | CLTS       | NP   | Valid      | Valid          | Clears TS flag in CR0.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nClears the task-switched (TS) flag in the CR0 register. This instruction is\nintended for use in operating-system procedures. It is a privileged instruction\nthat can only be executed at a CPL of 0. It is allowed to be executed in realaddress\nmode to allow initialization for protected mode.\n\nThe processor sets the TS flag every time a task switch occurs. The flag is\nused to synchronize the saving of FPU context in multitasking applications.\nSee the description of the TS flag in the section titled \u201cControl Registers\u201d\nin Chapter 2 of the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 3A, for more information about this flag.\n\nCLTS operation is the same in non-64-bit modes and 64-bit mode.\n\nSee Chapter 25, \u201cVMX Non-Root Operation,\u201d of the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 3C, for more information about the behavior\nof this instruction in VMX non-root operation.\n\nOperation:\n\nCR0.TS[bit 3] <- 0;\n\nFlags Affected:\nThe TS flag in CR0 register is cleared.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the current privilege level is not\n|       | 0.                                   \n| #UD   | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| CLTS is not recognized in virtual-8086\n|       | mode.                                 \n| #UD   | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)| If the CPL is greater than 0.\n| #UD   | If the LOCK prefix is used.  \n", 
      "mnem": "CLTS"
    }, 
    {
      "description": "\nCMC - Complement Carry Flag:\n| Opcode| Instruction| Op/En| 64-bit Mode| Compat/Leg Mode| Description        \n| F5    | CMC        | NP   | Valid      | Valid          | Complement CF flag.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nComplements the CF flag in the EFLAGS register. CMC operation is the same in\nnon-64-bit modes and 64-bit mode.\n\nOperation:\n\nEFLAGS.CF[bit 0]<- NOT EFLAGS.CF[bit 0];\n\nFlags Affected:\nThe CF flag contains the complement of its original value. The OF, ZF, SF, AF,\nand PF flags are unaffected.\n\n\nExceptions (All Operating Modes):\n| #UD| If the LOCK prefix is used.\n", 
      "mnem": "CMC"
    }, 
    {
      "description": "\nCMOVcc - Conditional Move:\n| Opcode          | Instruction       | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                            \n| 0F 47 /r        | CMOVA r16, r/m16  | RM   | Valid      | Valid          | Move if above (CF=0 and ZF=0).         \n| 0F 47 /r        | CMOVA r32, r/m32  | RM   | Valid      | Valid          | Move if above (CF=0 and ZF=0).         \n| REX.W + 0F 47 /r| CMOVA r64, r/m64  | RM   | Valid      | N.E.           | Move if above (CF=0 and ZF=0).         \n| 0F 43 /r        | CMOVAE r16, r/m16 | RM   | Valid      | Valid          | Move if above or equal (CF=0).         \n| 0F 43 /r        | CMOVAE r32, r/m32 | RM   | Valid      | Valid          | Move if above or equal (CF=0).         \n| REX.W + 0F 43 /r| CMOVAE r64, r/m64 | RM   | Valid      | N.E.           | Move if above or equal (CF=0).         \n| 0F 42 /r        | CMOVB r16, r/m16  | RM   | Valid      | Valid          | Move if below (CF=1).                  \n| 0F 42 /r        | CMOVB r32, r/m32  | RM   | Valid      | Valid          | Move if below (CF=1).                  \n| REX.W + 0F 42 /r| CMOVB r64, r/m64  | RM   | Valid      | N.E.           | Move if below (CF=1).                  \n| 0F 46 /r        | CMOVBE r16, r/m16 | RM   | Valid      | Valid          | Move if below or equal (CF=1 or ZF=1). \n| 0F 46 /r        | CMOVBE r32, r/m32 | RM   | Valid      | Valid          | Move if below or equal (CF=1 or ZF=1). \n| REX.W + 0F 46 /r| CMOVBE r64, r/m64 | RM   | Valid      | N.E.           | Move if below or equal (CF=1 or ZF=1). \n| 0F 42 /r        | CMOVC r16, r/m16  | RM   | Valid      | Valid          | Move if carry (CF=1).                  \n| 0F 42 /r        | CMOVC r32, r/m32  | RM   | Valid      | Valid          | Move if carry (CF=1).                  \n| REX.W + 0F 42 /r| CMOVC r64, r/m64  | RM   | Valid      | N.E.           | Move if carry (CF=1).                  \n| 0F 44 /r        | CMOVE r16, r/m16  | RM   | Valid      | Valid          | Move if equal (ZF=1).                  \n| 0F 44 /r        | CMOVE r32, r/m32  | RM   | Valid      | Valid          | Move if equal (ZF=1).                  \n| REX.W + 0F 44 /r| CMOVE r64, r/m64  | RM   | Valid      | N.E.           | Move if equal (ZF=1).                  \n| 0F 4F /r        | CMOVG r16, r/m16  | RM   | Valid      | Valid          | Move if greater (ZF=0 and SF=OF).      \n| 0F 4F /r        | CMOVG r32, r/m32  | RM   | Valid      | Valid          | Move if greater (ZF=0 and SF=OF).      \n| REX.W + 0F 4F /r| CMOVG r64, r/m64  | RM   | V/N.E.     | NA             | Move if greater (ZF=0 and SF=OF).      \n| 0F 4D /r        | CMOVGE r16, r/m16 | RM   | Valid      | Valid          | Move if greater or equal (SF=OF).      \n| 0F 4D /r        | CMOVGE r32, r/m32 | RM   | Valid      | Valid          | Move if greater or equal (SF=OF).      \n| REX.W + 0F 4D /r| CMOVGE r64, r/m64 | RM   | Valid      | N.E.           | Move if greater or equal (SF=OF).      \n| 0F 4C /r        | CMOVL r16, r/m16  | RM   | Valid      | Valid          | Move if less (SF!= OF).                 \n| 0F 4C /r        | CMOVL r32, r/m32  | RM   | Valid      | Valid          | Move if less (SF!= OF).                 \n| REX.W + 0F 4C /r| CMOVL r64, r/m64  | RM   | Valid      | N.E.           | Move if less (SF!= OF).                 \n| 0F 4E /r        | CMOVLE r16, r/m16 | RM   | Valid      | Valid          | Move if less or equal (ZF=1 or SF!= OF).\n| 0F 4E /r        | CMOVLE r32, r/m32 | RM   | Valid      | Valid          | Move if less or equal (ZF=1 or SF!= OF).\n| REX.W + 0F 4E /r| CMOVLE r64, r/m64 | RM   | Valid      | N.E.           | Move if less or equal (ZF=1 or SF!= OF).\n| 0F 46 /r        | CMOVNA r16, r/m16 | RM   | Valid      | Valid          | Move if not above (CF=1 or ZF=1).      \n| 0F 46 /r        | CMOVNA r32, r/m32 | RM   | Valid      | Valid          | Move if not above (CF=1 or ZF=1).      \n| REX.W + 0F 46 /r| CMOVNA r64, r/m64 | RM   | Valid      | N.E.           | Move if not above (CF=1 or ZF=1).      \n| 0F 42 /r        | CMOVNAE r16, r/m16| RM   | Valid      | Valid          | Move if not above or equal (CF=1).     \n| 0F 42 /r        | CMOVNAE r32, r/m32| RM   | Valid      | Valid          | Move if not above or equal (CF=1).     \n| REX.W + 0F 42 /r| CMOVNAE r64, r/m64| RM   | Valid      | N.E.           | Move if not above or equal (CF=1).     \n| 0F 43 /r        | CMOVNB r16, r/m16 | RM   | Valid      | Valid          | Move if not below (CF=0).              \n| 0F 43 /r        | CMOVNB r32, r/m32 | RM   | Valid      | Valid          | Move if not below (CF=0).              \n| REX.W + 0F 43 /r| CMOVNB r64, r/m64 | RM   | Valid      | N.E.           | Move if not below (CF=0).              \n| 0F 47 /r        | CMOVNBE r16, r/m16| RM   | Valid      | Valid          | Move if not below or equal (CF=0 and   \n|                 |                   |      |            |                | ZF=0).                                 \n| Opcode          | Instruction       | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                            \n| 0F 47 /r        | CMOVNBE r32, r/m32| RM   | Valid      | Valid          | Move if not below or equal (CF=0 and   \n|                 |                   |      |            |                | ZF=0).                                 \n| REX.W + 0F 47 /r| CMOVNBE r64, r/m64| RM   | Valid      | N.E.           | Move if not below or equal (CF=0 and   \n|                 |                   |      |            |                | ZF=0).                                 \n| 0F 43 /r        | CMOVNC r16, r/m16 | RM   | Valid      | Valid          | Move if not carry (CF=0).              \n| 0F 43 /r        | CMOVNC r32, r/m32 | RM   | Valid      | Valid          | Move if not carry (CF=0).              \n| REX.W + 0F 43 /r| CMOVNC r64, r/m64 | RM   | Valid      | N.E.           | Move if not carry (CF=0).              \n| 0F 45 /r        | CMOVNE r16, r/m16 | RM   | Valid      | Valid          | Move if not equal (ZF=0).              \n| 0F 45 /r        | CMOVNE r32, r/m32 | RM   | Valid      | Valid          | Move if not equal (ZF=0).              \n| REX.W + 0F 45 /r| CMOVNE r64, r/m64 | RM   | Valid      | N.E.           | Move if not equal (ZF=0).              \n| 0F 4E /r        | CMOVNG r16, r/m16 | RM   | Valid      | Valid          | Move if not greater (ZF=1 or SF!= OF).  \n| 0F 4E /r        | CMOVNG r32, r/m32 | RM   | Valid      | Valid          | Move if not greater (ZF=1 or SF!= OF).  \n| REX.W + 0F 4E /r| CMOVNG r64, r/m64 | RM   | Valid      | N.E.           | Move if not greater (ZF=1 or SF!= OF).  \n| 0F 4C /r        | CMOVNGE r16, r/m16| RM   | Valid      | Valid          | Move if not greater or equal (SF!= OF). \n| 0F 4C /r        | CMOVNGE r32, r/m32| RM   | Valid      | Valid          | Move if not greater or equal (SF!= OF). \n| REX.W + 0F 4C /r| CMOVNGE r64, r/m64| RM   | Valid      | N.E.           | Move if not greater or equal (SF!= OF). \n| 0F 4D /r        | CMOVNL r16, r/m16 | RM   | Valid      | Valid          | Move if not less (SF=OF).              \n| 0F 4D /r        | CMOVNL r32, r/m32 | RM   | Valid      | Valid          | Move if not less (SF=OF).              \n| REX.W + 0F 4D /r| CMOVNL r64, r/m64 | RM   | Valid      | N.E.           | Move if not less (SF=OF).              \n| 0F 4F /r        | CMOVNLE r16, r/m16| RM   | Valid      | Valid          | Move if not less or equal (ZF=0 and    \n|                 |                   |      |            |                | SF=OF).                                \n| 0F 4F /r        | CMOVNLE r32, r/m32| RM   | Valid      | Valid          | Move if not less or equal (ZF=0 and    \n|                 |                   |      |            |                | SF=OF).                                \n| REX.W + 0F 4F /r| CMOVNLE r64, r/m64| RM   | Valid      | N.E.           | Move if not less or equal (ZF=0 and    \n|                 |                   |      |            |                | SF=OF).                                \n| 0F 41 /r        | CMOVNO r16, r/m16 | RM   | Valid      | Valid          | Move if not overflow (OF=0).           \n| 0F 41 /r        | CMOVNO r32, r/m32 | RM   | Valid      | Valid          | Move if not overflow (OF=0).           \n| REX.W + 0F 41 /r| CMOVNO r64, r/m64 | RM   | Valid      | N.E.           | Move if not overflow (OF=0).           \n| 0F 4B /r        | CMOVNP r16, r/m16 | RM   | Valid      | Valid          | Move if not parity (PF=0).             \n| 0F 4B /r        | CMOVNP r32, r/m32 | RM   | Valid      | Valid          | Move if not parity (PF=0).             \n| REX.W + 0F 4B /r| CMOVNP r64, r/m64 | RM   | Valid      | N.E.           | Move if not parity (PF=0).             \n| 0F 49 /r        | CMOVNS r16, r/m16 | RM   | Valid      | Valid          | Move if not sign (SF=0).               \n| 0F 49 /r        | CMOVNS r32, r/m32 | RM   | Valid      | Valid          | Move if not sign (SF=0).               \n| REX.W + 0F 49 /r| CMOVNS r64, r/m64 | RM   | Valid      | N.E.           | Move if not sign (SF=0).               \n| 0F 45 /r        | CMOVNZ r16, r/m16 | RM   | Valid      | Valid          | Move if not zero (ZF=0).               \n| 0F 45 /r        | CMOVNZ r32, r/m32 | RM   | Valid      | Valid          | Move if not zero (ZF=0).               \n| REX.W + 0F 45 /r| CMOVNZ r64, r/m64 | RM   | Valid      | N.E.           | Move if not zero (ZF=0).               \n| 0F 40 /r        | CMOVO r16, r/m16  | RM   | Valid      | Valid          | Move if overflow (OF=1).               \n| 0F 40 /r        | CMOVO r32, r/m32  | RM   | Valid      | Valid          | Move if overflow (OF=1).               \n| REX.W + 0F 40 /r| CMOVO r64, r/m64  | RM   | Valid      | N.E.           | Move if overflow (OF=1).               \n| 0F 4A /r        | CMOVP r16, r/m16  | RM   | Valid      | Valid          | Move if parity (PF=1).                 \n| 0F 4A /r        | CMOVP r32, r/m32  | RM   | Valid      | Valid          | Move if parity (PF=1).                 \n| REX.W + 0F 4A /r| CMOVP r64, r/m64  | RM   | Valid      | N.E.           | Move if parity (PF=1).                 \n| 0F 4A /r        | CMOVPE r16, r/m16 | RM   | Valid      | Valid          | Move if parity even (PF=1).            \n| 0F 4A /r        | CMOVPE r32, r/m32 | RM   | Valid      | Valid          | Move if parity even (PF=1).            \n| REX.W + 0F 4A /r| CMOVPE r64, r/m64 | RM   | Valid      | N.E.           | Move if parity even (PF=1).            \n| Opcode          | Instruction       | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                            \n| 0F 4B /r        | CMOVPO r16, r/m16 | RM   | Valid      | Valid          | Move if parity odd (PF=0).             \n| 0F 4B /r        | CMOVPO r32, r/m32 | RM   | Valid      | Valid          | Move if parity odd (PF=0).             \n| REX.W + 0F 4B /r| CMOVPO r64, r/m64 | RM   | Valid      | N.E.           | Move if parity odd (PF=0).             \n| 0F 48 /r        | CMOVS r16, r/m16  | RM   | Valid      | Valid          | Move if sign (SF=1).                   \n| 0F 48 /r        | CMOVS r32, r/m32  | RM   | Valid      | Valid          | Move if sign (SF=1).                   \n| REX.W + 0F 48 /r| CMOVS r64, r/m64  | RM   | Valid      | N.E.           | Move if sign (SF=1).                   \n| 0F 44 /r        | CMOVZ r16, r/m16  | RM   | Valid      | Valid          | Move if zero (ZF=1).                   \n| 0F 44 /r        | CMOVZ r32, r/m32  | RM   | Valid      | Valid          | Move if zero (ZF=1).                   \n| REX.W + 0F 44 /r| CMOVZ r64, r/m64  | RM   | Valid      | N.E.           | Move if zero (ZF=1).                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nThe CMOVcc instructions check the state of one or more of the status flags in\nthe EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if\nthe flags are in a specified state (or condition). A condition code (cc) is\nassociated with each instruction to indicate the condition being tested for.\nIf the condition is not satisfied, a move is not performed and execution continues\nwith the instruction following the CMOVcc instruction.\n\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a\ngeneral-purpose register or from one general-purpose register to another. Conditional\nmoves of 8-bit register operands are not supported.\n\nThe condition for each CMOVcc mnemonic is given in the description column of\nthe above table. The terms \u201cless\u201dand \u201cgreater\u201d are used for comparisons of signed\nintegers and the terms \u201cabove\u201d and \u201cbelow\u201d are used for unsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted\nin two ways, two mnemonics are defined for some opcodes. For example, the CMOVA\n(conditional move if above) instruction and the CMOVNBE (conditional move if\nnot below or equal) instruction are alternate mnemonics for the opcode 0F 47H.\n\nThe CMOVcc instructions were introduced in P6 family processors; however, these\ninstructions may not be supported by all IA-32 processors. Software can determine\nif the CMOVcc instructions are supported by checking the processor's feature\ninformation with the CPUID instruction (see \u201cCPUID - CPU Identification\u201d in this\nchapter).\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.R prefix permits access to additional registers (R8-R15). Use of the\nREX.W prefix promotes operation to 64 bits. See the summary chart at the beginning\nof this section for encoding data and limits.\n\nOperation:\n\ntemp <- SRC\nIF condition TRUE\n  THEN\n     DEST <- temp;\n  FI;\nELSE\n  IF (OperandSize = 32 and IA-32e mode active)\n     THEN\n       DEST[63:32] <- 0;\n  FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "CMOVcc"
    }, 
    {
      "description": "\nCMP - Compare Two Operands:\n| Opcode          | Instruction     | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| 3C ib           | CMP AL, imm8    | I    | Valid      | Valid          | Compare imm8 with AL.                 \n| 3D iw           | CMP AX, imm16   | I    | Valid      | Valid          | Compare imm16 with AX.                \n| 3D id           | CMP EAX, imm32  | I    | Valid      | Valid          | Compare imm32 with EAX.               \n| REX.W + 3D id   | CMP RAX, imm32  | I    | Valid      | N.E.           | Compare imm32 sign-extended to 64-bits\n|                 |                 |      |            |                | with RAX.                             \n| 80 /7 ib        | CMP r/m8, imm8  | MI   | Valid      | Valid          | Compare imm8 with r/m8.               \n| REX + 80 /7 ib  | CMP r/m8*, imm8 | MI   | Valid      | N.E.           | Compare imm8 with r/m8.               \n| 81 /7 iw        | CMP r/m16, imm16| MI   | Valid      | Valid          | Compare imm16 with r/m16.             \n| 81 /7 id        | CMP r/m32, imm32| MI   | Valid      | Valid          | Compare imm32 with r/m32.             \n| REX.W + 81 /7 id| CMP r/m64, imm32| MI   | Valid      | N.E.           | Compare imm32 sign-extended to 64-bits\n|                 |                 |      |            |                | with r/m64.                           \n| 83 /7 ib        | CMP r/m16, imm8 | MI   | Valid      | Valid          | Compare imm8 with r/m16.              \n| 83 /7 ib        | CMP r/m32, imm8 | MI   | Valid      | Valid          | Compare imm8 with r/m32.              \n| REX.W + 83 /7 ib| CMP r/m64, imm8 | MI   | Valid      | N.E.           | Compare imm8 with r/m64.              \n| 38 /r           | CMP r/m8, r8    | MR   | Valid      | Valid          | Compare r8 with r/m8.                 \n| REX + 38 /r     | CMP r/m8*, r8*  | MR   | Valid      | N.E.           | Compare r8 with r/m8.                 \n| 39 /r           | CMP r/m16, r16  | MR   | Valid      | Valid          | Compare r16 with r/m16.               \n| 39 /r           | CMP r/m32, r32  | MR   | Valid      | Valid          | Compare r32 with r/m32.               \n| REX.W + 39 /r   | CMP r/m64,r64   | MR   | Valid      | N.E.           | Compare r64 with r/m64.               \n| 3A /r           | CMP r8, r/m8    | RM   | Valid      | Valid          | Compare r/m8 with r8.                 \n| REX + 3A /r     | CMP r8*, r/m8*  | RM   | Valid      | N.E.           | Compare r/m8 with r8.                 \n| 3B /r           | CMP r16, r/m16  | RM   | Valid      | Valid          | Compare r/m16 with r16.               \n| 3B /r           | CMP r32, r/m32  | RM   | Valid      | Valid          | Compare r/m32 with r32.               \n| REX.W + 3B /r   | CMP r64, r/m64  | RM   | Valid      | N.E.           | Compare r/m64 with r64.               \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA       | NA       \n| MR   | ModRM:r/m (r, w)| ModRM:reg (w)| NA       | NA       \n| MI   | ModRM:r/m (r, w)| imm8         | NA       | NA       \n| I    | AL/AX/EAX/RAX   | imm8         | NA       | NA       \n\nDescription:\nCompares the first source operand with the second source operand and sets the\nstatus flags in the EFLAGS register according to the results. The comparison\nis performed by subtracting the second operand from the first operand and then\nsetting the status flags in the same manner as the SUB instruction. When an\nimmediate value is used as an operand, it is sign-extended to the length of\nthe first operand.\n\nThe condition codes used by the Jcc, CMOVcc, and SETcc instructions are based\non the results of a CMP instruction. Appendix B, \u201cEFLAGS Condition Codes,\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 1,\nshows the relationship of the status flags and the condition codes.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.R prefix permits access to additional registers (R8-R15). Use of the\nREX.W prefix promotes operation to 64 bits. See the summary chart at the beginning\nof this section for encoding data and limits.\n\nOperation:\n\ntemp <- SRC1 \u2212 SignExtend(SRC2);\nModifyStatusFlags; (* Modify status flags in the same manner as the SUB instruction*)\n\nFlags Affected:\nThe CF, OF, SF, ZF, AF, and PF flags are set according to the result.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "CMP"
    }, 
    {
      "description": "\nCMPPD - Compare Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                   | Op/En| 64/32bit Mode| CPUID Feature Flag| Description                                  \n| 66 0F C2 /r ib CMPPD xmm1, xmm2/m128,| RMI  | V/V          | SSE2              | Compare packed double-precision floatingpoint\n| imm8                                 |      |              |                   | values in xmm2/m128 and xmm1 using imm8      \n|                                      |      |              |                   | as comparison predicate.                     \n| VEX.NDS.128.66.0F.WIG C2 /r ib VCMPPD| RVMI | V/V          | AVX               | Compare packed double-precision floatingpoint\n| xmm1, xmm2, xmm3/m128, imm8          |      |              |                   | values in xmm3/m128 and xmm2 using bits      \n|                                      |      |              |                   | 4:0 of imm8 as a comparison predicate.       \n| VEX.NDS.256.66.0F.WIG C2 /r ib VCMPPD| RVMI | V/V          | AVX               | Compare packed double-precision floatingpoint\n| ymm1, ymm2, ymm3/m256, imm8          |      |              |                   | values in ymm3/m256 and ymm2 using bits      \n|                                      |      |              |                   | 4:0 of imm8 as a comparison predicate.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nPerforms a SIMD compare of the packed double-precision floating-point values\nin the source operand (second operand) and the destination operand (first operand)\nand returns the results of the comparison to the destination operand. The comparison\npredicate operand (third operand) specifies the type of comparison performed\non each of the pairs of packed values. The result of each comparison is a quadword\nmask of all 1s (comparison true) or all 0s (comparison false). The sign of zero\nis ignored for comparisons, so that -0.0 is equal to +0.0. 128-bit Legacy SSE\nversion: The first source and destination operand (first operand) is an XMM\nregister. The second source operand (second operand) can be an XMM register\nor 128-bit memory location. The comparison predicate operand is an 8-bit immediate,\nbits 2:0 of the immediate define the type of comparison to be performed (see\nTable 3-7). Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:128) of the\ncorresponding YMM destination register remain unchanged. Two comparisons are\nperformed with results written to bits 127:0 of the destination operand.\n\n\nTable 3-7. Comparison Predicate for CMPPD and CMPPS Instructions:\n| Predicate EQ LT LE UNORD NEQ NLT| imm8 Encoding 000B 001B 010B 011B 100B| Description Equal Less-than Less-than-or-equal     | Relation where: A Is 1st Operand B Is  | Emulation Swap Operands, Use LT Swap | Result if NaN Operand False False False| QNaN Oper-and Signals Invalid No Yes \n|                                 | 101B                                  | Greater than Greater-than-or-equal Unordered       | 2nd Operand A = B A < B A \u2264 B A > B    | Operands, Use LE                     | False False True True True             | Yes Yes Yes No No Yes (Contd.)       \n|                                 |                                       | Not-equal Not-less-than Table 3-7.                 | A \u2265 B A, B = Unordered A != B NOT(A <   |                                      |                                        |                                      \n|                                 |                                       |                                                    | B) Comparison Predicate for CMPPD and  |                                      |                                        |                                      \n|                                 |                                       |                                                    | CMPPS Instructions                     |                                      |                                        |                                      \n| Predicate NLE ORD               | imm8 Encoding 110B 111B               | Description Not-less-than-or-equal Not-greater-than| Relation where: A Is 1st Operand B Is  | Emulation Swap Operands, Use NLT Swap| Result if NaN Operand True True True   | QNaN Oper-and Signals Invalid Yes Yes\n|                                 |                                       | Not-greater-than-or-equal Ordered                  | 2nd Operand NOT(A \u2264 B) NOT(A > B) NOT(A| Operands, Use NLE                    | False                                  | Yes No                               \n|                                 |                                       |                                                    | \u2265 B) A , B = Ordered                   |                                      |                                        |                                      \nThe unordered relationship is true when at least one of the two source operands\nbeing compared is a NaN; the ordered relationship is true when neither source\noperand is a NaN.\n\nA subsequent computational instruction that uses the mask result in the destination\noperand as an input operand will not generate an exception, because a mask of\nall 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds\nto a QNaN.\n\nNote that the processors with \u201cCPUID.1H:ECX.AVX =0\u201d do not implement the greater-than,\ngreater-than-or-equal, not-greater-than, and not-greater-than-or-equal relations.\nThese comparisons can be made either by using the inverse relationship (that\nis, use the \u201cnot-less-than-or-equal\u201d to make a \u201cgreater-than\u201d comparison) or\nby using software emulation. When using software emulation, the program must\nswap the operands (copying registers when necessary to protect the data that\nwill now be in the destination), and then perform the compare using a different\npredicate. The predicate to be used for these emulations is listed in Table\n3-7 under the heading Emulation.\n\nCompilers and assemblers may implement the following two-operand pseudo-ops\nin addition to the three-operand CMPPD instruction, for processors with \u201cCPUID.1H:ECX.AVX\n=0\u201d. See Table 3-8. Compiler should treat reserved Imm8 values as illegal syntax.\n\n| : Pseudo-Op CMPEQPD xmm1, xmm2 CMPLTPD  | Table 3-8.| Pseudo-Op and CMPPD Implementation CMPPD\n| xmm1, xmm2 CMPLEPD xmm1, xmm2 CMPUNORDPD|           | Implementation CMPPD xmm1, xmm2, 0 CMPPD\n| xmm1, xmm2 CMPNEQPD xmm1, xmm2 CMPNLTPD |           | xmm1, xmm2, 1 CMPPD xmm1, xmm2, 2 CMPPD \n| xmm1, xmm2 CMPNLEPD xmm1, xmm2 CMPORDPD |           | xmm1, xmm2, 3 CMPPD xmm1, xmm2, 4 CMPPD \n| xmm1, xmm2                              |           | xmm1, xmm2, 5 CMPPD xmm1, xmm2, 6 CMPPD \n|                                         |           | xmm1, xmm2, 7                           \nThe greater-than relations that the processor does not implement, require more\nthan one instruction to emulate in software and therefore should not be implemented\nas pseudo-ops. (For these, the programmer should reverse the operands of the\ncorresponding less than relations and use move instructions to ensure that the\nmask is moved to the correct destination register and that the source operand\nis left intact.)\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nEnhanced Comparison Predicate for VEX-Encoded VCMPPD VEX.128 encoded version:\nThe first source operand (second operand) is an XMM register. The second source\noperand (third operand) can be an XMM register or a 128-bit memory location.\nBits (VLMAX-1:128) of the destination YMM register are zeroed. Two comparisons\nare performed with results written to bits 127:0 of the destination operand.\n\nVEX.256 encoded version: The first source operand (second operand) is a YMM\nregister. The second source operand (third operand) can be a YMM register or\na 256-bit memory location. The destination operand (first operand) is a YMM\nregister. Four comparisons are performed with results written to the destination\noperand. The comparison predicate operand is an 8-bit immediate:\n\n - For instructions encoded using the VEX prefix, bits 4:0 define the type of comparison\nto be performed (see Table 3-9). Bits 5 through 7 of the immediate are reserved.\nTable 3-9. Comparison Predicate for VCMPPD and VCMPPS Instructions\n\n| Predicate      | imm8 Value    | Description                                     | Result: A Is 1st Operand, B Is 2nd Operand| Signals #IA on QNAN Unordered1\n|                |               |                                                 | A = B                                     |                               \n| EQ_OQ (EQ)     | 0H            | Equal (ordered, non-signaling)                  | True                                      | No                            \n| LT_OS (LT)     | 1H            | Less-than (ordered, signaling)                  | False                                     | Yes                           \n| LE_OS (LE)     | 2H            | Less-than-or-equal (ordered, signaling)         | True                                      | Yes                           \n| UNORD_Q (UNORD)| 3H            | Unordered (non-signaling)                       | False                                     | No                            \n| NEQ_UQ (NEQ)   | 4H            | Not-equal (unordered, nonsignaling)             | False                                     | No                            \n| NLT_US (NLT)   | 5H            | Not-less-than (unordered, signaling)            | True                                      | Yes                           \n| NLE_US (NLE)   | 6H            | Not-less-than-or-equal (unordered, signaling)   | False                                     | Yes                           \n| ORD_Q (ORD)    | 7H            | Ordered (non-signaling)                         | True                                      | No                            \n| EQ_UQ          | 8H            | Equal (unordered, non-signaling)                | True                                      | No                            \n| NGE_US (NGE)   | 9H            | Not-greater-than-or-equal (unordered,           | False                                     | Yes                           \n|                |               | signaling)                                      |                                           |                               \n| NGT_US (NGT)   | AH            | Not-greater-than (unordered, signaling)         | True                                      | Yes                           \n| FALSE_OQ(FALSE)| BH            | False (ordered, non-signaling)                  | False                                     | No                            \n| NEQ_OQ         | CH            | Not-equal (ordered, non-signaling)              | False                                     | No                            \n| GE_OS (GE)     | DH            | Greater-than-or-equal (ordered, signaling)      | True                                      | Yes                           \n| GT_OS (GT)     | EH            | Greater-than (ordered, signaling)               | False                                     | Yes                           \n| TRUE_UQ(TRUE)  | FH            | True (unordered, non-signaling)                 | True                                      | No                            \n| EQ_OS          | 10H           | Equal (ordered, signaling)                      | True                                      | Yes                           \n| LT_OQ          | 11H           | Less-than (ordered, nonsignaling)               | False                                     | No                            \n| LE_OQ          | 12H           | Less-than-or-equal (ordered, nonsignaling)      | True                                      | No                            \n| UNORD_S        | 13H           | Unordered (signaling)                           | False                                     | Yes                           \n| NEQ_US         | 14H           | Not-equal (unordered, signaling)                | False                                     | Yes                           \n| NLT_UQ         | 15H           | Not-less-than (unordered, nonsignaling)         | True                                      | No                            \n| NLE_UQ         | 16H           | Not-less-than-or-equal (unordered, nonsignaling)| False                                     | No                            \n| ORD_S          | 17H           | Ordered (signaling)                             | True                                      | Yes                           \n| EQ_US          | 18H Table 3-9.| Equal (unordered, signaling) Comparison         | True                                      | Yes (Contd.)                  \n|                |               | Predicate for VCMPPD and VCMPPS Instructions    |                                           |                               \n| Predicate      | imm8 Value    | Description                                     | Result: A Is 1st Operand, B Is 2nd Operand| Signals #IA on QNAN Unordered1\n|                |               |                                                 | A = B                                     |                               \n| NGE_UQ         | 19H           | Not-greater-than-or-equal (unordered,           | False                                     | No                            \n|                |               | nonsignaling)                                   |                                           |                               \n| NGT_UQ         | 1AH           | Not-greater-than (unordered, nonsignaling)      | True                                      | No                            \n| FALSE_OS       | 1BH           | False (ordered, signaling)                      | False                                     | Yes                           \n| NEQ_OS         | 1CH           | Not-equal (ordered, signaling)                  | False                                     | Yes                           \n| GE_OQ          | 1DH           | Greater-than-or-equal (ordered, nonsignaling)   | True                                      | No                            \n| GT_OQ          | 1EH           | Greater-than (ordered, nonsignaling)            | False                                     | No                            \n| TRUE_US        | 1FH           | True (unordered, signaling)                     | True                                      | Yes                           \nNotes: 1. If either operand A or B is a NAN.\n\nProcessors with \u201cCPUID.1H:ECX.AVX =1\u201d implement the full complement of 32 predicates\nshown in Table 3-9, software emulation is no longer needed. Compilers and assemblers\nmay implement the following three-operand pseudo-ops in addition to the four-operand\nVCMPPD instruction. See Table 3-10, where the notations of reg1 reg2, and reg3\nrepresent either XMM registers or YMM registers. Compiler should treat reserved\nImm8 values as illegal syntax. Alternately, intrinsics can map the pseudo-ops\nto pre-defined constants to support a simpler intrinsic interface.\n\n| : Pseudo-Op VCMPEQPD reg1, reg2, reg3          | Table 3-10. Table 3-10.| Pseudo-Op and VCMPPD Implementation      \n| VCMPLTPD reg1, reg2, reg3 VCMPLEPD reg1,       |                        | CMPPD Implementation VCMPPD reg1, reg2,  \n| reg2, reg3 VCMPUNORDPD reg1, reg2, reg3        |                        | reg3, 0 VCMPPD reg1, reg2, reg3, 1 VCMPPD\n| VCMPNEQPD reg1, reg2, reg3 VCMPNLTPD           |                        | reg1, reg2, reg3, 2 VCMPPD reg1, reg2,   \n| reg1, reg2, reg3 VCMPNLEPD reg1, reg2,         |                        | reg3, 3 VCMPPD reg1, reg2, reg3, 4 VCMPPD\n| reg3 VCMPORDPD reg1, reg2, reg3 VCMPEQ_UQPD    |                        | reg1, reg2, reg3, 5 VCMPPD reg1, reg2,   \n| reg1, reg2, reg3 VCMPNGEPD reg1, reg2,         |                        | reg3, 6 VCMPPD reg1, reg2, reg3, 7 VCMPPD\n| reg3 VCMPNGTPD reg1, reg2, reg3 VCMPFALSEPD    |                        | reg1, reg2, reg3, 8 VCMPPD reg1, reg2,   \n| reg1, reg2, reg3 VCMPNEQ_OQPD reg1,            |                        | reg3, 9 VCMPPD reg1, reg2, reg3, 0AH     \n| reg2, reg3 VCMPGEPD reg1, reg2, reg3           |                        | VCMPPD reg1, reg2, reg3, 0BH VCMPPD      \n| VCMPGTPD reg1, reg2, reg3 VCMPTRUEPD           |                        | reg1, reg2, reg3, 0CH VCMPPD reg1, reg2, \n| reg1, reg2, reg3 VCMPEQ_OSPD reg1, reg2,       |                        | reg3, 0DH VCMPPD reg1, reg2, reg3, 0EH   \n| reg3 VCMPLT_OQPD reg1, reg2, reg3 VCMPLE_OQPD  |                        | VCMPPD reg1, reg2, reg3, 0FH VCMPPD      \n| reg1, reg2, reg3 Pseudo-Op VCMPUNORD_SPD       |                        | reg1, reg2, reg3, 10H VCMPPD reg1, reg2, \n| reg1, reg2, reg3 VCMPNEQ_USPD reg1,            |                        | reg3, 11H VCMPPD reg1, reg2, reg3, 12H   \n| reg2, reg3 VCMPNLT_UQPD reg1, reg2,            |                        | Pseudo-Op and VCMPPD Implementation      \n| reg3 VCMPNLE_UQPD reg1, reg2, reg3 VCMPORD_SPD |                        | CMPPD Implementation VCMPPD reg1, reg2,  \n| reg1, reg2, reg3 VCMPEQ_USPD reg1, reg2,       |                        | reg3, 13H VCMPPD reg1, reg2, reg3, 14H   \n| reg3 VCMPNGE_UQPD reg1, reg2, reg3 VCMPNGT_UQPD|                        | VCMPPD reg1, reg2, reg3, 15H VCMPPD      \n| reg1, reg2, reg3 VCMPFALSE_OSPD reg1,          |                        | reg1, reg2, reg3, 16H VCMPPD reg1, reg2, \n| reg2, reg3 VCMPNEQ_OSPD reg1, reg2,            |                        | reg3, 17H VCMPPD reg1, reg2, reg3, 18H   \n| reg3 VCMPGE_OQPD reg1, reg2, reg3 VCMPGT_OQPD  |                        | VCMPPD reg1, reg2, reg3, 19H VCMPPD      \n| reg1, reg2, reg3 VCMPTRUE_USPD reg1,           |                        | reg1, reg2, reg3, 1AH VCMPPD reg1, reg2, \n| reg2, reg3                                     |                        | reg3, 1BH VCMPPD reg1, reg2, reg3, 1CH   \n|                                                |                        | VCMPPD reg1, reg2, reg3, 1DH VCMPPD      \n|                                                |                        | reg1, reg2, reg3, 1EH VCMPPD reg1, reg2, \n|                                                |                        | reg3, 1FH                                \nOperation:\n\nCASE (COMPARISON PREDICATE) OF\n  0: OP3 <- EQ_OQ; OP5 <- EQ_OQ;\n  1: OP3 <- LT_OS; OP5 <- LT_OS;\n  2: OP3 <- LE_OS; OP5 <- LE_OS;\n  3: OP3 <- UNORD_Q; OP5 <- UNORD_Q;\n  4: OP3 <- NEQ_UQ; OP5 <- NEQ_UQ;\n  5: OP3 <- NLT_US; OP5 <- NLT_US;\n  6: OP3 <- NLE_US; OP5 <- NLE_US;\n  7: OP3 <- ORD_Q; OP5 <- ORD_Q;\n  8: OP5 <- EQ_UQ;\n  9: OP5 <- NGE_US;\n  10: OP5 <- NGT_US;\n  11: OP5 <- FALSE_OQ;\n  12: OP5 <- NEQ_OQ;\n  13: OP5 <- GE_OS;\n  14: OP5 <- GT_OS;\n  15: OP5 <- TRUE_UQ;\n  16: OP5 <- EQ_OS;\n  17: OP5 <- LT_OQ;\n  18: OP5 <- LE_OQ;\n  19: OP5 <- UNORD_S;\n  20: OP5 <- NEQ_US;\n  21: OP5 <- NLT_UQ;\n  22: OP5 <- NLE_UQ;\n  23: OP5 <- ORD_S;\n  24: OP5 <- EQ_US;\n  25: OP5 <- NGE_UQ;\n  26: OP5 <- NGT_UQ;\n  27: OP5 <- FALSE_OS;\n  28: OP5 <- NEQ_OS;\n  29: OP5 <- GE_OQ;\n  30: OP5 <- GT_OQ;\n  31: OP5 <- TRUE_US;\n  DEFAULT: Reserved;\nCMPPD (128-bit Legacy SSE version)\nCMP0 <- SRC1[63:0] OP3 SRC2[63:0];\nCMP1 <- SRC1[127:64] OP3 SRC2[127:64];\nIF CMP0 = TRUE\n  THEN DEST[63:0] <- FFFFFFFFFFFFFFFFH;\n  ELSE DEST[63:0] <- 0000000000000000H; FI;\nIF CMP1 = TRUE\n  THEN DEST[127:64] <- FFFFFFFFFFFFFFFFH;\n  ELSE DEST[127:64] <- 0000000000000000H; FI;\nDEST[VLMAX-1:128] (Unmodified)\nVCMPPD (VEX.128 encoded version)\nCMP0 <- SRC1[63:0] OP5 SRC2[63:0];\nCMP1 <- SRC1[127:64] OP5 SRC2[127:64];\nIF CMP0 = TRUE\n  THEN DEST[63:0] <- FFFFFFFFFFFFFFFFH;\n  ELSE DEST[63:0] <- 0000000000000000H; FI;\nIF CMP1 = TRUE\n  THEN DEST[127:64] <- FFFFFFFFFFFFFFFFH;\n  ELSE DEST[127:64] <- 0000000000000000H; FI;\nDEST[VLMAX-1:128] <- 0\nVCMPPD (VEX.256 encoded version)\nCMP0 <- SRC1[63:0] OP5 SRC2[63:0];\nCMP1 <- SRC1[127:64] OP5 SRC2[127:64];\nCMP2 <- SRC1[191:128] OP5 SRC2[191:128];\nCMP3 <- SRC1[255:192] OP5 SRC2[255:192];\nIF CMP0 = TRUE\n  THEN DEST[63:0] <- FFFFFFFFFFFFFFFFH;\n  ELSE DEST[63:0] <- 0000000000000000H; FI;\nIF CMP1 = TRUE\n  THEN DEST[127:64] <- FFFFFFFFFFFFFFFFH;\n  ELSE DEST[127:64] <- 0000000000000000H; FI;\nIF CMP2 = TRUE\n  THEN DEST[191:128] <- FFFFFFFFFFFFFFFFH;\n  ELSE DEST[191:128] <- 0000000000000000H; FI;\nIF CMP3 = TRUE\n  THEN DEST[255:192] <- FFFFFFFFFFFFFFFFH;\n  ELSE DEST[255:192] <- 0000000000000000H; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| CMPPD for equality:                               | __m128d _mm_cmpeq_pd(__m128d a, __m128d   \n|                                                   | b)                                        \n| CMPPD for less-than: CMPPD for less-than-or-equal:| __m128d _mm_cmplt_pd(__m128d a, __m128d   \n| __m128d _mm_cmple_pd(__m128d a, __m128d           | b)                                        \n| b)                                                |                                           \n| CMPPD for greater-than:                           | __m128d _mm_cmpgt_pd(__m128d a, __m128d   \n|                                                   | b)                                        \n| CMPPD for greater-than-or-equal:                  | __m128d _mm_cmpge_pd(__m128d a, __m128d   \n|                                                   | b)                                        \n| CMPPD for inequality:                             | __m128d _mm_cmpneq_pd(__m128d a, __m128d  \n|                                                   | b)                                        \n| CMPPD for not-less-than:                          | __m128d _mm_cmpnlt_pd(__m128d a, __m128d  \n|                                                   | b)                                        \n| CMPPD for not-greater-than:                       | __m128d _mm_cmpngt_pd(__m128d a, __m128d  \n|                                                   | b)                                        \n| CMPPD for not-greater-than-or-equal:              | __m128d _mm_cmpnge_pd(__m128d a, __m128d  \n|                                                   | b)                                        \n| CMPPD for ordered:                                | __m128d _mm_cmpord_pd(__m128d a, __m128d  \n|                                                   | b)                                        \n| CMPPD for unordered:                              | __m128d _mm_cmpunord_pd(__m128d a, __m128d\n|                                                   | b)                                        \n| CMPPD for not-less-than-or-equal: __m256          | __m128d _mm_cmpnle_pd(__m128d a, __m128d  \n| _mm256_cmp_pd(__m256 a, __m256 b, const           | b)                                        \n| int imm)                                          |                                           \n| VCMPPD:                                           | __m128 _mm_cmp_pd(__m128 a, __m128 b,     \n|                                                   | const int imm)                            \n\nSIMD Floating-Point Exceptions:\nInvalid if SNaN operand and invalid if QNaN and predicate as listed in above\ntable, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "CMPPD"
    }, 
    {
      "description": "\nCMPPS - Compare Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                      | Op/En| 64/32bit Mode| CPUID Feature Flag| Description                                  \n| 0F C2 /r ib CMPPS xmm1, xmm2/m128, imm8 | RMI  | V/V          | SSE               | Compare packed single-precision floatingpoint\n|                                         |      |              |                   | values in xmm2/mem and xmm1 using imm8       \n|                                         |      |              |                   | as comparison predicate.                     \n| VEX.NDS.128.0F.WIG C2 /r ib VCMPPS xmm1,| RVMI | V/V          | AVX               | Compare packed single-precision floatingpoint\n| xmm2, xmm3/m128, imm8                   |      |              |                   | values in xmm3/m128 and xmm2 using bits      \n|                                         |      |              |                   | 4:0 of imm8 as a comparison predicate.       \n| VEX.NDS.256.0F.WIG C2 /r ib VCMPPS ymm1,| RVMI | V/V          | AVX               | Compare packed single-precision floatingpoint\n| ymm2, ymm3/m256, imm8                   |      |              |                   | values in ymm3/m256 and ymm2 using bits      \n|                                         |      |              |                   | 4:0 of imm8 as a comparison predicate.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nPerforms a SIMD compare of the packed single-precision floating-point values\nin the source operand (second operand) and the destination operand (first operand)\nand returns the results of the comparison to the destination operand. The comparison\npredicate operand (third operand) specifies the type of comparison performed\non each of the pairs of packed values. The result of each comparison is a doubleword\nmask of all 1s (comparison true) or all 0s (comparison false). The sign of zero\nis ignored for comparisons, so that -0.0 is equal to +0.0. 128-bit Legacy SSE\nversion: The first source and destination operand (first operand) is an XMM\nregister. The second source operand (second operand) can be an XMM register\nor 128-bit memory location. The comparison predicate operand is an 8-bit immediate,\nbits 2:0 of the immediate define the type of comparison to be performed (see\nTable 3-7). Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:128) of the\ncorresponding YMM destination register remain unchanged. Four comparisons are\nperformed with results written to bits 127:0 of the destination operand.\n\nThe unordered relationship is true when at least one of the two source operands\nbeing compared is a NaN; the ordered relationship is true when neither source\noperand is a NaN.\n\nA subsequent computational instruction that uses the mask result in the destination\noperand as an input operand will not generate a fault, because a mask of all\n0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds\nto a QNaN.\n\nNote that processors with \u201cCPUID.1H:ECX.AVX =0\u201d do not implement the \u201cgreater-than\u201d,\n\u201cgreater-than-or-equal\u201d, \u201cnot-greater than\u201d, and \u201cnot-greater-than-or-equal\nrelations\u201d predicates. These comparisons can be made either by using the inverse\nrelationship (that is, use the \u201cnot-less-than-or-equal\u201d to make a \u201cgreater-than\u201d\ncomparison) or by using software emulation. When using software emulation, the\nprogram must swap the operands (copying registers when necessary to protect\nthe data that will now be in the destination), and then perform the compare\nusing a different predicate. The predicate to be used for these emulations is\nlisted in Table 3-7 under the heading Emulation.\n\nCompilers and assemblers may implement the following two-operand pseudo-ops\nin addition to the three-operand CMPPS instruction, for processors with \u201cCPUID.1H:ECX.AVX\n=0\u201d. See Table 3-11. Compiler should treat reserved Imm8 values as illegal syntax.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\n\nTable 3-11. Pseudo-Ops and CMPPS:\n| Pseudo-Op            | Implementation     \n| CMPEQPS xmm1, xmm2   | CMPPS xmm1, xmm2, 0\n| CMPLTPS xmm1, xmm2   | CMPPS xmm1, xmm2, 1\n| CMPLEPS xmm1, xmm2   | CMPPS xmm1, xmm2, 2\n| CMPUNORDPS xmm1, xmm2| CMPPS xmm1, xmm2, 3\n| CMPNEQPS xmm1, xmm2  | CMPPS xmm1, xmm2, 4\n| CMPNLTPS xmm1, xmm2  | CMPPS xmm1, xmm2, 5\n| CMPNLEPS xmm1, xmm2  | CMPPS xmm1, xmm2, 6\n| CMPORDPS xmm1, xmm2  | CMPPS xmm1, xmm2, 7\nThe greater-than relations not implemented by processor require more than one\ninstruction to emulate in software and therefore should not be implemented as\npseudo-ops. (For these, the programmer should reverse the operands of the corresponding\nless than relations and use move instructions to ensure that the mask is moved\nto the correct destination register and that the source operand is left intact.)\n\nEnhanced Comparison Predicate for VEX-Encoded VCMPPS VEX.128 encoded version:\nThe first source operand (second operand) is an XMM register. The second source\noperand (third operand) can be an XMM register or a 128-bit memory location.\nBits (VLMAX-1:128) of the destination YMM register are zeroed. Four comparisons\nare performed with results written to bits 127:0 of the destination operand.\nVEX.256 encoded version: The first source operand (second operand) is a YMM\nregister. The second source operand (third operand) can be a YMM register or\na 256-bit memory location. The destination operand (first operand) is a YMM\nregister. Eight comparisons are performed with results written to the destination\noperand. The comparison predicate operand is an 8-bit immediate:\n\n - For instructions encoded using the VEX prefix, bits 4:0 define the type of comparison\nto be performed (see Table 3-9). Bits 5 through 7 of the immediate are reserved.\n\nProcessors with \u201cCPUID.1H:ECX.AVX =1\u201d implement the full complement of 32 predicates\nshown in Table 3-9, software emulation is no longer needed. Compilers and assemblers\nmay implement the following three-operand pseudo-ops in addition to the four-operand\nVCMPPS instruction. See Table 3-12, where the notation of reg1 and reg2 represent\neither XMM registers or YMM registers. Compiler should treat reserved Imm8 values\nas illegal syntax. Alternately, intrinsics can map the pseudo-ops to pre-defined\nconstants to support a simpler intrinsic interface.\n\n| : Pseudo-Op VCMPEQPS reg1, reg2, reg3          | Table 3-12. Table 3-12.| Pseudo-Op and VCMPPS Implementation           \n| VCMPLTPS reg1, reg2, reg3 VCMPLEPS reg1,       |                        | CMPPS Implementation VCMPPS reg1, reg2,       \n| reg2, reg3 VCMPUNORDPS reg1, reg2, reg3        |                        | reg3, 0 VCMPPS reg1, reg2, reg3, 1 VCMPPS     \n| VCMPNEQPS reg1, reg2, reg3 VCMPNLTPS           |                        | reg1, reg2, reg3, 2 VCMPPS reg1, reg2,        \n| reg1, reg2, reg3 VCMPNLEPS reg1, reg2,         |                        | reg3, 3 VCMPPS reg1, reg2, reg3, 4 VCMPPS     \n| reg3 VCMPORDPS reg1, reg2, reg3 VCMPEQ_UQPS    |                        | reg1, reg2, reg3, 5 VCMPPS reg1, reg2,        \n| reg1, reg2, reg3 VCMPNGEPS reg1, reg2,         |                        | reg3, 6 VCMPPS reg1, reg2, reg3, 7 VCMPPS     \n| reg3 VCMPNGTPS reg1, reg2, reg3 VCMPFALSEPS    |                        | reg1, reg2, reg3, 8 VCMPPS reg1, reg2,        \n| reg1, reg2, reg3 Pseudo-Op VCMPNEQ_OQPS        |                        | reg3, 9 VCMPPS reg1, reg2, reg3, 0AH          \n| reg1, reg2, reg3 VCMPGEPS reg1, reg2,          |                        | VCMPPS reg1, reg2, reg3, 0BH Pseudo-Op        \n| reg3 VCMPGTPS reg1, reg2, reg3 VCMPTRUEPS      |                        | and VCMPPS Implementation CMPPS Implementation\n| reg1, reg2, reg3 VCMPEQ_OSPS reg1, reg2,       |                        | VCMPPS reg1, reg2, reg3, 0CH VCMPPS           \n| reg3 VCMPLT_OQPS reg1, reg2, reg3 VCMPLE_OQPS  |                        | reg1, reg2, reg3, 0DH VCMPPS reg1, reg2,      \n| reg1, reg2, reg3 VCMPUNORD_SPS reg1,           |                        | reg3, 0EH VCMPPS reg1, reg2, reg3, 0FH        \n| reg2, reg3 VCMPNEQ_USPS reg1, reg2,            |                        | VCMPPS reg1, reg2, reg3, 10H VCMPPS           \n| reg3 VCMPNLT_UQPS reg1, reg2, reg3 VCMPNLE_UQPS|                        | reg1, reg2, reg3, 11H VCMPPS reg1, reg2,      \n| reg1, reg2, reg3 VCMPORD_SPS reg1, reg2,       |                        | reg3, 12H VCMPPS reg1, reg2, reg3, 13H        \n| reg3 VCMPEQ_USPS reg1, reg2, reg3 VCMPNGE_UQPS |                        | VCMPPS reg1, reg2, reg3, 14H VCMPPS           \n| reg1, reg2, reg3 VCMPNGT_UQPS reg1,            |                        | reg1, reg2, reg3, 15H VCMPPS reg1, reg2,      \n| reg2, reg3 VCMPFALSE_OSPS reg1, reg2,          |                        | reg3, 16H VCMPPS reg1, reg2, reg3, 17H        \n| reg3 VCMPNEQ_OSPS reg1, reg2, reg3 VCMPGE_OQPS |                        | VCMPPS reg1, reg2, reg3, 18H VCMPPS           \n| reg1, reg2, reg3 VCMPGT_OQPS reg1, reg2,       |                        | reg1, reg2, reg3, 19H VCMPPS reg1, reg2,      \n| reg3 VCMPTRUE_USPS reg1, reg2, reg3            |                        | reg3, 1AH VCMPPS reg1, reg2, reg3, 1BH        \n|                                                |                        | VCMPPS reg1, reg2, reg3, 1CH VCMPPS           \n|                                                |                        | reg1, reg2, reg3, 1DH VCMPPS reg1, reg2,      \n|                                                |                        | reg3, 1EH VCMPPS reg1, reg2, reg3, 1FH        \nOperation:\n\nCASE (COMPARISON PREDICATE) OF\n  0: OP3 <- EQ_OQ; OP5 <- EQ_OQ;\n  1: OP3 <- LT_OS; OP5 <- LT_OS;\n  2: OP3 <- LE_OS; OP5 <- LE_OS;\n  3: OP3 <- UNORD_Q; OP5 <- UNORD_Q;\n  4: OP3 <- NEQ_UQ; OP5 <- NEQ_UQ;\n  5: OP3 <- NLT_US; OP5 <- NLT_US;\n  6: OP3 <- NLE_US; OP5 <- NLE_US;\n  7: OP3 <- ORD_Q; OP5 <- ORD_Q;\n  8: OP5 <- EQ_UQ;\n  9: OP5 <- NGE_US;\n  10: OP5 <- NGT_US;\n  11: OP5 <- FALSE_OQ;\n  12: OP5 <- NEQ_OQ;\n  13: OP5 <- GE_OS;\n  14: OP5 <- GT_OS;\n  15: OP5 <- TRUE_UQ;\n  16: OP5 <- EQ_OS;\n  17: OP5 <- LT_OQ;\n  18: OP5 <- LE_OQ;\n  19: OP5 <- UNORD_S;\n  20: OP5 <- NEQ_US;\n  21: OP5 <- NLT_UQ;\n  22: OP5 <- NLE_UQ;\n  23: OP5 <- ORD_S;\n  24: OP5 <- EQ_US;\n  25: OP5 <- NGE_UQ;\n  26: OP5 <- NGT_UQ;\n  27: OP5 <- FALSE_OS;\n  28: OP5 <- NEQ_OS;\n  29: OP5 <- GE_OQ;\n  30: OP5 <- GT_OQ;\n  31: OP5 <- TRUE_US;\n  DEFAULT: Reserved\nEASC;\nCMPPS (128-bit Legacy SSE version)\nCMP0 <- SRC1[31:0] OP3 SRC2[31:0];\nCMP1 <- SRC1[63:32] OP3 SRC2[63:32];\nCMP2 <- SRC1[95:64] OP3 SRC2[95:64];\nCMP3 <- SRC1[127:96] OP3 SRC2[127:96];\nIF CMP0 = TRUE\n  THEN DEST[31:0] <-FFFFFFFFH;\n  ELSE DEST[31:0] <- 000000000H; FI;\nIF CMP1 = TRUE\n  THEN DEST[63:32] <- FFFFFFFFH;\n  ELSE DEST[63:32] <- 000000000H; FI;\nIF CMP2 = TRUE\n  THEN DEST[95:64] <- FFFFFFFFH;\n  ELSE DEST[95:64] <- 000000000H; FI;\nIF CMP3 = TRUE\n  THEN DEST[127:96] <- FFFFFFFFH;\n  ELSE DEST[127:96] <-000000000H; FI;\nDEST[VLMAX-1:128] (Unmodified)\nVCMPPS (VEX.128 encoded version)\nCMP0 <- SRC1[31:0] OP5 SRC2[31:0];\nCMP1 <- SRC1[63:32] OP5 SRC2[63:32];\nCMP2 <- SRC1[95:64] OP5 SRC2[95:64];\nCMP3 <- SRC1[127:96] OP5 SRC2[127:96];\nIF CMP0 = TRUE\n  THEN DEST[31:0] <-FFFFFFFFH;\n  ELSE DEST[31:0] <- 000000000H; FI;\nIF CMP1 = TRUE\n  THEN DEST[63:32] <- FFFFFFFFH;\n  ELSE DEST[63:32] <- 000000000H; FI;\nIF CMP2 = TRUE\n  THEN DEST[95:64] <- FFFFFFFFH;\n  ELSE DEST[95:64] <- 000000000H; FI;\nIF CMP3 = TRUE\n  THEN DEST[127:96] <- FFFFFFFFH;\n  ELSE DEST[127:96] <-000000000H; FI;\nDEST[VLMAX-1:128] <- 0\nVCMPPS (VEX.256 encoded version)\nCMP0 <- SRC1[31:0] OP5 SRC2[31:0];\nCMP1 <- SRC1[63:32] OP5 SRC2[63:32];\nCMP2 <- SRC1[95:64] OP5 SRC2[95:64];\nCMP3 <- SRC1[127:96] OP5 SRC2[127:96];\nCMP4 <- SRC1[159:128] OP5 SRC2[159:128];\nCMP5 <- SRC1[191:160] OP5 SRC2[191:160];\nCMP6 <- SRC1[223:192] OP5 SRC2[223:192];\nCMP7 <- SRC1[255:224] OP5 SRC2[255:224];\nIF CMP0 = TRUE\n  THEN DEST[31:0] <-FFFFFFFFH;\n  ELSE DEST[31:0] <- 000000000H; FI;\nIF CMP1 = TRUE\n  THEN DEST[63:32] <- FFFFFFFFH;\n  ELSE DEST[63:32] <-000000000H; FI;\nIF CMP2 = TRUE\n  THEN DEST[95:64] <- FFFFFFFFH;\n  ELSE DEST[95:64] <- 000000000H; FI;\nIF CMP3 = TRUE\n  THEN DEST[127:96] <- FFFFFFFFH;\n  ELSE DEST[127:96] <- 000000000H; FI;\nIF CMP4 = TRUE\n  THEN DEST[159:128] <- FFFFFFFFH;\n  ELSE DEST[159:128] <- 000000000H; FI;\nIF CMP5 = TRUE\n  THEN DEST[191:160] <- FFFFFFFFH;\n  ELSE DEST[191:160] <- 000000000H; FI;\nIF CMP6 = TRUE\n  THEN DEST[223:192] <- FFFFFFFFH;\n  ELSE DEST[223:192] <-000000000H; FI;\nIF CMP7 = TRUE\n  THEN DEST[255:224] <- FFFFFFFFH;\n  ELSE DEST[255:224] <- 000000000H; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| CMPPS for equality:                     | __m128 _mm_cmpeq_ps(__m128 a, __m128   \n|                                         | b)                                     \n| CMPPS for less-than:                    | __m128 _mm_cmplt_ps(__m128 a, __m128   \n|                                         | b)                                     \n| CMPPS for less-than-or-equal:           | __m128 _mm_cmple_ps(__m128 a, __m128   \n|                                         | b)                                     \n| CMPPS for greater-than:                 | __m128 _mm_cmpgt_ps(__m128 a, __m128   \n|                                         | b)                                     \n| CMPPS for greater-than-or-equal:        | __m128 _mm_cmpge_ps(__m128 a, __m128   \n|                                         | b)                                     \n| CMPPS for inequality:                   | __m128 _mm_cmpneq_ps(__m128 a, __m128  \n|                                         | b)                                     \n| CMPPS for not-less-than:                | __m128 _mm_cmpnlt_ps(__m128 a, __m128  \n|                                         | b)                                     \n| CMPPS for not-greater-than:             | __m128 _mm_cmpngt_ps(__m128 a, __m128  \n|                                         | b)                                     \n| CMPPS for not-greater-than-or-equal:    | __m128 _mm_cmpnge_ps(__m128 a, __m128  \n|                                         | b)                                     \n| CMPPS for ordered:                      | __m128 _mm_cmpord_ps(__m128 a, __m128  \n|                                         | b)                                     \n| CMPPS for unordered:                    | __m128 _mm_cmpunord_ps(__m128 a, __m128\n|                                         | b)                                     \n| CMPPS for not-less-than-or-equal: __m256| __m128 _mm_cmpnle_ps(__m128 a, __m128  \n| _mm256_cmp_ps(__m256 a, __m256 b, const | b)                                     \n| int imm) __m128 _mm_cmp_ps(__m128 a,    |                                        \n| __m128 b, const int imm)                |                                        \n\nSIMD Floating-Point Exceptions:\nInvalid if SNaN operand and invalid if QNaN and predicate as listed in above\ntable, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "CMPPS"
    }, 
    {
      "description": "\nCMPS/CMPSB/CMPSW/CMPSD/CMPSQ - Compare String Operands:\n| Opcode    | Instruction  | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                              \n| A6        | CMPS m8, m8  | NP   | Valid      | Valid          | For legacy mode, compare byte at address \n|           |              |      |            |                | DS:(E)SI with byte at address ES:(E)DI;  \n|           |              |      |            |                | For 64bit mode compare byte at address   \n|           |              |      |            |                | (R|E)SI to byte at address (R|E)DI.      \n|           |              |      |            |                | The status flags are set accordingly.    \n| A7        | CMPS m16, m16| NP   | Valid      | Valid          | For legacy mode, compare word at address \n|           |              |      |            |                | DS:(E)SI with word at address ES:(E)DI;  \n|           |              |      |            |                | For 64bit mode compare word at address   \n|           |              |      |            |                | (R|E)SI with word at address (R|E)DI.    \n|           |              |      |            |                | The status flags are set accordingly.    \n| A7        | CMPS m32, m32| NP   | Valid      | Valid          | For legacy mode, compare dword at address\n|           |              |      |            |                | DS:(E)SI at dword at address ES:(E)DI;   \n|           |              |      |            |                | For 64bit mode compare dword at address  \n|           |              |      |            |                | (R|E)SI at dword at address (R|E)DI.     \n|           |              |      |            |                | The status flags are set accordingly.    \n| REX.W + A7| CMPS m64, m64| NP   | Valid      | N.E.           | Compares quadword at address (R|E)SI     \n|           |              |      |            |                | with quadword at address (R|E)DI and     \n|           |              |      |            |                | sets the status flags accordingly.       \n| A6        | CMPSB        | NP   | Valid      | Valid          | For legacy mode, compare byte at address \n|           |              |      |            |                | DS:(E)SI with byte at address ES:(E)DI;  \n|           |              |      |            |                | For 64bit mode compare byte at address   \n|           |              |      |            |                | (R|E)SI with byte at address (R|E)DI.    \n|           |              |      |            |                | The status flags are set accordingly.    \n| A7        | CMPSW        | NP   | Valid      | Valid          | For legacy mode, compare word at address \n|           |              |      |            |                | DS:(E)SI with word at address ES:(E)DI;  \n|           |              |      |            |                | For 64bit mode compare word at address   \n|           |              |      |            |                | (R|E)SI with word at address (R|E)DI.    \n|           |              |      |            |                | The status flags are set accordingly.    \n| A7        | CMPSD        | NP   | Valid      | Valid          | For legacy mode, compare dword at address\n|           |              |      |            |                | DS:(E)SI with dword at address ES:(E)DI; \n|           |              |      |            |                | For 64-bit mode compare dword at address \n|           |              |      |            |                | (R|E)SI with dword at address (R|E)DI.   \n|           |              |      |            |                | The status flags are set accordingly.    \n| REX.W + A7| CMPSQ        | NP   | Valid      | N.E.           | Compares quadword at address (R|E)SI     \n|           |              |      |            |                | with quadword at address (R|E)DI and     \n|           |              |      |            |                | sets the status flags accordingly.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nCompares the byte, word, doubleword, or quadword specified with the first source\noperand with the byte, word, doubleword, or quadword specified with the second\nsource operand and sets the status flags in the EFLAGS register according to\nthe results.\n\nBoth source operands are located in memory. The address of the first source\noperand is read from DS:SI, DS:ESI or RSI (depending on the address-size attribute\nof the instruction is 16, 32, or 64, respectively). The address of the second\nsource operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size\nattribute of the\n\ninstruction is 16, 32, or 64). The DS segment may be overridden with a segment\noverride prefix, but the ES segment cannot be overridden.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \u201cexplicit-operands\u201d\nform and the \u201cnooperands\u201d form. The explicit-operands form (specified with the\nCMPS mnemonic) allows the two source operands to be specified explicitly. Here,\nthe source operands should be symbols that indicate the size and location of\nthe source values. This explicit-operand form is provided to allow documentation.\nHowever, note that the documentation provided by this form can be misleading.\nThat is, the source operand symbols must specify the correct type (size) of\nthe operands (bytes, words, or doublewords, quadwords), but they do not have\nto specify the correct location. Locations of the source operands are always\nspecified by the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers, which must\nbe loaded correctly before the compare string instruction is executed.\n\nThe no-operands form provides \u201cshort forms\u201d of the byte, word, and doubleword\nversions of the CMPS instructions. Here also the DS:(E)SI (or RSI) and ES:(E)DI\n(or RDI) registers are assumed by the processor to specify the location of the\nsource operands. The size of the source operands is selected with the mnemonic:\nCMPSB (byte comparison), CMPSW (word comparison), CMPSD (doubleword comparison),\nor CMPSQ (quadword comparison using REX.W).\n\nAfter the comparison, the (E/R)SI and (E/R)DI registers increment or decrement\nautomatically according to the setting of the DF flag in the EFLAGS register.\n(If the DF flag is 0, the (E/R)SI and (E/R)DI register increment; if the DF\nflag is 1, the registers decrement.) The registers increment or decrement by\n1 for byte operations, by 2 for word operations, 4 for doubleword operations.\nIf operand size is 64, RSI and RDI registers increment by 8 for quadword operations.\n\nThe CMPS, CMPSB, CMPSW, CMPSD, and CMPSQ instructions can be preceded by the\nREP prefix for block comparisons. More often, however, these instructions will\nbe used in a LOOP construct that takes some action based on the setting of the\nstatus flags before the next comparison is made. See \u201cREP/REPE/REPZ /REPNE/REPNZ - Repeat\nString Operation Prefix\u201d in Chapter 4 of the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 2B, for a description of the REP prefix.\n\nIn 64-bit mode, the instruction's default address size is 64 bits, 32 bit address\nsize is supported using the prefix 67H. Use of the REX.W prefix promotes doubleword\noperation to 64 bits (see CMPSQ). See the summary chart at the beginning of\nthis section for encoding data and limits.\n\nOperation:\n\ntemp <- SRC1 - SRC2;\nSetStatusFlags(temp);\nIF (64-Bit Mode)\n  THEN\n     IF (Byte comparison)\n     THEN IF DF = 0\n       THEN\n          (R|E)SI <- (R|E)SI + 1;\n          (R|E)DI <- (R|E)DI + 1;\n       ELSE\n          (R|E)SI <- (R|E)SI - 1;\n          (R|E)DI <- (R|E)DI - 1;\n       FI;\n     ELSE IF (Word comparison)\n       THEN IF DF = 0\n          THEN\n             (R|E)SI <- (R|E)SI + 2;\n             (R|E)DI <- (R|E)DI + 2;\n          ELSE\n             (R|E)SI <- (R|E)SI - 2;\n             (R|E)DI <- (R|E)DI - 2;\n          FI;\n     ELSE IF (Doubleword comparison)\n       THEN IF DF = 0\n          THEN\n             (R|E)SI <- (R|E)SI + 4;\n             (R|E)DI <- (R|E)DI + 4;\n          ELSE\n             (R|E)SI <- (R|E)SI - 4;\n             (R|E)DI <- (R|E)DI - 4;\n          FI;\n     ELSE (* Quadword comparison *)\n       THEN IF DF = 0\n          (R|E)SI <- (R|E)SI + 8;\n          (R|E)DI <- (R|E)DI + 8;\n       ELSE\n          (R|E)SI <- (R|E)SI - 8;\n          (R|E)DI <- (R|E)DI - 8;\n       FI;\n     FI;\n  ELSE (* Non-64-bit Mode *)\n     IF (byte comparison)\n     THEN IF DF = 0\n       THEN\n          (E)SI <- (E)SI + 1;\n          (E)DI <- (E)DI + 1;\n       ELSE\n          (E)SI <- (E)SI - 1;\n          (E)DI <- (E)DI - 1;\n       FI;\n     ELSE IF (Word comparison)\n       THEN IF DF = 0\n          (E)SI <- (E)SI + 2;\n          (E)DI <- (E)DI + 2;\n       ELSE\n          (E)SI <- (E)SI - 2;\n          (E)DI <- (E)DI - 2;\n       FI;\n     ELSE (* Doubleword comparison *)\n       THEN IF DF = 0\n          (E)SI <- (E)SI + 4;\n          (E)DI <- (E)DI + 4;\n       ELSE\n          (E)SI <- (E)SI - 4;\n          (E)DI <- (E)DI - 4;\n       FI;\n     FI;\nFI;\n\nFlags Affected:\nThe CF, OF, SF, ZF, AF, and PF flags are set according to the temporary result\nof the comparison.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.  \n\nCMPSD - Compare Scalar Double-Precision Floating-Point Values:\n| Opcode/Instruction                   | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| F2 0F C2 /r ib CMPSD xmm1, xmm2/m64, | RMI  | V/V           | SSE2              | Compare low double-precision floating-point\n| imm8                                 |      |               |                   | value in xmm2/m64 and xmm1 using imm8      \n|                                      |      |               |                   | as comparison predicate.                   \n| VEX.NDS.LIG.F2.0F.WIG C2 /r ib VCMPSD| RVMI | V/V           | AVX               | Compare low double precision floating-point\n| xmm1, xmm2, xmm3/m64, imm8           |      |               |                   | value in xmm3/m64 and xmm2 using bits      \n|                                      |      |               |                   | 4:0 of imm8 as comparison predicate.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nCompares the low double-precision floating-point values in the source operand\n(second operand) and the destination operand (first operand) and returns the\nresults of the comparison to the destination operand. The comparison predicate\noperand (third operand) specifies the type of comparison performed. The comparison\nresult is a quadword mask of all 1s (comparison true) or all 0s (comparison\nfalse). The sign of zero is ignored for comparisons, so that -0.0 is equal to\n+0.0. 128-bit Legacy SSE version: The first source and destination operand (first\noperand) is an XMM register. The second source operand (second operand) can\nbe an XMM register or 64-bit memory location. The comparison predicate operand\nis an 8-bit immediate, bits 2:0 of the immediate define the type of comparison\nto be performed (see Table 3-7). Bits 7:3 of the immediate is reserved. Bits\n(VLMAX-1:64) of the corresponding YMM destination register remain unchanged.\n\nThe unordered relationship is true when at least one of the two source operands\nbeing compared is a NaN; the ordered relationship is true when neither source\noperand is a NaN.\n\nA subsequent computational instruction that uses the mask result in the destination\noperand as an input operand will not generate a fault, because a mask of all\n0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds\nto a QNaN.\n\nNote that processors with \u201cCPUID.1H:ECX.AVX =0\u201d do not implement the \u201cgreater-than\u201d,\n\u201cgreater-than-or-equal\u201d, \u201cnot-greater than\u201d, and \u201cnot-greater-than-or-equal\nrelations\u201d predicates. These comparisons can be made either by using the inverse\nrelationship (that is, use the \u201cnot-less-than-or-equal\u201d to make a \u201cgreater-than\u201d\ncomparison) or by using software emulation. When using software emulation, the\nprogram must swap the operands (copying registers when necessary to protect\nthe data that will now be in the destination operand), and then perform the\ncompare using a different predicate. The predicate to be used for these emulations\nis listed in Table 3-7 under the heading Emulation.\n\nCompilers and assemblers may implement the following two-operand pseudo-ops\nin addition to the three-operand CMPSD instruction, for processors with \u201cCPUID.1H:ECX.AVX\n=0\u201d. See Table 3-13. Compiler should treat reserved Imm8 values as illegal syntax.\n\n\nTable 3-13. Pseudo-Ops and CMPSD:\n| Pseudo-Op            | Implementation    \n| CMPEQSD xmm1, xmm2   | CMPSD xmm1,xmm2, 0\n| CMPLTSD xmm1, xmm2   | CMPSD xmm1,xmm2, 1\n| CMPLESD xmm1, xmm2   | CMPSD xmm1,xmm2, 2\n| CMPUNORDSD xmm1, xmm2| CMPSD xmm1,xmm2, 3\n| CMPNEQSD xmm1, xmm2  | CMPSD xmm1,xmm2, 4\n| CMPNLTSD xmm1, xmm2  | CMPSD xmm1,xmm2, 5\n| CMPNLESD xmm1, xmm2  | CMPSD xmm1,xmm2, 6\n| CMPORDSD xmm1, xmm2  | CMPSD xmm1,xmm2, 7\nThe greater-than relations not implemented in the processor require more than\none instruction to emulate in software and therefore should not be implemented\nas pseudo-ops. (For these, the programmer should reverse the operands of the\ncorresponding less than relations and use move instructions to ensure that the\nmask is moved to the correct destination register and that the source operand\nis left intact.)\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nEnhanced Comparison Predicate for VEX-Encoded VCMPSD VEX.128 encoded version:\nThe first source operand (second operand) is an XMM register. The second source\noperand (third operand) can be an XMM register or a 64-bit memory location.\nBits (VLMAX-1:128) of the destination YMM register are zeroed. The comparison\npredicate operand is an 8-bit immediate:\n\n - For instructions encoded using the VEX prefix, bits 4:0 define the type of comparison\nto be performed (see Table 3-9). Bits 5 through 7 of the immediate are reserved.\n\nProcessors with \u201cCPUID.1H:ECX.AVX =1\u201d implement the full complement of 32 predicates\nshown in Table 3-9, software emulation is no longer needed. Compilers and assemblers\nmay implement the following three-operand pseudo-ops in addition to the four-operand\nVCMPSD instruction. See Table 3-14, where the notations of reg1 reg2, and reg3\nrepresent either XMM registers or YMM registers. Compiler should treat reserved\nImm8 values as illegal syntax. Alternately, intrinsics can map the pseudo-ops\nto pre-defined constants to support a simpler intrinsic interface.\n\n| : Pseudo-Op VCMPEQSD reg1, reg2, reg3          | Table 3-14. Table 3-14.| Pseudo-Op and VCMPSD Implementation      \n| VCMPLTSD reg1, reg2, reg3 VCMPLESD reg1,       |                        | CMPSD Implementation VCMPSD reg1, reg2,  \n| reg2, reg3 VCMPUNORDSD reg1, reg2, reg3        |                        | reg3, 0 VCMPSD reg1, reg2, reg3, 1 VCMPSD\n| VCMPNEQSD reg1, reg2, reg3 VCMPNLTSD           |                        | reg1, reg2, reg3, 2 VCMPSD reg1, reg2,   \n| reg1, reg2, reg3 VCMPNLESD reg1, reg2,         |                        | reg3, 3 VCMPSD reg1, reg2, reg3, 4 VCMPSD\n| reg3 VCMPORDSD reg1, reg2, reg3 VCMPEQ_UQSD    |                        | reg1, reg2, reg3, 5 VCMPSD reg1, reg2,   \n| reg1, reg2, reg3 VCMPNGESD reg1, reg2,         |                        | reg3, 6 VCMPSD reg1, reg2, reg3, 7 VCMPSD\n| reg3 VCMPNGTSD reg1, reg2, reg3 VCMPFALSESD    |                        | reg1, reg2, reg3, 8 VCMPSD reg1, reg2,   \n| reg1, reg2, reg3 VCMPNEQ_OQSD reg1,            |                        | reg3, 9 VCMPSD reg1, reg2, reg3, 0AH     \n| reg2, reg3 VCMPGESD reg1, reg2, reg3           |                        | VCMPSD reg1, reg2, reg3, 0BH VCMPSD      \n| VCMPGTSD reg1, reg2, reg3 Pseudo-Op            |                        | reg1, reg2, reg3, 0CH VCMPSD reg1, reg2, \n| VCMPTRUESD reg1, reg2, reg3 VCMPEQ_OSSD        |                        | reg3, 0DH VCMPSD reg1, reg2, reg3, 0EH   \n| reg1, reg2, reg3 VCMPLT_OQSD reg1, reg2,       |                        | Pseudo-Op and VCMPSD Implementation      \n| reg3 VCMPLE_OQSD reg1, reg2, reg3 VCMPUNORD_SSD|                        | (Contd.) CMPSD Implementation VCMPSD     \n| reg1, reg2, reg3 VCMPNEQ_USSD reg1,            |                        | reg1, reg2, reg3, 0FH VCMPSD reg1, reg2, \n| reg2, reg3 VCMPNLT_UQSD reg1, reg2,            |                        | reg3, 10H VCMPSD reg1, reg2, reg3, 11H   \n| reg3 VCMPNLE_UQSD reg1, reg2, reg3 VCMPORD_SSD |                        | VCMPSD reg1, reg2, reg3, 12H VCMPSD      \n| reg1, reg2, reg3 VCMPEQ_USSD reg1, reg2,       |                        | reg1, reg2, reg3, 13H VCMPSD reg1, reg2, \n| reg3 VCMPNGE_UQSD reg1, reg2, reg3 VCMPNGT_UQSD|                        | reg3, 14H VCMPSD reg1, reg2, reg3, 15H   \n| reg1, reg2, reg3 VCMPFALSE_OSSD reg1,          |                        | VCMPSD reg1, reg2, reg3, 16H VCMPSD      \n| reg2, reg3 VCMPNEQ_OSSD reg1, reg2,            |                        | reg1, reg2, reg3, 17H VCMPSD reg1, reg2, \n| reg3 VCMPGE_OQSD reg1, reg2, reg3 VCMPGT_OQSD  |                        | reg3, 18H VCMPSD reg1, reg2, reg3, 19H   \n| reg1, reg2, reg3 VCMPTRUE_USSD reg1,           |                        | VCMPSD reg1, reg2, reg3, 1AH VCMPSD      \n| reg2, reg3                                     |                        | reg1, reg2, reg3, 1BH VCMPSD reg1, reg2, \n|                                                |                        | reg3, 1CH VCMPSD reg1, reg2, reg3, 1DH   \n|                                                |                        | VCMPSD reg1, reg2, reg3, 1EH VCMPSD      \n|                                                |                        | reg1, reg2, reg3, 1FH                    \nOperation:\n\nCASE (COMPARISON PREDICATE) OF\n  0: OP3 <- EQ_OQ; OP5 <- EQ_OQ;\n  1: OP3 <- LT_OS; OP5 <- LT_OS;\n  2: OP3 <- LE_OS; OP5 <- LE_OS;\n  3: OP3 <- UNORD_Q; OP5 <- UNORD_Q;\n  4: OP3 <- NEQ_UQ; OP5 <- NEQ_UQ;\n  5: OP3 <- NLT_US; OP5 <- NLT_US;\n  6: OP3 <- NLE_US; OP5 <- NLE_US;\n  7: OP3 <- ORD_Q; OP5 <- ORD_Q;\n  8: OP5 <- EQ_UQ;\n  9: OP5 <- NGE_US;\n  10: OP5 <- NGT_US;\n  11: OP5 <- FALSE_OQ;\n  12: OP5 <- NEQ_OQ;\n  13: OP5 <- GE_OS;\n  14: OP5 <- GT_OS;\n  15: OP5 <- TRUE_UQ;\n  16: OP5 <- EQ_OS;\n  17: OP5 <- LT_OQ;\n  18: OP5 <- LE_OQ;\n  19: OP5 <- UNORD_S;\n  20: OP5 <- NEQ_US;\n  21: OP5 <- NLT_UQ;\n  22: OP5 <- NLE_UQ;\n  23: OP5 <- ORD_S;\n  24: OP5 <- EQ_US;\n  25: OP5 <- NGE_UQ;\n  26: OP5 <- NGT_UQ;\n  27: OP5 <- FALSE_OS;\n  28: OP5 <- NEQ_OS;\n  29: OP5 <- GE_OQ;\n  30: OP5 <- GT_OQ;\n  31: OP5 <- TRUE_US;\n  DEFAULT: Reserved\nESAC;\nCMPSD (128-bit Legacy SSE version)\nCMP0 <- DEST[63:0] OP3 SRC[63:0];\nIF CMP0 = TRUE\nTHEN DEST[63:0] <- FFFFFFFFFFFFFFFFH;\nELSE DEST[63:0] <- 0000000000000000H; FI;\nDEST[VLMAX-1:64] (Unmodified)\nVCMPSD (VEX.128 encoded version)\nCMP0 <- SRC1[63:0] OP5 SRC2[63:0];\nIF CMP0 = TRUE\nTHEN DEST[63:0] <- FFFFFFFFFFFFFFFFH;\nELSE DEST[63:0] <- 0000000000000000H; FI;\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| CMPSD for equality:                                     | __m128d _mm_cmpeq_sd(__m128d a, __m128d   \n|                                                         | b)                                        \n| CMPSD for less-than:                                    | __m128d _mm_cmplt_sd(__m128d a, __m128d   \n|                                                         | b)                                        \n| CMPSD for less-than-or-equal:                           | __m128d _mm_cmple_sd(__m128d a, __m128d   \n|                                                         | b)                                        \n| CMPSD for greater-than:                                 | __m128d _mm_cmpgt_sd(__m128d a, __m128d   \n|                                                         | b)                                        \n| CMPSD for greater-than-or-equal:                        | __m128d _mm_cmpge_sd(__m128d a, __m128d   \n|                                                         | b)                                        \n| CMPSD for inequality:                                   | __m128d _mm_cmpneq_sd(__m128d a, __m128d  \n|                                                         | b)                                        \n| CMPSD for not-less-than:                                | __m128d _mm_cmpnlt_sd(__m128d a, __m128d  \n|                                                         | b)                                        \n| CMPSD for not-greater-than: CMPSD for                   | __m128d _mm_cmpngt_sd(__m128d a, __m128d  \n| not-greater-than-or-equal: __m128d _mm_cmpnge_sd(__m128d| b)                                        \n| a, __m128d b)                                           |                                           \n| CMPSD for ordered:                                      | __m128d _mm_cmpord_sd(__m128d a, __m128d  \n|                                                         | b)                                        \n| CMPSD for unordered:                                    | __m128d _mm_cmpunord_sd(__m128d a, __m128d\n|                                                         | b)                                        \n| CMPSD for not-less-than-or-equal:                       | __m128d _mm_cmpnle_sd(__m128d a, __m128d  \n|                                                         | b)                                        \n| VCMPSD:                                                 | __m128 _mm_cmp_sd(__m128 a, __m128 b,     \n|                                                         | const int imm)                            \n\nSIMD Floating-Point Exceptions:\nInvalid if SNaN operand, Invalid if QNaN and predicate as listed in above table,\nDenormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.              \n", 
      "mnem": "CMPS"
    }, 
    {
      "description": "-R:CMPS", 
      "mnem": "CMPSB"
    }, 
    {
      "description": "-R:CMPS", 
      "mnem": "CMPSD"
    }, 
    {
      "description": "-R:CMPS", 
      "mnem": "CMPSQ"
    }, 
    {
      "description": "\nCMPSS - Compare Scalar Single-Precision Floating-Point Values:\n| Opcode/Instruction                   | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| F3 0F C2 /r ib CMPSS xmm1, xmm2/m32, | RMI  | V/V           | SSE               | Compare low single-precision floating-point\n| imm8                                 |      |               |                   | value in xmm2/m32 and xmm1 using imm8      \n|                                      |      |               |                   | as comparison predicate.                   \n| VEX.NDS.LIG.F3.0F.WIG C2 /r ib VCMPSS| RVMI | V/V           | AVX               | Compare low single precision floating-point\n| xmm1, xmm2, xmm3/m32, imm8           |      |               |                   | value in xmm3/m32 and xmm2 using bits      \n|                                      |      |               |                   | 4:0 of imm8 as comparison predicate.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nCompares the low single-precision floating-point values in the source operand\n(second operand) and the destination operand (first operand) and returns the\nresults of the comparison to the destination operand. The comparison predicate\noperand (third operand) specifies the type of comparison performed. The comparison\nresult is a doubleword mask of all 1s (comparison true) or all 0s (comparison\nfalse). The sign of zero is ignored for comparisons, so that -0.0 is equal to\n+0.0. 128-bit Legacy SSE version: The first source and destination operand (first\noperand) is an XMM register. The second source operand (second operand) can\nbe an XMM register or 64-bit memory location. The comparison predicate operand\nis an 8-bit immediate, bits 2:0 of the immediate define the type of comparison\nto be performed (see Table 3-7). Bits 7:3 of the immediate is reserved. Bits\n(VLMAX-1:32) of the corresponding YMM destination register remain unchanged.\n\nThe unordered relationship is true when at least one of the two source operands\nbeing compared is a NaN; the ordered relationship is true when neither source\noperand is a NaN\n\nA subsequent computational instruction that uses the mask result in the destination\noperand as an input operand will not generate a fault, since a mask of all 0s\ncorresponds to a floating-point value of +0.0 and a mask of all 1s corresponds\nto a QNaN.\n\nNote that processors with \u201cCPUID.1H:ECX.AVX =0\u201d do not implement the \u201cgreater-than\u201d,\n\u201cgreater-than-or-equal\u201d, \u201cnot-greater than\u201d, and \u201cnot-greater-than-or-equal\nrelations\u201d predicates. These comparisons can be made either by using the inverse\nrelationship (that is, use the \u201cnot-less-than-or-equal\u201d to make a \u201cgreater-than\u201d\ncomparison) or by using software emulation. When using software emulation, the\nprogram must swap the operands (copying registers when necessary to protect\nthe data that will now be in the destination operand), and then perform the\ncompare using a different predicate. The predicate to be used for these emulations\nis listed in Table 3-7 under the heading Emulation.\n\nCompilers and assemblers may implement the following two-operand pseudo-ops\nin addition to the three-operand CMPSS instruction, for processors with \u201cCPUID.1H:ECX.AVX\n=0\u201d. See Table 3-15. Compiler should treat reserved Imm8 values as illegal syntax.\n\n\nTable 3-15. Pseudo-Ops and CMPSS:\n| Pseudo-Op            | CMPSS Implementation\n| CMPEQSS xmm1, xmm2   | CMPSS xmm1, xmm2, 0 \n| CMPLTSS xmm1, xmm2   | CMPSS xmm1, xmm2, 1 \n| CMPLESS xmm1, xmm2   | CMPSS xmm1, xmm2, 2 \n| CMPUNORDSS xmm1, xmm2| CMPSS xmm1, xmm2, 3 \n| CMPNEQSS xmm1, xmm2  | CMPSS xmm1, xmm2, 4 \n| CMPNLTSS xmm1, xmm2  | CMPSS xmm1, xmm2, 5 \n| CMPNLESS xmm1, xmm2  | CMPSS xmm1, xmm2, 6 \n| CMPORDSS xmm1, xmm2  | CMPSS xmm1, xmm2, 7 \nThe greater-than relations not implemented in the processor require more than\none instruction to emulate in software and therefore should not be implemented\nas pseudo-ops. (For these, the programmer should reverse the operands of the\ncorresponding less than relations and use move instructions to ensure that the\nmask is moved to the correct destination register and that the source operand\nis left intact.)\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nEnhanced Comparison Predicate for VEX-Encoded VCMPSD VEX.128 encoded version:\nThe first source operand (second operand) is an XMM register. The second source\noperand (third operand) can be an XMM register or a 32-bit memory location.\nBits (VLMAX-1:128) of the destination YMM register are zeroed. The comparison\npredicate operand is an 8-bit immediate:\n\n - For instructions encoded using the VEX prefix, bits 4:0 define the type of comparison\nto be performed (see Table 3-9). Bits 5 through 7 of the immediate are reserved.\n\nProcessors with \u201cCPUID.1H:ECX.AVX =1\u201d implement the full complement of 32 predicates\nshown in Table 3-9, software emulation is no longer needed. Compilers and assemblers\nmay implement the following three-operand pseudo-ops in addition to the four-operand\nVCMPSS instruction. See Table 3-16, where the notations of reg1 reg2, and reg3\nrepresent either XMM registers or YMM registers. Compiler should treat reserved\nImm8 values as illegal syntax. Alternately, intrinsics can map the pseudo-ops\nto pre-defined constants to support a simpler intrinsic interface.\n\n| : Pseudo-Op VCMPEQSS reg1, reg2, reg3          | Table 3-16. Table 3-16.| Pseudo-Op and VCMPSS Implementation      \n| VCMPLTSS reg1, reg2, reg3 VCMPLESS reg1,       |                        | CMPSS Implementation VCMPSS reg1, reg2,  \n| reg2, reg3 VCMPUNORDSS reg1, reg2, reg3        |                        | reg3, 0 VCMPSS reg1, reg2, reg3, 1 VCMPSS\n| VCMPNEQSS reg1, reg2, reg3 VCMPNLTSS           |                        | reg1, reg2, reg3, 2 VCMPSS reg1, reg2,   \n| reg1, reg2, reg3 VCMPNLESS reg1, reg2,         |                        | reg3, 3 VCMPSS reg1, reg2, reg3, 4 VCMPSS\n| reg3 VCMPORDSS reg1, reg2, reg3 VCMPEQ_UQSS    |                        | reg1, reg2, reg3, 5 VCMPSS reg1, reg2,   \n| reg1, reg2, reg3 VCMPNGESS reg1, reg2,         |                        | reg3, 6 VCMPSS reg1, reg2, reg3, 7 VCMPSS\n| reg3 VCMPNGTSS reg1, reg2, reg3 VCMPFALSESS    |                        | reg1, reg2, reg3, 8 VCMPSS reg1, reg2,   \n| reg1, reg2, reg3 VCMPNEQ_OQSS reg1,            |                        | reg3, 9 VCMPSS reg1, reg2, reg3, 0AH     \n| reg2, reg3 VCMPGESS reg1, reg2, reg3           |                        | VCMPSS reg1, reg2, reg3, 0BH VCMPSS      \n| VCMPGTSS reg1, reg2, reg3 Pseudo-Op            |                        | reg1, reg2, reg3, 0CH VCMPSS reg1, reg2, \n| VCMPTRUESS reg1, reg2, reg3 VCMPEQ_OSSS        |                        | reg3, 0DH VCMPSS reg1, reg2, reg3, 0EH   \n| reg1, reg2, reg3 VCMPLT_OQSS reg1, reg2,       |                        | Pseudo-Op and VCMPSS Implementation      \n| reg3 VCMPLE_OQSS reg1, reg2, reg3 VCMPUNORD_SSS|                        | (Contd.) CMPSS Implementation VCMPSS     \n| reg1, reg2, reg3 VCMPNEQ_USSS reg1,            |                        | reg1, reg2, reg3, 0FH VCMPSS reg1, reg2, \n| reg2, reg3 VCMPNLT_UQSS reg1, reg2,            |                        | reg3, 10H VCMPSS reg1, reg2, reg3, 11H   \n| reg3 VCMPNLE_UQSS reg1, reg2, reg3 VCMPORD_SSS |                        | VCMPSS reg1, reg2, reg3, 12H VCMPSS      \n| reg1, reg2, reg3 VCMPEQ_USSS reg1, reg2,       |                        | reg1, reg2, reg3, 13H VCMPSS reg1, reg2, \n| reg3 VCMPNGE_UQSS reg1, reg2, reg3 VCMPNGT_UQSS|                        | reg3, 14H VCMPSS reg1, reg2, reg3, 15H   \n| reg1, reg2, reg3 VCMPFALSE_OSSS reg1,          |                        | VCMPSS reg1, reg2, reg3, 16H VCMPSS      \n| reg2, reg3 VCMPNEQ_OSSS reg1, reg2,            |                        | reg1, reg2, reg3, 17H VCMPSS reg1, reg2, \n| reg3 VCMPGE_OQSS reg1, reg2, reg3 VCMPGT_OQSS  |                        | reg3, 18H VCMPSS reg1, reg2, reg3, 19H   \n| reg1, reg2, reg3 VCMPTRUE_USSS reg1,           |                        | VCMPSS reg1, reg2, reg3, 1AH VCMPSS      \n| reg2, reg3                                     |                        | reg1, reg2, reg3, 1BH VCMPSS reg1, reg2, \n|                                                |                        | reg3, 1CH VCMPSS reg1, reg2, reg3, 1DH   \n|                                                |                        | VCMPSS reg1, reg2, reg3, 1EH VCMPSS      \n|                                                |                        | reg1, reg2, reg3, 1FH                    \nOperation:\n\nCASE (COMPARISON PREDICATE) OF\n  0: OP3 <- EQ_OQ; OP5 <- EQ_OQ;\n  1: OP3 <- LT_OS; OP5 <- LT_OS;\n  2: OP3 <- LE_OS; OP5 <- LE_OS;\n  3: OP3 <- UNORD_Q; OP5 <- UNORD_Q;\n  4: OP3 <- NEQ_UQ; OP5 <- NEQ_UQ;\n  5: OP3 <- NLT_US; OP5 <- NLT_US;\n  6: OP3 <- NLE_US; OP5 <- NLE_US;\n  7: OP3 <- ORD_Q; OP5 <- ORD_Q;\n  8: OP5 <- EQ_UQ;\n  9: OP5 <- NGE_US;\n  10: OP5 <- NGT_US;\n  11: OP5 <- FALSE_OQ;\n  12: OP5 <- NEQ_OQ;\n  13: OP5 <- GE_OS;\n  14: OP5 <- GT_OS;\n  15: OP5 <- TRUE_UQ;\n  16: OP5 <- EQ_OS;\n  17: OP5 <- LT_OQ;\n  18: OP5 <- LE_OQ;\n  19: OP5 <- UNORD_S;\n  20: OP5 <- NEQ_US;\n  21: OP5 <- NLT_UQ;\n  22: OP5 <- NLE_UQ;\n  23: OP5 <- ORD_S;\n  24: OP5 <- EQ_US;\n  25: OP5 <- NGE_UQ;\n  26: OP5 <- NGT_UQ;\n  27: OP5 <- FALSE_OS;\n  28: OP5 <- NEQ_OS;\n  29: OP5 <- GE_OQ;\n  30: OP5 <- GT_OQ;\n  31: OP5 <- TRUE_US;\n  DEFAULT: Reserved\nESAC;\nCMPSS (128-bit Legacy SSE version)\nCMP0 <- DEST[31:0] OP3 SRC[31:0];\nIF CMP0 = TRUE\nTHEN DEST[31:0] <- FFFFFFFFH;\nELSE DEST[31:0] <- 00000000H; FI;\nDEST[VLMAX-1:32] (Unmodified)\nVCMPSS (VEX.128 encoded version)\nCMP0 <- SRC1[31:0] OP5 SRC2[31:0];\nIF CMP0 = TRUE\nTHEN DEST[31:0] <- FFFFFFFFH;\nELSE DEST[31:0] <- 00000000H; FI;\nDEST[127:32] <- SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| CMPSS for equality:                                   | __m128 _mm_cmpeq_ss(__m128 a, __m128   \n|                                                       | b)                                     \n| CMPSS for less-than:                                  | __m128 _mm_cmplt_ss(__m128 a, __m128   \n|                                                       | b)                                     \n| CMPSS for less-than-or-equal:                         | __m128 _mm_cmple_ss(__m128 a, __m128   \n|                                                       | b)                                     \n| CMPSS for greater-than:                               | __m128 _mm_cmpgt_ss(__m128 a, __m128   \n|                                                       | b)                                     \n| CMPSS for greater-than-or-equal:                      | __m128 _mm_cmpge_ss(__m128 a, __m128   \n|                                                       | b)                                     \n| CMPSS for inequality:                                 | __m128 _mm_cmpneq_ss(__m128 a, __m128  \n|                                                       | b)                                     \n| CMPSS for not-less-than:                              | __m128 _mm_cmpnlt_ss(__m128 a, __m128  \n|                                                       | b)                                     \n| CMPSS for not-greater-than: CMPSS for                 | __m128 _mm_cmpngt_ss(__m128 a, __m128  \n| not-greater-than-or-equal: __m128 _mm_cmpnge_ss(__m128| b)                                     \n| a, __m128 b)                                          |                                        \n| CMPSS for ordered:                                    | __m128 _mm_cmpord_ss(__m128 a, __m128  \n|                                                       | b)                                     \n| CMPSS for unordered:                                  | __m128 _mm_cmpunord_ss(__m128 a, __m128\n|                                                       | b)                                     \n| CMPSS for not-less-than-or-equal:                     | __m128 _mm_cmpnle_ss(__m128 a, __m128  \n|                                                       | b)                                     \n| VCMPSS:                                               | __m128 _mm_cmp_ss(__m128 a, __m128 b,  \n|                                                       | const int imm)                         \n\nSIMD Floating-Point Exceptions:\nInvalid if SNaN operand, Invalid if QNaN and predicate as listed in above table,\nDenormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "CMPSS"
    }, 
    {
      "description": "-R:CMPS", 
      "mnem": "CMPSW"
    }, 
    {
      "description": "\nCMPXCHG - Compare and Exchange:\n| Opcode/Instruction                | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                            \n| 0F B0/r CMPXCHG r/m8, r8          | MR   | Valid      | Valid*         | Compare AL with r/m8. If equal, ZF is  \n|                                   |      |            |                | set and r8 is loaded into r/m8. Else,  \n|                                   |      |            |                | clear ZF and load r/m8 into AL.        \n| REX + 0F B0/r CMPXCHG r/m8**,r8   | MR   | Valid      | N.E.           | Compare AL with r/m8. If equal, ZF is  \n|                                   |      |            |                | set and r8 is loaded into r/m8. Else,  \n|                                   |      |            |                | clear ZF and load r/m8 into AL.        \n| 0F B1/r CMPXCHG r/m16, r16        | MR   | Valid      | Valid*         | Compare AX with r/m16. If equal, ZF    \n|                                   |      |            |                | is set and r16 is loaded into r/m16.   \n|                                   |      |            |                | Else, clear ZF and load r/m16 into AX. \n| 0F B1/r CMPXCHG r/m32, r32        | MR   | Valid      | Valid*         | Compare EAX with r/m32. If equal, ZF   \n|                                   |      |            |                | is set and r32 is loaded into r/m32.   \n|                                   |      |            |                | Else, clear ZF and load r/m32 into EAX.\n| REX.W + 0F B1/r CMPXCHG r/m64, r64| MR   | Valid      | N.E.           | Compare RAX with r/m64. If equal, ZF   \n|                                   |      |            |                | is set and r64 is loaded into r/m64.   \n|                                   |      |            |                | Else, clear ZF and load r/m64 into RAX.\nNotes: * See the IA-32 Architecture Compatibility section below. ** In 64-bit\nmode, r/m8 can not be encoded to access the following byte registers if a REX\nprefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (r, w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nCompares the value in the AL, AX, EAX, or RAX register with the first operand\n(destination operand). If the two values are equal, the second operand (source\noperand) is loaded into the destination operand. Otherwise, the destination\noperand is loaded into the AL, AX, EAX or RAX register. RAX register is available\nonly in 64-bit mode.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically. To simplify the interface to the processor's bus, the\ndestination operand receives a write cycle without regard to the result of the\ncomparison. The destination operand is written back if the comparison fails;\notherwise, the source operand is written into the destination. (The processor\nnever produces a locked read without also producing a locked write.)\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.R prefix permits access to additional registers (R8-R15). Use of the\nREX.W prefix promotes operation to 64 bits. See the summary chart at the beginning\nof this section for encoding data and limits.\n\n\nIA-32 Architecture Compatibility:\nThis instruction is not supported on Intel processors earlier than the Intel486\nprocessors.\n\nOperation:\n\n(* Accumulator = AL, AX, EAX, or RAX depending on whether a byte, word, doubleword, or quadword comparison is being performed *)\nTEMP <- DEST\nIF accumulator = TEMP\n  THEN\n     ZF <- 1;\n     DEST <- SRC;\n  ELSE\n     ZF <- 0;\n     accumulator <- TEMP;\n     DEST <- TEMP;\nFI;\n\nFlags Affected:\nThe ZF flag is set if the values in the destination operand and register AL,\nAX, or EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags\nare set according to the results of the comparison operation.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register contains a NULL segment     \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used but the destination \n|                | is not a memory operand.                       \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "CMPXCHG"
    }, 
    {
      "description": "-R:CMPXCHG8B", 
      "mnem": "CMPXCHG16B"
    }, 
    {
      "description": "\nCMPXCHG8B/CMPXCHG16B - Compare and Exchange Bytes:\n| Opcode/Instruction                   | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                             \n| 0F C7 /1 m64 CMPXCHG8B m64           | M    | Valid      | Valid*         | Compare EDX:EAX with m64. If equal,     \n|                                      |      |            |                | set ZF and load ECX:EBX into m64. Else, \n|                                      |      |            |                | clear ZF and load m64 into EDX:EAX.     \n| REX.W + 0F C7 /1 m128 CMPXCHG16B m128| M    | Valid      | N.E.           | Compare RDX:RAX with m128. If equal,    \n|                                      |      |            |                | set ZF and load RCX:RBX into m128. Else,\n|                                      |      |            |                | clear ZF and load m128 into RDX:RAX.    \nNotes: *See IA-32 Architecture Compatibility section below.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r, w)| NA       | NA       | NA       \n\nDescription:\nCompares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand\nsize is 128 bits) with the operand (destination operand). If the values are\nequal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored in\nthe destination operand. Otherwise, the value in the destination operand is\nloaded into EDX:EAX (or RDX:RAX). The destination operand is an 8-byte memory\nlocation (or 16-byte memory location if operand size is 128 bits). For the EDX:EAX\nand ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX\nand EBX contain the low-order 32 bits of a 64-bit value. For the RDX:RAX and\nRCX:RBX register pairs, RDX and RCX contain the highorder 64 bits and RAX and\nRBX contain the low-order 64bits of a 128-bit value.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically. To simplify the interface to the processor's bus, the\ndestination operand receives a write cycle without regard to the result of the\ncomparison. The destination operand is written back if the comparison fails;\notherwise, the source operand is written into the destination. (The processor\nnever produces a locked read without also producing a locked write.)\n\nIn 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes\noperation to 128 bits. Note that CMPXCHG16B requires that the destination (memory)\noperand be 16-byte aligned. See the summary chart at the beginning of this section\nfor encoding data and limits. For information on the CPUID flag that indicates\nCMPXCHG16B, see page 3-170.\n\n\nIA-32 Architecture Compatibility:\nThis instruction encoding is not supported on Intel processors earlier than\nthe Pentium processors.\n\nOperation:\n\nIF (64-Bit Mode and OperandSize = 64)\n  THEN\n     TEMP128 <- DEST\n     IF (RDX:RAX = TEMP128)\n       THEN\n          ZF <- 1;\n          DEST <- RCX:RBX;\n       ELSE\n          ZF <- 0;\n          RDX:RAX <- TEMP128;\n          DEST <- TEMP128;\n          FI;\n     FI\n  ELSE\n     TEMP64 <- DEST;\n     IF (EDX:EAX = TEMP64)\n       THEN\n          ZF <- 1;\n          DEST <- ECX:EBX;\n       ELSE\n          ZF <- 0;\n          EDX:EAX <- TEMP64;\n          DEST <- TEMP64;\n          FI;\n     FI;\nFI;\n\nFlags Affected:\nThe ZF flag is set if the destination operand and EDX:EAX are equal; otherwise\nit is cleared. The CF, PF, AF, SF, and OF flags are unaffected.\n\n\nProtected Mode Exceptions:\n| #UD            | If the destination is not a memory operand.    \n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register contains a NULL segment     \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n\nReal-Address Mode Exceptions:\n| #UD| If the destination operand is not a  \n|    | memory location.                     \n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n\nVirtual-8086 Mode Exceptions:\n| #UD            | If the destination operand is not a   \n|                | memory location.                      \n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form. If memory operand for CMPXCHG16B     \n|                | is not aligned on a 16-byte boundary.      \n|                | If CPUID.01H:ECX.CMPXCHG16B[bit 13]        \n|                | = 0.                                       \n| #UD            | If the destination operand is not a        \n|                | memory location.                           \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n", 
      "mnem": "CMPXCHG8B"
    }, 
    {
      "description": "\nCOMISD - Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS:\n| Opcode/Instruction                   | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| 66 0F 2F /r COMISD xmm1, xmm2/m64    | RM   | V/V           | SSE2              | Compare low double-precision floating-point\n|                                      |      |               |                   | values in xmm1 and xmm2/mem64 and set      \n|                                      |      |               |                   | the EFLAGS flags accordingly.              \n| VEX.LIG.66.0F.WIG 2F /r VCOMISD xmm1,| RM   | V/V           | AVX               | Compare low double precision floating-point\n| xmm2/m64                             |      |               |                   | values in xmm1 and xmm2/mem64 and set      \n|                                      |      |               |                   | the EFLAGS flags accordingly.              \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nCompares the double-precision floating-point values in the low quadwords of\noperand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF,\nand CF flags in the EFLAGS register according to the result (unordered, greater\nthan, less than, or equal). The OF, SF and AF flags in the EFLAGS register are\nset to 0. The unordered result is returned if either source operand is a NaN\n(QNaN or SNaN).The sign of zero is ignored for comparisons, so that -0.0 is\nequal to +0.0.\n\nOperand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory\nlocation.\n\nThe COMISD instruction differs from the UCOMISD instruction in that it signals\na SIMD floating-point invalid operation exception (#I) when a source operand\nis either a QNaN or SNaN. The UCOMISD instruction signals an invalid numeric\nexception only if a source operand is an SNaN.\n\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception\nis generated.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). Note: In VEX-encoded versions, VEX.vvvv is reserved\nand must be 1111b, otherwise instructions will #UD.\n\nOperation:\n\nRESULT <- OrderedCompare(DEST[63:0] <> SRC[63:0]) {\n(* Set EFLAGS *) CASE (RESULT) OF\n  UNORDERED:\n  GREATER_THAN:\n  LESS_THAN:\n  EQUAL:\nESAC;\nOF, AF, SF <- 0; }\n\nIntel C/C++ Compiler Intrinsic Equivalents:\nint _mm_comieq_sd (__m128d a, __m128d b) int _mm_comilt_sd (__m128d a, __m128d\nb) int _mm_comile_sd (__m128d a, __m128d b) int _mm_comigt_sd (__m128d a, __m128d\nb) int _mm_comige_sd (__m128d a, __m128d b) int _mm_comineq_sd (__m128d a, __m128d\nb)\n\n\nSIMD Floating-Point Exceptions:\nInvalid (if SNaN or QNaN operands), Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "COMISD"
    }, 
    {
      "description": "\nCOMISS - Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS:\n| Opcode/Instruction                         | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| 0F 2F /r COMISS xmm1, xmm2/m32             | RM   | V/V           | SSE               | Compare low single-precision floating-point\n|                                            |      |               |                   | values in xmm1 and xmm2/mem32 and set      \n|                                            |      |               |                   | the EFLAGS flags accordingly.              \n| VEX.LIG.0F.WIG 2F /r VCOMISS xmm1, xmm2/m32| RM   | V/V           | AVX               | Compare low single precision floating-point\n|                                            |      |               |                   | values in xmm1 and xmm2/mem32 and set      \n|                                            |      |               |                   | the EFLAGS flags accordingly.              \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nCompares the single-precision floating-point values in the low doublewords of\noperand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF,\nand CF flags in the EFLAGS register according to the result (unordered, greater\nthan, less than, or equal). The OF, SF, and AF flags in the EFLAGS register\nare set to 0. The unordered result is returned if either source operand is a\nNaN (QNaN or SNaN). The sign of zero is ignored for comparisons, so that -0.0\nis equal to +0.0.\n\nOperand 1 is an XMM register; Operand 2 can be an XMM register or a 32 bit memory\nlocation.\n\nThe COMISS instruction differs from the UCOMISS instruction in that it signals\na SIMD floating-point invalid operation exception (#I) when a source operand\nis either a QNaN or SNaN. The UCOMISS instruction signals an invalid numeric\nexception only if a source operand is an SNaN.\n\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception\nis generated.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). Note: In VEX-encoded versions, VEX.vvvv is reserved\nand must be 1111b, otherwise instructions will #UD.\n\nOperation:\n\nRESULT <- OrderedCompare(SRC1[31:0] <> SRC2[31:0]) {\n(* Set EFLAGS *) CASE (RESULT) OF\n  UNORDERED:\n  GREATER_THAN:\n  LESS_THAN:\n  EQUAL:\nESAC;\nOF,AF,SF <- 0; }\n\nIntel C/C++ Compiler Intrinsic Equivalents:\nint _mm_comieq_ss (__m128 a, __m128 b) int _mm_comilt_ss (__m128 a, __m128 b)\nint _mm_comile_ss (__m128 a, __m128 b) int _mm_comigt_ss (__m128 a, __m128 b)\nint _mm_comige_ss (__m128 a, __m128 b) int _mm_comineq_ss (__m128 a, __m128\nb)\n\n\nSIMD Floating-Point Exceptions:\nInvalid (if SNaN or QNaN operands), Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "COMISS"
    }, 
    {
      "description": "\nCPUID - CPU Identification:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                            \n| 0F A2 | CPUID      | NP   | Valid      | Valid          | Returns processor identification and   \n|       |            |      |            |                | feature information to the EAX, EBX,   \n|       |            |      |            |                | ECX, and EDX registers, as determined  \n|       |            |      |            |                | by input entered in EAX (in some cases,\n|       |            |      |            |                | ECX as well).                          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nThe ID flag (bit 21) in the EFLAGS register indicates support for the CPUID\ninstruction. If a software procedure can set and clear this flag, the processor\nexecuting the procedure supports the CPUID instruction. This instruction operates\nthe same in non-64-bit modes and 64-bit mode. CPUID returns processor identification\nand feature information in the EAX, EBX, ECX, and EDX registers.1 The instruction's\noutput is dependent on the contents of the EAX register upon execution (in some\ncases, ECX as well). For example, the following pseudocode loads EAX with 00H\nand causes CPUID to return a Maximum Return Value and the Vendor Identification\nString in the appropriate registers:\n\nMOV EAX, 00H CPUID\n\nTable 3-17 shows information returned, depending on the initial value loaded\ninto the EAX register. Table 3-18 shows the maximum CPUID input value recognized\nfor each family of IA-32 processors on which CPUID is implemented.\n\nTwo types of information are returned: basic and extended function information.\nIf a value entered for CPUID.EAX is higher than the maximum input value for\nbasic or extended function for that processor then the data for the highest\nbasic information leaf is returned. For example, using the Intel Core i7 processor,\nthe following is true: CPUID.EAX = 05H (* Returns MONITOR/MWAIT leaf. *) CPUID.EAX\n= 0AH (* Returns Architectural Performance Monitoring leaf. *) CPUID.EAX = 0BH\n(* Returns Extended Topology Enumeration leaf. *) CPUID.EAX = 0CH (* INVALID:\nReturns the same information as CPUID.EAX = 0BH. *) CPUID.EAX = 80000008H (*\nReturns linear/physical address size data. *) CPUID.EAX = 8000000AH (* INVALID:\nReturns same information as CPUID.EAX = 0BH. *)\n\nIf a value entered for CPUID.EAX is less than or equal to the maximum input\nvalue and the leaf is not supported on that processor then 0 is returned in\nall the registers. For example, using the Intel Core i7 processor, the following\nis true: CPUID.EAX = 07H (*Returns EAX=EBX=ECX=EDX=0. *)\n\nWhen CPUID returns the highest basic leaf information as a result of an invalid\ninput EAX value, any dependence on input ECX value in the basic leaf is honored.\n\nCPUID can be executed at any privilege level to serialize instruction execution.\nSerializing instruction execution guarantees that any modifications to flags,\nregisters, and memory for previous instructions are completed before the next\ninstruction is fetched and executed.\n\nSee also:\n\n\u201cSerializing Instructions\u201d in Chapter 8, \u201cMultiple-Processor Management,\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 3A.\n\n| 1.| On Intel 64 processors, CPUID clears   \n|   | the high 32 bits of the RAX/RBX/RCX/RDX\n|   | registers in all modes.                \n\u201cCaching Translation Information\u201d in Chapter 4, \u201cPaging,\u201d in the Intel\u00ae 64 and\nIA-32 Architectures Software Developer's Manual, Volume 3A.\n\n\nTable 3-17. Information Returned by CPUID Instruction:\nInitial EAX\n\n| Value Basic CPUID Information Maximum     | Information Provided about the Processor\n| Input Value for Basic CPUID Information   |                                         \n| (see Table 3-18) \u201cGenu\u201d\u201cntel\u201d\u201cineI\u201dVersion|                                         \n| Information: Type, Family, Model, and     |                                         \n| Stepping ID (see Figure 3-5) Bits 07-00:  |                                         \n| Brand Index Bits 15-08: CLFLUSH line      |                                         \n| size (Value * 8 = cache line size in      |                                         \n| bytes) Bits 23-16: Maximum number of      |                                         \n| addressable IDs for logical processors    |                                         \n| in this physical package*. Bits 31-24:    |                                         \n| Initial APIC ID Feature Information       |                                         \n| (see Figure 3-6 and Table 3-20) Feature   |                                         \n| Information (see Figure 3-7 and Table     |                                         \n| 3-21)                                     |                                         \nNotes: * The nearest power-of-2 integer that is not smaller than EBX[23:16]\nis the number of unique initial APIC IDs reserved for addressing different logical\nprocessors in a physical package. This field is only valid if CPUID.1.EDX.HTT[bit\n28]= 1.\n\n| 02H| EAX EBX ECX EDX| Cache and TLB Information (see Table         \n|    |                | 3-22) Cache and TLB Information Cache        \n|    |                | and TLB Information Cache and TLB Information\n| 03H| EAX EBX ECX EDX| Reserved. Reserved. Bits 00-31 of 96         \n|    |                | bit processor serial number. (Available      \n|    |                | in Pentium III processor only; otherwise,    \n|    |                | the value in this register is reserved.)     \n|    |                | Bits 32-63 of 96 bit processor serial        \n|    |                | number. (Available in Pentium III processor  \n|    |                | only; otherwise, the value in this register  \n|    |                | is reserved.)                                \nNotes: Processor serial number (PSN) is not supported in the Pentium 4 processor\nor later. On all models, use the PSN flag (returned using CPUID) to check for\nPSN support before accessing the feature.\n\nSee AP-485, Intel Processor Identification and the CPUID Instruction (Order\nNumber 241618) for more information on PSN.\n\nCPUID leaves > 3 < 80000000 are visible only when IA32_MISC_ENABLE.BOOT_NT4[bit\n22] = 0 (default).\n\nDeterministic Cache Parameters Leaf\n\n| 04H| NOTES: Leaf 04H output depends on the       \n|    | initial value in ECX.*See also: \u201cINPUT      \n|    | EAX = 4: Returns Deterministic Cache        \n|    | Parameters for each level on page 3-178.    \n| EAX| Bits 04-00: Cache Type Field 0 = Null       \n|    | - No more caches 1 = Data Cache 2 =         \n|    | Instruction Cache 3 = Unified Cache         \n|    | 4-31 = Reserved Information Returned        \n|    | by CPUID Instruction (Contd.) Initial       \n|    | EAX Information Provided about the Processor\n|    | Bits 07-05: Cache Level (starts at 1)       \n|    | Bit 08: Self Initializing cache level       \n|    | (does not need SW initialization) Bit       \n|    | 09: Fully Associative cache Bits 13-10:     \n|    | Reserved Bits 25-14: Maximum number         \n|    | of addressable IDs for logical processors   \n|    | sharing this cache**, ***Bits 31-26:        \n|    | Maximum number of addressable IDs for       \n|    | processor cores in the physical package**,  \n|    | ****, *****                                 \n| EBX| Bits 11-00: L = System Coherency Line       \n|    | Size**Bits 21-12: P = Physical Line         \n|    | partitions**Bits 31-22: W = Ways of         \n|    | associativity**                             \n| ECX| Bits 31-00: S = Number of Sets**            \n| EDX| Bit 0: Write-Back Invalidate/Invalidate     \n|    | 0 = WBINVD/INVD from threads sharing        \n|    | this cache acts upon lower level caches     \n|    | for threads sharing this cache. 1 =         \n|    | WBINVD/INVD is not guaranteed to act        \n|    | upon lower level caches of non-originating  \n|    | threads sharing this cache. Bit 1: Cache    \n|    | Inclusiveness 0 = Cache is not inclusive    \n|    | of lower cache levels. 1 = Cache is         \n|    | inclusive of lower cache levels. Bit        \n|    | 2: Complex Cache Indexing 0 = Direct        \n|    | mapped cache. 1 = A complex function        \n|    | is used to index the cache, potentially     \n|    | using all address bits. Bits 31-03:         \n|    | Reserved = 0                                \nNotes: * If ECX contains an invalid sub leaf index, EAX/EBX/ECX/EDX return 0.\nInvalid sub-leaves of EAX = 04H: ECX = n, n > 3. ** Add one to the return value\nto get the result. ***The nearest power-of-2 integer that is not smaller than\n(1 + EAX[25:14]) is the number of unique initial APIC IDs reserved for addressing\ndifferent logical processors sharing this cache **** The nearest power-of-2\ninteger that is not smaller than (1 + EAX[31:26]) is the number of unique Core_IDs\nreserved for addressing different processor cores in a physical package. Core\nID is a subset of bits of the initial APIC ID. ***** The returned value is constant\nfor valid initial values in ECX. Valid ECX values start from 0.\n\nMONITOR/MWAIT Leaf\n\n| 05H| EAX EBX ECX EDX| Bits 15-00: Smallest monitor-line size      \n|    |                | in bytes (default is processor's monitor    \n|    |                | granularity) Bits 31-16: Reserved =         \n|    |                | 0 Bits 15-00: Largest monitor-line size     \n|    |                | in bytes (default is processor's monitor    \n|    |                | granularity) Bits 31-16: Reserved =         \n|    |                | 0 Bit 00: Enumeration of Monitor-Mwait      \n|    |                | extensions (beyond EAX and EBX registers)   \n|    |                | supported Bit 01: Supports treating         \n|    |                | interrupts as break-event for MWAIT,        \n|    |                | even when interrupts disabled Bits 31       \n|    |                | - 02: Reserved Information Returned         \n|    |                | by CPUID Instruction (Contd.) Initial       \n|    |                | EAX Information Provided about the Processor\n|    |                | Bits 03 - 00: Number of C0* sub C-states    \n|    |                | supported using MWAIT Bits 07 - 04:         \n|    |                | Number of C1* sub C-states supported        \n|    |                | using MWAIT Bits 11 - 08: Number of         \n|    |                | C2* sub C-states supported using MWAIT      \n|    |                | Bits 15 - 12: Number of C3* sub C-states    \n|    |                | supported using MWAIT Bits 19 - 16:         \n|    |                | Number of C4* sub C-states supported        \n|    |                | using MWAIT Bits 23 - 20: Number of         \n|    |                | C5* sub C-states supported using MWAIT      \n|    |                | Bits 27 - 24: Number of C6* sub C-states    \n|    |                | supported using MWAIT Bits 31 - 28:         \n|    |                | Number of C7* sub C-states supported        \n|    |                | using MWAIT                                 \n\nNOTE::\n| *                                                             | The definition of C0 through C7 states    \n|                                                               | for MWAIT extension are processor-specific\n|                                                               | C-states, not ACPI Cstates. Thermal       \n|                                                               | and Power Management Leaf                 \n| Bit 00: Digital temperature sensor is                         | EAX EBX                                   \n| supported if set Bit 01: Intel Turbo                          |                                           \n| Boost Technology Available (see description                   |                                           \n| of IA32_MISC_ENABLE[38]). Bit 02: ARAT.                       |                                           \n| APIC-Timer-always-running feature is                          |                                           \n| supported if set. Bit 03: Reserved Bit                        |                                           \n| 04: PLN. Power limit notification controls                    |                                           \n| are supported if set. Bit 05: ECMD.                           |                                           \n| Clock modulation duty cycle extension                         |                                           \n| is supported if set. Bit 06: PTM. Package                     |                                           \n| thermal management is supported if set.                       |                                           \n| Bit 07: HWP. HWP base registers (IA32_PM_ENALBE[bit           |                                           \n| 0], IA32_HWP_CAPABILITIES, IA32_HWP_REQUEST,                  |                                           \n| IA32_HWP_STATUS) are supported if set.                        |                                           \n| Bit 08: HWP_Notification. IA32_HWP_INTERRUPT                  |                                           \n| MSR is supported if set. Bit 09: HWP_Activity_Window.         |                                           \n| IA32_HWP_REQUEST[bits 41:32] is supported                     |                                           \n| if set. Bit 10: HWP_Energy_Performance_Preference.            |                                           \n| IA32_HWP_REQUEST[bits 31:24] is supported                     |                                           \n| if set. Bit 11: HWP_Package_Level_Request.                    |                                           \n| IA32_HWP_REQUEST_PKG MSR is supported                         |                                           \n| if set. Bit 12: Reserved. Bit 13: HDC.                        |                                           \n| HDC base registers IA32_PKG_HDC_CTL,                          |                                           \n| IA32_PM_CTL1, IA32_THREAD_STALL MSRs                          |                                           \n| are supported if set. Bits 31 - 15:                           |                                           \n| Reserved Bits 03 - 00: Number of Interrupt                    |                                           \n| Thresholds in Digital Thermal Sensor                          |                                           \n| Bits 31 - 04: Reserved                                        |                                           \n| Bit 00: Hardware Coordination Feedback                        | ECX                                       \n| Capability (Presence of IA32_MPERF and                        |                                           \n| IA32_APERF). The capability to provide                        |                                           \n| a measure of delivered processor performance                  |                                           \n| (since last reset of the counters),                           |                                           \n| as a percentage of expected processor                         |                                           \n| performance at frequency specified in                         |                                           \n| CPUID Brand String Bits 02 - 01: Reserved                     |                                           \n| = 0 Bit 03: The processor supports performance-energy         |                                           \n| bias preference if CPUID.06H:ECX.SETBH[bit                    |                                           \n| 3] is set and it also implies the presence                    |                                           \n| of a new architectural MSR called IA32_ENERGY_PERF_BIAS       |                                           \n| (1B0H) Bits 31 - 04: Reserved = 0                             |                                           \n| Reserved = 0                                                  | EDX Structured Extended Feature Flags     \n|                                                               | Enumeration Leaf (Output depends on       \n|                                                               | ECX input value) Sub-leaf 0 (Input ECX    \n|                                                               | = 0). *                                   \n| Bits 31-00: Reports the maximum input                         | EAX                                       \n| value for supported leaf 7 sub-leaves.                        |                                           \n| Table 3-17.                                                   | Information Returned by CPUID Instruction \n|                                                               | (Contd.) Initial EAX Information Provided \n|                                                               | about the Processor                       \n| Bit 00: FSGSBASE. Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE| EBX                                       \n| if 1. Bit 01: IA32_TSC_ADJUST MSR is                          |                                           \n| supported if 1. Bit 02: Reserved Bit                          |                                           \n| 03: BMI1 Bit 04: HLE Bit 05: AVX2 Bit                         |                                           \n| 06: Reserved Bit 07: SMEP. Supports                           |                                           \n| Supervisor-Mode Execution Prevention                          |                                           \n| if 1. Bit 08: BMI2 Bit 09: Supports                           |                                           \n| Enhanced REP MOVSB/STOSB if 1. Bit 10:                        |                                           \n| INVPCID. If 1, supports INVPCID instruction                   |                                           \n| for system software that manages process-context              |                                           \n| identifiers. Bit 11: RTM Bit 12: Supports                     |                                           \n| Platform Quality of Service Monitoring                        |                                           \n| (PQM) capability if 1. Bit 13: Deprecates                     |                                           \n| FPU CS and FPU DS values if 1. Bit 14:                        |                                           \n| Reserved. Bit 15: Supports Platform                           |                                           \n| Quality of Service Enforcement (PQE)                          |                                           \n| capability if 1. Bits 31:16: Reserved                         |                                           \n| Reserved                                                      | ECX                                       \n| Reserved                                                      | EDX                                       \n\nNOTE::\n* If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Invalid\nsub-leaves of EAX = 07H: ECX = n, n > 0.\n\nDirect Cache Access Information Leaf\n\n| 09H    | EAX EBX ECX EDX Architectural Performance    | Value of bits [31:0] of IA32_PLATFORM_DCA_CAP\n|        | Monitoring Leaf                              | MSR (address 1F8H) Reserved Reserved         \n|        |                                              | Reserved                                     \n| 0AH 0BH| EAX EBX ECX EDX Extended Topology Enumeration| Bits 07 - 00: Version ID of architectural    \n|        | Leaf EAX EBX ECX EDX                         | performance monitoring Bits 15- 08:          \n|        |                                              | Number of general-purpose performance        \n|        |                                              | monitoring counter per logical processor     \n|        |                                              | Bits 23 - 16: Bit width of general-purpose,  \n|        |                                              | performance monitoring counter Bits          \n|        |                                              | 31 - 24: Length of EBX bit vector to         \n|        |                                              | enumerate architectural performance          \n|        |                                              | monitoring events Bit 00: Core cycle         \n|        |                                              | event not available if 1 Bit 01: Instruction \n|        |                                              | retired event not available if 1 Bit         \n|        |                                              | 02: Reference cycles event not available     \n|        |                                              | if 1 Bit 03: Last-level cache reference      \n|        |                                              | event not available if 1 Bit 04: Last-level  \n|        |                                              | cache misses event not available if          \n|        |                                              | 1 Bit 05: Branch instruction retired         \n|        |                                              | event not available if 1 Bit 06: Branch      \n|        |                                              | mispredict retired event not available       \n|        |                                              | if 1 Bits 31- 07: Reserved = 0 Reserved      \n|        |                                              | = 0 Bits 04 - 00: Number of fixed-function   \n|        |                                              | performance counters (if Version ID          \n|        |                                              | > 1) Bits 12- 05: Bit width of fixed-function\n|        |                                              | performance counters (if Version ID          \n|        |                                              | > 1) Reserved = 0 Information Returned       \n|        |                                              | by CPUID Instruction (Contd.) Initial        \n|        |                                              | EAX Information Provided about the Processor \n|        |                                              | NOTES: Most of Leaf 0BH output depends       \n|        |                                              | on the initial value in ECX. The EDX         \n|        |                                              | output of leaf 0BH is always valid and       \n|        |                                              | does not vary with input value in ECX.       \n|        |                                              | Output value in ECX[7:0] always equals       \n|        |                                              | input value in ECX[7:0]. For sub-leaves      \n|        |                                              | that return an invalid level-type of         \n|        |                                              | 0 in ECX[15:8]; EAX and EBX will return      \n|        |                                              | 0. If an input value n in ECX returns        \n|        |                                              | the invalid level-type of 0 in ECX[15:8],    \n|        |                                              | other input values with ECX >n also          \n|        |                                              | return 0 in ECX[15:8]. Bits 04-00: Number    \n|        |                                              | of bits to shift right on x2APIC ID          \n|        |                                              | to get a unique topology ID of the next      \n|        |                                              | level type*. All logical processors          \n|        |                                              | with the same next level ID share current    \n|        |                                              | level. Bits 31-05: Reserved. Bits 15         \n|        |                                              | - 00: Number of logical processors at        \n|        |                                              | this level type. The number reflects         \n|        |                                              | configuration as shipped by Intel**.         \n|        |                                              | Bits 31- 16: Reserved. Bits 07 - 00:         \n|        |                                              | Level number. Same value in ECX input        \n|        |                                              | Bits 15 - 08: Level type***. Bits 31         \n|        |                                              | - 16:: Reserved. Bits 31- 00: x2APIC         \n|        |                                              | ID the current logical processor.            \nNotes: * Software should use this field (EAX[4:0]) to enumerate processor topology\nof the system.\n\n** Software must not use EBX[15:0] to enumerate processor topology of the system.\nThis value in this field (EBX[15:0]) is only intended for display/diagnostic\npurposes. The actual number of logical processors available to BIOS/OS/Applications\nmay be different from the value of EBX[15:0], depending on software and platform\nhardware configurations.\n\n*** The value of the \u201clevel type\u201d field is not related to level numbers in any\nway, higher \u201clevel type\u201d values do not mean higher levels. Level type field\nhas the following encoding: 0 : invalid 1 : SMT 2 : Core 3-255 : Reserved\n\nProcessor Extended State Enumeration Main Leaf (EAX = 0DH, ECX = 0)\n\n| 0DH                                     | NOTES: Leaf 0DH main leaf (ECX = 0).               \n| EAX                                     | Bits 31-00: Reports the valid bit fields           \n|                                         | of the lower 32 bits of XCR0. If a bit             \n|                                         | is 0, the corresponding bit field in               \n|                                         | XCR0 is reserved. Bit 00: legacy x87               \n|                                         | Bit 01: 128-bit SSE Bit 02: 256-bit                \n|                                         | AVX Bits 31- 03: Reserved                          \n| EBX                                     | Bits 31-00: Maximum size (bytes, from              \n|                                         | the beginning of the XSAVE/XRSTOR save             \n|                                         | area) required by enabled features in              \n|                                         | XCR0. May be different than ECX if some            \n|                                         | features at the end of the XSAVE save              \n|                                         | area are not enabled.                              \n| ECX                                     | Bit 31-00: Maximum size (bytes, from               \n|                                         | the beginning of the XSAVE/XRSTOR save             \n|                                         | area) of the XSAVE/XRSTOR save area                \n|                                         | required by all supported features in              \n|                                         | the processor, i.e all the valid bit               \n|                                         | fields in XCR0.                                    \n| EDX Processor Extended State Enumeration| Bit 31-00: Reports the valid bit fields            \n| Sub-leaf (EAX = 0DH, ECX = 1)           | of the upper 32 bits of XCR0. If a bit             \n|                                         | is 0, the corresponding bit field in               \n|                                         | XCR0 is reserved. Information Returned             \n|                                         | by CPUID Instruction (Contd.) Initial              \n|                                         | EAX Information Provided about the Processor       \n| EAX                                     | Bits 31-04: Reserved Bit 00: XSAVEOPT              \n|                                         | is available Bit 01: Supports XSAVEC               \n|                                         | and the compacted form of XRSTOR if                \n|                                         | set Bit 02: Supports XGETBV with ECX               \n|                                         | = 1 if set Bit 03: Supports XSAVES/XRSTORS         \n|                                         | and IA32_XSS if set                                \n| EBX                                     | Bits 31-00: The size in bytes of the               \n|                                         | XSAVE area containing all states enabled           \n|                                         | by XCRO | IA32_XSS.                                \n| ECX                                     | Bits 31-00: Reports the valid bit fields           \n|                                         | of the lower 32 bits of IA32_XSS. If               \n|                                         | a bit is 0, the corresponding bit field            \n|                                         | in IA32_XSS is reserved. Bits 07-00:               \n|                                         | Reserved Bit 08: IA32_XSS[bit 8] is                \n|                                         | supported if 1 Bits 31-09: Reserved                \n| EDX Processor Extended State Enumeration| Bits 31-00: Reports the valid bit fields           \n| Sub-leaves (EAX = 0DH, ECX = n, n >     | of the upper 32 bits of IA32_XSS. If               \n| 1)                                      | a bit is 0, the corresponding bit field            \n|                                         | in IA32_XSS is reserved. Bits 31-00:               \n|                                         | Reserved                                           \n| 0DH                                     | NOTES: Leaf 0DH output depends on the              \n|                                         | initial value in ECX. Each valid sub-leaf          \n|                                         | index maps to a valid bit in either                \n|                                         | the XCR0 register or the IA32_XSS MSR              \n|                                         | starting at bit position 2. * If ECX               \n|                                         | contains an invalid sub-leaf index,                \n|                                         | EAX/EBX/ECX/EDX return 0. Invalid sub-leaves       \n|                                         | of EAX = 0DH: ECX = n, n > 2.                      \n| EAX                                     | Bits 31-0: The size in bytes (from the             \n|                                         | offset specified in EBX) of the save               \n|                                         | area for an extended state feature associated      \n|                                         | with a valid sub-leaf index, n. This               \n|                                         | field reports 0 if the sub-leaf index,             \n|                                         | n, does not map to a valid bit in the              \n|                                         | XCR0 register*.                                    \n| EBX                                     | Bits 31-0: The offset in bytes of this             \n|                                         | extended state component's save area               \n|                                         | from the beginning of the XSAVE/XRSTOR             \n|                                         | area. This field reports 0 if the sub-leaf         \n|                                         | index, n, is invalid*.                             \n| ECX                                     | This field reports 0 if the sub-leaf               \n|                                         | index, n, is invalid*; otherwise, bit              \n|                                         | 0 is set if the sub-leaf index, n, maps            \n|                                         | to a valid bit in the IA32_XSS MSR,                \n|                                         | and bits 31-1 are reserved.                        \n| EDX Platform QoS Monitoring Enumeration | This field reports 0 if the sub-leaf               \n| Sub-leaf (EAX = 0FH, ECX = 0)           | index, n, is invalid*; otherwise it                \n|                                         | is reserved.                                       \n| 0FH                                     | NOTES: Leaf 0FH output depends on the              \n|                                         | initial value in ECX. Sub-leaf index               \n|                                         | 0 reports valid resource type starting             \n|                                         | at bit position 1 of EDX                           \n| EAX                                     | Reserved.                                          \n| EBX                                     | Bits 31-0: Maximum range (zero-based)              \n|                                         | of RMID within this physical processor             \n|                                         | of all types.                                      \n| ECX                                     | Reserved.                                          \n| EDX L3 Cache QoS Monitoring Capability  | Bit 00: Reserved. Bit 01: Supports L3              \n| Enumeration Sub-leaf (EAX = 0FH, ECX    | Cache QoS Monitoring if 1. Bits 31:02:             \n| = 1)                                    | Reserved Information Returned by CPUID             \n|                                         | Instruction (Contd.) Initial EAX Information       \n|                                         | Provided about the Processor                       \n| 0FH                                     | NOTES: Leaf 0FH output depends on the              \n|                                         | initial value in ECX.                              \n| EAX                                     | Reserved.                                          \n| EBX                                     | Bits 31-0: Conversion factor from reported         \n|                                         | IA32_QM_CTR value to occupancy metric              \n|                                         | (bytes).                                           \n| ECX                                     | Maximum range (zero-based) of RMID of              \n|                                         | this resource type.                                \n| EDX Platform QoS Enforcement Enumeration| Bit 00: Supports L3 occupancy monitoring           \n| Sub-leaf (EAX = 10H, ECX = 0)           | if 1. Bits 31:01: Reserved                         \n| 10H                                     | NOTES: Leaf 10H output depends on the              \n|                                         | initial value in ECX. Sub-leaf index               \n|                                         | 0 reports valid resource identification            \n|                                         | (ResID) starting at bit position 1 of              \n|                                         | EDX                                                \n| EAX                                     | Reserved.                                          \n| EBX                                     | Bit 00: Reserved. Bit 01: Supports L3              \n|                                         | Cache QoS Enforcement if 1. Bits 31:02:            \n|                                         | Reserved                                           \n| ECX                                     | Reserved.                                          \n| EDX L3 Cache QoS Enforcement Enumeration| Reserved.                                          \n| Sub-leaf (EAX = 10H, ECX = ResID =1)    |                                                    \n| 10H                                     | NOTES: Leaf 10H output depends on the              \n|                                         | initial value in ECX.                              \n| EAX                                     | Bits 4:0: Length of the capacity bit               \n|                                         | mask for the corresponding ResID. Bits             \n|                                         | 31:05: Reserved                                    \n| EBX                                     | Bits 31-0: Bit-granular map of isolation/contention\n|                                         | of allocation units.                               \n| ECX                                     | Bit 00: Reserved. Bit 01: Updates of               \n|                                         | COS should be infrequent if 1. Bits                \n|                                         | 31:02: Reserved                                    \n| EDX Unimplemented CPUID Leaf Functions  | Bits 15:0: Highest COS number supported            \n| Extended Function CPUID Information     | for this ResID. Bits 31:16: Reserved               \n|                                         | Invalid. No existing or future CPU will            \n|                                         | return processor identification or feature         \n|                                         | information if the initial EAX value               \n|                                         | is in the range 40000000H to 4FFFFFFFH.            \n|                                         | 4FFFFFFFH                                          \n| EAX                                     | Maximum Input Value for Extended Function          \n|                                         | CPUID Information (see Table 3-18).                \n| EBX ECX EDX                             | Reserved Reserved Reserved Information             \n|                                         | Returned by CPUID Instruction (Contd.)             \n|                                         | Initial EAX Information Provided about             \n|                                         | the Processor                                      \n| EAX                                     | Extended Processor Signature and Feature           \n|                                         | Bits.                                              \n| EBX                                     | Reserved                                           \n| ECX                                     | Bit 00: LAHF/SAHF available in 64-bit              \n|                                         | mode Bits 04-01 Reserved Bit 05: LZCNT             \n|                                         | Bits 07-06 Reserved Bit 08: PREFETCHW              \n|                                         | Bits 31-09 Reserved                                \n| EDX                                     | Bits 10-00: Reserved Bit 11: SYSCALL/SYSRET        \n|                                         | available in 64-bit mode Bits 19-12:               \n|                                         | Reserved = 0 Bit 20: Execute Disable               \n|                                         | Bit available Bits 25-21: Reserved =               \n|                                         | 0 Bit 26: 1-GByte pages are available              \n|                                         | if 1 Bit 27: RDTSCP and IA32_TSC_AUX               \n|                                         | are available if 1 Bits 28: Reserved               \n|                                         | = 0 Bit 29: Intel\u00ae 64 Architecture available       \n|                                         | if 1 Bits 31-30: Reserved = 0                      \n| EAX EBX ECX EDX                         | Processor Brand String Processor Brand             \n|                                         | String Continued Processor Brand String            \n|                                         | Continued Processor Brand String Continued         \n| EAX EBX ECX EDX                         | Processor Brand String Continued Processor         \n|                                         | Brand String Continued Processor Brand             \n|                                         | String Continued Processor Brand String            \n|                                         | Continued                                          \n| EAX EBX ECX EDX                         | Processor Brand String Continued Processor         \n|                                         | Brand String Continued Processor Brand             \n|                                         | String Continued Processor Brand String            \n|                                         | Continued                                          \n| EAX EBX ECX EDX                         | Reserved = 0 Reserved = 0 Reserved =               \n|                                         | 0 Reserved = 0                                     \n| EAX EBX                                 | Reserved = 0 Reserved = 0                          \n| ECX EDX                                 | Bits 07-00: Cache Line size in bytes               \n|                                         | Bits 11-08: Reserved Bits 15-12: L2                \n|                                         | Associativity field *Bits 31-16: Cache             \n|                                         | size in 1K units Reserved = 0 Information          \n|                                         | Returned by CPUID Instruction (Contd.)             \n|                                         | Initial EAX Information Provided about             \n|                                         | the Processor                                      \nNotes: * L2 associativity field encodings: 00H - Disabled 01H - Direct mapped\n02H - 2-way 04H - 4-way 06H - 8-way 08H - 16-way 0FH - Fully associative\n\n| 80000007H| EAX EBX ECX EDX| Reserved = 0 Reserved = 0 Reserved =        \n|          |                | 0 Bits 07-00: Reserved = 0 Bit 08: Invariant\n|          |                | TSC available if 1 Bits 31-09: Reserved     \n|          |                | = 0                                         \n| 80000008H| EAX EBX ECX EDX| Linear/Physical Address size Bits 07-00:    \n|          |                | #Physical Address Bits*Bits 15-8: #Linear   \n|          |                | Address Bits Bits 31-16: Reserved =         \n|          |                | 0 Reserved = 0 Reserved = 0 Reserved        \n|          |                | = 0                                         \nNotes: \n\n| *| If CPUID.80000008H:EAX[7:0] is supported,\n|  | the maximum physical address number      \n|  | supported should come from this field.   \n\nINPUT EAX = 0: Returns CPUID's Highest Value for Basic Processor Information and the Vendor Identification String:\nWhen CPUID executes with EAX set to 0, the processor returns the highest value\nthe CPUID recognizes for returning basic processor information. The value is\nreturned in the EAX register (see Table 3-18) and is processor specific. A vendor\nidentification string is also returned in EBX, EDX, and ECX. For Intel processors,\nthe string is \u201cGenuineIntel\u201d and is expressed: EBX \u2190 756e6547h (* \"Genu\", with\nG in the low eight bits of BL *) EDX \u2190 49656e69h (* \"ineI\", with i in the low\neight bits of DL *) ECX \u2190 6c65746eh (* \"ntel\", with n in the low eight bits\nof CL *)\n\n\nINPUT EAX = 80000000H: Returns CPUID's Highest Value for Extended Processor Information:\nWhen CPUID executes with EAX set to 80000000H, the processor returns the highest\nvalue the processor recognizes for returning extended processor information.\nThe value is returned in the EAX register (see Table 3-18) and is processor\nspecific.\n\n\nTable 3-18. Highest CPUID Source Operand for Intel 64 and IA-32 Processors:\nHighest Value in EAX Intel 64 or IA-32 Processors\n\n| Basic Information                        | Extended Function Information CPUID     \n|                                          | Not Implemented                         \n| 01H                                      | Not Implemented                         \n| Highest CPUID Source Operand for Intel   | (Contd.) Highest Value in EAX Intel     \n| 64 and IA-32 Processors Basic Information| 64 or IA-32 Processors Extended Function\n|                                          | Information                             \n| 02H                                      | Not Implemented Processors              \n| 03H                                      | Not Implemented                         \n| 02H                                      | 80000004H                               \n| 02H                                      | 80000004H                               \n| 02H                                      | 80000004H                               \n| 05H                                      | 80000008H Technology                    \n| 05H                                      | 80000008H                               \n| 06H                                      | 80000008H                               \n| 0AH                                      | 80000008H                               \n| 0AH                                      | 80000008H                               \n| 0AH                                      | 80000008H Series                        \n| 0DH                                      | 80000008H                               \n| 0AH                                      | 80000008H                               \n| 0AH                                      | 80000008H                               \n| 0BH                                      | 80000008H                               \n\nIA32_BIOS_SIGN_ID Returns Microcode Update Signature:\nFor processors that support the microcode update facility, the IA32_BIOS_SIGN_ID\nMSR is loaded with the update signature whenever CPUID executes. The signature\nis returned in the upper DWORD. For details, see Chapter 9 in the Intel\u00ae 64\nand IA-32 Architectures Software Developer's Manual, Volume 3A.\n\n\nINPUT EAX = 1: Returns Model, Family, Stepping Information:\nWhen CPUID executes with EAX set to 1, version information is returned in EAX\n(see Figure 3-5). For example: model, family, and processor type for the Intel\nXeon processor 5100 series is as follows:\n\n - Model  -  1111B\n - Family  -  0101B\n - Processor Type  -  00B\n\nSee Table 3-19 for available processor type values. Stepping IDs are provided\nas needed.\n\n| 31| 28 27 Extended Family ID| 20 19 Extended Model ID| 16 15 14 13 12 11| 8 Family ID| 7 Model| 4| 3 Stepping ID| 0 EAX\nExtended Family ID (0) Extended Model ID (0) Processor Type Family (0FH for\nthe Pentium 4 Processor Family) Model\n\nReserved\n\nOM16525\n\n| Figure 3-5.| Version Information Returned by CPUID\n|            | in EAX Processor Type Field Encoding \n|            | 00B 01B 10B 11B                      \nNOTE See Chapter 17 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 1, for information on identifying earlier IA-32 processors.\n\nThe Extended Family ID needs to be examined only when the Family ID is 0FH.\nIntegrate the fields into a display using the following rule:\n\nIF Family_ID != 0FH THEN DisplayFamily = Family_ID; ELSE DisplayFamily = Extended_Family_ID\n+ Family_ID; (* Right justify and zero-extend 4-bit field. *) FI; (* Show DisplayFamily\nas HEX field. *)\n\nThe Extended Model ID needs to be examined only when the Family ID is 06H or\n0FH. Integrate the field into a display using the following rule:\n\nIF (Family_ID = 06H or Family_ID = 0FH) THEN DisplayModel = (Extended_Model_ID\n\u00ab 4) + Model_ID; (* Right justify and zero-extend 4-bit field; display Model_ID\nas HEX field.*) ELSE DisplayModel = Model_ID; FI; (* Show DisplayModel as HEX\nfield. *)\n\n\nINPUT EAX = 1: Returns Additional Information in EBX:\nWhen CPUID executes with EAX set to 1, additional information is returned to\nthe EBX register:\n\n - Brand index (low byte of EBX)  -  this number provides an entry into a brand string\ntable that contains brand strings for IA-32 processors. More information about\nthis field is provided later in this section.\n - CLFLUSH instruction cache line size (second byte of EBX)  -  this number indicates\nthe size of the cache line flushed with CLFLUSH instruction in 8-byte increments.\nThis field was introduced in the Pentium 4 processor.\n - Local APIC ID (high byte of EBX)  -  this number is the 8-bit ID that is assigned\nto the local APIC on the processor during power up. This field was introduced\nin the Pentium 4 processor.\n\n\nINPUT EAX = 1: Returns Feature Information in ECX and EDX:\nWhen CPUID executes with EAX set to 1, feature information is returned in ECX\nand EDX.\n\n - Figure 3-6 and Table 3-20 show encodings for ECX.\n - Figure 3-7 and Table 3-21 show encodings for EDX.\n\nFor all feature flags, a 1 indicates that the feature is supported. Use Intel\nto properly interpret feature flags.\n\n\nNOTE:\nSoftware must confirm that a processor feature is present using feature flags\nreturned by CPUID prior to using the feature. Software should not depend on\nfuture offerings retaining all features.\n\n| 31 30 29 28 27 26 25 24 23 22 21 20| 17| 16| 15| 14| 13| 12| 11| 10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0\n| 19 18                              |   |   |   |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  \nECX 0\n\nRDRAND F16C AVX OSXSAVE XSAVE AES TSC-Deadline POPCNT MOVBE x2APIC\n\n| SSE4_2  - SSE4_1  - DCA  - PCID  - PDCM  - | SSE4.2 SSE4.1 Direct Cache Access Process-context\n|                                  | Identifiers Perf/Debug Capability MSR            \nxTPR Update Control CMPXCHG16B\n\n| FMA  - SDBG CNXT-ID  -  L1 Context ID SSSE3  | Fused Multiply Add SSSE3 Extensions                 \n|  - TM2  -  Thermal Monitor 2 EST  - SMX  -       | Technology 64-bit DS Area Carryless                 \n| Safer Mode Extensions VMX  -  Virtual      | Multiplication SSE3 Extensions OM16524b             \n| Machine Extensions DS-CPL  -  CPL Qualified| Feature Information Returned in the                 \n| Debug Store MONITOR  -  MONITOR/MWAIT      | ECX Register Feature Information Returned           \n| DTES64 PCLMULQDQ SSE3 Reserved           | in the ECX Register Description Streaming           \n|                                          | SIMD Extensions 3 (SSE3). A value of                \n|                                          | 1 indicates the processor supports this             \n|                                          | technology. PCLMULQDQ. A value of 1                 \n|                                          | indicates the processor supports the                \n|                                          | PCLMULQDQ instruction 64-bit DS Area.               \n|                                          | A value of 1 indicates the processor                \n|                                          | supports DS area using 64-bit layout                \n|                                          | MONITOR/MWAIT. A value of 1 indicates               \n|                                          | the processor supports this feature.                \n|                                          | CPL Qualified Debug Store. A value of               \n|                                          | 1 indicates the processor supports the              \n|                                          | extensions to the Debug Store feature               \n|                                          | to allow for branch message storage                 \n|                                          | qualified by CPL. Virtual Machine Extensions.       \n|                                          | A value of 1 indicates that the processor           \n|                                          | supports this technology Safer Mode                 \n|                                          | Extensions. A value of 1 indicates that             \n|                                          | the processor supports this technology.             \n|                                          | See Chapter 5, \u201cSafer Mode Extensions               \n|                                          | Reference\u201d. Enhanced Intel SpeedStep\u00ae               \n|                                          | technology. A value of 1 indicates that             \n|                                          | the processor supports this technology.             \n|                                          | Thermal Monitor 2. A value of 1 indicates           \n|                                          | whether the processor supports this                 \n|                                          | technology. A value of 1 indicates the              \n|                                          | presence of the Supplemental Streaming              \n|                                          | SIMD Extensions 3 (SSSE3). A value of               \n|                                          | 0 indicates the instruction extensions              \n|                                          | are not present in the processor (Contd.)           \n|                                          | Description L1 Context ID. A value of               \n|                                          | 1 indicates the L1 data cache mode can              \n|                                          | be set to either adaptive mode or shared            \n|                                          | mode. A value of 0 indicates this feature           \n|                                          | is not supported. See definition of                 \n|                                          | the IA32_MISC_ENABLE MSR Bit 24 (L1                 \n|                                          | Data Cache Context Mode) for details.               \n|                                          | A value of 1 indicates the processor                \n|                                          | supports IA32_DEBUG_INTERFACE MSR for               \n|                                          | silicon debug. A value of 1 indicates               \n|                                          | the processor supports FMA extensions               \n|                                          | using YMM state. CMPXCHG16B Available.              \n|                                          | A value of 1 indicates that the feature             \n|                                          | is available. See the \u201cCMPXCHG8B/CMPXCHG16B - Compare \n|                                          | and Exchange Bytes\u201d section in this                 \n|                                          | chapter for a description. xTPR Update              \n|                                          | Control. A value of 1 indicates that                \n|                                          | the processor supports changing IA32_MISC_ENABLE[bit\n|                                          | 23]. Perfmon and Debug Capability: A                \n|                                          | value of 1 indicates the processor supports         \n|                                          | the performance and debug feature indication        \n|                                          | MSR IA32_PERF_CAPABILITIES. Reserved                \n|                                          | Process-context identifiers. A value                \n|                                          | of 1 indicates that the processor supports          \n|                                          | PCIDs and that software may set CR4.PCIDE           \n|                                          | to 1. A value of 1 indicates the processor          \n|                                          | supports the ability to prefetch data               \n|                                          | from a memory mapped device. A value                \n|                                          | of 1 indicates that the processor supports          \n|                                          | SSE4.1. A value of 1 indicates that                 \n|                                          | the processor supports SSE4.2. A value              \n|                                          | of 1 indicates that the processor supports          \n|                                          | x2APIC feature. A value of 1 indicates              \n|                                          | that the processor supports MOVBE instruction.      \n|                                          | A value of 1 indicates that the processor           \n|                                          | supports the POPCNT instruction. A value            \n|                                          | of 1 indicates that the processor's                 \n|                                          | local APIC timer supports one-shot operation        \n|                                          | using a TSC deadline value. A value                 \n|                                          | of 1 indicates that the processor supports          \n|                                          | the AESNI instruction extensions. A                 \n|                                          | value of 1 indicates that the processor             \n|                                          | supports the XSAVE/XRSTOR processor                 \n|                                          | extended states feature, the XSETBV/XGETBV          \n|                                          | instructions, and XCR0. A value of 1                \n|                                          | indicates that the OS has set CR4.OSXSAVE[bit       \n|                                          | 18] to enable the XSAVE feature set.                \n|                                          | A value of 1 indicates the processor                \n|                                          | supports the AVX instruction extensions.            \n|                                          | A value of 1 indicates that processor               \n|                                          | supports 16-bit floating-point conversion           \n|                                          | instructions. A value of 1 indicates                \n|                                          | that processor supports RDRAND instruction.         \n|                                          | Always returns 0. 0                                 \nEDX\n\nPBE-Pend. Brk. EN. TM-Therm. Monitor HTT-Multi-threading SS-Self Snoop SSE2-SSE2\nExtensions SSE-SSE Extensions FXSR-FXSAVE/FXRSTOR MMX-MMX Technology ACPI-Thermal\nMonitor and Clock Ctrl DS-Debug Store CLFSH-CFLUSH instruction PSN-Processor\nSerial Number PSE-36 - Page Size Extension PAT-Page Attribute Table CMOV-Conditional\nMove/Compare Instruction MCA-Machine Check Architecture PGE-PTE Global Bit MTRR-Memory\nType Range Registers SEP-SYSENTER and SYSEXIT APIC-APIC on Chip CX8-CMPXCHG8B\nInst. MCE-Machine Check Exception PAE-Physical Address Extensions MSR-RDMSR\nand WRMSR Support TSC-Time Stamp Counter PSE-Page Size Extensions DE-Debugging\nExtensions VME-Virtual-8086 Mode Enhancement FPU-x87 FPU on Chip\n\nReserved\n\nOM16523\n\n| Figure 3-7.                         | Feature Information Returned in the               \n|                                     | EDX Register More on Feature Information          \n|                                     | Returned in the EDX Register Description          \n|                                     | Floating Point Unit On-Chip. The processor        \n|                                     | contains an x87 FPU. Virtual 8086 Mode            \n|                                     | Enhancements. Virtual 8086 mode enhancements,     \n|                                     | including CR4.VME for controlling the             \n|                                     | feature, CR4.PVI for protected mode               \n|                                     | virtual interrupts, software interrupt            \n|                                     | indirection, expansion of the TSS with            \n|                                     | the software indirection bitmap, and              \n|                                     | EFLAGS.VIF and EFLAGS.VIP flags. Debugging        \n|                                     | Extensions. Support for I/O breakpoints,          \n|                                     | including CR4.DE for controlling the              \n|                                     | feature, and optional trapping of accesses        \n|                                     | to DR4 and DR5. Page Size Extension.              \n|                                     | Large pages of size 4 MByte are supported,        \n|                                     | including CR4.PSE for controlling the             \n|                                     | feature, the defined dirty bit in PDE             \n|                                     | (Page Directory Entries), optional reserved       \n|                                     | bit trapping in CR3, PDEs, and PTEs.              \n|                                     | Time Stamp Counter. The RDTSC instruction         \n|                                     | is supported, including CR4.TSD for               \n|                                     | controlling privilege. Model Specific             \n|                                     | Registers RDMSR and WRMSR Instructions.           \n|                                     | The RDMSR and WRMSR instructions are              \n|                                     | supported. Some of the MSRs are implementation    \n|                                     | dependent. Physical Address Extension.            \n|                                     | Physical addresses greater than 32 bits           \n|                                     | are supported: extended page table entry          \n|                                     | formats, an extra level in the page               \n|                                     | translation tables is defined, 2-MByte            \n|                                     | pages are supported instead of 4 Mbyte            \n|                                     | pages if PAE bit is 1. Machine Check              \n|                                     | Exception. Exception 18 is defined for            \n|                                     | Machine Checks, including CR4.MCE for             \n|                                     | controlling the feature. This feature             \n|                                     | does not define the model-specific implementations\n|                                     | of machine-check error logging, reporting,        \n|                                     | and processor shutdowns. Machine Check            \n|                                     | exception handlers may have to depend             \n|                                     | on processor version to do model specific         \n|                                     | processing of the exception, or test              \n|                                     | for the presence of the Machine Check             \n|                                     | feature. CMPXCHG8B Instruction. The               \n|                                     | compare-and-exchange 8 bytes (64 bits)            \n|                                     | instruction is supported (implicitly              \n|                                     | locked and atomic). APIC On-Chip. The             \n|                                     | processor contains an Advanced Programmable       \n|                                     | Interrupt Controller (APIC), responding           \n|                                     | to memory mapped commands in the physical         \n|                                     | address range FFFE0000H to FFFE0FFFH              \n|                                     | (by default - some processors permit              \n|                                     | the APIC to be relocated). Reserved               \n|                                     | SYSENTER and SYSEXIT Instructions. The            \n|                                     | SYSENTER and SYSEXIT and associated               \n|                                     | MSRs are supported. Memory Type Range             \n|                                     | Registers. MTRRs are supported. The               \n|                                     | MTRRcap MSR contains feature bits that            \n|                                     | describe what memory types are supported,         \n|                                     | how many variable MTRRs are supported,            \n|                                     | and whether fixed MTRRs are supported.            \n|                                     | Page Global Bit. The global bit is supported      \n|                                     | in paging-structure entries that map              \n|                                     | a page, indicating TLB entries that               \n|                                     | are common to different processes and             \n|                                     | need not be flushed. The CR4.PGE bit              \n|                                     | controls this feature. Machine Check              \n|                                     | Architecture. The Machine Check Architecture,     \n|                                     | which provides a compatible mechanism             \n|                                     | for error reporting in P6 family, Pentium         \n|                                     | 4, Intel Xeon processors, and future              \n|                                     | processors, is supported. The MCG_CAP             \n|                                     | MSR contains feature bits describing              \n|                                     | how many banks of error reporting MSRs            \n|                                     | are supported. Conditional Move Instructions.     \n|                                     | The conditional move instruction CMOV             \n|                                     | is supported. In addition, if x87 FPU             \n|                                     | is present as indicated by the CPUID.FPU          \n|                                     | feature bit, then the FCOMI and FCMOV             \n|                                     | instructions are supported Page Attribute         \n|                                     | Table. Page Attribute Table is supported.         \n|                                     | This feature augments the Memory Type             \n|                                     | Range Registers (MTRRs), allowing an              \n|                                     | operating system to specify attributes            \n|                                     | of memory accessed through a linear               \n|                                     | address on a 4KB granularity. 36-Bit              \n|                                     | Page Size Extension. 4-MByte pages addressing     \n|                                     | physical memory beyond 4 GBytes are               \n|                                     | supported with 32-bit paging. This feature        \n|                                     | indicates that upper bits of the physical         \n|                                     | address of a 4-MByte page are encoded             \n|                                     | in bits 20:13 of the page-directory               \n|                                     | entry. Such physical addresses are limited        \n|                                     | by MAXPHYADDR and may be up to 40 bits            \n|                                     | in size. Processor Serial Number. The             \n|                                     | processor supports the 96-bit processor           \n|                                     | identification number feature and the             \n|                                     | feature is enabled. CLFLUSH Instruction.          \n|                                     | CLFLUSH Instruction is supported. Reserved        \n| More on Feature Information Returned| Table 3-21. Description Debug Store.              \n| in the EDX Register (Contd.)        | The processor supports the ability to             \n|                                     | write debug information into a memory             \n|                                     | resident buffer. This feature is used             \n|                                     | by the branch trace store (BTS) and               \n|                                     | precise event-based sampling (PEBS)               \n|                                     | facilities (see Chapter 23, \u201cIntroduction         \n|                                     | to Virtual-Machine Extensions,\u201d in the            \n|                                     | Intel\u00ae 64 and IA-32 Architectures Software        \n|                                     | Developer's Manual, Volume 3C). Thermal           \n|                                     | Monitor and Software Controlled Clock             \n|                                     | Facilities. The processor implements              \n|                                     | internal MSRs that allow processor temperature    \n|                                     | to be monitored and processor performance         \n|                                     | to be modulated in predefined duty cycles         \n|                                     | under software control. Intel MMX Technology.     \n|                                     | The processor supports the Intel MMX              \n|                                     | technology. FXSAVE and FXRSTOR Instructions.      \n|                                     | The FXSAVE and FXRSTOR instructions               \n|                                     | are supported for fast save and restore           \n|                                     | of the floating point context. Presence           \n|                                     | of this bit also indicates that CR4.OSFXSR        \n|                                     | is available for an operating system              \n|                                     | to indicate that it supports the FXSAVE           \n|                                     | and FXRSTOR instructions. SSE. The processor      \n|                                     | supports the SSE extensions. SSE2. The            \n|                                     | processor supports the SSE2 extensions.           \n|                                     | Self Snoop. The processor supports the            \n|                                     | management of conflicting memory types            \n|                                     | by performing a snoop of its own cache            \n|                                     | structure for transactions issued to              \n|                                     | the bus. Max APIC IDs reserved field              \n|                                     | is Valid. A value of 0 for HTT indicates          \n|                                     | there is only a single logical processor          \n|                                     | in A value of 1 for HTT indicates the             \n|                                     | value in CPUID.1.EBX[23:16] (the Maximum          \n|                                     | number of addressable IDs for logical             \n|                                     | processors in this package) is valid              \n|                                     | for the package. Thermal Monitor. The             \n|                                     | processor implements the thermal monitor          \n|                                     | automatic thermal control circuitry               \n|                                     | (TCC). Reserved Pending Break Enable.             \n|                                     | The processor supports the use of the             \n|                                     | FERR#/PBE# pin when the processor is              \n|                                     | in the stop-clock state (STPCLK# is               \n|                                     | asserted) to signal the processor that            \n|                                     | an interrupt is pending and that the              \n|                                     | processor should return to normal operation       \n|                                     | to handle the interrupt. Bit 10 (PBE              \n|                                     | enable) in the IA32_MISC_ENABLE MSR               \n|                                     | enables this capability.                          \n\nINPUT EAX = 2: TLB/Cache/Prefetch Information Returned in EAX, EBX, ECX, EDX:\nWhen CPUID executes with EAX set to 2, the processor returns information about\nthe processor's internal TLBs, cache and prefetch hardware in the EAX, EBX,\nECX, and EDX registers. The information is reported in encoded form and fall\ninto the following categories:\n\n - The least-significant byte in register EAX (register AL) indicates the number\nof times the CPUID instruction must be executed with an input value of 2 to\nget a complete description of the processor's TLB/Cache/Prefetch hardware. The\nIntel Xeon processor 7400 series will return a 1.\n - The most significant bit (bit 31) of each register indicates whether the register\ncontains valid information (set to 0) or is reserved (set to 1).\n - If a register contains valid information, the information is contained in 1\nbyte descriptors. There are four types of encoding values for the byte descriptor,\nthe encoding type is noted in the second column of Table 3-22. Table 3-22 lists\nthe encoding of these descriptors. Note that the order of descriptors in the\nEAX, EBX, ECX, and EDX registers is not defined; that is, specific bytes are\nnot designated to contain descriptors for specific cache, prefetch, or TLB types.\nThe descriptors may appear in any order. Note also a processor may report a\ngeneral descriptor type (FFH) and not report any byte descriptor of \u201ccache type\u201d\nvia CPUID leaf 2. Table 3-22. Encoding of CPUID Leaf 2 Descriptors\n\n| Value 00H 01H 02H 03H 04H 05H 06H 08H     | Type Null descriptor, this byte contains       | Description (Contd.)                     \n| 09H 0AH 0BH 0CH 0DH 0EH 1DH 21H 22H       | no information Instruction TLB: 4 KByte        |                                          \n| 23H 24H 25H 29H 2CH 30H 40H 41H 42H       | pages, 4-way set associative, 32 entries       |                                          \n| 43H 44H 45H 46H 47H 48H 49H 4AH 4BH       | Instruction TLB: 4 MByte pages, fully          |                                          \n| 4CH 4DH 4EH 4FH                           | associative, 2 entries Data TLB: 4 KByte       |                                          \n|                                           | pages, 4-way set associative, 64 entries       |                                          \n|                                           | Data TLB: 4 MByte pages, 4-way set associative,|                                          \n|                                           | 8 entries Data TLB1: 4 MByte pages,            |                                          \n|                                           | 4-way set associative, 32 entries 1st-level    |                                          \n|                                           | instruction cache: 8 KBytes, 4-way set         |                                          \n|                                           | associative, 32 byte line size 1st-level       |                                          \n|                                           | instruction cache: 16 KBytes, 4-way            |                                          \n|                                           | set associative, 32 byte line size 1st-level   |                                          \n|                                           | instruction cache: 32KBytes, 4-way set         |                                          \n|                                           | associative, 64 byte line size 1st-level       |                                          \n|                                           | data cache: 8 KBytes, 2-way set associative,   |                                          \n|                                           | 32 byte line size Instruction TLB: 4           |                                          \n|                                           | MByte pages, 4-way set associative,            |                                          \n|                                           | 4 entries 1st-level data cache: 16 KBytes,     |                                          \n|                                           | 4-way set associative, 32 byte line            |                                          \n|                                           | size 1st-level data cache: 16 KBytes,          |                                          \n|                                           | 4-way set associative, 64 byte line            |                                          \n|                                           | size 1st-level data cache: 24 KBytes,          |                                          \n|                                           | 6-way set associative, 64 byte line            |                                          \n|                                           | size 2nd-level cache: 128 KBytes, 2-way        |                                          \n|                                           | set associative, 64 byte line size 2nd-level   |                                          \n|                                           | cache: 256 KBytes, 8-way set associative,      |                                          \n|                                           | 64 byte line size 3rd-level cache: 512         |                                          \n|                                           | KBytes, 4-way set associative, 64 byte         |                                          \n|                                           | line size, 2 lines per sector 3rd-level        |                                          \n|                                           | cache: 1 MBytes, 8-way set associative,        |                                          \n|                                           | 64 byte line size, 2 lines per sector          |                                          \n|                                           | 2nd-level cache: 1 MBytes, 16-way set          |                                          \n|                                           | associative, 64 byte line size 3rd-level       |                                          \n|                                           | cache: 2 MBytes, 8-way set associative,        |                                          \n|                                           | 64 byte line size, 2 lines per sector          |                                          \n|                                           | 3rd-level cache: 4 MBytes, 8-way set           |                                          \n|                                           | associative, 64 byte line size, 2 lines        |                                          \n|                                           | per sector 1st-level data cache: 32            |                                          \n|                                           | KBytes, 8-way set associative, 64 byte         |                                          \n|                                           | line size 1st-level instruction cache:         |                                          \n|                                           | 32 KBytes, 8-way set associative, 64           |                                          \n|                                           | byte line size No 2nd-level cache or,          |                                          \n|                                           | if processor contains a valid 2nd-level        |                                          \n|                                           | cache, no 3rd-level cache 2nd-level            |                                          \n|                                           | cache: 128 KBytes, 4-way set associative,      |                                          \n|                                           | 32 byte line size 2nd-level cache: 256         |                                          \n|                                           | KBytes, 4-way set associative, 32 byte         |                                          \n|                                           | line size 2nd-level cache: 512 KBytes,         |                                          \n|                                           | 4-way set associative, 32 byte line            |                                          \n|                                           | size 2nd-level cache: 1 MByte, 4-way           |                                          \n|                                           | set associative, 32 byte line size 2nd-level   |                                          \n|                                           | cache: 2 MByte, 4-way set associative,         |                                          \n|                                           | 32 byte line size 3rd-level cache: 4           |                                          \n|                                           | MByte, 4-way set associative, 64 byte          |                                          \n|                                           | line size 3rd-level cache: 8 MByte,            |                                          \n|                                           | 8-way set associative, 64 byte line            |                                          \n|                                           | size 2nd-level cache: 3MByte, 12-way           |                                          \n|                                           | set associative, 64 byte line size 3rd-level   |                                          \n|                                           | cache: 4MB, 16-way set associative,            |                                          \n|                                           | 64-byte line size (Intel Xeon processor        |                                          \n|                                           | MP, Family 0FH, Model 06H); 2nd-level          |                                          \n|                                           | cache: 4 MByte, 16-way set associative,        |                                          \n|                                           | 64 byte line size 3rd-level cache: 6MByte,     |                                          \n|                                           | 12-way set associative, 64 byte line           |                                          \n|                                           | size 3rd-level cache: 8MByte, 16-way           |                                          \n|                                           | set associative, 64 byte line size 3rd-level   |                                          \n|                                           | cache: 12MByte, 12-way set associative,        |                                          \n|                                           | 64 byte line size 3rd-level cache: 16MByte,    |                                          \n|                                           | 16-way set associative, 64 byte line           |                                          \n|                                           | size 2nd-level cache: 6MByte, 24-way           |                                          \n|                                           | set associative, 64 byte line size Instruction |                                          \n|                                           | TLB: 4 KByte pages, 32 entries Table           |                                          \n|                                           | 3-22.                                          |                                          \n| Value 50H 51H 52H 55H 56H 57H 59H 5AH     | Type Instruction TLB: 4 KByte and 2-MByte      | Description (Contd.)                     \n| 5BH 5CH 5DH 60H 61H 63H 66H 67H 68H       | or 4-MByte pages, 64 entries Instruction       |                                          \n| 70H 71H 72H 76H 78H 79H 7AH 7BH 7CH       | TLB: 4 KByte and 2-MByte or 4-MByte            |                                          \n| 7DH 7FH 80H 82H 83H 84H 85H 86H 87H       | pages, 128 entries Instruction TLB:            |                                          \n| A0H B0H B1H B2H B3H B4H                   | 4 KByte and 2-MByte or 4-MByte pages,          |                                          \n|                                           | 256 entries Instruction TLB: 2-MByte           |                                          \n|                                           | or 4-MByte pages, fully associative,           |                                          \n|                                           | 7 entries Data TLB0: 4 MByte pages,            |                                          \n|                                           | 4-way set associative, 16 entries Data         |                                          \n|                                           | TLB0: 4 KByte pages, 4-way associative,        |                                          \n|                                           | 16 entries Data TLB0: 4 KByte pages,           |                                          \n|                                           | fully associative, 16 entries Data TLB0:       |                                          \n|                                           | 2-MByte or 4 MByte pages, 4-way set            |                                          \n|                                           | associative, 32 entries Data TLB: 4            |                                          \n|                                           | KByte and 4 MByte pages, 64 entries            |                                          \n|                                           | Data TLB: 4 KByte and 4 MByte pages,128        |                                          \n|                                           | entries Data TLB: 4 KByte and 4 MByte          |                                          \n|                                           | pages,256 entries 1st-level data cache:        |                                          \n|                                           | 16 KByte, 8-way set associative, 64            |                                          \n|                                           | byte line size Instruction TLB: 4 KByte        |                                          \n|                                           | pages, fully associative, 48 entries           |                                          \n|                                           | Data TLB: 1 GByte pages, 4-way set associative,|                                          \n|                                           | 4 entries 1st-level data cache: 8 KByte,       |                                          \n|                                           | 4-way set associative, 64 byte line            |                                          \n|                                           | size 1st-level data cache: 16 KByte,           |                                          \n|                                           | 4-way set associative, 64 byte line            |                                          \n|                                           | size 1st-level data cache: 32 KByte,           |                                          \n|                                           | 4-way set associative, 64 byte line            |                                          \n|                                           | size Trace cache: 12 K-\u03bcop, 8-way set          |                                          \n|                                           | associative Trace cache: 16 K-\u03bcop, 8-way       |                                          \n|                                           | set associative Trace cache: 32 K-\u03bcop,         |                                          \n|                                           | 8-way set associative Instruction TLB:         |                                          \n|                                           | 2M/4M pages, fully associative, 8 entries      |                                          \n|                                           | 2nd-level cache: 1 MByte, 4-way set            |                                          \n|                                           | associative, 64byte line size 2nd-level        |                                          \n|                                           | cache: 128 KByte, 8-way set associative,       |                                          \n|                                           | 64 byte line size, 2 lines per sector          |                                          \n|                                           | 2nd-level cache: 256 KByte, 8-way set          |                                          \n|                                           | associative, 64 byte line size, 2 lines        |                                          \n|                                           | per sector 2nd-level cache: 512 KByte,         |                                          \n|                                           | 8-way set associative, 64 byte line            |                                          \n|                                           | size, 2 lines per sector 2nd-level cache:      |                                          \n|                                           | 1 MByte, 8-way set associative, 64 byte        |                                          \n|                                           | line size, 2 lines per sector 2nd-level        |                                          \n|                                           | cache: 2 MByte, 8-way set associative,         |                                          \n|                                           | 64byte line size 2nd-level cache: 512          |                                          \n|                                           | KByte, 2-way set associative, 64-byte          |                                          \n|                                           | line size 2nd-level cache: 512 KByte,          |                                          \n|                                           | 8-way set associative, 64-byte line            |                                          \n|                                           | size 2nd-level cache: 256 KByte, 8-way         |                                          \n|                                           | set associative, 32 byte line size 2nd-level   |                                          \n|                                           | cache: 512 KByte, 8-way set associative,       |                                          \n|                                           | 32 byte line size 2nd-level cache: 1           |                                          \n|                                           | MByte, 8-way set associative, 32 byte          |                                          \n|                                           | line size 2nd-level cache: 2 MByte,            |                                          \n|                                           | 8-way set associative, 32 byte line            |                                          \n|                                           | size 2nd-level cache: 512 KByte, 4-way         |                                          \n|                                           | set associative, 64 byte line size 2nd-level   |                                          \n|                                           | cache: 1 MByte, 8-way set associative,         |                                          \n|                                           | 64 byte line size DTLB: 4k pages, fully        |                                          \n|                                           | associative, 32 entries Instruction            |                                          \n|                                           | TLB: 4 KByte pages, 4-way set associative,     |                                          \n|                                           | 128 entries Instruction TLB: 2M pages,         |                                          \n|                                           | 4-way, 8 entries or 4M pages, 4-way,           |                                          \n|                                           | 4 entries Instruction TLB: 4KByte pages,       |                                          \n|                                           | 4-way set associative, 64 entries Data         |                                          \n|                                           | TLB: 4 KByte pages, 4-way set associative,     |                                          \n|                                           | 128 entries Data TLB1: 4 KByte pages,          |                                          \n|                                           | 4-way associative, 256 entries Table           |                                          \n|                                           | 3-22.                                          |                                          \n| Value B5H B6H BAH C0H C1H C2H CAH D0H     | Type Instruction TLB: 4KByte pages,            | Description Example 3-1. The first member\n| D1H D2H D6H D7H D8H DCH DDH DEH E2H       | 8-way set associative, 64 entries Instruction  | of the family of Pentium 4 processors    \n| E3H E4H EAH EBH ECH F0H F1H FFH EAX       | TLB: 4KByte pages, 8-way set associative,      | returns the following information about  \n| EBX ECX EDX The least-significant byte    | 128 entries Data TLB1: 4 KByte pages,          | caches and TLBs when the CPUID executes  \n| (byte 0) of register EAX is set to 01H.   | 4-way associative, 64 entries Data TLB:        | with an input value of 2: Which means:   \n| This indicates that CPUID needs to be     | 4 KByte and 4 MByte pages, 4-way associative,  | \u2022\u2022\u2022\u2022\u2022                                    \n| executed once with an input value of      | 8 entries Shared 2nd-Level TLB: 4 KByte/2MByte |                                          \n| 2 to retrieve complete information about  | pages, 8-way associative, 1024 entries         |                                          \n| caches and TLBs. The most-significant     | DTLB: 4 KByte/2 MByte pages, 4-way associative,|                                          \n| bit of all four registers (EAX, EBX,      | 16 entries Shared 2nd-Level TLB: 4 KByte       |                                          \n| ECX, and EDX) is set to 0, indicating     | pages, 4-way associative, 512 entries          |                                          \n| that each register contains valid 1-byte  | 3rd-level cache: 512 KByte, 4-way set          |                                          \n| descriptors. Bytes 1, 2, and 3 of register| associative, 64 byte line size 3rd-level       |                                          \n| EAX indicate that the processor has:      | cache: 1 MByte, 4-way set associative,         |                                          \n|  -  -  - The descriptors in registers EBX       | 64 byte line size 3rd-level cache: 2           |                                          \n| and ECX are valid, but contain NULL       | MByte, 4-way set associative, 64 byte          |                                          \n| descriptors. Bytes 0, 1, 2, and 3 of      | line size 3rd-level cache: 1 MByte,            |                                          \n| register EDX indicate that the processor  | 8-way set associative, 64 byte line            |                                          \n| has:  -  -  -  -                                  | size 3rd-level cache: 2 MByte, 8-way           |                                          \n|                                           | set associative, 64 byte line size 3rd-level   |                                          \n|                                           | cache: 4 MByte, 8-way set associative,         |                                          \n|                                           | 64 byte line size 3rd-level cache: 1.5         |                                          \n|                                           | MByte, 12-way set associative, 64 byte         |                                          \n|                                           | line size 3rd-level cache: 3 MByte,            |                                          \n|                                           | 12-way set associative, 64 byte line           |                                          \n|                                           | size 3rd-level cache: 6 MByte, 12-way          |                                          \n|                                           | set associative, 64 byte line size 3rd-level   |                                          \n|                                           | cache: 2 MByte, 16-way set associative,        |                                          \n|                                           | 64 byte line size 3rd-level cache: 4           |                                          \n|                                           | MByte, 16-way set associative, 64 byte         |                                          \n|                                           | line size 3rd-level cache: 8 MByte,            |                                          \n|                                           | 16-way set associative, 64 byte line           |                                          \n|                                           | size 3rd-level cache: 12MByte, 24-way          |                                          \n|                                           | set associative, 64 byte line size 3rd-level   |                                          \n|                                           | cache: 18MByte, 24-way set associative,        |                                          \n|                                           | 64 byte line size 3rd-level cache: 24MByte,    |                                          \n|                                           | 24-way set associative, 64 byte line           |                                          \n|                                           | size 64-Byte prefetching 128-Byte prefetching  |                                          \n|                                           | CPUID leaf 2 does not report cache descriptor  |                                          \n|                                           | information, use CPUID leaf 4 to query         |                                          \n|                                           | cache parameters Example of Cache and          |                                          \n|                                           | TLB Interpretation 66 5B 50 01H 0H 0H          |                                          \n|                                           | 00 7A 70 00H 50H - a 64-entry instruction      |                                          \n|                                           | TLB, for mapping 4-KByte and 2-MByte           |                                          \n|                                           | or 4-MByte pages. 5BH - a 64-entry data        |                                          \n|                                           | TLB, for mapping 4-KByte and 4-MByte           |                                          \n|                                           | pages. 66H - an 8-KByte 1st level data         |                                          \n|                                           | cache, 4-way set associative, with a           |                                          \n|                                           | 64-Byte cache line size. 00H - NULL            |                                          \n|                                           | descriptor. 70H - Trace cache: 12 K-\u03bcop,       |                                          \n|                                           | 8-way set associative. 7AH - a 256-KByte       |                                          \n|                                           | 2nd level cache, 8-way set associative,        |                                          \n|                                           | with a sectored, 64-byte cache line            |                                          \n|                                           | size. 00H - NULL descriptor.                   |                                          \n\nINPUT EAX = 04H: Returns Deterministic Cache Parameters for Each Level:\nWhen CPUID executes with EAX set to 04H and ECX contains an index value, the\nprocessor returns encoded data that describe a set of deterministic cache parameters\n(for the cache level associated with the input in ECX). Valid index values start\nfrom 0.\n\nSoftware can enumerate the deterministic cache parameters for each level of\nthe cache hierarchy starting with an index value of 0, until the parameters\nreport the value associated with the cache type field is 0. The architecturally\ndefined fields reported by deterministic cache parameters are documented in\nTable 3-17.\n\nThis Cache Size in Bytes\n\n= (Ways + 1) * (Partitions + 1) * (Line_Size + 1) * (Sets + 1)\n\n= (EBX[31:22] + 1) * (EBX[21:12] + 1) * (EBX[11:0] + 1) * (ECX + 1)\n\nThe CPUID leaf 04H also reports data that can be used to derive the topology\nof processor cores in a physical package. This information is constant for all\nvalid index values. Software can query the raw data reported by executing CPUID\nwith EAX=04H and ECX=0 and use it as part of the topology enumeration algorithm\ndescribed in Chapter 8, \u201cMultiple-Processor Management,\u201d in the Intel\u00ae 64 and\nIA-32 Architectures Software Developer's Manual, Volume 3A.\n\n\nINPUT EAX = 05H: Returns MONITOR and MWAIT Features:\nWhen CPUID executes with EAX set to 05H, the processor returns information about\nfeatures available to MONITOR/MWAIT instructions. The MONITOR instruction is\nused for address-range monitoring in conjunction with MWAIT instruction. The\nMWAIT instruction optionally provides additional extensions for advanced power\nmanagement. See Table 3-17.\n\n\nINPUT EAX = 06H: Returns Thermal and Power Management Features:\nWhen CPUID executes with EAX set to 06H, the processor returns information about\nthermal and power management features. See Table 3-17.\n\n\nINPUT EAX = 07H: Returns Structured Extended Feature Enumeration Information:\nWhen CPUID executes with EAX set to 07H and ECX = 0, the processor returns information\nabout the maximum input value for sub-leaves that contain extended feature flags.\nSee Table 3-17.\n\nWhen CPUID executes with EAX set to 07H and the input value of ECX is invalid\n(see leaf 07H entry in Table 3-17), the processor returns 0 in EAX/EBX/ECX/EDX.\nIn subleaf 0, EAX returns the maximum input value of the highest leaf 7 sub-leaf,\nand EBX, ECX & EDX contain information of extended feature flags.\n\n\nINPUT EAX = 09H: Returns Direct Cache Access Information:\nWhen CPUID executes with EAX set to 09H, the processor returns information about\nDirect Cache Access capabilities. See Table 3-17.\n\n\nINPUT EAX = 0AH: Returns Architectural Performance Monitoring Features:\nWhen CPUID executes with EAX set to 0AH, the processor returns information about\nsupport for architectural performance monitoring capabilities. Architectural\nperformance monitoring is supported if the version ID (see Table 3-17) is greater\nthan Pn 0. See Table 3-17.\n\nFor each version of architectural performance monitoring capability, software\nmust enumerate this leaf to discover the programming facilities and the architectural\nperformance events available in the processor. The details are described in\nChapter 23, \u201cIntroduction to Virtual-Machine Extensions,\u201d in the Intel\u00ae 64 and\nIA-32 Architectures Software Developer's Manual, Volume 3C.\n\n\nINPUT EAX = 0BH: Returns Extended Topology Information:\nWhen CPUID executes with EAX set to 0BH, the processor returns information about\nextended topology enumeration data. Software must detect the presence of CPUID\nleaf 0BH by verifying (a) the highest leaf index supported by CPUID is >= 0BH,\nand (b) CPUID.0BH:EBX[15:0] reports a non-zero value. See Table 3-17.\n\n\nINPUT EAX = 0DH: Returns Processor Extended States Enumeration Information:\nWhen CPUID executes with EAX set to 0DH and ECX = 0, the processor returns information\nabout the bit-vector representation of all processor state extensions that are\nsupported in the processor and storage size requirements of the XSAVE/XRSTOR\narea. See Table 3-17.\n\nWhen CPUID executes with EAX set to 0DH and ECX = n (n > 1, and is a valid sub-leaf\nindex), the processor returns information about the size and offset of each\nprocessor extended state save area within the XSAVE/XRSTOR area. See Table 3-17.\nSoftware can use the forward-extendable technique depicted below to query the\nvalid sub-leaves and obtain size and offset information for each processor extended\nstate save area:\n\nFor i = 2 to 62 // sub-leaf 1 is reserved IF (CPUID.(EAX=0DH, ECX=0):VECTOR[i]\n= 1 ) // VECTOR is the 64-bit value of EDX:EAX Execute CPUID.(EAX=0DH, ECX =\ni) to examine size and offset for sub-leaf i; FI;\n\n\nINPUT EAX = 0FH: Returns Platform Quality of Service (PQoS) Monitoring Enumeration Information:\nWhen CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information\nabout the bit-vector representation of QoS monitoring resource types that are\nsupported in the processor and maximum range of RMID values the processor can\nuse to monitor of any supported resource types. Each bit, starting from bit\n1, corresponds to a specific resource type if the bit is set. The bit position\ncorresponds to the sub-leaf index (or ResID) that software must use to query\nQoS monitoring capability available for that type. See Table 3-17.\n\nWhen CPUID executes with EAX set to 0FH and ECX = n (n >= 1, and is a valid\nResID), the processor returns information software can use to program IA32_PQR_ASSOC,\nIA32_QM_EVTSEL MSRs before reading QoS data from the IA32_QM_CTR MSR.\n\n\nINPUT EAX = 10H: Returns Platform Quality of Service (PQoS) Enforcement Enumeration Information:\nWhen CPUID executes with EAX set to 10H and ECX = 0, the processor returns information\nabout the bit-vector representation of QoS Enforcement resource types that are\nsupported in the processor. Each bit, starting from bit 1, corresponds to a\nspecific resource type if the bit is set. The bit position corresponds to the\nsub-leaf index (or ResID) that software must use to query QoS enforcement capability\navailable for that type. See Table 3-17.\n\nWhen CPUID executes with EAX set to 10H and ECX = n (n >= 1, and is a valid\nResID), the processor returns information about available classes of service\nand range of QoS mask MSRs that software can use to configure each class of\nservices using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.\n\n\nMETHODS FOR RETURNING BRANDING INFORMATION:\nUse the following techniques to access branding information:\n\n| 1.| Processor brand string method; this    \n|   | method also returns the processor's    \n|   | maximum operating frequency            \n| 2.| Processor brand index; this method uses\n|   | a software supplied brand string table.\nThese two methods are discussed in the following sections. For methods that\nare available in early processors, see Section: \u201cIdentification of Earlier IA-32\nProcessors\u201d in Chapter 17 of the Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1.\n\n\nThe Processor Brand String Method:\nFigure 3-8 describes the algorithm used for detection of the brand string. Processor\nbrand identification software should execute this algorithm on all Intel 64\nand IA-32 processors.\n\nThis method (introduced with Pentium 4 processors) returns an ASCII brand identification\nstring and the maximum operating frequency of the processor to the EAX, EBX,\nECX, and EDX registers.\n\nInput: EAX=0x80000000\n\nCPUID\n\n| False| Processor Brand String Not Supported\nCPUID True \u2265Function Extended Supported\n\nEAX Return Value =Max. Extended CPUID Function Index\n\nTrue\n\n| IF (EAX Return Value \u2265 0x80000004)| Processor Brand String Supported\nOM15194\n\n| Figure 3-8.| Determination of Support for the Processor\n|            | Brand String                              \n\nHow Brand Strings Work:\nTo use the brand string method, execute CPUID with EAX input of 8000002H through\n80000004H. For each input value, CPUID returns 16 ASCII characters using EAX,\nEBX, ECX, and EDX. The returned string will be NULL-terminated.\n\nTable 3-23 shows the brand string that is returned by the first processor in\nthe Pentium 4 processor family.\n\n\nTable 3-23. Processor Brand String Returned with Pentium 4 Processor:\n| EAX Input Value| Return Values                              | ASCII Equivalent                      \n| Table 3-23.    | Processor Brand String Returned with       | (Contd.) \u201d\u201d\u201d\u201d\u201c(let\u201d\u201cP )R\u201d\u201citne\u201d\u201cR(mu\u201d\u201c\n|                | Pentium 4 Processor EAX = 20202020H        | 4 )\u201d\u201c UPC\u201d\u201c0051\u201d\u201c\\0zHM\u201d               \n|                | EBX = 20202020H ECX = 20202020H EDX        |                                       \n|                | = 6E492020H EAX = 286C6574H EBX = 50202952H|                                       \n|                | ECX = 69746E65H EDX = 52286D75H EAX        |                                       \n|                | = 20342029H EBX = 20555043H ECX = 30303531H|                                       \n|                | EDX = 007A484DH                            |                                       \n\nExtracting the Maximum Processor Frequency from Brand Strings:\nFigure 3-9 provides an algorithm which software can use to extract the maximum\nprocessor operating frequency from the processor brand string.\n\n\nNOTE:\nWhen a frequency is given in a brand string, it is the maximum qualified frequency\nof the processor, not the frequency at which the processor is currently running.\n\n| Figure 3-9.| Algorithm for Extracting Maximum Processor\n|            | Frequency                                 \n\nThe Processor Brand Index Method:\nThe brand index method (introduced with Pentium\u00ae III Xeon\u00ae processors) provides\nan entry point into a brand identification table that is maintained in memory\nby system software and is accessible from system- and user-level code. In this\ntable, each brand index is associate with an ASCII brand identification string\nthat identifies the official Intel family and model number of a processor.\n\nWhen CPUID executes with EAX set to 1, the processor returns a brand index to\nthe low byte in EBX. Software can then use this index to locate the brand identification\nstring for the processor in the brand identification table. The first entry\n(brand index 0) in this table is reserved, allowing for backward compatibility\nwith processors that do not support the brand identification feature. Starting\nwith processor signature family ID = 0FH, model = 03H, brand index method is\nno longer supported. Use brand string method instead.\n\nTable 3-24 shows brand indices that have identification strings associated with\nthem.\n\n\nTable 3-24. Mapping of Brand Indices; and Intel 64 and IA-32 Processor Brand Strings:\n| Brand Index This processor does not         | Brand String                         \n| support the brand identification feature    |                                      \n| Intel(R) Celeron(R) processor1 Intel(R)     |                                      \n| Pentium(R) III processor1                   |                                      \n| Table 3-24. Intel(R) Pentium(R) III         | Mapping of Brand Indices; and Intel  \n| Xeon(R) processor; If processor signature   | 64 and IA-32 Processor Brand Strings \n| = 000006B1h, then Intel(R) Celeron(R)       | NOTES: 1. Indicates versions of these\n| processor Intel(R) Pentium(R) III processor | processors that were introduced after\n| Mobile Intel(R) Pentium(R) III processor-M  | the Pentium III                      \n| Mobile Intel(R) Celeron(R) processor1       |                                      \n| Intel(R) Pentium(R) 4 processor Intel(R)    |                                      \n| Pentium(R) 4 processor Intel(R) Celeron(R)  |                                      \n| processor1 Intel(R) Xeon(R) processor;      |                                      \n| If processor signature = 00000F13h,         |                                      \n| then Intel(R) Xeon(R) processor MP Intel(R) |                                      \n| Xeon(R) processor MP Mobile Intel(R)        |                                      \n| Pentium(R) 4 processor-M; If processor      |                                      \n| signature = 00000F13h, then Intel(R)        |                                      \n| Xeon(R) processor Mobile Intel(R) Celeron(R)|                                      \n| processor1 Mobile Genuine Intel(R) processor|                                      \n| Intel(R) Celeron(R) M processor Mobile      |                                      \n| Intel(R) Celeron(R) processor1 Intel(R)     |                                      \n| Celeron(R) processor Mobile Genuine         |                                      \n| Intel(R) processor Intel(R) Pentium(R)      |                                      \n| M processor Mobile Intel(R) Celeron(R)      |                                      \n| processor1 RESERVED                         |                                      \n\nIA-32 Architecture Compatibility:\nCPUID is not supported in early models of the Intel486 processor or in any IA-32\nprocessor earlier than the Intel486 processor.\n\nOperation:\n\nIA32_BIOS_SIGN_ID MSR <- Update with installed microcode revision number;\nCASE (EAX) OF\n  EAX = 0:\n     EAX <- Highest basic function input value understood by CPUID;\n     EBX <- Vendor identification string;\n     EDX <- Vendor identification string;\n     ECX <- Vendor identification string;\n  BREAK;\n  EAX = 1H:\n     EAX[3:0] <- Stepping ID;\n     EAX[7:4] <- Model;\n     EAX[11:8] <- Family;\n     EAX[13:12] <- Processor type;\n     EAX[15:14] <- Reserved;\n     EAX[19:16] <- Extended Model;\n     EAX[27:20] <- Extended Family;\n     EAX[31:28] <- Reserved;\n     EBX[7:0] <- Brand Index; (* Reserved if the value is zero. *)\n     EBX[15:8] <- CLFLUSH Line Size;\n     EBX[16:23] <- Reserved; (* Number of threads enabled = 2 if MT enable fuse set. *)\n     EBX[24:31] <- Initial APIC ID;\n     ECX <- Feature flags; (* See Figure 3-6. *)\n     EDX <- Feature flags; (* See Figure 3-7. *)\n  BREAK;\n  EAX = 2H:\n     EAX <- Cache and TLB information;\n     EBX <- Cache and TLB information;\n     ECX <- Cache and TLB information;\n     EDX <- Cache and TLB information;\n  BREAK;\n  EAX = 3H:\n     EAX <- Reserved;\n     EBX <- Reserved;\n     ECX <- ProcessorSerialNumber[31:0];\n     (* Pentium III processors only, otherwise reserved. *)\n     EDX <- ProcessorSerialNumber[63:32];\n     (* Pentium III processors only, otherwise reserved. *\n  BREAK\n  EAX = 4H:\n     EAX <- Deterministic Cache Parameters Leaf; (* See Table 3-17. *)\n     EBX <- Deterministic Cache Parameters Leaf;\n     ECX <- Deterministic Cache Parameters Leaf;\n     EDX <- Deterministic Cache Parameters Leaf;\n  BREAK;\n  EAX = 5H:\n     EAX <- MONITOR/MWAIT Leaf; (* See Table 3-17. *)\n     EBX <- MONITOR/MWAIT Leaf;\n     ECX <- MONITOR/MWAIT Leaf;\n     EDX <- MONITOR/MWAIT Leaf;\n  BREAK;\n  EAX = 6H:\n     EAX <- Thermal and Power Management Leaf; (* See Table 3-17. *)\n     EBX <- Thermal and Power Management Leaf;\n     ECX <- Thermal and Power Management Leaf;\n     EDX <- Thermal and Power Management Leaf;\n  BREAK;\n  EAX = 7H:\n     EAX <- Structured Extended Feature Flags Enumeration Leaf; (* See Table 3-17. *)\n     EBX <- Structured Extended Feature Flags Enumeration Leaf;\n     ECX <- Structured Extended Feature Flags Enumeration Leaf;\n     EDX <- Structured Extended Feature Flags Enumeration Leaf;\n  BREAK;\n  EAX = 8H:\n     EAX <- Reserved = 0;\n     EBX <- Reserved = 0;\n     ECX <- Reserved = 0;\n     EDX <- Reserved = 0;\n  BREAK;\n  EAX = 9H:\n     EAX <- Direct Cache Access Information Leaf; (* See Table 3-17. *)\n     EBX <- Direct Cache Access Information Leaf;\n     ECX <- Direct Cache Access Information Leaf;\n     EDX <- Direct Cache Access Information Leaf;\n  BREAK;\n  EAX = AH:\n     EAX <- Architectural Performance Monitoring Leaf; (* See Table 3-17. *)\n     EBX <- Architectural Performance Monitoring Leaf;\n     ECX <- Architectural Performance Monitoring Leaf;\n     EDX <- Architectural Performance Monitoring Leaf;\n     BREAK\n  EAX = BH:\n     EAX <- Extended Topology Enumeration Leaf; (* See Table 3-17. *)\n     EBX <- Extended Topology Enumeration Leaf;\n     ECX <- Extended Topology Enumeration Leaf;\n     EDX <- Extended Topology Enumeration Leaf;\n  BREAK;\n  EAX = CH:\n     EAX <- Reserved = 0;\n     EBX <- Reserved = 0;\n     ECX <- Reserved = 0;\n     EDX <- Reserved = 0;\n  BREAK;\n  EAX = DH:\n     EAX <- Processor Extended State Enumeration Leaf; (* See Table 3-17. *)\n     EBX <- Processor Extended State Enumeration Leaf;\n     ECX <- Processor Extended State Enumeration Leaf;\n     EDX <- Processor Extended State Enumeration Leaf;\n  BREAK;\n  EAX = EH:\n     EAX <- Reserved = 0;\n     EBX <- Reserved = 0;\n     ECX <- Reserved = 0;\n     EDX <- Reserved = 0;\n  BREAK;\n  EAX = FH:\n     EAX <- Platform Quality of Service Monitoring Enumeration Leaf; (* See Table 3-17. *)\n     EBX <- Platform Quality of Service Monitoring Enumeration Leaf;\n     ECX <- Platform Quality of Service Monitoring Enumeration Leaf;\n     EDX <- Platform Quality of Service Monitoring Enumeration Leaf;\n  BREAK;\n  EAX = 10H:\n     EAX <- Platform Quality of Service Enforcement Enumeration Leaf; (* See Table 3-17. *)\n     EBX <- Platform Quality of Service Enforcement Enumeration Leaf;\n     ECX <- Platform Quality of Service Enforcement Enumeration Leaf;\n     EDX <- Platform Quality of Service Enforcement Enumeration Leaf;\n  BREAK;\nBREAK;\n  EAX = 80000000H:\n     EAX <- Highest extended function input value understood by CPUID;\n     EBX <- Reserved;\n     ECX <- Reserved;\n     EDX <- Reserved;\n  BREAK;\n  EAX = 80000001H:\n     EAX <- Reserved;\n     EBX <- Reserved;\n     ECX <- Extended Feature Bits (* See Table 3-17.*);\n     EDX <- Extended Feature Bits (* See Table 3-17. *);\n  BREAK;\n  EAX = 80000002H:\n     EAX <- Processor Brand String;\n     EBX <- Processor Brand String, continued;\n     ECX <- Processor Brand String, continued;\n     EDX <- Processor Brand String, continued;\n  BREAK;\n  EAX = 80000003H:\n     EAX <- Processor Brand String, continued;\n     EBX <- Processor Brand String, continued;\n     ECX <- Processor Brand String, continued;\n     EDX <- Processor Brand String, continued;\n  BREAK;\n  EAX = 80000004H:\n     EAX <- Processor Brand String, continued;\n     EBX <- Processor Brand String, continued;\n     ECX <- Processor Brand String, continued;\n     EDX <- Processor Brand String, continued;\n  BREAK;\n  EAX = 80000005H:\n     EAX <- Reserved = 0;\n     EBX <- Reserved = 0;\n     ECX <- Reserved = 0;\n     EDX <- Reserved = 0;\n  BREAK;\n  EAX = 80000006H:\n     EAX <- Reserved = 0;\n     EBX <- Reserved = 0;\n     ECX <- Cache information;\n     EDX <- Reserved = 0;\n  BREAK;\n  EAX = 80000007H:\n     EAX <- Reserved = 0;\n     EBX <- Reserved = 0;\n     ECX <- Reserved = 0;\n     EDX <- Reserved = Misc Feature Flags;\n  BREAK;\n  EAX = 80000008H:\n     EAX <- Reserved = Physical Address Size Information;\n     EBX <- Reserved = Virtual Address Size Information;\n     ECX <- Reserved = 0;\n     EDX <- Reserved = 0;\n  BREAK;\n  EAX >= 40000000H and EAX <= 4FFFFFFFH:\n  DEFAULT: (* EAX = Value outside of recognized range for CPUID. *)\n     (* If the highest basic information leaf data depend on ECX input value, ECX is honored.*)\n     EAX <- Reserved; (* Information returned for highest basic information leaf. *)\n     EBX <- Reserved; (* Information returned for highest basic information leaf. *)\n     ECX <- Reserved; (* Information returned for highest basic information leaf. *)\n     EDX <- Reserved; (* Information returned for highest basic information leaf. *)\n  BREAK;\nESAC;\n\nFlags Affected:\nNone.\n\n\nExceptions (All Operating Modes):\n| #UD| If the LOCK prefix is used. In earlier \n|    | IA-32 processors that do not support   \n|    | the CPUID instruction, execution of    \n|    | the instruction results in an invalid  \n|    | opcode (#UD) exception being generated.\n", 
      "mnem": "CPUID"
    }, 
    {
      "description": "-R:CWD", 
      "mnem": "CQO"
    }, 
    {
      "description": "\nCRC32  -  Accumulate CRC32 Value:\n| Opcode/Instruction                   | Op/En| 64-Bit Mode| Compat/Leg Mode| Description               \n| F2 0F 38 F0 /r CRC32 r32, r/m8       | RM   | Valid      | Valid          | Accumulate CRC32 on r/m8. \n| F2 REX 0F 38 F0 /r CRC32 r32, r/m8*  | RM   | Valid      | N.E.           | Accumulate CRC32 on r/m8. \n| F2 0F 38 F1 /r CRC32 r32, r/m16      | RM   | Valid      | Valid          | Accumulate CRC32 on r/m16.\n| F2 0F 38 F1 /r CRC32 r32, r/m32      | RM   | Valid      | Valid          | Accumulate CRC32 on r/m32.\n| F2 REX.W 0F 38 F0 /r CRC32 r64, r/m8 | RM   | Valid      | N.E.           | Accumulate CRC32 on r/m8. \n| F2 REX.W 0F 38 F1 /r CRC32 r64, r/m64| RM   | Valid      | N.E.           | Accumulate CRC32 on r/m64.\nNotes: *In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nStarting with an initial value in the first operand (destination operand), accumulates\na CRC32 (polynomial 0x11EDC6F41) value for the second operand (source operand)\nand stores the result in the destination operand. The source operand can be\na register or a memory location. The destination operand must be an r32 or r64\nregister. If the destination is an r64 register, then the 32-bit result is stored\nin the least significant double word and 00000000H is stored in the most significant\ndouble word of the r64 register.\n\nThe initial value supplied in the destination operand is a double word integer\nstored in the r32 register or the least significant double word of the r64 register.\nTo incrementally accumulate a CRC32 value, software retains the result of the\nprevious CRC32 operation in the destination operand, then executes the CRC32\ninstruction again with new input data in the source operand. Data contained\nin the source operand is processed in reflected bit order. This means that the\nmost significant bit of the source operand is treated as the least significant\nbit of the quotient, and so on, for all the bits of the source operand. Likewise,\nthe result of the CRC operation is stored in the destination operand in reflected\nbit order. This means that the most significant bit of the resulting CRC (bit\n31) is stored in the least significant bit of the destination operand (bit 0),\nand so on, for all the bits of the CRC.\n\nOperation:\n\nNotes: \n\nBIT_REFLECT64: DST[63-0] = SRC[0-63]BIT_REFLECT32: DST[31-0] = SRC[0-31]BIT_REFLECT16:\nDST[15-0] = SRC[0-15]BIT_REFLECT8: DST[7-0] = SRC[0-7]MOD2: Remainder from Polynomial\ndivision modulus 2\n\nCRC32 instruction for 64-bit source operand and 64-bit destination operand:\n\nTEMP1[63-0] \uf0df BIT_REFLECT64 (SRC[63-0]) TEMP2[31-0] \uf0df BIT_REFLECT32 (DEST[31-0])\nTEMP3[95-0] \uf0df TEMP1[63-0] \u00ab 32 TEMP4[95-0] \uf0df TEMP2[31-0] \u00ab 64 TEMP5[95-0] \uf0df\nTEMP3[95-0] XOR TEMP4[95-0]TEMP6[31-0] \uf0df TEMP5[95-0] MOD2 11EDC6F41H DEST[31-0]\n\uf0df BIT_REFLECT (TEMP6[31-0]) DEST[63-32] \uf0df 00000000H\n\nCRC32 instruction for 32-bit source operand and 32-bit destination operand:\n\nTEMP1[31-0] \uf0df BIT_REFLECT32 (SRC[31-0]) TEMP2[31-0] \uf0df BIT_REFLECT32 (DEST[31-0])\nTEMP3[63-0] \uf0df TEMP1[31-0] \u00ab 32 TEMP4[63-0] \uf0df TEMP2[31-0] \u00ab 32 TEMP5[63-0] \uf0df\nTEMP3[63-0] XOR TEMP4[63-0]TEMP6[31-0] \uf0df TEMP5[63-0] MOD2 11EDC6F41H DEST[31-0]\n\uf0df BIT_REFLECT (TEMP6[31-0])\n\nCRC32 instruction for 16-bit source operand and 32-bit destination operand:\n\nTEMP1[15-0] \uf0df BIT_REFLECT16 (SRC[15-0]) TEMP2[31-0] \uf0df BIT_REFLECT32 (DEST[31-0])\nTEMP3[47-0] \uf0df TEMP1[15-0] \u00ab 32 TEMP4[47-0] \uf0df TEMP2[31-0] \u00ab 16 TEMP5[47-0] \uf0df\nTEMP3[47-0] XOR TEMP4[47-0]TEMP6[31-0] \uf0df TEMP5[47-0] MOD2 11EDC6F41H DEST[31-0]\n\uf0df BIT_REFLECT (TEMP6[31-0])\n\nCRC32 instruction for 8-bit source operand and 64-bit destination operand:\n\nTEMP1[7-0] \uf0df BIT_REFLECT8(SRC[7-0]) TEMP2[31-0] \uf0df BIT_REFLECT32 (DEST[31-0])\nTEMP3[39-0] \uf0df TEMP1[7-0] \u00ab 32 TEMP4[39-0] \uf0df TEMP2[31-0] \u00ab 8 TEMP5[39-0] \uf0df TEMP3[39-0]\nXOR TEMP4[39-0]TEMP6[31-0] \uf0df TEMP5[39-0] MOD2 11EDC6F41H DEST[31-0] \uf0df BIT_REFLECT\n(TEMP6[31-0]) DEST[63-32] \uf0df 00000000H\n\nCRC32 instruction for 8-bit source operand and 32-bit destination operand:\n\nTEMP1[7-0] \uf0df BIT_REFLECT8(SRC[7-0]) TEMP2[31-0] \uf0df BIT_REFLECT32 (DEST[31-0])\nTEMP3[39-0] \uf0df TEMP1[7-0] \u00ab 32 TEMP4[39-0] \uf0df TEMP2[31-0] \u00ab 8 TEMP5[39-0] \uf0df TEMP3[39-0]\nXOR TEMP4[39-0]TEMP6[31-0] \uf0df TEMP5[39-0] MOD2 11EDC6F41H DEST[31-0] \uf0df BIT_REFLECT\n(TEMP6[31-0])\n\n\nFlags Affected:\nNone\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nunsigned int _mm_crc32_u8( unsigned int crc, unsigned char data ) unsigned int\n_mm_crc32_u16( unsigned int crc, unsigned short data ) unsigned int _mm_crc32_u32(\nunsigned int crc, unsigned int data ) unsinged __int64 _mm_crc32_u64( unsinged\n__int64 crc, unsigned __int64 data )\n\n\nSIMD Floating Point Exceptions:\nNone\n\n\nProtected Mode Exceptions:\n| #GP(0)          | If a memory operand effective address\n|                 | is outside the CS, DS, ES, FS or GS  \n|                 | segments.                            \n| #SS(0)          | If a memory operand effective address\n|                 | is outside the SS segment limit.     \n| #PF (fault-code)| For a page fault.                    \n| #AC(0)          | If alignment checking is enabled and \n|                 | an unaligned memory reference is made\n|                 | while the current privilege level is \n|                 | 3.                                   \n| #UD             | If CPUID.01H:ECX.SSE4_2 [Bit 20] = 0.\n|                 | If LOCK prefix is used.              \n\nReal-Address Mode Exceptions:\n| #GP(0)| If any part of the operand lies outside\n|       | of the effective address space from    \n|       | 0 to 0FFFFH.                           \n| #SS(0)| If a memory operand effective address  \n|       | is outside the SS segment limit.       \n| #UD   | If CPUID.01H:ECX.SSE4_2 [Bit 20] = 0.  \n|       | If LOCK prefix is used.                \n\nVirtual 8086 Mode Exceptions:\n| #GP(0)          | If any part of the operand lies outside\n|                 | of the effective address space from    \n|                 | 0 to 0FFFFH.                           \n| #SS(0)          | If a memory operand effective address  \n|                 | is outside the SS segment limit.       \n| #PF (fault-code)| For a page fault.                      \n| #AC(0)          | If alignment checking is enabled and   \n|                 | an unaligned memory reference is made. \n| #UD             | If CPUID.01H:ECX.SSE4_2 [Bit 20] = 0.  \n|                 | If LOCK prefix is used.                \n\nCompatibility Mode Exceptions:\nSame exceptions as in Protected Mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)          | If the memory address is in a non-canonical\n|                 | form.                                      \n| #SS(0)          | If a memory address referencing the        \n|                 | SS segment is in a non-canonical form.     \n| #PF (fault-code)| For a page fault.                          \n| #AC(0)          | If alignment checking is enabled and       \n|                 | an unaligned memory reference is made      \n|                 | while the current privilege level is       \n|                 | 3.                                         \n| #UD             | If CPUID.01H:ECX.SSE4_2 [Bit 20] = 0.      \n|                 | If LOCK prefix is used.                    \n", 
      "mnem": "CRC32"
    }, 
    {
      "description": "\nCVTDQ2PD - Convert Packed Dword Integers to Packed Double-Precision FP Values:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                           \n| F3 0F E6 CVTDQ2PD xmm1, xmm2/m64       | RM   | V/V           | SSE2              | Convert two packed signed doubleword  \n|                                        |      |               |                   | integers from xmm2/m128 to two packed \n|                                        |      |               |                   | double-precision floating-point values\n|                                        |      |               |                   | in xmm1.                              \n| VEX.128.F3.0F.WIG E6 /r VCVTDQ2PD xmm1,| RM   | V/V           | AVX               | Convert two packed signed doubleword  \n| xmm2/m64                               |      |               |                   | integers from xmm2/mem to two packed  \n|                                        |      |               |                   | double-precision floating-point values\n|                                        |      |               |                   | in xmm1.                              \n| VEX.256.F3.0F.WIG E6 /r VCVTDQ2PD ymm1,| RM   | V/V           | AVX               | Convert four packed signed doubleword \n| xmm2/m128                              |      |               |                   | integers from xmm2/mem to four packed \n|                                        |      |               |                   | double-precision floating-point values\n|                                        |      |               |                   | in ymm1.                              \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts two packed signed doubleword integers in the source operand (second\noperand) to two packed doubleprecision floating-point values in the destination\noperand (first operand).\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The source operand is an\nXMM register or 64- bit memory location. The destination operation is an XMM\nregister. The upper bits (VLMAX-1:128) of the corresponding XMM register destination\nare unmodified. VEX.128 encoded version: The source operand is an XMM register\nor 64- bit memory location. The destination operation is an XMM register. The\nupper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or 128- bit memory\nlocation. The destination operation is a YMM register. Note: In VEX-encoded\nversions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will\n#UD.\n\n| SRC X3| X3 X2| X2 X1| X1| X0 X0\nDEST\n\n| Figure 3-10.| CVTDQ2PD (VEX.256 encoded version)\nOperation:\n\nCVTDQ2PD (128-bit Legacy SSE version)\nDEST[63:0] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC[31:0])\nDEST[127:64] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC[63:32])\nDEST[VLMAX-1:128] (unmodified)\nVCVTDQ2PD (VEX.128 encoded version)\nDEST[63:0] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC[31:0])\nDEST[127:64] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC[63:32])\nDEST[VLMAX-1:128] <- 0\nVCVTDQ2PD (VEX.256 encoded version)\nDEST[63:0] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC[31:0])\nDEST[127:64] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC[63:32])\nDEST[191:128] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC[95:64])\nDEST[255:192] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC[127:96)\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTDQ2PD: | __m128d _mm_cvtepi32_pd(__m128i a) \n| VCVTDQ2PD:| __m256d _mm256_cvtepi32_pd (__m128i\n|           | src)                               \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "CVTDQ2PD"
    }, 
    {
      "description": "\nCVTDQ2PS - Convert Packed Dword Integers to Packed Single-Precision FP Values:\n| Opcode/Instruction                  | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                           \n| 0F 5B /r CVTDQ2PS xmm1, xmm2/m128   | RM   | V/V           | SSE2              | Convert four packed signed doubleword \n|                                     |      |               |                   | integers from xmm2/m128 to four packed\n|                                     |      |               |                   | single-precision floating-point values\n|                                     |      |               |                   | in xmm1.                              \n| VEX.128.0F.WIG 5B /r VCVTDQ2PS xmm1,| RM   | V/V           | AVX               | Convert four packed signed doubleword \n| xmm2/m128                           |      |               |                   | integers from xmm2/mem to four packed \n|                                     |      |               |                   | single-precision floating-point values\n|                                     |      |               |                   | in xmm1.                              \n| VEX.256.0F.WIG 5B /r VCVTDQ2PS ymm1,| RM   | V/V           | AVX               | Convert eight packed signed doubleword\n| ymm2/m256                           |      |               |                   | integers from ymm2/mem to eight packed\n|                                     |      |               |                   | single-precision floating-point values\n|                                     |      |               |                   | in ymm1.                              \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts four packed signed doubleword integers in the source operand (second\noperand) to four packed singleprecision floating-point values in the destination\noperand (first operand).\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The source operand is an\nXMM register or 128- bit memory location. The destination operation is an XMM\nregister. The upper bits (VLMAX-1:128) of the corresponding XMM register destination\nare unmodified. VEX.128 encoded version: The source operand is an XMM register\nor 128- bit memory location. The destination operation is an XMM register. The\nupper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory\nlocation. The destination operation is a YMM register. Note: In VEX-encoded\nversions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will\n#UD.\n\nOperation:\n\nCVTDQ2PS (128-bit Legacy SSE version)\nDEST[31:0] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0])\nDEST[63:32] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[63:32])\nDEST[95:64] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[95:64])\nDEST[127:96] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[127z:96)\nDEST[VLMAX-1:128] (unmodified)\nVCVTDQ2PS (VEX.128 encoded version)\nDEST[31:0] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0])\nDEST[63:32] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[63:32])\nDEST[95:64] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[95:64])\nDEST[127:96] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[127z:96)\nDEST[VLMAX-1:128] <- 0\nVCVTDQ2PS (VEX.256 encoded version)\nDEST[31:0] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0])\nDEST[63:32] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[63:32])\nDEST[95:64] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[95:64])\nDEST[127:96] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[127z:96)\nDEST[159:128] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[159:128])\nDEST[191:160] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[191:160])\nDEST[223:192] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[223:192])\nDEST[255:224] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[255:224)\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTDQ2PS: | __m128 _mm_cvtepi32_ps(__m128i a)      \n| VCVTDQ2PS:| __m256 _mm256_cvtepi32_ps (__m256i src)\n\nSIMD Floating-Point Exceptions:\nPrecision.\n\n\nOther Exceptions:\nSee Exceptions Type 2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "CVTDQ2PS"
    }, 
    {
      "description": "\nCVTPD2DQ - Convert Packed Double-Precision FP Values to Packed Dword Integers:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                             \n| F2 0F E6 /r CVTPD2DQ xmm1, xmm2/m128   | RM   | V/V           | SSE2              | Convert two packed double-precision     \n|                                        |      |               |                   | floatingpoint values from xmm2/m128     \n|                                        |      |               |                   | to two packed signed doubleword integers\n|                                        |      |               |                   | in xmm1.                                \n| VEX.128.F2.0F.WIG E6 /r VCVTPD2DQ xmm1,| RM   | V/V           | AVX               | Convert two packed double-precision     \n| xmm2/m128                              |      |               |                   | floatingpoint values in xmm2/mem to     \n|                                        |      |               |                   | two signed doubleword integers in xmm1. \n| VEX.256.F2.0F.WIG E6 /r VCVTPD2DQ xmm1,| RM   | V/V           | AVX               | Convert four packed double-precision    \n| ymm2/m256                              |      |               |                   | floatingpoint values in ymm2/mem to     \n|                                        |      |               |                   | four signed doubleword integers in xmm1.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts two packed double-precision floating-point values in the source operand\n(second operand) to two packed signed doubleword integers in the destination\noperand (first operand).\n\nThe source operand can be an XMM register or a 128-bit memory location. The\ndestination operand is an XMM register. The result is stored in the low quadword\nof the destination operand and the high quadword is cleared to all 0s.\n\nWhen a conversion is inexact, the value returned is rounded according to the\nrounding control bits in the MXCSR register. If a converted result is larger\nthan the maximum signed doubleword integer, the floating-point invalid exception\nis raised, and if this exception is masked, the indefinite integer value (80000000H)\nis returned.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The source operand is an\nXMM register or 128- bit memory location. The destination operation is an XMM\nregister. Bits[127:64] of the destination XMM register are zeroed. However,\nthe upper bits (VLMAX-1:128) of the corresponding YMM register destination are\nunmodified. VEX.128 encoded version: The source operand is an XMM register or\n128- bit memory location. The destination operation is a YMM register. The upper\nbits (VLMAX-1:64) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory\nlocation. The destination operation is an XMM register. The upper bits (255:128)\nof the corresponding YMM register destination are zeroed. Note: In VEX-encoded\nversions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will\n#UD.\n\n| SRC DEST| X3 Figure 3-11.| X2 0 VCVTPD2DQ (VEX.256 encoded version)| X1 X2| X0 X0\nOperation:\n\nCVTPD2DQ (128-bit Legacy SSE version)\nDEST[31:0] <- Convert_Double_Precision_Floating_Point_To_Integer(SRC[63:0])\nDEST[63:32] <- Convert_Double_Precision_Floating_Point_To_Integer(SRC[127:64])\nDEST[127:64] <- 0\nDEST[VLMAX-1:128] (unmodified)\nVCVTPD2DQ (VEX.128 encoded version)\nDEST[31:0] <- Convert_Double_Precision_Floating_Point_To_Integer(SRC[63:0])\nDEST[63:32] <- Convert_Double_Precision_Floating_Point_To_Integer(SRC[127:64])\nDEST[VLMAX-1:64] <- 0\nVCVTPD2DQ (VEX.256 encoded version)\nDEST[31:0] <- Convert_Double_Precision_Floating_Point_To_Integer(SRC[63:0])\nDEST[63:32] <- Convert_Double_Precision_Floating_Point_To_Integer(SRC[127:64])\nDEST[95:64] <- Convert_Double_Precision_Floating_Point_To_Integer(SRC[191:128])\nDEST[127:96] <- Convert_Double_Precision_Floating_Point_To_Integer(SRC[255:192)\nDEST[255:128]<- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTPD2DQ:| __m128i _mm_cvtpd_epi32 (__m128d src)\n| CVTPD2DQ:| __m128i _mm256_cvtpd_epi32 (__m256d  \n|          | src)                                 \n\nSIMD Floating-Point Exceptions:\nInvalid, Precision.\n\n\nOther Exceptions:\nSee Exceptions Type 2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "CVTPD2DQ"
    }, 
    {
      "description": "\nCVTPD2PI - Convert Packed Double-Precision FP Values to Packed Dword Integers:\n| Opcode/Instruction               | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 66 0F 2D /r CVTPD2PI mm, xmm/m128| RM   | Valid      | Valid          | Convert two packed double-precision  \n|                                  |      |            |                | floatingpoint values from xmm/m128 to\n|                                  |      |            |                | two packed signed doubleword integers\n|                                  |      |            |                | in mm.                               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts two packed double-precision floating-point values in the source operand\n(second operand) to two packed signed doubleword integers in the destination\noperand (first operand).\n\nThe source operand can be an XMM register or a 128-bit memory location. The\ndestination operand is an MMX technology register.\n\nWhen a conversion is inexact, the value returned is rounded according to the\nrounding control bits in the MXCSR register. If a converted result is larger\nthan the maximum signed doubleword integer, the floating-point invalid exception\nis raised, and if this exception is masked, the indefinite integer value (80000000H)\nis returned.\n\nThis instruction causes a transition from x87 FPU to MMX technology operation\n(that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word\nis set to all 0s [valid]). If this instruction is executed while an x87 FPU\nfloating-point exception is pending, the exception is handled before the CVTPD2PI\ninstruction is executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nOperation:\n\nDEST[31:0] <- Convert_Double_Precision_Floating_Point_To_Integer32(SRC[63:0]);\nDEST[63:32] <- Convert_Double_Precision_Floating_Point_To_Integer32(SRC[127:64]);\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTPD1PI:| __m64 _mm_cvtpd_pi32(__m128d a)\n\nSIMD Floating-Point Exceptions:\nInvalid, Precision.\n\n\nOther Exceptions:\nSee Table 22-4, \u201cException Conditions for Legacy SIMD/MMX Instructions with\nFP Exception and 16-Byte Alignment,\u201d in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 3B.\n\n", 
      "mnem": "CVTPD2PI"
    }, 
    {
      "description": "\nCVTPD2PS - Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                               \n| 66 0F 5A /r CVTPD2PS xmm1, xmm2/m128   | RM   | V/V           | SSE2              | Convert two packed double-precision       \n|                                        |      |               |                   | floatingpoint values in xmm2/m128 to      \n|                                        |      |               |                   | two packed single-precision floating-point\n|                                        |      |               |                   | values in xmm1.                           \n| VEX.128.66.0F.WIG 5A /r VCVTPD2PS xmm1,| RM   | V/V           | AVX               | Convert two packed double-precision       \n| xmm2/m128                              |      |               |                   | floatingpoint values in xmm2/mem to       \n|                                        |      |               |                   | two singleprecision floating-point values \n|                                        |      |               |                   | in xmm1.                                  \n| VEX.256.66.0F.WIG 5A /r VCVTPD2PS xmm1,| RM   | V/V           | AVX               | Convert four packed double-precision      \n| ymm2/m256                              |      |               |                   | floatingpoint values in ymm2/mem to       \n|                                        |      |               |                   | four singleprecision floating-point       \n|                                        |      |               |                   | values in xmm1.                           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts two packed double-precision floating-point values in the source operand\n(second operand) to two packed single-precision floating-point values in the\ndestination operand (first operand). When a conversion is inexact, the value\nreturned is rounded according to the rounding control bits in the MXCSR register.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The source operand is an\nXMM register or 128- bit memory location. The destination operation is an XMM\nregister. Bits[127:64] of the destination XMM register are zeroed. However,\nthe upper bits (VLMAX-1:128) of the corresponding YMM register destination are\nunmodified. VEX.128 encoded version: The source operand is an XMM register or\n128- bit memory location. The destination operation is a YMM register. The upper\nbits (VLMAX-1:64) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory\nlocation. The destination operation is an XMM register. The upper bits (255:128)\nof the corresponding YMM register destination are zeroed. Note: In VEX-encoded\nversions, VEX.vvvv is reserved and must be 1111b otherwise instructions will\n#UD.\n\n| SRC DEST| X3 Figure 3-12.| X2 0 VCVTPD2PS (VEX.256 encoded version)| X1 X2| X0 X0\nOperation:\n\nCVTPD2PS (128-bit Legacy SSE version)\nDEST[31:0] <- Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[63:0])\nDEST[63:32] <- Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[127:64])\nDEST[127:64] <- 0\nDEST[VLMAX-1:128] (unmodified)\nVCVTPD2PS (VEX.128 encoded version)\nDEST[31:0] <- Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[63:0])\nDEST[63:32] <- Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[127:64])\nDEST[VLMAX-1:64] <- 0\nVCVTPD2PS (VEX.256 encoded version)\nDEST[31:0] <- Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[63:0])\nDEST[63:32] <- Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[127:64])\nDEST[95:64] <- Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[191:128])\nDEST[127:96] <- Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[255:192)\nDEST[255:128]<- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTPD2PS:| __m128 _mm_cvtpd_ps(__m128d a)    \n| CVTPD2PS:| __m256 _mm256_cvtpd_ps (__m256d a)\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "CVTPD2PS"
    }, 
    {
      "description": "\nCVTPI2PD - Convert Packed Dword Integers to Packed Double-Precision FP Values:\n| Opcode/Instruction               | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| 66 0F 2A /r CVTPI2PD xmm, mm/m64*| RM   | Valid      | Valid          | Convert two packed signed doubleword  \n|                                  |      |            |                | integers from mm/mem64 to two packed  \n|                                  |      |            |                | double-precision floating-point values\n|                                  |      |            |                | in xmm.                               \nNotes: *Operation is different for different operand sets; see the Description\nsection.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts two packed signed doubleword integers in the source operand (second\noperand) to two packed doubleprecision floating-point values in the destination\noperand (first operand).\n\nThe source operand can be an MMX technology register or a 64-bit memory location.\nThe destination operand is an XMM register. In addition, depending on the operand\nconfiguration:\n\n - For operands xmm, mm: the instruction causes a transition from x87 FPU to MMX\ntechnology operation (that is, the x87 FPU top-of-stack pointer is set to 0\nand the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed\nwhile an x87 FPU floating-point exception is pending, the exception is handled\nbefore the CVTPI2PD instruction is executed.\n - For operands xmm, m64: the instruction does not cause a transition to MMX technology\nand does not take x87 FPU exceptions.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nOperation:\n\nDEST[63:0] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC[31:0]);\nDEST[127:64] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC[63:32]);\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTPI2PD:| __m128d _mm_cvtpi32_pd(__m64 a)\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Table 22-6, \u201cException Conditions for Legacy SIMD/MMX Instructions with\nXMM and without FP Exception,\u201d in the Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 3B.\n\n", 
      "mnem": "CVTPI2PD"
    }, 
    {
      "description": "\nCVTPI2PS - Convert Packed Dword Integers to Packed Single-Precision FP Values:\n| Opcode/Instruction           | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| 0F 2A /r CVTPI2PS xmm, mm/m64| RM   | Valid      | Valid          | Convert two signed doubleword integers\n|                              |      |            |                | from mm/m64 to two single-precision   \n|                              |      |            |                | floating-point values in xmm.         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts two packed signed doubleword integers in the source operand (second\noperand) to two packed singleprecision floating-point values in the destination\noperand (first operand).\n\nThe source operand can be an MMX technology register or a 64-bit memory location.\nThe destination operand is an XMM register. The results are stored in the low\nquadword of the destination operand, and the high quadword remains unchanged.\nWhen a conversion is inexact, the value returned is rounded according to the\nrounding control bits in the MXCSR register.\n\nThis instruction causes a transition from x87 FPU to MMX technology operation\n(that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word\nis set to all 0s [valid]). If this instruction is executed while an x87 FPU\nfloating-point exception is pending, the exception is handled before the CVTPI2PS\ninstruction is executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nOperation:\n\nDEST[31:0] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0]);\nDEST[63:32] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[63:32]);\n(* High quadword of destination unchanged *)\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTPI2PS:| __m128 _mm_cvtpi32_ps(__m128 a, __m64\n|          | b)                                   \n\nSIMD Floating-Point Exceptions:\nPrecision.\n\n\nOther Exceptions:\nSee Table 22-5, \u201cException Conditions for Legacy SIMD/MMX Instructions with\nXMM and FP Exception,\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3B.\n\n", 
      "mnem": "CVTPI2PS"
    }, 
    {
      "description": "\nCVTPS2DQ - Convert Packed Single-Precision FP Values to Packed Dword Integers:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                              \n| 66 0F 5B /r CVTPS2DQ xmm1, xmm2/m128   | RM   | V/V           | SSE2              | Convert four packed single-precision     \n|                                        |      |               |                   | floatingpoint values from xmm2/m128      \n|                                        |      |               |                   | to four packed signed doubleword integers\n|                                        |      |               |                   | in xmm1.                                 \n| VEX.128.66.0F.WIG 5B /r VCVTPS2DQ xmm1,| RM   | V/V           | AVX               | Convert four packed single precision     \n| xmm2/m128                              |      |               |                   | floatingpoint values from xmm2/mem to    \n|                                        |      |               |                   | four packed signed doubleword values     \n|                                        |      |               |                   | in xmm1.                                 \n| VEX.256.66.0F.WIG 5B /r VCVTPS2DQ ymm1,| RM   | V/V           | AVX               | Convert eight packed single precision    \n| ymm2/m256                              |      |               |                   | floatingpoint values from ymm2/mem to    \n|                                        |      |               |                   | eight packed signed doubleword values    \n|                                        |      |               |                   | in ymm1.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts four or eight packed single-precision floating-point values in the\nsource operand to four or eight signed doubleword integers in the destination\noperand.\n\nWhen a conversion is inexact, the value returned is rounded according to the\nrounding control bits in the MXCSR register. If a converted result is larger\nthan the maximum signed doubleword integer, the floating-point invalid exception\nis raised, and if this exception is masked, the indefinite integer value (80000000H)\nis returned.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The source operand is an\nXMM register or 128- bit memory location. The destination operation is an XMM\nregister. The upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. VEX.128 encoded version: The source operand is an XMM register\nor 128- bit memory location. The destination operation is a YMM register. The\nupper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory\nlocation. The destination operation is a YMM register. Note: In VEX-encoded\nversions, VEX.vvvv is reserved and must be 1111b otherwise instructions will\n#UD.\n\nOperation:\n\nCVTPS2DQ (128-bit Legacy SSE version)\nDEST[31:0] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0])\nDEST[63:32] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[63:32])\nDEST[95:64] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[95:64])\nDEST[127:96] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[127:96])\nDEST[VLMAX-1:128] (unmodified)\nVCVTPS2DQ (VEX.128 encoded version)\nDEST[31:0] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0])\nDEST[63:32] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[63:32])\nDEST[95:64] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[95:64])\nDEST[127:96] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[127:96])\nDEST[VLMAX-1:128] <- 0\nVCVTPS2DQ (VEX.256 encoded version)\nDEST[31:0] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0])\nDEST[63:32] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[63:32])\nDEST[95:64] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[95:64])\nDEST[127:96] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[127:96)\nDEST[159:128] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[159:128])\nDEST[191:160] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[191:160])\nDEST[223:192] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[223:192])\nDEST[255:224] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[255:224])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTPS2DQ: | __m128i _mm_cvtps_epi32(__m128 a)  \n| VCVTPS2DQ:| __ m256i _mm256_cvtps_epi32 (__m256\n|           | a)                                 \n\nSIMD Floating-Point Exceptions:\nInvalid, Precision.\n\n\nOther Exceptions:\nSee Exceptions Type 2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "CVTPS2DQ"
    }, 
    {
      "description": "\nCVTPS2PD - Convert Packed Single-Precision FP Values to Packed Double-Precision FP Values:\n| Opcode/Instruction                  | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| 0F 5A /r CVTPS2PD xmm1, xmm2/m64    | RM   | V/V           | SSE2              | Convert two packed single-precision        \n|                                     |      |               |                   | floatingpoint values in xmm2/m64 to        \n|                                     |      |               |                   | two packed double-precision floating-point \n|                                     |      |               |                   | values in xmm1.                            \n| VEX.128.0F.WIG 5A /r VCVTPS2PD xmm1,| RM   | V/V           | AVX               | Convert two packed single-precision        \n| xmm2/m64                            |      |               |                   | floatingpoint values in xmm2/mem to        \n|                                     |      |               |                   | two packed double-precision floating-point \n|                                     |      |               |                   | values in xmm1.                            \n| VEX.256.0F.WIG 5A /r VCVTPS2PD ymm1,| RM   | V/V           | AVX               | Convert four packed single-precision       \n| xmm2/m128                           |      |               |                   | floatingpoint values in xmm2/mem to        \n|                                     |      |               |                   | four packed double-precision floating-point\n|                                     |      |               |                   | values in ymm1.                            \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts two or four packed single-precision floating-point values in the source\noperand (second operand) to two or four packed double-precision floating-point\nvalues in the destination operand (first operand).\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The source operand is an\nXMM register or 64- bit memory location. The destination operation is an XMM\nregister. The upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. VEX.128 encoded version: The source operand is an XMM register\nor 64- bit memory location. The destination operation is a YMM register. The\nupper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is an XMM register or 128- bit memory\nlocation. The destination operation is a YMM register. Note: In VEX-encoded\nversions, VEX.vvvv is reserved and must be 1111b otherwise instructions will\n#UD.\n\n| SRC X3| X3 X2| X2 X1| X1| X0 X0\nDEST\n\n| Figure 3-13.| CVTPS2PD (VEX.256 encoded version)\nOperation:\n\nCVTPS2PD (128-bit Legacy SSE version)\nDEST[63:0] <- Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[31:0])\nDEST[127:64] <- Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[63:32])\nDEST[VLMAX-1:128] (unmodified)\nVCVTPS2PD (VEX.128 encoded version)\nDEST[63:0] <- Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[31:0])\nDEST[127:64] <- Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[63:32])\nDEST[VLMAX-1:128] <- 0\nVCVTPS2PD (VEX.256 encoded version)\nDEST[63:0] <- Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[31:0])\nDEST[127:64] <- Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[63:32])\nDEST[191:128] <- Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[95:64])\nDEST[255:192] <- Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[127:96)\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTPS2PD: | __m128d _mm_cvtps_pd(__m128 a)    \n| VCVTPS2PD:| __m256d _mm256_cvtps_pd (__m128 a)\n\nSIMD Floating-Point Exceptions:\nInvalid, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3; additionally\n\n#UDIf VEX.vvvv != 1111B.\n\n", 
      "mnem": "CVTPS2PD"
    }, 
    {
      "description": "\nCVTPS2PI - Convert Packed Single-Precision FP Values to Packed Dword Integers:\n| Opcode/Instruction           | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F 2D /r CVTPS2PI mm, xmm/m64| RM   | Valid      | Valid          | Convert two packed single-precision  \n|                              |      |            |                | floatingpoint values from xmm/m64 to \n|                              |      |            |                | two packed signed doubleword integers\n|                              |      |            |                | in mm.                               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts two packed single-precision floating-point values in the source operand\n(second operand) to two packed signed doubleword integers in the destination\noperand (first operand).\n\nThe source operand can be an XMM register or a 128-bit memory location. The\ndestination operand is an MMX technology register. When the source operand is\nan XMM register, the two single-precision floating-point values are contained\nin the low quadword of the register. When a conversion is inexact, the value\nreturned is rounded according to the rounding control bits in the MXCSR register.\nIf a converted result is larger than the maximum signed doubleword integer,\nthe floating-point invalid exception is raised, and if this exception is masked,\nthe indefinite integer value (80000000H) is returned.\n\nCVTPS2PI causes a transition from x87 FPU to MMX technology operation (that\nis, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is\nset to all 0s [valid]). If this instruction is executed while an x87 FPU floatingpoint\nexception is pending, the exception is handled before the CVTPS2PI instruction\nis executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nOperation:\n\nDEST[31:0] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0]);\nDEST[63:32] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[63:32]);\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTPS2PI:| __m64 _mm_cvtps_pi32(__m128 a)\n\nSIMD Floating-Point Exceptions:\nInvalid, Precision.\n\n\nOther Exceptions:\nSee Table 22-5, \u201cException Conditions for Legacy SIMD/MMX Instructions with\nXMM and FP Exception,\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3B.\n\n", 
      "mnem": "CVTPS2PI"
    }, 
    {
      "description": "\nCVTSD2SI - Convert Scalar Double-Precision FP Value to Integer:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                 \n| F2 0F 2D /r CVTSD2SI r32, xmm/m64      | RM   | V/V           | SSE2              | Convert one double-precision floating-point \n|                                        |      |               |                   | value from xmm/m64 to one signed doubleword \n|                                        |      |               |                   | integer r32.                                \n| F2 REX.W 0F 2D /r CVTSD2SI r64, xmm/m64| RM   | V/N.E.        | SSE2              | Convert one double-precision floating-point \n|                                        |      |               |                   | value from xmm/m64 to one signed quadword   \n|                                        |      |               |                   | integer sign-extended into r64.             \n| VEX.LIG.F2.0F.W0 2D /r VCVTSD2SI r32,  | RM   | V/V           | AVX               | Convert one double precision floating-point \n| xmm1/m64                               |      |               |                   | value from xmm1/m64 to one signed doubleword\n|                                        |      |               |                   | integer r32.                                \n| VEX.LIG.F2.0F.W1 2D /r VCVTSD2SI r64,  | RM   | V/N.E.1       | AVX               | Convert one double precision floating-point \n| xmm1/m64                               |      |               |                   | value from xmm1/m64 to one signed quadword  \n|                                        |      |               |                   | integer sign-extended into r64.             \nNotes: 1. Encoding the VEX prefix with VEX.W=1 in non-64-bit mode is ignored.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts a double-precision floating-point value in the source operand (second\noperand) to a signed doubleword integer in the destination operand (first operand).\nThe source operand can be an XMM register or a 64-bit memory location. The destination\noperand is a general-purpose register. When the source operand is an XMM register,\nthe double-precision floating-point value is contained in the low quadword of\nthe register.\n\nWhen a conversion is inexact, the value returned is rounded according to the\nrounding control bits in the MXCSR register. If a converted result is larger\nthan the maximum signed doubleword integer, the floating-point invalid exception\nis raised, and if this exception is masked, the indefinite integer value (80000000H)\nis returned.\n\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15,\nR8-R15) when used with a REX.R prefix. Use of the REX.W prefix promotes the\ninstruction to 64-bit operation. See the summary chart at the beginning of this\nsection for encoding data and limits. Legacy SSE instructions: Use of the REX.W\nprefix promotes the instruction to 64-bit operation. See the summary chart at\nthe beginning of this section for encoding data and limits. Note: In VEX-encoded\nversions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will\n#UD.\n\nOperation:\n\nIF 64-Bit Mode and OperandSize = 64\n  THEN\n     DEST[63:0] <- Convert_Double_Precision_Floating_Point_To_Integer64(SRC[63:0]);\n  ELSE\n     DEST[31:0] <- Convert_Double_Precision_Floating_Point_To_Integer32(SRC[63:0]);\nFI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nint _mm_cvtsd_si32(__m128d a) __int64 _mm_cvtsd_si64(__m128d a)\n\n\nSIMD Floating-Point Exceptions:\nInvalid, Precision.\n\n\nOther Exceptions:\nSee Exceptions Type 3; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "CVTSD2SI"
    }, 
    {
      "description": "\nCVTSD2SS - Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value:\n| Opcode/Instruction                   | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| F2 0F 5A /r CVTSD2SS xmm1, xmm2/m64  | RM   | V/V           | SSE2              | Convert one double-precision floating-point\n|                                      |      |               |                   | value in xmm2/m64 to one single-precision  \n|                                      |      |               |                   | floating-point value in xmm1.              \n| VEX.NDS.LIG.F2.0F.WIG 5A /r VCVTSD2SS| RVM  | V/V           | AVX               | Convert one double-precision floating-point\n| xmm1,xmm2, xmm3/m64                  |      |               |                   | value in xmm3/m64 to one single-precision  \n|                                      |      |               |                   | floating-point value and merge with        \n|                                      |      |               |                   | high bits in xmm2.                         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nConverts a double-precision floating-point value in the source operand (second\noperand) to a single-precision floating-point value in the destination operand\n(first operand).\n\nThe source operand can be an XMM register or a 64-bit memory location. The destination\noperand is an XMM register. When the source operand is an XMM register, the\ndouble-precision floating-point value is contained in the low quadword of the\nregister. The result is stored in the low doubleword of the destination operand,\nand the upper 3 doublewords are left unchanged. When the conversion is inexact,\nthe value returned is rounded according to the rounding control bits in the\nMXCSR register.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The destination and first\nsource operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: Bits (127:64) of the XMM\nregister destination are copied from corresponding bits in the first source\noperand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nOperation:\n\nCVTSD2SS (128-bit Legacy SSE version)\nDEST[31:0] <- Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[63:0]);\n(* DEST[VLMAX-1:32] Unmodified *)\nVCVTSD2SS (VEX.128 encoded version)\nDEST[31:0] <- Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC2[63:0]);\nDEST[127:32] <- SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTSD2SS:| __m128 _mm_cvtsd_ss(__m128 a, __m128d\n|          | b)                                   \n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "CVTSD2SS"
    }, 
    {
      "description": "\nCVTSI2SD - Convert Dword Integer to Scalar Double-Precision FP Value:\n| Opcode/Instruction                   | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                      \n| F2 0F 2A /r CVTSI2SD xmm, r/m32      | RM   | V/V           | SSE2              | Convert one signed doubleword integer            \n|                                      |      |               |                   | from r/m32 to one double-precision floating-point\n|                                      |      |               |                   | value in xmm.                                    \n| F2 REX.W 0F 2A /r CVTSI2SD xmm, r/m64| RM   | V/N.E.        | SSE2              | Convert one signed quadword integer              \n|                                      |      |               |                   | from r/m64 to one double-precision floating-point\n|                                      |      |               |                   | value in xmm.                                    \n| VEX.NDS.LIG.F2.0F.W0 2A /r VCVTSI2SD | RVM  | V/V           | AVX               | Convert one signed doubleword integer            \n| xmm1, xmm2, r/m32                    |      |               |                   | from r/m32 to one double-precision floating-point\n|                                      |      |               |                   | value in xmm1.                                   \n| VEX.NDS.LIG.F2.0F.W1 2A /r VCVTSI2SD | RVM  | V/N.E.1       | AVX               | Convert one signed quadword integer              \n| xmm1, xmm2, r/m64                    |      |               |                   | from r/m64 to one double-precision floating-point\n|                                      |      |               |                   | value in xmm1.                                   \nNotes: 1. Encoding the VEX prefix with VEX.W=1 in non-64-bit mode is ignored.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nConverts a signed doubleword integer (or signed quadword integer if operand\nsize is 64 bits) in the second source operand to a double-precision floating-point\nvalue in the destination operand. The result is stored in the low quadword of\nthe destination operand, and the high quadword left unchanged. When conversion\nis inexact, the value returned is rounded according to the rounding control\nbits in the MXCSR register. Legacy SSE instructions: Use of the REX.W prefix\npromotes the instruction to 64-bit operands. See the summary chart at the beginning\nof this section for encoding data and limits. The second source operand can\nbe a general-purpose register or a 32/64-bit memory location. The first source\nand destination operands are XMM registers. 128-bit Legacy SSE version: The\ndestination and first source operand are the same. Bits (VLMAX-1:64) of the\ncorresponding YMM destination register remain unchanged. VEX.128 encoded version:\nBits (127:64) of the XMM register destination are copied from corresponding\nbits in the first source operand. Bits (VLMAX-1:128) of the destination YMM\nregister are zeroed.\n\nOperation:\n\nCVTSI2SD\nIF 64-Bit Mode And OperandSize = 64\nTHEN\n  DEST[63:0] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC[63:0]);\nELSE\n  DEST[63:0] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC[31:0]);\nFI;\nDEST[VLMAX-1:64] (Unmodified)\nVCVTSI2SD\nIF 64-Bit Mode And OperandSize = 64\nTHEN\n  DEST[63:0] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC2[63:0]);\nELSE\n  DEST[63:0] <- Convert_Integer_To_Double_Precision_Floating_Point(SRC2[31:0]);\nFI;\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTSI2SD:| __m128d _mm_cvtsi32_sd(__m128d a, int    \n|          | b)                                       \n| CVTSI2SD:| __m128d _mm_cvtsi64_sd(__m128d a, __int64\n|          | b)                                       \n\nSIMD Floating-Point Exceptions:\nPrecision.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "CVTSI2SD"
    }, 
    {
      "description": "\nCVTSI2SS - Convert Dword Integer to Scalar Single-Precision FP Value:\n| Opcode/Instruction                   | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                      \n| F3 0F 2A /r CVTSI2SS xmm, r/m32      | RM   | V/V           | SSE               | Convert one signed doubleword integer            \n|                                      |      |               |                   | from r/m32 to one single-precision floating-point\n|                                      |      |               |                   | value in xmm.                                    \n| F3 REX.W 0F 2A /r CVTSI2SS xmm, r/m64| RM   | V/N.E.        | SSE               | Convert one signed quadword integer              \n|                                      |      |               |                   | from r/m64 to one single-precision floating-point\n|                                      |      |               |                   | value in xmm.                                    \n| VEX.NDS.LIG.F3.0F.W0 2A /r VCVTSI2SS | RVM  | V/V           | AVX               | Convert one signed doubleword integer            \n| xmm1, xmm2, r/m32                    |      |               |                   | from r/m32 to one single-precision floating-point\n|                                      |      |               |                   | value in xmm1.                                   \n| VEX.NDS.LIG.F3.0F.W1 2A /r VCVTSI2SS | RVM  | V/N.E.1       | AVX               | Convert one signed quadword integer              \n| xmm1, xmm2, r/m64                    |      |               |                   | from r/m64 to one single-precision floating-point\n|                                      |      |               |                   | value in xmm1.                                   \nNotes: 1. Encoding the VEX prefix with VEX.W=1 in non-64-bit mode is ignored.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nConverts a signed doubleword integer (or signed quadword integer if operand\nsize is 64 bits) in the source operand (second operand) to a single-precision\nfloating-point value in the destination operand (first operand). The source\noperand can be a general-purpose register or a memory location. The destination\noperand is an XMM register. The result is stored in the low doubleword of the\ndestination operand, and the upper three doublewords are left unchanged. When\na conversion is inexact, the value returned is rounded according to the rounding\ncontrol bits in the MXCSR register.\n\nLegacy SSE instructions: In 64-bit mode, the instruction can access additional\nregisters (XMM8-XMM15, R8-R15) when used with a REX.R prefix. Use of the REX.W\nprefix promotes the instruction to 64-bit operands. See the summary chart at\nthe beginning of this section for encoding data and limits.\n\n128-bit Legacy SSE version: The destination and first source operand are the\nsame. Bits (VLMAX-1:32) of the corresponding YMM destination register remain\nunchanged. VEX.128 encoded version: Bits (127:32) of the XMM register destination\nare copied from corresponding bits in the first source operand. Bits (VLMAX-1:128)\nof the destination YMM register are zeroed.\n\nOperation:\n\nCVTSI2SS (128-bit Legacy SSE version)\nIF 64-Bit Mode And OperandSize = 64\nTHEN\n  DEST[31:0] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[63:0]);\nELSE\n  DEST[31:0] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0]);\nFI;\nDEST[VLMAX-1:32] (Unmodified)\nVCVTSI2SS (VEX.128 encoded version)\nIF 64-Bit Mode And OperandSize = 64\nTHEN\n  DEST[31:0] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[63:0]);\nELSE\n  DEST[31:0] <- Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0]);\nFI;\nDEST[127:32] <- SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTSI2SS:| __m128| _mm_cvtsi32_ss(__m128| a, int b)    \n| CVTSI2SS:| __m128| _mm_cvtsi64_ss(__m128| a, __int64 b)\n\nSIMD Floating-Point Exceptions:\nPrecision.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "CVTSI2SS"
    }, 
    {
      "description": "\nCVTSS2SD - Convert Scalar Single-Precision FP Value to Scalar Double-Precision FP Value:\n| Opcode/Instruction                   | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| F3 0F 5A /r CVTSS2SD xmm1, xmm2/m32  | RM   | V/V           | SSE2              | Convert one single-precision floating-point\n|                                      |      |               |                   | value in xmm2/m32 to one double-precision  \n|                                      |      |               |                   | floating-point value in xmm1.              \n| VEX.NDS.LIG.F3.0F.WIG 5A /r VCVTSS2SD| RVM  | V/V           | AVX               | Convert one single-precision floating-point\n| xmm1, xmm2, xmm3/m32                 |      |               |                   | value in xmm3/m32 to one double-precision  \n|                                      |      |               |                   | floating-point value and merge with        \n|                                      |      |               |                   | high bits of xmm2.                         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nConverts a single-precision floating-point value in the source operand (second\noperand) to a double-precision floating-point value in the destination operand\n(first operand). The source operand can be an XMM register or a 32bit memory\nlocation. The destination operand is an XMM register. When the source operand\nis an XMM register, the single-precision floating-point value is contained in\nthe low doubleword of the register. The result is stored in the low quadword\nof the destination operand, and the high quadword is left unchanged.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The destination and first\nsource operand are the same. Bits (VLMAX-1:64) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: Bits (127:64) of the XMM\nregister destination are copied from corresponding bits in the first source\noperand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nOperation:\n\nCVTSS2SD (128-bit Legacy SSE version)\nDEST[63:0] <- Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[31:0]);\nDEST[VLMAX-1:64] (Unmodified)\nVCVTSS2SD (VEX.128 encoded version)\nDEST[63:0] <- Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC2[31:0])\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTSS2SD:| __m128d _mm_cvtss_sd(__m128d a, __m128\n|          | b)                                    \n\nSIMD Floating-Point Exceptions:\nInvalid, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "CVTSS2SD"
    }, 
    {
      "description": "\nCVTSS2SI - Convert Scalar Single-Precision FP Value to Dword Integer:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                 \n| F3 0F 2D /r CVTSS2SI r32, xmm/m32      | RM   | V/V           | SSE               | Convert one single-precision floating-point \n|                                        |      |               |                   | value from xmm/m32 to one signed doubleword \n|                                        |      |               |                   | integer in r32.                             \n| F3 REX.W 0F 2D /r CVTSS2SI r64, xmm/m32| RM   | V/N.E.        | SSE               | Convert one single-precision floating-point \n|                                        |      |               |                   | value from xmm/m32 to one signed quadword   \n|                                        |      |               |                   | integer in r64.                             \n| VEX.LIG.F3.0F.W0 2D /r VCVTSS2SI r32,  | RM   | V/V           | AVX               | Convert one single-precision floating-point \n| xmm1/m32                               |      |               |                   | value from xmm1/m32 to one signed doubleword\n|                                        |      |               |                   | integer in r32.                             \n| VEX.LIG.F3.0F.W1 2D /r VCVTSS2SI r64,  | RM   | V/N.E.1       | AVX               | Convert one single-precision floating-point \n| xmm1/m32                               |      |               |                   | value from xmm1/m32 to one signed quadword  \n|                                        |      |               |                   | integer in r64.                             \nNotes: 1. Encoding the VEX prefix with VEX.W=1 in non-64-bit mode is ignored.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts a single-precision floating-point value in the source operand (second\noperand) to a signed doubleword integer (or signed quadword integer if operand\nsize is 64 bits) in the destination operand (first operand). The source operand\ncan be an XMM register or a memory location. The destination operand is a general-purpose\nregister. When the source operand is an XMM register, the single-precision floating-point\nvalue is contained in the low doubleword of the register.\n\nWhen a conversion is inexact, the value returned is rounded according to the\nrounding control bits in the MXCSR register. If a converted result is larger\nthan the maximum signed doubleword integer, the floating-point invalid exception\nis raised, and if this exception is masked, the indefinite integer value (80000000H)\nis returned.\n\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15,\nR8-R15) when used with a REX.R prefix. Use of the REX.W prefix promotes the\ninstruction to 64-bit operands. See the summary chart at the beginning of this\nsection for encoding data and limits. Legacy SSE instructions: In 64-bit mode,\nUse of the REX.W prefix promotes the instruction to 64-bit operands. See the\nsummary chart at the beginning of this section for encoding data and limits.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise\ninstructions will #UD.\n\nOperation:\n\nIF 64-bit Mode and OperandSize = 64\n  THEN\n     DEST[64:0] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0]);\n  ELSE\n     DEST[31:0] <- Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0]);\nFI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nint _mm_cvtss_si32(__m128d a) __int64 _mm_cvtss_si64(__m128d a)\n\n\nSIMD Floating-Point Exceptions:\nInvalid, Precision.\n\n\nOther Exceptions:\nSee Exceptions Type 3; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "CVTSS2SI"
    }, 
    {
      "description": "\nCVTTPD2DQ - Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                             \n| 66 0F E6 /r CVTTPD2DQ xmm1, xmm2/m128   | RM   | V/V           | SSE2              | Convert two packed double-precision     \n|                                         |      |               |                   | floatingpoint values from xmm2/m128     \n|                                         |      |               |                   | to two packed signed doubleword integers\n|                                         |      |               |                   | in xmm1 using truncation.               \n| VEX.128.66.0F.WIG E6 /r VCVTTPD2DQ xmm1,| RM   | V/V           | AVX               | Convert two packed double-precision     \n| xmm2/m128                               |      |               |                   | floatingpoint values in xmm2/mem to     \n|                                         |      |               |                   | two signed doubleword integers in xmm1  \n|                                         |      |               |                   | using truncation.                       \n| VEX.256.66.0F.WIG E6 /r VCVTTPD2DQ xmm1,| RM   | V/V           | AVX               | Convert four packed double-precision    \n| ymm2/m256                               |      |               |                   | floatingpoint values in ymm2/mem to     \n|                                         |      |               |                   | four signed doubleword integers in xmm1 \n|                                         |      |               |                   | using truncation.                       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts two or four packed double-precision floating-point values in the source\noperand (second operand) to two or four packed signed doubleword integers in\nthe destination operand (first operand). When a conversion is inexact, a truncated\n(round toward zero) value is returned.If a converted result is larger than the\nmaximum signed doubleword integer, the floating-point invalid exception is raised,\nand if this exception is masked, the indefinite integer value (80000000H) is\nreturned.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The source operand is an\nXMM register or 128- bit memory location. The destination operation is an XMM\nregister. The upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. VEX.128 encoded version: The source operand is an XMM register\nor 128- bit memory location. The destination operation is a YMM register. The\nupper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory\nlocation. The destination operation is an XMM register. The upper bits (255:128)\nof the corresponding YMM register destination are zeroed. Note: In VEX-encoded\nversions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will\n#UD.\n\n| SRC DEST| X3 Figure 3-14.| X2 0 VCVTTPD2DQ (VEX.256 encoded version)| X1 X2| X0 X0\nOperation:\n\nCVTTPD2DQ (128-bit Legacy SSE version)\nDEST[31:0] <- Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[63:0])\nDEST[63:32] <- Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[127:64])\nDEST[127:64] <- 0\nDEST[VLMAX-1:128] (unmodified)\nVCVTTPD2DQ (VEX.128 encoded version)\nDEST[31:0] <- Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[63:0])\nDEST[63:32] <- Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[127:64])\nDEST[VLMAX-1:64] <- 0\nVCVTTPD2DQ (VEX.256 encoded version)\nDEST[31:0] <- Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[63:0])\nDEST[63:32] <- Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[127:64])\nDEST[95:64] <- Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[191:128])\nDEST[127:96] <- Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[255:192)\nDEST[255:128]<- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTTPD2DQ: | __m128i _mm_cvttpd_epi32(__m128d a) \n| VCVTTPD2DQ:| __m128i _mm256_cvttpd_epi32 (__m256d\n|            | src)                                \n\nSIMD Floating-Point Exceptions:\nInvalid, Precision.\n\n\nOther Exceptions:\nSee Exceptions Type 2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "CVTTPD2DQ"
    }, 
    {
      "description": "\nCVTTPD2PI - Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers:\n| Opcode/Instruction                | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 66 0F 2C /r CVTTPD2PI mm, xmm/m128| RM   | Valid      | Valid          | Convert two packer double-precision  \n|                                   |      |            |                | floatingpoint values from xmm/m128 to\n|                                   |      |            |                | two packed signed doubleword integers\n|                                   |      |            |                | in mm using truncation.              \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts two packed double-precision floating-point values in the source operand\n(second operand) to two packed signed doubleword integers in the destination\noperand (first operand). The source operand can be an XMM register or a 128-bit\nmemory location. The destination operand is an MMX technology register.\n\nWhen a conversion is inexact, a truncated (round toward zero) result is returned.\nIf a converted result is larger than the maximum signed doubleword integer,\nthe floating-point invalid exception is raised, and if this exception is masked,\nthe indefinite integer value (80000000H) is returned.\n\nThis instruction causes a transition from x87 FPU to MMX technology operation\n(that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word\nis set to all 0s [valid]). If this instruction is executed while an x87 FPU\nfloating-point exception is pending, the exception is handled before the CVTTPD2PI\ninstruction is executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nOperation:\n\nDEST[31:0] <- Convert_Double_Precision_Floating_Point_To_Integer32_Truncate(SRC[63:0]);\nDEST[63:32] <- Convert_Double_Precision_Floating_Point_To_Integer32_\n          Truncate(SRC[127:64]);\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTTPD1PI:| __m64 _mm_cvttpd_pi32(__m128d a)\n\nSIMD Floating-Point Exceptions:\nInvalid, Precision.\n\n\nOther Mode Exceptions:\nSee Table 22-4, \u201cException Conditions for Legacy SIMD/MMX Instructions with\nFP Exception and 16-Byte Alignment,\u201d in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 3B.\n\n", 
      "mnem": "CVTTPD2PI"
    }, 
    {
      "description": "\nCVTTPS2DQ - Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                  \n| F3 0F 5B /r CVTTPS2DQ xmm1, xmm2/m128   | RM   | V/V           | SSE2              | Convert four single-precision floating-point \n|                                         |      |               |                   | values from xmm2/m128 to four signed         \n|                                         |      |               |                   | doubleword integers in xmm1 using truncation.\n| VEX.128.F3.0F.WIG 5B /r VCVTTPS2DQ xmm1,| RM   | V/V           | AVX               | Convert four packed single precision         \n| xmm2/m128                               |      |               |                   | floatingpoint values from xmm2/mem to        \n|                                         |      |               |                   | four packed signed doubleword values         \n|                                         |      |               |                   | in xmm1 using truncation.                    \n| VEX.256.F3.0F.WIG 5B /r VCVTTPS2DQ ymm1,| RM   | V/V           | AVX               | Convert eight packed single precision        \n| ymm2/m256                               |      |               |                   | floatingpoint values from ymm2/mem to        \n|                                         |      |               |                   | eight packed signed doubleword values        \n|                                         |      |               |                   | in ymm1 using truncation.                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts four or eight packed single-precision floating-point values in the\nsource operand to four or eight signed doubleword integers in the destination\noperand. When a conversion is inexact, a truncated (round toward zero) value\nis returned.If a converted result is larger than the maximum signed doubleword\ninteger, the floating-point invalid exception is raised, and if this exception\nis masked, the indefinite integer value (80000000H) is returned.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The source operand is an\nXMM register or 128- bit memory location. The destination operation is an XMM\nregister. The upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. VEX.128 encoded version: The source operand is an XMM register\nor 128- bit memory location. The destination operation is a YMM register. The\nupper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory\nlocation. The destination operation is a YMM register. Note: In VEX-encoded\nversions, VEX.vvvv is reserved and must be 1111b otherwise instructions will\n#UD.\n\nOperation:\n\nCVTTPS2DQ (128-bit Legacy SSE version)\nDEST[31:0] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31:0])\nDEST[63:32] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[63:32])\nDEST[95:64] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[95:64])\nDEST[127:96] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[127:96])\nDEST[VLMAX-1:128] (unmodified)\nVCVTTPS2DQ (VEX.128 encoded version)\nDEST[31:0] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31:0])\nDEST[63:32] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[63:32])\nDEST[95:64] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[95:64])\nDEST[127:96] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[127:96])\nDEST[VLMAX-1:128] <- 0\nVCVTTPS2DQ (VEX.256 encoded version)\nDEST[31:0] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31:0])\nDEST[63:32] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[63:32])\nDEST[95:64] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[95:64])\nDEST[127:96] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[127:96)\nDEST[159:128] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[159:128])\nDEST[191:160] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[191:160])\nDEST[223:192] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[223:192])\nDEST[255:224] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[255:224])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTTPS2DQ: | __m128i _mm_cvttps_epi32(__m128 a) \n| VCVTTPS2DQ:| __m256i _mm256_cvttps_epi32 (__m256\n|            | a)                                 \n\nSIMD Floating-Point Exceptions:\nInvalid, Precision.\n\n\nOther Exceptions:\nSee Exceptions Type 2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "CVTTPS2DQ"
    }, 
    {
      "description": "\nCVTTPS2PI - Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers:\n| Opcode/Instruction            | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                 \n| 0F 2C /r CVTTPS2PI mm, xmm/m64| RM   | Valid      | Valid          | Convert two single-precision floating-point \n|                               |      |            |                | values from xmm/m64 to two signed doubleword\n|                               |      |            |                | signed integers in mm using truncation.     \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts two packed single-precision floating-point values in the source operand\n(second operand) to two packed signed doubleword integers in the destination\noperand (first operand). The source operand can be an XMM register or a 64-bit\nmemory location. The destination operand is an MMX technology register. When\nthe source operand is an XMM register, the two single-precision floating-point\nvalues are contained in the low quadword of the register.\n\nWhen a conversion is inexact, a truncated (round toward zero) result is returned.\nIf a converted result is larger than the maximum signed doubleword integer,\nthe floating-point invalid exception is raised, and if this exception is masked,\nthe indefinite integer value (80000000H) is returned.\n\nThis instruction causes a transition from x87 FPU to MMX technology operation\n(that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word\nis set to all 0s [valid]). If this instruction is executed while an x87 FPU\nfloating-point exception is pending, the exception is handled before the CVTTPS2PI\ninstruction is executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nOperation:\n\nDEST[31:0] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31:0]);\nDEST[63:32] <- Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[63:32]);\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| CVTTPS2PI:| __m64 _mm_cvttps_pi32(__m128 a)\n\nSIMD Floating-Point Exceptions:\nInvalid, Precision.\n\n\nOther Exceptions:\nSee Table 22-5, \u201cException Conditions for Legacy SIMD/MMX Instructions with\nXMM and FP Exception,\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3B.\n\n", 
      "mnem": "CVTTPS2PI"
    }, 
    {
      "description": "\nCVTTSD2SI - Convert with Truncation Scalar Double-Precision FP Value to Signed Integer:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                 \n| F2 0F 2C /r CVTTSD2SI r32, xmm/m64      | RM   | V/V           | SSE2              | Convert one double-precision floating-point \n|                                         |      |               |                   | value from xmm/m64 to one signed doubleword \n|                                         |      |               |                   | integer in r32 using truncation.            \n| F2 REX.W 0F 2C /r CVTTSD2SI r64, xmm/m64| RM   | V/N.E.        | SSE2              | Convert one double precision floating-point \n|                                         |      |               |                   | value from xmm/m64 to one signedquadword    \n|                                         |      |               |                   | integer in r64 using truncation.            \n| VEX.LIG.F2.0F.W0 2C /r VCVTTSD2SI r32,  | RM   | V/V           | AVX               | Convert one double-precision floating-point \n| xmm1/m64                                |      |               |                   | value from xmm1/m64 to one signed doubleword\n|                                         |      |               |                   | integer in r32 using truncation.            \n| VEX.LIG.F2.0F.W1 2C /r VCVTTSD2SI r64,  | RM   | V/N.E.1       | AVX               | Convert one double precision floating-point \n| xmm1/m64                                |      |               |                   | value from xmm1/m64 to one signed quadword  \n|                                         |      |               |                   | integer in r64 using truncation.            \nNotes: 1. Encoding the VEX prefix with VEX.W=1 in non-64-bit mode is ignored.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts a double-precision floating-point value in the source operand (second\noperand) to a signed doubleword integer (or signed quadword integer if operand\nsize is 64 bits) in the destination operand (first operand). The source operand\ncan be an XMM register or a 64-bit memory location. The destination operand\nis a general purpose register. When the source operand is an XMM register, the\ndouble-precision floating-point value is contained in the low quadword of the\nregister. When a conversion is inexact, a truncated (round toward zero) result\nis returned. If a converted result is larger than the maximum signed doubleword\ninteger, the floating point invalid exception is raised. If this exception is\nmasked, the indefinite integer value (80000000H) is returned. Legacy SSE instructions:\nIn 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation.\nSee the summary chart at the beginning of this section for encoding data and\nlimits. Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b,\notherwise instructions will #UD.\n\nOperation:\n\nIF 64-Bit Mode and OperandSize = 64\n  THEN\n     DEST[63:0] <- Convert_Double_Precision_Floating_Point_To_\n              Integer64_Truncate(SRC[63:0]);\n  ELSE\n     DEST[31:0] <- Convert_Double_Precision_Floating_Point_To_\n             Integer32_Truncate(SRC[63:0]);\nFI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nint _mm_cvttsd_si32(__m128d a) __int64 _mm_cvttsd_si64(__m128d a)\n\n\nSIMD Floating-Point Exceptions:\nInvalid, Precision.\n\n\nOther Exceptions:\nSee Exceptions Type 3; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "CVTTSD2SI"
    }, 
    {
      "description": "\nCVTTSS2SI - Convert with Truncation Scalar Single-Precision FP Value to Dword Integer:\n| Opcode/Instruction                      | Op/ En| 64/32-bit Mode| CPUID Feature Flag| Description                                 \n| F3 0F 2C /r CVTTSS2SI r32, xmm/m32      | RM    | V/V           | SSE               | Convert one single-precision floating-point \n|                                         |       |               |                   | value from xmm/m32 to one signed doubleword \n|                                         |       |               |                   | integer in r32 using truncation.            \n| F3 REX.W 0F 2C /r CVTTSS2SI r64, xmm/m32| RM    | V/N.E.        | SSE               | Convert one single-precision floating-point \n|                                         |       |               |                   | value from xmm/m32 to one signed quadword   \n|                                         |       |               |                   | integer in r64 using truncation.            \n| VEX.LIG.F3.0F.W0 2C /r VCVTTSS2SI r32,  | RM    | V/V           | AVX               | Convert one single-precision floating-point \n| xmm1/m32                                |       |               |                   | value from xmm1/m32 to one signed doubleword\n|                                         |       |               |                   | integer in r32 using truncation.            \n| VEX.LIG.F3.0F.W1 2C /r VCVTTSS2SI r64,  | RM    | V/N.E.1       | AVX               | Convert one single-precision floating-point \n| xmm1/m32                                |       |               |                   | value from xmm1/m32 to one signed quadword  \n|                                         |       |               |                   | integer in r64 using truncation.            \nNotes: 1. Encoding the VEX prefix with VEX.W=1 in non-64-bit mode is ignored.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts a single-precision floating-point value in the source operand (second\noperand) to a signed doubleword integer (or signed quadword integer if operand\nsize is 64 bits) in the destination operand (first operand). The source operand\ncan be an XMM register or a 32-bit memory location. The destination operand\nis a general-purpose register. When the source operand is an XMM register, the\nsingle-precision floating-point value is contained in the low doubleword of\nthe register.\n\nWhen a conversion is inexact, a truncated (round toward zero) result is returned.\nIf a converted result is larger than the maximum signed doubleword integer,\nthe floating-point invalid exception is raised. If this exception is masked,\nthe indefinite integer value (80000000H) is returned.\n\nLegacy SSE instructions: In 64-bit mode, the instruction can access additional\nregisters (XMM8-XMM15, R8-R15) when used with a REX.R prefix. Use of the REX.W\nprefix promotes the instruction to 64-bit operation. See the summary chart at\nthe beginning of this section for encoding data and limits. Note: In VEX-encoded\nversions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will\n#UD.\n\nOperation:\n\nIF 64-Bit Mode and OperandSize = 64\n  THEN\n     DEST[63:0] <- Convert_Single_Precision_Floating_Point_To_\n             Integer_Truncate(SRC[31:0]);\n  ELSE\n     DEST[31:0] <- Convert_Single_Precision_Floating_Point_To_\n             Integer_Truncate(SRC[31:0]);\nFI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nint _mm_cvttss_si32(__m128d a) __int64 _mm_cvttss_si64(__m128d a)\n\n\nSIMD Floating-Point Exceptions:\nInvalid, Precision.\n\n\nOther Exceptions:\nSee Exceptions Type 3; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "CVTTSS2SI"
    }, 
    {
      "description": "\nCWD/CDQ/CQO - Convert Word to Doubleword/Convert Doubleword to Quadword:\n| Opcode    | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                  \n| 99        | CWD        | NP   | Valid      | Valid          | DX:AX \u2190 sign-extend of AX.   \n| 99        | CDQ        | NP   | Valid      | Valid          | EDX:EAX \u2190 sign-extend of EAX.\n| REX.W + 99| CQO        | NP   | Valid      | N.E.           | RDX:RAX\u2190 sign-extend of RAX. \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nDoubles the size of the operand in register AX, EAX, or RAX (depending on the\noperand size) by means of sign extension and stores the result in registers\nDX:AX, EDX:EAX, or RDX:RAX, respectively. The CWD instruction copies the sign\n(bit 15) of the value in the AX register into every bit position in the DX register.\nThe CDQ instruction copies the sign (bit 31) of the value in the EAX register\ninto every bit position in the EDX register. The CQO instruction (available\nin 64-bit mode only) copies the sign (bit 63) of the value in the RAX register\ninto every bit position in the RDX register.\n\nThe CWD instruction can be used to produce a doubleword dividend from a word\nbefore word division. The CDQ instruction can be used to produce a quadword\ndividend from a doubleword before doubleword division. The CQO instruction can\nbe used to produce a double quadword dividend from a quadword before a quadword\ndivision.\n\nThe CWD and CDQ mnemonics reference the same opcode. The CWD instruction is\nintended for use when the operand-size attribute is 16 and the CDQ instruction\nfor when the operand-size attribute is 32. Some assemblers may force the operand\nsize to 16 when CWD is used and to 32 when CDQ is used. Others may treat these\nmnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size\nattribute to determine the size of values to be converted, regardless of the\nmnemonic used.\n\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO\nmnemonics reference the same opcode as CWD/CDQ. See the summary chart at the\nbeginning of this section for encoding data and limits.\n\nOperation:\n\nIF OperandSize = 16 (* CWD instruction *)\n  THEN\n     DX <- SignExtend(AX);\n  ELSE IF OperandSize = 32 (* CDQ instruction *)\n     EDX <- SignExtend(EAX); FI;\n  ELSE IF 64-Bit Mode and OperandSize = 64 (* CQO instruction*)\n     RDX <- SignExtend(RAX); FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nExceptions (All Operating Modes):\n| #UD| If the LOCK prefix is used.\n", 
      "mnem": "CWD"
    }, 
    {
      "description": "-R:CBW", 
      "mnem": "CWDE"
    }, 
    {
      "description": "\nDAA - Decimal Adjust AL after Addition:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                      \n| 27    | DAA        | NP   | Invalid    | Valid          | Decimal adjust AL after addition.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nAdjusts the sum of two packed BCD values to create a packed BCD result. The\nAL register is the implied source and destination operand. The DAA instruction\nis only useful when it follows an ADD instruction that adds (binary addition)\ntwo 2-digit, packed BCD values and stores a byte result in the AL register.\nThe DAA instruction then adjusts the contents of the AL register to contain\nthe correct 2-digit, packed BCD result. If a decimal carry is detected, the\nCF and AF flags are set accordingly.\n\nThis instruction executes as described above in compatibility mode and legacy\nmode. It is not valid in 64-bit mode.\n\nOperation:\n\nIF 64-Bit Mode\n  THEN\n     #UD;\n  ELSE\n     old_AL <- AL;\n     old_CF <- CF;\n     CF <- 0;\n     IF (((AL AND 0FH) > 9) or AF = 1)\n        THEN\n          AL <- AL + 6;\n          CF <- old_CF or (Carry from AL <- AL + 6);\n          AF <- 1;\n        ELSE\n          AF <- 0;\n     FI;\n     IF ((old_AL > 99H) or (old_CF = 1))\n       THEN\n          AL <- AL + 60H;\n          CF <- 1;\n       ELSE\n          CF <- 0;\n     FI;\nFI;\n\nExample:\n| ADD DAA DAA| AL, BL| Before: AL=79H BL=35H EFLAGS(OSZAPC)=XXXXXX\n|            |       | After: AL=AEH BL=35H EFLAGS(0SZAPC)=110000 \n|            |       | Before: AL=AEH BL=35H EFLAGS(OSZAPC)=110000\n|            |       | After: AL=14H BL=35H EFLAGS(0SZAPC)=X00111 \n|            |       | Before: AL=2EH BL=35H EFLAGS(OSZAPC)=110000\n|            |       | After: AL=34H BL=35H EFLAGS(0SZAPC)=X00101 \n\nFlags Affected:\nThe CF and AF flags are set if the adjustment of the value results in a decimal\ncarry in either digit of the result (see the \u201cOperation\u201d section above). The\nSF, ZF, and PF flags are set according to the result. The OF flag is undefined.\n\n\nProtected Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nReal-Address Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nVirtual-8086 Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nCompatibility Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\n64-Bit Mode Exceptions:\n| #UD| If in 64-bit mode.\n", 
      "mnem": "DAA"
    }, 
    {
      "description": "\nDAS - Decimal Adjust AL after Subtraction:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                         \n| 2F    | DAS        | NP   | Invalid    | Valid          | Decimal adjust AL after subtraction.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nAdjusts the result of the subtraction of two packed BCD values to create a packed\nBCD result. The AL register is the implied source and destination operand. The\nDAS instruction is only useful when it follows a SUB instruction that subtracts\n(binary subtraction) one 2-digit, packed BCD value from another and stores a\nbyte result in the AL register. The DAS instruction then adjusts the contents\nof the AL register to contain the correct 2-digit, packed BCD result. If a decimal\nborrow is detected, the CF and AF flags are set accordingly.\n\nThis instruction executes as described above in compatibility mode and legacy\nmode. It is not valid in 64-bit mode.\n\nOperation:\n\nIF 64-Bit Mode\n  THEN\n     #UD;\n  ELSE\n     old_AL <- AL;\n     old_CF <- CF;\n     CF <- 0;\n     IF (((AL AND 0FH) > 9) or AF = 1)\n       THEN\n          AL <- AL - 6;\n          CF <- old_CF or (Borrow from AL <- AL \u2212 6);\n          AF <- 1;\n       ELSE\n          AF <- 0;\n     FI;\n     IF ((old_AL > 99H) or (old_CF = 1))\n        THEN\n          AL <- AL \u2212 60H;\n          CF <- 1;\n     FI;\nFI;\n\nExample:\n| SUB DAA| AL, BL| Before: AL = 35H, BL = 47H, EFLAGS(OSZAPC)\n|        |       | = XXXXXX After: AL = EEH, BL = 47H,       \n|        |       | EFLAGS(0SZAPC) = 010111 Before: AL =      \n|        |       | EEH, BL = 47H, EFLAGS(OSZAPC) = 010111    \n|        |       | After: AL = 88H, BL = 47H, EFLAGS(0SZAPC) \n|        |       | = X10111                                  \n\nFlags Affected:\nThe CF and AF flags are set if the adjustment of the value results in a decimal\nborrow in either digit of the result (see the \u201cOperation\u201d section above). The\nSF, ZF, and PF flags are set according to the result. The OF flag is undefined.\n\n\nProtected Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nReal-Address Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nVirtual-8086 Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nCompatibility Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\n64-Bit Mode Exceptions:\n| #UD| If in 64-bit mode.\n", 
      "mnem": "DAS"
    }, 
    {
      "description": "\nDEC - Decrement by 1:\n| Opcode           | Instruction       | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                        \n| FE /1 REX + FE /1| DEC r/m8 DEC r/m8*| M M  | Valid Valid| Valid N.E.     | Decrement r/m8 by 1. Decrement r/m8\n|                  |                   |      |            |                | by 1.                              \n| FF /1            | DEC r/m16         | M    | Valid      | Valid          | Decrement r/m16 by 1.              \n| FF /1            | DEC r/m32         | M    | Valid      | Valid          | Decrement r/m32 by 1.              \n| REX.W + FF /1    | DEC r/m64         | M    | Valid      | N.E.           | Decrement r/m64 by 1.              \n| 48+rw            | DEC r16           | O    | N.E.       | Valid          | Decrement r16 by 1.                \n| 48+rd            | DEC r32           | O    | N.E.       | Valid          | Decrement r32 by 1.                \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1         | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r, w)  | NA       | NA       | NA       \n| O    | opcode + rd (r, w)| NA       | NA       | NA       \n\nDescription:\nSubtracts 1 from the destination operand, while preserving the state of the\nCF flag. The destination operand can be a register or a memory location. This\ninstruction allows a loop counter to be updated without disturbing the CF flag.\n(To perform a decrement operation that updates the CF flag, use a SUB instruction\nwith an immediate operand of 1.)\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\nIn 64-bit mode, DEC r16 and DEC r32 are not encodable (because opcodes 48H through\n4FH are REX prefixes). Otherwise, the instruction's 64-bit mode default operation\nsize is 32 bits. Use of the REX.R prefix permits access to additional registers\n(R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n\nSee the summary chart at the beginning of this section for encoding data and\nlimits.\n\nOperation:\n\nDEST <- DEST - 1;\n\nFlags Affected:\nThe CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set according\nto the result.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination operand is located         \n|                | in a non-writable segment. If a memory        \n|                | operand effective address is outside          \n|                | the CS, DS, ES, FS, or GS segment limit.      \n|                | If the DS, ES, FS, or GS register contains    \n|                | a NULL segment selector.                      \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "DEC"
    }, 
    {
      "description": "\nDIV - Unsigned Divide:\n| Opcode       | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                             \n| F6 /6        | DIV r/m8   | M    | Valid      | Valid          | Unsigned divide AX by r/m8, with result \n|              |            |      |            |                | stored in AL \u2190 Quotient, AH \u2190 Remainder.\n| REX + F6 /6  | DIV r/m8*  | M    | Valid      | N.E.           | Unsigned divide AX by r/m8, with result \n|              |            |      |            |                | stored in AL \u2190 Quotient, AH \u2190 Remainder.\n| F7 /6        | DIV r/m16  | M    | Valid      | Valid          | Unsigned divide DX:AX by r/m16, with    \n|              |            |      |            |                | result stored in AX \u2190 Quotient, DX \u2190    \n|              |            |      |            |                | Remainder.                              \n| F7 /6        | DIV r/m32  | M    | Valid      | Valid          | Unsigned divide EDX:EAX by r/m32, with  \n|              |            |      |            |                | result stored in EAX \u2190 Quotient, EDX    \n|              |            |      |            |                | \u2190Remainder.                             \n| REX.W + F7 /6| DIV r/m64  | M    | Valid      | N.E.           | Unsigned divide RDX:RAX by r/m64, with  \n|              |            |      |            |                | result stored in RAX \u2190 Quotient, RDX    \n|              |            |      |            |                | \u2190Remainder.                             \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nDivides unsigned the value in the AX, DX:AX, EDX:EAX, or RDX:RAX registers (dividend)\nby the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX,\nEDX:EAX, or RDX:RAX registers. The source operand can be a general-purpose register\nor a memory location. The action of this instruction depends on the operand\nsize (dividend/divisor). Division using 64-bit operand is available only in\n64-bit mode.\n\nNon-integral results are truncated (chopped) towards 0. The remainder is always\nless than the divisor in magnitude. Overflow is indicated with the #DE (divide\nerror) exception rather than with the CF flag.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.R prefix permits access to additional registers (R8-R15). Use of the\nREX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied,\nthe instruction divides the unsigned value in RDX:RAX by the source operand\nand stores the quotient in RAX, the remainder in RDX.\n\nSee the summary chart at the beginning of this section for encoding data and\nlimits. See Table 3-25.\n\n\nTable 3-25. DIV Action:\nMaximum\n\n| Operand Size           | Dividend| Divisor| Quotient| Remainder| Quotient\n| Word/byte              | AX      | r/m8   | AL      | AH       | 255     \n| Doubleword/word        | DX:AX   | r/m16  | AX      | DX       | 65,535  \n| Quadword/doubleword    | EDX:EAX | r/m32  | EAX     | EDX      | 232 \u2212 1 \n| Doublequadword/quadword| RDX:RAX | r/m64  | RAX     | RDX      | 264 \u2212 1 \nOperation:\n\nIF SRC = 0\n  THEN #DE; FI; (* Divide Error *)\nIF OperandSize = 8 (* Word/Byte Operation *)\n  THEN\n     temp <- AX / SRC;\n     IF temp > FFH\n       THEN #DE; (* Divide error *)\n       ELSE\n          AL <- temp;\n          AH <- AX MOD SRC;\n     FI;\n  ELSE IF OperandSize = 16 (* Doubleword/word operation *)\n     THEN\n       temp <- DX:AX / SRC;\n       IF temp > FFFFH\n          THEN #DE; (* Divide error *)\n       ELSE\n          AX <- temp;\n          DX <- DX:AX MOD SRC;\n       FI;\n     FI;\n  ELSE IF Operandsize = 32 (* Quadword/doubleword operation *)\n     THEN\n       temp <- EDX:EAX / SRC;\n       IF temp > FFFFFFFFH\n          THEN #DE; (* Divide error *)\n       ELSE\n          EAX <- temp;\n          EDX <- EDX:EAX MOD SRC;\n       FI;\n     FI;\n  ELSE IF 64-Bit Mode and Operandsize = 64 (* Doublequadword/quadword operation *)\n     THEN\n       temp <- RDX:RAX / SRC;\n       IF temp > FFFFFFFFFFFFFFFFH\n          THEN #DE; (* Divide error *)\n       ELSE\n          RAX <- temp;\n          RDX <- RDX:RAX MOD SRC;\n       FI;\n     FI;\nFI;\n\nFlags Affected:\nThe CF, OF, SF, ZF, AF, and PF flags are undefined.\n\n\nProtected Mode Exceptions:\n| #DE            | If the source operand (divisor) is 0 \n|                | If the quotient is too large for the \n|                | designated register.                 \n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #DE   | If the source operand (divisor) is 0.\n|       | If the quotient is too large for the \n|       | designated register.                 \n| #GP   | If a memory operand effective address\n|       | is outside the CS, DS, ES, FS, or GS \n|       | segment limit. If the DS, ES, FS, or \n|       | GS register contains a NULL segment  \n|       | selector.                            \n| #SS(0)| If a memory operand effective address\n|       | is outside the SS segment limit.     \n| #UD   | If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #DE            | If the source operand (divisor) is 0. \n|                | If the quotient is too large for the  \n|                | designated register.                  \n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS            | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #DE            | If the source operand (divisor) is 0       \n|                | If the quotient is too large for the       \n|                | designated register.                       \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "DIV"
    }, 
    {
      "description": "\nDIVPD - Divide Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                  \n| 66 0F 5E /r DIVPD xmm1, xmm2/m128       | RM   | V/V           | SSE2              | Divide packed double-precision floating-point\n|                                         |      |               |                   | values in xmm1 by packed double-precision    \n|                                         |      |               |                   | floating-point values xmm2/m128.             \n| VEX.NDS.128.66.0F.WIG 5E /r VDIVPD xmm1,| RVM  | V/V           | AVX               | Divide packed double-precision floating-point\n| xmm2, xmm3/m128                         |      |               |                   | values in xmm2 by packed double-precision    \n|                                         |      |               |                   | floating-point values in xmm3/mem.           \n| VEX.NDS.256.66.0F.WIG 5E /r VDIVPD ymm1,| RVM  | V/V           | AVX               | Divide packed double-precision floating-point\n| ymm2, ymm3/m256                         |      |               |                   | values in ymm2 by packed double-precision    \n|                                         |      |               |                   | floating-point values in ymm3/mem.           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an SIMD divide of the two or four packed double-precision floating-point\nvalues in the first source operand by the two or four packed double-precision\nfloating-point values in the second source operand. See Chapter 11 in the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an overview\nof a SIMD doubleprecision floating-point operation.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The second source can be\nan XMM register or an 128-bit memory location. The destination is not distinct\nfrom the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are unmodified. VEX.128 encoded version: the first\nsource operand is an XMM register or 128-bit memory location. The destination\noperand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are zeroed. VEX.256 encoded version: The first source\noperand is a YMM register. The second source operand can be a YMM register or\na 256-bit memory location. The destination operand is a YMM register.\n\nOperation:\n\nDIVPD (128-bit Legacy SSE version)\nDEST[63:0] <- SRC1[63:0] / SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] / SRC2[127:64]\nDEST[VLMAX-1:128] (Unmodified)\nVDIVPD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0] / SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] / SRC2[127:64]\nDEST[VLMAX-1:128] <- 0\nVDIVPD (VEX.256 encoded version)\nDEST[63:0] <- SRC1[63:0] / SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] / SRC2[127:64]\nDEST[191:128] <- SRC1[191:128] / SRC2[191:128]\nDEST[255:192] <- SRC1[255:192] / SRC2[255:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| DIVPD: | __m128d _mm_div_pd(__m128d a, __m128d    \n|        | b)                                       \n| VDIVPD:| __m256d _mm256_div_pd (__m256d a, __m256d\n|        | b);                                      \n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Divide-by-Zero, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "DIVPD"
    }, 
    {
      "description": "\nDIVPS - Divide Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                   | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                  \n| 0F 5E /r DIVPS xmm1, xmm2/m128       | RM   | V/V           | SSE               | Divide packed single-precision floating-point\n|                                      |      |               |                   | values in xmm1 by packed single-precision    \n|                                      |      |               |                   | floating-point values xmm2/m128.             \n| VEX.NDS.128.0F.WIG 5E /r VDIVPS xmm1,| RVM  | V/V           | AVX               | Divide packed single-precision floating-point\n| xmm2, xmm3/m128                      |      |               |                   | values in xmm2 by packed double-precision    \n|                                      |      |               |                   | floating-point values in xmm3/mem.           \n| VEX.NDS.256.0F.WIG 5E /r VDIVPS ymm1,| RVM  | V/V           | AVX               | Divide packed single-precision floating-point\n| ymm2, ymm3/m256                      |      |               |                   | values in ymm2 by packed double-precision    \n|                                      |      |               |                   | floating-point values in ymm3/mem.           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an SIMD divide of the four or eight packed single-precision floating-point\nvalues in the first source operand by the four or eight packed single-precision\nfloating-point values in the second source operand. See Chapter 10 in the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an overview\nof a SIMD single-precision floating-point operation.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The second source can be\nan XMM register or an 128-bit memory location. The destination is not distinct\nfrom the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are unmodified. VEX.128 encoded version: the first\nsource operand is an XMM register or 128-bit memory location. The destination\noperand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are zeroed. VEX.256 encoded version: The first source\noperand is a YMM register. The second source operand can be a YMM register or\na 256-bit memory location. The destination operand is a YMM register.\n\nOperation:\n\nDIVPS (128-bit Legacy SSE version)\nDEST[31:0] <- SRC1[31:0] / SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] / SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] / SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] / SRC2[127:96]\nDEST[VLMAX-1:128] (Unmodified)\nVDIVPS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0] / SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] / SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] / SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] / SRC2[127:96]\nDEST[VLMAX-1:128] <- 0\nVDIVPS (VEX.256 encoded version)\nDEST[31:0] <- SRC1[31:0] / SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] / SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] / SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] / SRC2[127:96]\nDEST[159:128] <- SRC1[159:128] / SRC2[159:128]\nDEST[191:160]<- SRC1[191:160] / SRC2[191:160]\nDEST[223:192] <- SRC1[223:192] / SRC2[223:192]\nDEST[255:224] <- SRC1[255:224] / SRC2[255:224].\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| DIVPS: | __m128 _mm_div_ps(__m128 a, __m128 b) \n| VDIVPS:| __m256 _mm256_div_ps (__m256 a, __m256\n|        | b);                                   \n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Divide-by-Zero, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "DIVPS"
    }, 
    {
      "description": "\nDIVSD - Divide Scalar Double-Precision Floating-Point Values:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                 \n| F2 0F 5E /r DIVSD xmm1, xmm2/m64        | RM   | V/V           | SSE2              | Divide low double-precision floating-point  \n|                                         |      |               |                   | value in xmm1 by low double-precision       \n|                                         |      |               |                   | floating-point value in xmm2/mem64.         \n| VEX.NDS.LIG.F2.0F.WIG 5E /r VDIVSD xmm1,| RVM  | V/V           | AVX               | Divide low double-precision floating        \n| xmm2, xmm3/m64                          |      |               |                   | point values in xmm2 by low double precision\n|                                         |      |               |                   | floating-point value in xmm3/mem64.         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nDivides the low double-precision floating-point value in the first source operand\nby the low double-precision floating-point value in the second source operand,\nand stores the double-precision floating-point result in the destination operand.\nThe second source operand can be an XMM register or a 64-bit memory location.\nThe first source and destination hyperons are XMM registers. The high quadword\nof the destination operand is copied from the high quadword of the first source\noperand. See Chapter 11 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 1, for an overview of a scalar double-precision floating-point\noperation.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The first source operand\nand the destination operand are the same. Bits (VLMAX1:64) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128)\nof the destination YMM register are zeroed.\n\nOperation:\n\nDIVSD (128-bit Legacy SSE version)\nDEST[63:0] <- DEST[63:0] / SRC[63:0]\nDEST[VLMAX-1:64] (Unmodified)\nVDIVSD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0] / SRC2[63:0]\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| DIVSD:| __m128d _mm_div_sd (m128d a, m128d b)\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Divide-by-Zero, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "DIVSD"
    }, 
    {
      "description": "\nDIVSS - Divide Scalar Single-Precision Floating-Point Values:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| F3 0F 5E /r DIVSS xmm1, xmm2/m32        | RM   | V/V           | SSE               | Divide low single-precision floating-point \n|                                         |      |               |                   | value in xmm1 by low single-precision      \n|                                         |      |               |                   | floating-point value in xmm2/m32.          \n| VEX.NDS.LIG.F3.0F.WIG 5E /r VDIVSS xmm1,| RVM  | V/V           | AVX               | Divide low single-precision floating       \n| xmm2, xmm3/m32                          |      |               |                   | point value in xmm2 by low single precision\n|                                         |      |               |                   | floating-point value in xmm3/m32.          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nDivides the low single-precision floating-point value in the first source operand\nby the low single-precision floatingpoint value in the second source operand,\nand stores the single-precision floating-point result in the destination operand.\nThe second source operand can be an XMM register or a 32-bit memory location.\nThe first source and destination operands are XMM registers. The three high-order\ndoublewords of the destination are copied from the same dwords of the first\nsource operand. See Chapter 10 in the Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1, for an overview of a scalar single-precision floating-point\noperation.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The first source operand\nand the destination operand are the same. Bits (VLMAX1:32) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128)\nof the destination YMM register are zeroed.\n\nOperation:\n\nDIVSS (128-bit Legacy SSE version)\nDEST[31:0] <- DEST[31:0] / SRC[31:0]\nDEST[VLMAX-1:32] (Unmodified)\nVDIVSS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0] / SRC2[31:0]\nDEST[127:32] <- SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| DIVSS:| __m128 _mm_div_ss(__m128 a, __m128 b)\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Divide-by-Zero, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "DIVSS"
    }, 
    {
      "description": "\nDPPD  -  Dot Product of Packed Double Precision Floating-Point Values:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                  \n| 66 0F 3A 41 /r ib DPPD xmm1, xmm2/m128,| RMI  | V/V           | SSE4_1            | Selectively multiply packed DP floating-point\n| imm8                                   |      |               |                   | values from xmm1 with packed DP floatingpoint\n|                                        |      |               |                   | values from xmm2, add and selectively        \n|                                        |      |               |                   | store the packed DP floating-point values    \n|                                        |      |               |                   | to xmm1.                                     \n| VEX.NDS.128.66.0F3A.WIG 41 /r ib VDPPD | RVMI | V/V           | AVX               | Selectively multiply packed DP floating-point\n| xmm1,xmm2, xmm3/m128, imm8             |      |               |                   | values from xmm2 with packed DP floatingpoint\n|                                        |      |               |                   | values from xmm3, add and selectively        \n|                                        |      |               |                   | store the packed DP floating-point values    \n|                                        |      |               |                   | to xmm1.                                     \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nConditionally multiplies the packed double-precision floating-point values in\nthe destination operand (first operand) with the packed double-precision floating-point\nvalues in the source (second operand) depending on a mask extracted from bits\n[5:4] of the immediate operand (third operand). If a condition mask bit is zero,\nthe corresponding multiplication is replaced by a value of 0.0 in the manner\ndescribed by Section 12.8.4 of Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 1.\n\nThe two resulting double-precision values are summed into an intermediate result.\nThe intermediate result is conditionally broadcasted to the destination using\na broadcast mask specified by bits [1:0] of the immediate byte.\n\nIf a broadcast mask bit is \"1\", the intermediate result is copied to the corresponding\nqword element in the destination operand. If a broadcast mask bit is zero, the\ncorresponding element in the destination is set to zero. DPPD follows the NaN\nforwarding rules stated in the Software Developer's Manual, vol. 1, table 4.7.\nThese rules do not cover horizontal prioritization of NaNs. Horizontal propagation\nof NaNs to the destination and the positioning of those NaNs in the destination\nis implementation dependent. NaNs on the input sources or computationally generated\nNaNs will have at least one NaN propagated to the destination. 128-bit Legacy\nSSE version: The second source can be an XMM register or an 128-bit memory location.\nThe destination is not distinct from the first source XMM register and the upper\nbits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit\nmemory location. The destination operand is an XMM register. The upper bits\n(VLMAX-1:128) of the corresponding YMM register destination are zeroed. If VDPPD\nis encoded with VEX.L= 1, an attempt to execute the instruction encoded with\nVEX.L= 1 will cause an #UD exception.\n\nOperation:\n\nDP_primitive (SRC1, SRC2)\nIF (imm8[4] = 1)\n  THEN Temp1[63:0] <- DEST[63:0] * SRC[63:0]; // update SIMD exception flags\n  ELSE Temp1[63:0] <- +0.0; FI;\nIF (imm8[5] = 1)\n  THEN Temp1[127:64] <- DEST[127:64] * SRC[127:64]; // update SIMD exception flags\n  ELSE Temp1[127:64] <- +0.0; FI;\n/* if unmasked exception reported, execute exception handler*/\nTemp2[63:0] <- Temp1[63:0] + Temp1[127:64]; // update SIMD exception flags\n/* if unmasked exception reported, execute exception handler*/\nIF (imm8[0] = 1)\n  THEN DEST[63:0] <- Temp2[63:0];\n  ELSE DEST[63:0] <- +0.0; FI;\nIF (imm8[1] = 1)\n  THEN DEST[127:64] <- Temp2[63:0];\n  ELSE DEST[127:64] <- +0.0; FI;\nDPPD (128-bit Legacy SSE version)\nDEST[127:0]<-DP_Primitive(SRC1[127:0], SRC2[127:0]);\nDEST[VLMAX-1:128] (Unmodified)\nVDPPD (VEX.128 encoded version)\nDEST[127:0]<-DP_Primitive(SRC1[127:0], SRC2[127:0]);\nDEST[VLMAX-1:128] <- 0\n\nFlags Affected:\nNone\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| DPPD:| __m128d _mm_dp_pd ( __m128d a, __m128d\n|      | b, const int mask);                   \n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal Exceptions are determined\nseparately for each add and multiply operation. Unmasked exceptions will leave\nthe destination untouched.\n\n\nOther Exceptions:\nSee Exceptions Type 2; additionally\n\n| #UD| If VEX.L= 1.\n", 
      "mnem": "DPPD"
    }, 
    {
      "description": "\nDPPS  -  Dot Product of Packed Single Precision Floating-Point Values:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                    \n| 66 0F 3A 40 /r ib DPPS xmm1, xmm2/m128,| RMI  | V/V           | SSE4_1            | Selectively multiply packed SP floating-point  \n| imm8                                   |      |               |                   | values from xmm1 with packed SP floatingpoint  \n|                                        |      |               |                   | values from xmm2, add and selectively          \n|                                        |      |               |                   | store the packed SP floating-point values      \n|                                        |      |               |                   | or zero values to xmm1.                        \n| VEX.NDS.128.66.0F3A.WIG 40 /r ib VDPPS | RVMI | V/V           | AVX               | Multiply packed SP floating point values       \n| xmm1,xmm2, xmm3/m128, imm8             |      |               |                   | from xmm1 with packed SP floating point        \n|                                        |      |               |                   | values from xmm2/mem selectively add           \n|                                        |      |               |                   | and store to xmm1.                             \n| VEX.NDS.256.66.0F3A.WIG 40 /r ib VDPPS | RVMI | V/V           | AVX               | Multiply packed single-precision floating-point\n| ymm1, ymm2, ymm3/m256, imm8            |      |               |                   | values from ymm2 with packed SP floating       \n|                                        |      |               |                   | point values from ymm3/mem, selectively        \n|                                        |      |               |                   | add pairs of elements and store to ymm1.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nConditionally multiplies the packed single precision floating-point values in\nthe destination operand (first operand) with the packed single-precision floats\nin the source (second operand) depending on a mask extracted from the high 4\nbits of the immediate byte (third operand). If a condition mask bit in Imm8[7:4]\nis zero, the corresponding multiplication is replaced by a value of 0.0 in the\nmanner described by Section 12.8.4 of Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1.\n\nThe four resulting single-precision values are summed into an intermediate result.\nThe intermediate result is conditionally broadcasted to the destination using\na broadcast mask specified by bits [3:0] of the immediate byte.\n\nIf a broadcast mask bit is \"1\", the intermediate result is copied to the corresponding\ndword element in the destination operand. If a broadcast mask bit is zero, the\ncorresponding element in the destination is set to zero. DPPS follows the NaN\nforwarding rules stated in the Software Developer's Manual, vol. 1, table 4.7.\nThese rules do not cover horizontal prioritization of NaNs. Horizontal propagation\nof NaNs to the destination and the positioning of those NaNs in the destination\nis implementation dependent. NaNs on the input sources or computationally generated\nNaNs will have at least one NaN propagated to the destination. 128-bit Legacy\nSSE version: The second source can be an XMM register or an 128-bit memory location.\nThe destination is not distinct from the first source XMM register and the upper\nbits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit\nmemory location. The destination operand is an XMM register. The upper bits\n(VLMAX-1:128) of the corresponding YMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second\nsource operand can be a YMM register or a 256-bit memory location. The destination\noperand is a YMM register.\n\nOperation:\n\nDP_primitive (SRC1, SRC2)\nIF (imm8[4] = 1)\n  THEN Temp1[31:0] <- DEST[31:0] * SRC[31:0]; // update SIMD exception flags\n  ELSE Temp1[31:0] <- +0.0; FI;\nIF (imm8[5] = 1)\n  THEN Temp1[63:32] <- DEST[63:32] * SRC[63:32]; // update SIMD exception flags\n  ELSE Temp1[63:32] <- +0.0; FI;\nIF (imm8[6] = 1)\n  THEN Temp1[95:64] <- DEST[95:64] * SRC[95:64]; // update SIMD exception flags\n  ELSE Temp1[95:64] <- +0.0; FI;\nIF (imm8[7] = 1)\n  THEN Temp1[127:96] <- DEST[127:96] * SRC[127:96]; // update SIMD exception flags\n  ELSE Temp1[127:96] <- +0.0; FI;\nTemp2[31:0] <- Temp1[31:0] + Temp1[63:32]; // update SIMD exception flags\n/* if unmasked exception reported, execute exception handler*/\nTemp3[31:0] <- Temp1[95:64] + Temp1[127:96]; // update SIMD exception flags\n/* if unmasked exception reported, execute exception handler*/\nTemp4[31:0] <- Temp2[31:0] + Temp3[31:0]; // update SIMD exception flags\n/* if unmasked exception reported, execute exception handler*/\nIF (imm8[0] = 1)\n  THEN DEST[31:0] <- Temp4[31:0];\n  ELSE DEST[31:0] <- +0.0; FI;\nIF (imm8[1] = 1)\n  THEN DEST[63:32] <- Temp4[31:0];\n  ELSE DEST[63:32] <- +0.0; FI;\nIF (imm8[2] = 1)\n  THEN DEST[95:64] <- Temp4[31:0];\n  ELSE DEST[95:64] <- +0.0; FI;\nIF (imm8[3] = 1)\n  THEN DEST[127:96] <- Temp4[31:0];\n  ELSE DEST[127:96] <- +0.0; FI;\nDPPS (128-bit Legacy SSE version)\nDEST[127:0]<-DP_Primitive(SRC1[127:0], SRC2[127:0]);\nDEST[VLMAX-1:128] (Unmodified)\nVDPPS (VEX.128 encoded version)\nDEST[127:0]<-DP_Primitive(SRC1[127:0], SRC2[127:0]);\nDEST[VLMAX-1:128] <- 0\nVDPPS (VEX.256 encoded version)\nDEST[127:0]<-DP_Primitive(SRC1[127:0], SRC2[127:0]);\nDEST[255:128]<-DP_Primitive(SRC1[255:128], SRC2[255:128]);\n\nFlags Affected:\nNone\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)DPPS:| __m128 _mm_dp_ps ( __m128 a, __m128   \n|         | b, const int mask);                   \n| VDPPS:  | __m256 _mm256_dp_ps ( __m256 a, __m256\n|         | b, const int mask);                   \n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal Exceptions are determined\nseparately for each add and multiply operation, in the order of their execution.\nUnmasked exceptions will leave the destination operands unchanged.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "DPPS"
    }, 
    {
      "description": "\nEMMS - Empty MMX Technology State:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                       \n| 0F 77 | EMMS       | NP   | Valid      | Valid          | Set the x87 FPU tag word to empty.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nSets the values of all the tags in the x87 FPU tag word to empty (all 1s). This\noperation marks the x87 FPU data registers (which are aliased to the MMX technology\nregisters) as available for use by x87 FPU floating-point instructions. (See\nFigure 8-7 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 1, for the format of the x87 FPU tag word.) All other MMX instructions\n(other than the EMMS instruction) set all the tags in x87 FPU tag word to valid\n(all 0s).\n\nThe EMMS instruction must be used to clear the MMX technology state at the end\nof all MMX technology procedures or subroutines and before calling other procedures\nor subroutines that may execute x87 floating-point instructions. If a floating-point\ninstruction loads one of the registers in the x87 FPU data register stack before\nthe x87 FPU tag word has been reset by the EMMS instruction, an x87 floating-point\nregister stack overflow can occur that will result in an x87 floating-point\nexception or incorrect result.\n\nEMMS operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nx87FPUTagWord <- FFFFH;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nvoid _mm_empty()\n\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #UD| If CR0.EM[bit 2] = 1.               \n| #NM| If CR0.TS[bit 3] = 1.               \n| #MF| If there is a pending FPU exception.\n| #UD| If the LOCK prefix is used.         \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "EMMS"
    }, 
    {
      "description": "\nENTER - Make Stack Frame for Procedure Parameters:\n| Opcode  | Instruction      | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                 \n| C8 iw 00| ENTER imm16, 0   | II   | Valid      | Valid          | Create a stack frame for a procedure.       \n| C8 iw 01| ENTER imm16,1    | II   | Valid      | Valid          | Create a nested stack frame for a procedure.\n| C8 iw ib| ENTER imm16, imm8| II   | Valid      | Valid          | Create a nested stack frame for a procedure.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| II   | iw       | imm8     | NA       | NA       \n\nDescription:\nCreates a stack frame for a procedure. The first operand (size operand) specifies\nthe size of the stack frame (that is, the number of bytes of dynamic storage\nallocated on the stack for the procedure). The second operand (nesting level\noperand) gives the lexical nesting level (0 to 31) of the procedure. The nesting\nlevel determines the number of stack frame pointers that are copied into the\n\u201cdisplay area\u201d of the new stack frame from the preceding frame. Both of these\noperands are immediate values.\n\nThe stack-size attribute determines whether the BP (16 bits), EBP (32 bits),\nor RBP (64 bits) register specifies the current frame pointer and whether SP\n(16 bits), ESP (32 bits), or RSP (64 bits) specifies the stack pointer. In 64bit\nmode, stack-size attribute is always 64-bits.\n\nThe ENTER and companion LEAVE instructions are provided to support block structured\nlanguages. The ENTER instruction (when used) is typically the first instruction\nin a procedure and is used to set up a new stack frame for a procedure. The\nLEAVE instruction is then used at the end of the procedure (just before the\nRET instruction) to release the stack frame.\n\nIf the nesting level is 0, the processor pushes the frame pointer from the BP/EBP/RBP\nregister onto the stack, copies the current stack pointer from the SP/ESP/RSP\nregister into the BP/EBP/RBP register, and loads the SP/ESP/RSP register with\nthe current stack-pointer value minus the value in the size operand. For nesting\nlevels of 1 or greater, the processor pushes additional frame pointers on the\nstack before adjusting the stack pointer. These additional frame pointers provide\nthe called procedure with access points to other nested frames on the stack.\nSee \u201cProcedure Calls for Block-Structured Languages\u201d in Chapter 6 of the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1, for more information\nabout the actions of the ENTER instruction.\n\nThe ENTER instruction causes a page fault whenever a write using the final value\nof the stack pointer (within the current stack segment) would do so.\n\nIn 64-bit mode, default operation size is 64 bits; 32-bit operation size cannot\nbe encoded.\n\nOperation:\n\nNestingLevel <- NestingLevel MOD 32\nIF 64-Bit Mode (StackSize = 64)\n  THEN\n     Push(RBP);\n     FrameTemp <- RSP;\n  ELSE IF StackSize = 32\n     THEN\n       Push(EBP);\n       FrameTemp <- ESP; FI;\n  ELSE (* StackSize = 16 *)\n       Push(BP);\n       FrameTemp <- SP;\nFI;\nIF NestingLevel = 0\n  THEN GOTO CONTINUE;\nFI;\nIF (NestingLevel > 1)\n  THEN FOR i <- 1 to (NestingLevel - 1)\n     DO\n       IF 64-Bit Mode (StackSize = 64)\n          THEN\n             RBP <- RBP - 8;\n             Push([RBP]); (* Quadword push *)\n          ELSE IF OperandSize = 32\n             THEN\n               IF StackSize = 32\n                  EBP <- EBP - 4;\n                  Push([EBP]); (* Doubleword push *)\n               ELSE (* StackSize = 16 *)\n                  BP <- BP - 4;\n                  Push([BP]); (* Doubleword push *)\n               FI;\n             FI;\n          ELSE (* OperandSize = 16 *)\n             IF StackSize = 32\n               THEN\n                  EBP <- EBP - 2;\n                  Push([EBP]); (* Word push *)\n               ELSE (* StackSize = 16 *)\n                  BP <- BP - 2;\n                  Push([BP]); (* Word push *)\n             FI;\n          FI;\n  OD;\nFI;\nIF 64-Bit Mode (StackSize = 64)\n  THEN\n     Push(FrameTemp); (* Quadword push *)\n  ELSE IF OperandSize = 32\n     THEN\n       Push(FrameTemp); FI; (* Doubleword push *)\n  ELSE (* OperandSize = 16 *)\n       Push(FrameTemp); (* Word push *)\nFI;\nCONTINUE:\nIF 64-Bit Mode (StackSize = 64)\n  THEN\n       RBP <- FrameTemp;\n       RSP <- RSP \u2212 Size;\n  ELSE IF StackSize = 32\n     THEN\n       EBP <- FrameTemp;\n       ESP <- ESP \u2212 Size; FI;\n  ELSE (* StackSize = 16 *)\n       BP <- FrameTemp;\n       SP <- SP \u2212 Size;\nFI;\nEND;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #SS(0)         | If the new value of the SP or ESP register\n|                | is outside the stack segment limit.       \n| #PF(fault-code)| If a page fault occurs or if a write      \n|                | using the final value of the stack pointer\n|                | (within the current stack segment) would  \n|                | cause a page fault.                       \n| #UD            | If the LOCK prefix is used.               \n\nReal-Address Mode Exceptions:\n| #SS| If the new value of the SP or ESP register\n|    | is outside the stack segment limit.       \n| #UD| If the LOCK prefix is used.               \n\nVirtual-8086 Mode Exceptions:\n| #SS(0)         | If the new value of the SP or ESP register\n|                | is outside the stack segment limit.       \n| #PF(fault-code)| If a page fault occurs or if a write      \n|                | using the final value of the stack pointer\n|                | (within the current stack segment) would  \n|                | cause a page fault.                       \n| #UD            | If the LOCK prefix is used.               \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If the stack address is in a non-canonical\n|                | form.                                     \n| #PF(fault-code)| If a page fault occurs or if a write      \n|                | using the final value of the stack pointer\n|                | (within the current stack segment) would  \n|                | cause a page fault.                       \n| #UD            | If the LOCK prefix is used.               \n", 
      "mnem": "ENTER"
    }, 
    {
      "description": "\nEXTRACTPS  -  Extract Packed Single Precision Floating-Point Value:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| 66 0F 3A 17 /r ib EXTRACTPS reg/m32,   | MRI  | V/V           | SSE4_1            | Extract a single-precision floating-point  \n| xmm2, imm8                             |      |               |                   | value from xmm2 at the source offset       \n|                                        |      |               |                   | specified by imm8 and store the result     \n|                                        |      |               |                   | to reg or m32. The upper 32 bits of        \n|                                        |      |               |                   | r64 is zeroed if reg is r64.               \n| VEX.128.66.0F3A.WIG 17 /r ib VEXTRACTPS| MRI  | V/V           | AVX               | Extract one single-precision floating-point\n| r/m32, xmm1, imm8                      |      |               |                   | value from xmm1 at the offset specified    \n|                                        |      |               |                   | by imm8 and store the result in reg        \n|                                        |      |               |                   | or m32. Zero extend the results in 64-bit  \n|                                        |      |               |                   | register if applicable.                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MRI  | ModRM:r/m (w)| ModRM:reg (r)| imm8     | NA       \n\nDescription:\nExtracts a single-precision floating-point value from the source operand (second\noperand) at the 32-bit offset specified from imm8. Immediate bits higher than\nthe most significant offset for the vector length are ignored. The extracted\nsingle-precision floating-point value is stored in the low 32-bits of the destination\noperand In 64-bit mode, destination register operand has default operand size\nof 64 bits. The upper 32-bits of the register are filled with zero. REX.W is\nignored. 128-bit Legacy SSE version: When a REX.W prefix is used in 64-bit mode\nwith a general purpose register (GPR) as a destination operand, the packed single\nquantity is zero extended to 64 bits. VEX.128 encoded version: When VEX.128.66.0F3A.W1\n17 form is used in 64-bit mode with a general purpose register (GPR) as a destination\noperand, the packed single quantity is zero extended to 64 bits. VEX.vvvv is\nreserved and must be 1111b otherwise instructions will #UD. The source register\nis an XMM register. Imm8[1:0] determine the starting DWORD offset from which\nto extract the 32-bit floating-point value. If VEXTRACTPS is encoded with VEX.L=\n1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an\n#UD exception.\n\nOperation:\n\nEXTRACTPS (128-bit Legacy SSE version)\nSRC_OFFSET <- IMM8[1:0]\nIF ( 64-Bit Mode and DEST is register)\n  DEST[31:0] <- (SRC[127:0] \u00bb (SRC_OFFET*32)) AND 0FFFFFFFFh\n  DEST[63:32] <- 0\nELSE\n  DEST[31:0] <- (SRC[127:0] \u00bb (SRC_OFFET*32)) AND 0FFFFFFFFh\nFI\nVEXTRACTPS (VEX.128 encoded version)\nSRC_OFFSET <- IMM8[1:0]\nIF ( 64-Bit Mode and DEST is register)\n  DEST[31:0] <- (SRC[127:0] \u00bb (SRC_OFFET*32)) AND 0FFFFFFFFh\n  DEST[63:32] <- 0\nELSE\n  DEST[31:0] <- (SRC[127:0] \u00bb (SRC_OFFET*32)) AND 0FFFFFFFFh\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| EXTRACTPS:| _mm_extractmem_ps (float *dest, __m128\n|           | a, const int nidx);                   \n| EXTRACTPS:| __m128 _mm_extract_ps (__m128 a, const\n|           | int nidx);                            \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L= 1.\n", 
      "mnem": "EXTRACTPS"
    }, 
    {
      "description": "\nF2XM1 - Compute 2x-1:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                     \n| D9 F0 | F2XM1      | Valid      | Valid          | Replace ST(0) with (2ST(0) - 1).\n\nDescription:\nComputes the exponential value of 2 to the power of the source operand minus\n1. The source operand is located in register ST(0) and the result is also stored\nin ST(0). The value of the source operand must lie in the range -1.0 to +1.0.\nIf the source value is outside this range, the result is undefined.\n\nThe following table shows the results obtained when computing the exponential\nvalue of various classes of numbers, assuming that neither overflow nor underflow\noccurs.\n\n\nTable 3-26. Results Obtained from F2XM1:\n| ST(0) SRC  | ST(0) DEST  \n| \u2212 1.0 to \u22120| \u2212 0.5 to \u2212 0\n| \u2212 0        | \u2212 0         \n| + 0        | + 0         \n| + 0 to +1.0| + 0 to 1.0  \nValues other than 2 can be exponentiated using the following formula:\n\nxy \u2190 2(y * log2x)\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nST(0) <- (2ST(0) \u2212 1);\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.                     \n| #IA| Source operand is an SNaN value or unsupported\n|    | format.                                       \n| #D | Source is a denormal value.                   \n| #U | Result is too small for destination           \n|    | format.                                       \n| #P | Value cannot be represented exactly           \n|    | in destination format.                        \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.\n| #UD| If the LOCK prefix is used.        \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "F2XM1"
    }, 
    {
      "description": "\nFABS - Absolute Value:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                        \n| D9 E1 | FABS       | Valid      | Valid          | Replace ST with its absolute value.\n\nDescription:\nClears the sign bit of ST(0) to create the absolute value of the operand. The\nfollowing table shows the results obtained when creating the absolute value\nof various classes of numbers.\n\n\nTable 3-27. Results Obtained from FABS:\n| ST(0) SRC| ST(0) DEST\n| \u2212 \u221e      | + \u221e       \n| \u2212 F      | + F       \n| \u2212 0      | + 0       \n| + 0      | + 0       \n| + F      | + F       \n| + \u221e      | + \u221e       \n| NaN      | NaN       \nNotes: F Means finite floating-point value.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nST(0) <- |ST(0)|;\n\nFPU Flags Affected:\n| C1        | Set to 0. \n| C0, C2, C3| Undefined.\n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.\n| #UD| If the LOCK prefix is used.        \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FABS"
    }, 
    {
      "description": "\nFADD/FADDP/FIADD - Add:\n| Opcode | Instruction       | 64-Bit Mode| Compat/Leg Mode| Description                         \n| D8 /0  | FADD m32fp        | Valid      | Valid          | Add m32fp to ST(0) and store result \n|        |                   |            |                | in ST(0).                           \n| DC /0  | FADD m64fp        | Valid      | Valid          | Add m64fp to ST(0) and store result \n|        |                   |            |                | in ST(0).                           \n| D8 C0+i| FADD ST(0), ST(i) | Valid      | Valid          | Add ST(0) to ST(i) and store result \n|        |                   |            |                | in ST(0).                           \n| DC C0+i| FADD ST(i), ST(0) | Valid      | Valid          | Add ST(i) to ST(0) and store result \n|        |                   |            |                | in ST(i).                           \n| DE C0+i| FADDP ST(i), ST(0)| Valid      | Valid          | Add ST(0) to ST(i), store result in \n|        |                   |            |                | ST(i), and pop the register stack.  \n| DE C1  | FADDP             | Valid      | Valid          | Add ST(0) to ST(1), store result in \n|        |                   |            |                | ST(1), and pop the register stack.  \n| DA /0  | FIADD m32int      | Valid      | Valid          | Add m32int to ST(0) and store result\n|        |                   |            |                | in ST(0).                           \n| DE /0  | FIADD m16int      | Valid      | Valid          | Add m16int to ST(0) and store result\n|        |                   |            |                | in ST(0).                           \n\nDescription:\nAdds the destination and source operands and stores the sum in the destination\nlocation. The destination operand is always an FPU register; the source operand\ncan be a register or a memory location. Source operands in memory can be in\nsingle-precision or double-precision floating-point format or in word or doubleword\ninteger format.\n\nThe no-operand version of the instruction adds the contents of the ST(0) register\nto the ST(1) register. The oneoperand version adds the contents of a memory\nlocation (either a floating-point or an integer value) to the contents of the\nST(0) register. The two-operand version, adds the contents of the ST(0) register\nto the ST(i) register or vice versa. The value in ST(0) can be doubled by coding:\n\nFADD ST(0), ST(0);\n\nThe FADDP instructions perform the additional operation of popping the FPU register\nstack after storing the result. To pop the register stack, the processor marks\nthe ST(0) register as empty and increments the stack pointer (TOP) by 1. (The\nno-operand version of the floating-point add instructions always results in\nthe register stack being popped. In some assemblers, the mnemonic for this instruction\nis FADD rather than FADDP.)\n\nThe FIADD instructions convert an integer source operand to double extended-precision\nfloating-point format before performing the addition.\n\nThe table on the following page shows the results obtained when adding various\nclasses of numbers, assuming that neither overflow nor underflow occurs.\n\nWhen the sum of two operands with opposite signs is 0, the result is +0, except\nfor the round toward \u2212\u221e mode, in which case the result is \u22120. When the source\noperand is an integer 0, it is treated as a +0.\n\nWhen both operand are infinities of the same sign, the result is \u221e of the expected\nsign. If both operands are infinities of opposite signs, an invalid-operation\nexception is generated. See Table 3-28.\n\n\nTable 3-28. FADD/FADDP/FIADD Results:\nDEST\n\n| \u2212 \u221e\u2212 \u221e| \u2212 F \u2212 \u221e       | \u2212 0 \u2212 \u221e| + 0 \u2212 \u221e| + F \u2212 \u221e   | + \u221e   | NaN NaN\n| \u2212 \u221e   | \u2212 F           | SRC    | SRC    | \u00b1 F or \u00b1 0| + \u221e   | NaN    \n| \u2212 \u221e   | DEST          | \u2212 0    | \u00b1 0    | DEST      | + \u221e   | NaN    \n| \u2212 \u221e   | DEST          | \u00b1 0    | + 0    | DEST      | + \u221e   | NaN    \n| \u2212 \u221e   | \u00b1 F or \u00b1 0 + \u221e| SRC + \u221e| SRC + \u221e| + F + \u221e   | + \u221e+ \u221e| NaN NaN\n| NaN   | NaN           | NaN    | NaN    | NaN       | NaN   | NaN    \nNotes: F Means finite floating-point value.\n\n| I * Indicates floating-point invalid-arithmetic-operand| Means integer.\n| (#IA) exception.                                       |               \nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF Instruction = FIADD\n  THEN\n     DEST <- DEST + ConvertToDoubleExtendedPrecisionFP(SRC);\n  ELSE (* Source operand is floating-point value *)\n     DEST <- DEST + SRC;\nFI;\nIF Instruction = FADDP\n  THEN\n     PopRegisterStack;\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.                \n| #IA| Operand is an SNaN value or unsupported  \n|    | format. Operands are infinities of unlike\n|    | sign.                                    \n| #D | Source operand is a denormal value.      \n| #U | Result is too small for destination      \n|    | format.                                  \n| #O | Result is too large for destination      \n|    | format.                                  \n| #P | Value cannot be represented exactly      \n|    | in destination format.                   \n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FADD"
    }, 
    {
      "description": "-R:FADD", 
      "mnem": "FADDP"
    }, 
    {
      "description": "\nFBLD - Load Binary Coded Decimal:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                        \n| DF /4 | FBLD m80dec| Valid      | Valid          | Convert BCD value to floating-point\n|       |            |            |                | and push onto the FPU stack.       \n\nDescription:\nConverts the BCD source operand into double extended-precision floating-point\nformat and pushes the value onto the FPU stack. The source operand is loaded\nwithout rounding errors. The sign of the source operand is preserved, including\nthat of \u22120.\n\nThe packed BCD digits are assumed to be in the range 0 through 9; the instruction\ndoes not check for invalid digits (AH through FH). Attempting to load an invalid\nencoding produces an undefined result.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nTOP <- TOP \u2212 1;\nST(0) <- ConvertToDoubleExtendedPrecisionFP(SRC);\n\nFPU Flags Affected:\n| C1        | Set to 1 if stack overflow occurred;\n|           | otherwise, set to 0.                \n| C0, C2, C3| Undefined.                          \n\nFloating-Point Exceptions:\n| #IS| Stack overflow occurred.\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FBLD"
    }, 
    {
      "description": "\nFBSTP - Store BCD Integer and Pop:\n| Opcode| Instruction | 64-Bit Mode| Compat/Leg Mode| Description                         \n| DF /6 | FBSTP m80bcd| Valid      | Valid          | Store ST(0) in m80bcd and pop ST(0).\n\nDescription:\nConverts the value in the ST(0) register to an 18-digit packed BCD integer,\nstores the result in the destination operand, and pops the register stack. If\nthe source value is a non-integral value, it is rounded to an integer value,\naccording to rounding mode specified by the RC field of the FPU control word.\nTo pop the register stack, the processor marks the ST(0) register as empty and\nincrements the stack pointer (TOP) by 1.\n\nThe destination operand specifies the address where the first byte destination\nvalue is to be stored. The BCD value (including its sign bit) requires 10 bytes\nof space in memory.\n\nThe following table shows the results obtained when storing various classes\nof numbers in packed BCD format.\n\n\nTable 3-29. FBSTP Results:\n| ST(0) | DEST \u2212 \u221e or Value Too Large for DEST\n|       | Format \u2212D **                        \n| \u2212 0   | \u2212 0                                 \n| + 0   | + 0 **                              \n| F \u2265 +1| + D + \u221e or Value Too Large for DEST \n|       | Format                              \n| NaN   | *                                   \nNotes: F Means finite floating-point value. D Means packed-BCD number. * Indicates\nfloating-point invalid-operation (#IA) exception. ** \u00b10 or \u00b11, depending on\nthe rounding mode.\n\nIf the converted value is too large for the destination format, or if the source\noperand is an \u221e, SNaN, QNAN, or is in an unsupported format, an invalid-arithmetic-operand\ncondition is signaled. If the invalid-operation exception is not masked, an\ninvalid-arithmetic-operand exception (#IA) is generated and no value is stored\nin the destination operand. If the invalid-operation exception is masked, the\npacked BCD indefinite value is stored in memory.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nDEST <- BCD(ST(0));\nPopRegisterStack;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.              \n| #IA| Converted value that exceeds 18 BCD    \n|    | digits in length. Source operand is    \n|    | an SNaN, QNaN, \u00b1\u221e, or in an unsupported\n|    | format.                                \n| #P | Value cannot be represented exactly    \n|    | in destination format.                 \n\nProtected Mode Exceptions:\n| #GP(0)         | If a segment register is being loaded     \n|                | with a segment selector that points       \n|                | to a non-writable segment. If a memory    \n|                | operand effective address is outside      \n|                | the CS, DS, ES, FS, or GS segment limit.  \n|                | If the DS, ES, FS, or GS register contains\n|                | a NULL segment selector.                  \n| #SS(0)         | If a memory operand effective address     \n|                | is outside the SS segment limit.          \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.       \n| #PF(fault-code)| If a page fault occurs.                   \n| #AC(0)         | If alignment checking is enabled and      \n|                | an unaligned memory reference is made     \n|                | while the current privilege level is      \n|                | 3.                                        \n| #UD            | If the LOCK prefix is used.               \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FBSTP"
    }, 
    {
      "description": "\nFCHS - Change Sign:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description               \n| D9 E0 | FCHS       | Valid      | Valid          | Complements sign of ST(0).\n\nDescription:\nComplements the sign bit of ST(0). This operation changes a positive value into\na negative value of equal magnitude or vice versa. The following table shows\nthe results obtained when changing the sign of various classes of numbers.\n\n\nTable 3-30. FCHS Results:\n| ST(0) SRC| ST(0) DEST + \u221e+ F + 0 \u2212 0 \u2212 F \u2212 \u221eNaN\nNotes: * F means finite floating-point value.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nSignBit(ST(0)) <- NOT (SignBit(ST(0)));\n\nFPU Flags Affected:\n| C1        | Set to 0. \n| C0, C2, C3| Undefined.\n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.\n| #UD| If the LOCK prefix is used.        \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FCHS"
    }, 
    {
      "description": "\nFCLEX/FNCLEX - Clear Exceptions:\n| Opcode* | Instruction| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 9B DB E2| FCLEX      | Valid      | Valid          | Clear floating-point exception flags \n|         |            |            |                | after checking for pending unmasked  \n|         |            |            |                | floating-point exceptions.           \n| DB E2   | FNCLEX*    | Valid      | Valid          | Clear floating-point exception flags \n|         |            |            |                | without checking for pending unmasked\n|         |            |            |                | floating-point exceptions.           \nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nDescription:\nClears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the\nexception summary status flag (ES), the stack fault flag (SF), and the busy\nflag (B) in the FPU status word. The FCLEX instruction checks for and handles\nany pending unmasked floating-point exceptions before clearing the exception\nflags; the FNCLEX instruction does not.\n\nThe assembler issues two instructions for the FCLEX instruction (an FWAIT instruction\nfollowed by an FNCLEX instruction), and the processor executes each of these\ninstructions separately. If an exception is generated for either of these instructions,\nthe save EIP points to the instruction that caused the exception.\n\n\nIA-32 Architecture Compatibility:\nWhen operating a Pentium or Intel486 processor in MS-DOS* compatibility mode,\nit is possible (under unusual circumstances) for an FNCLEX instruction to be\ninterrupted prior to being executed to handle a pending FPU exception. See the\nsection titled \u201cNo-Wait FPU Instructions Can Get FPU Interrupt in Window\u201d in\nAppendix D of the Intel\u00ae64 and IA-32 Architectures Software Developer's Manual,\nVolume 1, for a description of these circumstances. An FNCLEX instruction cannot\nbe interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.\n\nThis instruction affects only the x87 FPU floating-point exception flags. It\ndoes not affect the SIMD floating-point exception flags in the MXCRS register.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nFPUStatusWord[0:7] <- 0;\nFPUStatusWord[15] <- 0;\n\nFPU Flags Affected:\nThe PE, UE, OE, ZE, DE, IE, ES, SF, and B flags in the FPU status word are cleared.\nThe C0, C1, C2, and C3 flags are undefined.\n\n\nFloating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.\n| #UD| If the LOCK prefix is used.        \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FCLEX"
    }, 
    {
      "description": "\nFCMOVcc - Floating-Point Conditional Move:\n| Opcode*| Instruction          | 64-Bit Mode| Compat/Leg Mode*| Description                           \n| DA C0+i| FCMOVB ST(0), ST(i)  | Valid      | Valid           | Move if below (CF=1).                 \n| DA C8+i| FCMOVE ST(0), ST(i)  | Valid      | Valid           | Move if equal (ZF=1).                 \n| DA D0+i| FCMOVBE ST(0), ST(i) | Valid      | Valid           | Move if below or equal (CF=1 or ZF=1).\n| DA D8+i| FCMOVU ST(0), ST(i)  | Valid      | Valid           | Move if unordered (PF=1).             \n| DB C0+i| FCMOVNB ST(0), ST(i) | Valid      | Valid           | Move if not below (CF=0).             \n| DB C8+i| FCMOVNE ST(0), ST(i) | Valid      | Valid           | Move if not equal (ZF=0).             \n| DB D0+i| FCMOVNBE ST(0), ST(i)| Valid      | Valid           | Move if not below or equal (CF=0 and  \n|        |                      |            |                 | ZF=0).                                \n| DB D8+i| FCMOVNU ST(0), ST(i) | Valid      | Valid           | Move if not unordered (PF=0).         \nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nDescription:\nTests the status flags in the EFLAGS register and moves the source operand (second\noperand) to the destination operand (first operand) if the given test condition\nis true. The condition for each mnemonic os given in the Description column\nabove and in Chapter 8 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 1. The source operand is always in the ST(i) register and the\ndestination operand is always ST(0).\n\nThe FCMOVcc instructions are useful for optimizing small IF constructions. They\nalso help eliminate branching overhead for IF operations and the possibility\nof branch mispredictions by the processor.\n\nA processor may not support the FCMOVcc instructions. Software can check if\nthe FCMOVcc instructions are supported by checking the processor's feature information\nwith the CPUID instruction (see \u201cCOMISS - Compare Scalar Ordered Single-Precision\nFloating-Point Values and Set EFLAGS\u201d in this chapter). If both the CMOV and\nFPU feature bits are set, the FCMOVcc instructions are supported.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nIA-32 Architecture Compatibility:\nThe FCMOVcc instructions were introduced to the IA-32 Architecture in the P6\nfamily processors and are not available in earlier IA-32 processors.\n\nOperation:\n\nIF condition TRUE\n  THEN ST(0) <- ST(i);\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.\n\nInteger Flags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.\n| #UD| If the LOCK prefix is used.        \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FCMOVcc"
    }, 
    {
      "description": "\nFCOM/FCOMP/FCOMPP - Compare Floating Point Values:\n| Opcode | Instruction| 64-Bit Mode| Compat/Leg Mode| Description                              \n| D8 /2  | FCOM m32fp | Valid      | Valid          | Compare ST(0) with m32fp.                \n| DC /2  | FCOM m64fp | Valid      | Valid          | Compare ST(0) with m64fp.                \n| D8 D0+i| FCOM ST(i) | Valid      | Valid          | Compare ST(0) with ST(i).                \n| D8 D1  | FCOM       | Valid      | Valid          | Compare ST(0) with ST(1).                \n| D8 /3  | FCOMP m32fp| Valid      | Valid          | Compare ST(0) with m32fp and pop register\n|        |            |            |                | stack.                                   \n| DC /3  | FCOMP m64fp| Valid      | Valid          | Compare ST(0) with m64fp and pop register\n|        |            |            |                | stack.                                   \n| D8 D8+i| FCOMP ST(i)| Valid      | Valid          | Compare ST(0) with ST(i) and pop register\n|        |            |            |                | stack.                                   \n| D8 D9  | FCOMP      | Valid      | Valid          | Compare ST(0) with ST(1) and pop register\n|        |            |            |                | stack.                                   \n| DE D9  | FCOMPP     | Valid      | Valid          | Compare ST(0) with ST(1) and pop register\n|        |            |            |                | stack twice.                             \n\nDescription:\nCompares the contents of register ST(0) and source value and sets condition\ncode flags C0, C2, and C3 in the FPU status word according to the results (see\nthe table below). The source operand can be a data register or a memory location.\nIf no source operand is given, the value in ST(0) is compared with the value\nin ST(1). The sign of zero is ignored, so that -0.0 is equal to +0.0.\n\n\nTable 3-31. FCOM/FCOMP/FCOMPP Results:\n| Condition| C3 0 0 1 1| C2 0 0 0 1| C0 0 1 0 1\nNotes: * Flags not set if unmasked invalid-arithmetic-operand (#IA) exception\nis generated.\n\nThis instruction checks the class of the numbers being compared (see \u201cFXAM - Examine\nModR/M\u201d in this chapter). If either operand is a NaN or is in an unsupported\nformat, an invalid-arithmetic-operand exception (#IA) is raised and, if the\nexception is masked, the condition flags are set to \u201cunordered.\u201d If the invalid-arithmetic-operand\nexception is unmasked, the condition code flags are not set.\n\nThe FCOMP instruction pops the register stack following the comparison operation\nand the FCOMPP instruction pops the register stack twice following the comparison\noperation. To pop the register stack, the processor marks the ST(0) register\nas empty and increments the stack pointer (TOP) by 1.\n\nThe FCOM instructions perform the same operation as the FUCOM instructions.\nThe only difference is how they handle QNaN operands. The FCOM instructions\nraise an invalid-arithmetic-operand exception (#IA) when either or both of the\noperands is a NaN value or is in an unsupported format. The FUCOM instructions\nperform the same operation as the FCOM instructions, except that they do not\ngenerate an invalid-arithmetic-operand exception for QNaNs.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nCASE (relation of operands) OF\n  ST > SRC:\n  ST < SRC:\n  ST = SRC:\nESAC;\nIF ST(0) or SRC = NaN or unsupported format\n  THEN\n     #IA\n     IF FPUControlWord.IM = 1\n       THEN\n          C3, C2, C0 <- 111;\n     FI;\nFI;\nIF Instruction = FCOMP\n  THEN\n     PopRegisterStack;\nFI;\nIF Instruction = FCOMPP\n  THEN\n     PopRegisterStack;\n     PopRegisterStack;\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 0.                  \n| C0, C2, C3| See table on previous page.\n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.                \n| #IA| One or both operands are NaN values      \n|    | or have unsupported formats. Register    \n|    | is marked empty.                         \n| #D | One or both operands are denormal values.\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FCOM"
    }, 
    {
      "description": "\nFCOMI/FCOMIP/FUCOMI/FUCOMIP - Compare Floating Point Values and Set EFLAGS:\n| Opcode | Instruction      | 64-Bit Mode| Compat/Leg Mode| Description                                  \n| DB F0+i| FCOMI ST, ST(i)  | Valid      | Valid          | Compare ST(0) with ST(i) and set status      \n|        |                  |            |                | flags accordingly.                           \n| DF F0+i| FCOMIP ST, ST(i) | Valid      | Valid          | Compare ST(0) with ST(i), set status         \n|        |                  |            |                | flags accordingly, and pop register          \n|        |                  |            |                | stack.                                       \n| DB E8+i| FUCOMI ST, ST(i) | Valid      | Valid          | Compare ST(0) with ST(i), check for          \n|        |                  |            |                | ordered values, and set status flags         \n|        |                  |            |                | accordingly.                                 \n| DF E8+i| FUCOMIP ST, ST(i)| Valid      | Valid          | Compare ST(0) with ST(i), check for          \n|        |                  |            |                | ordered values, set status flags accordingly,\n|        |                  |            |                | and pop register stack.                      \n\nDescription:\nPerforms an unordered comparison of the contents of registers ST(0) and ST(i)\nand sets the status flags ZF, PF, and CF in the EFLAGS register according to\nthe results (see the table below). The sign of zero is ignored for comparisons,\nso that -0.0 is equal to +0.0.\n\n\nTable 3-32. FCOMI/FCOMIP/ FUCOMI/FUCOMIP Results:\n| Comparison Results*| ZF| PF| CF\n| ST0 > ST(i)        | 0 | 0 | 0 \n| ST0 < ST(i)        | 0 | 0 | 1 \n| ST0 = ST(i)        | 1 | 0 | 0 \n| Unordered**        | 1 | 1 | 1 \nNotes: * See the IA-32 Architecture Compatibility section below. ** Flags not\nset if unmasked invalid-arithmetic-operand (#IA) exception is generated.\n\nAn unordered comparison checks the class of the numbers being compared (see\n\u201cFXAM - Examine ModR/M\u201d in this chapter). The FUCOMI/FUCOMIP instructions perform\nthe same operations as the FCOMI/FCOMIP instructions. The only difference is\nthat the FUCOMI/FUCOMIP instructions raise the invalid-arithmetic-operand exception\n(#IA) only when either or both operands are an SNaN or are in an unsupported\nformat; QNaNs cause the condition code flags to be set to unordered, but do\nnot cause an exception to be generated. The FCOMI/FCOMIP instructions raise\nan invalid-operation exception when either or both of the operands are a NaN\nvalue of any kind or are in an unsupported format.\n\nIf the operation results in an invalid-arithmetic-operand exception being raised,\nthe status flags in the EFLAGS register are set only if the exception is masked.\n\nThe FCOMI/FCOMIP and FUCOMI/FUCOMIP instructions set the OF, SF and AF flags\nto zero in the EFLAGS register (regardless of whether an invalid-operation exception\nis detected).\n\nThe FCOMIP and FUCOMIP instructions also pop the register stack following the\ncomparison operation. To pop the register stack, the processor marks the ST(0)\nregister as empty and increments the stack pointer (TOP) by 1.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nIA-32 Architecture Compatibility:\nThe FCOMI/FCOMIP/FUCOMI/FUCOMIP instructions were introduced to the IA-32 Architecture\nin the P6 family processors and are not available in earlier IA-32 processors.\n\nOperation:\n\nCASE (relation of operands) OF\n  ST(0) > ST(i):\n  ST(0) < ST(i):\n  ST(0) = ST(i):\nESAC;\nIF Instruction is FCOMI or FCOMIP\n  THEN\n     IF ST(0) or ST(i) = NaN or unsupported format\n       THEN\n          #IA\n          IF FPUControlWord.IM = 1\n             THEN\n               ZF, PF, CF <- 111;\n          FI;\n     FI;\nFI;\nIF Instruction is FUCOMI or FUCOMIP\n  THEN\n     IF ST(0) or ST(i) = QNaN, but not SNaN or unsupported format\n       THEN\n          ZF, PF, CF <- 111;\n       ELSE (* ST(0) or ST(i) is SNaN or unsupported format *)\n          #IA;\n          IF FPUControlWord.IM = 1\n             THEN\n               ZF, PF, CF <- 111;\n          FI;\n     FI;\nFI;\nIF Instruction is FCOMIP or FUCOMIP\n  THEN\n     PopRegisterStack;\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 0.    \n| C0, C2, C3| Not affected.\n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.              \n| #IA| (FCOMI or FCOMIP instruction) One or   \n|    | both operands are NaN values or have   \n|    | unsupported formats. (FUCOMI or FUCOMIP\n|    | instruction) One or both operands are  \n|    | SNaN values (but not QNaNs) or have    \n|    | undefined formats. Detection of a QNaN \n|    | value does not raise an invalid-operand\n|    | exception.                             \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FCOMI"
    }, 
    {
      "description": "-R:FCOMI", 
      "mnem": "FCOMIP"
    }, 
    {
      "description": "-R:FCOM", 
      "mnem": "FCOMP"
    }, 
    {
      "description": "-R:FCOM", 
      "mnem": "FCOMPP"
    }, 
    {
      "description": "\nFCOS - Cosine:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                   \n| D9 FF | FCOS       | Valid      | Valid          | Replace ST(0) with its cosine.\n\nDescription:\nComputes the cosine of the source operand in register ST(0) and stores the result\nin ST(0). The source operand must be given in radians and must be within the\nrange \u2212263 to +263. The following table shows the results obtained when taking\nthe cosine of various classes of numbers.\n\n\nTable 3-33. FCOS Results:\n| ST(0) SRC \u2212 \u221e| ST(0) DEST\n| \u2212 F          | \u22121 to +1  \n| \u2212 0          | +1        \n| + 0          | +1        \n| + F + \u221e      | \u2212 1 to + 1\n| NaN          | NaN       \nNotes: F Means finite floating-point value.\n\n| *| Indicates floating-point invalid-arithmetic-operand\n|  | (#IA) exception.                                   \nIf the source operand is outside the acceptable range, the C2 flag in the FPU\nstatus word is set, and the value in register ST(0) remains unchanged. The instruction\ndoes not raise an exception when the source operand is out of range. It is up\nto the program to check the C2 flag for out-of-range conditions. Source values\noutside the range \u2212263 to +263 can be reduced to the range of the instruction\nby subtracting an appropriate integer multiple of 2\u03c0 or by using the FPREM instruction\nwith a divisor of 2\u03c0. See the section titled \u201cPi\u201d in Chapter 8 of the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a discussion\nof the proper value to use for \u03c0 in performing such reductions.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF |ST(0)| < 263\nTHEN\n  C2 <- 0;\n  ST(0) <- cosine(ST(0));\nELSE (* Source operand is out-of-range *)\n  C2 <- 1;\nFI;\n\nFPU Flags Affected:\n| C1    | Set to 0 if stack underflow occurred.   \n|       | Set if result was rounded up; cleared   \n|       | otherwise. Undefined if C2 is 1.        \n| C2    | Set to 1 if outside range (\u2212263 < source\n|       | operand < +263); otherwise, set to 0.   \n| C0, C3| Undefined.                              \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.          \n| #IA| Source operand is an SNaN value, \u221e,\n|    | or unsupported format.             \n| #D | Source is a denormal value.        \n| #P | Value cannot be represented exactly\n|    | in destination format.             \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FCOS"
    }, 
    {
      "description": "\nFDECSTP - Decrement Stack-Top Pointer:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                            \n| D9 F6 | FDECSTP    | Valid      | Valid          | Decrement TOP field in FPU status word.\n\nDescription:\nSubtracts one from the TOP field of the FPU status word (decrements the top-of-stack\npointer). If the TOP field contains a 0, it is set to 7. The effect of this\ninstruction is to rotate the stack by one position. The contents of the FPU\ndata registers and tag register are not affected.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF TOP = 0\n  THEN TOP <- 7;\n  ELSE TOP <- TOP - 1;\nFI;\n\nFPU Flags Affected:\nThe C1 flag is set to 0. The C0, C2, and C3 flags are undefined.\n\n\nFloating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FDECSTP"
    }, 
    {
      "description": "\nFDIV/FDIVP/FIDIV - Divide:\n| Opcode | Instruction       | 64-Bit Mode| Compat/Leg Mode| Description                            \n| D8 /6  | FDIV m32fp        | Valid      | Valid          | Divide ST(0) by m32fp and store result \n|        |                   |            |                | in ST(0).                              \n| DC /6  | FDIV m64fp        | Valid      | Valid          | Divide ST(0) by m64fp and store result \n|        |                   |            |                | in ST(0).                              \n| D8 F0+i| FDIV ST(0), ST(i) | Valid      | Valid          | Divide ST(0) by ST(i) and store result \n|        |                   |            |                | in ST(0).                              \n| DC F8+i| FDIV ST(i), ST(0) | Valid      | Valid          | Divide ST(i) by ST(0) and store result \n|        |                   |            |                | in ST(i).                              \n| DE F8+i| FDIVP ST(i), ST(0)| Valid      | Valid          | Divide ST(i) by ST(0), store result    \n|        |                   |            |                | in ST(i), and pop the register stack.  \n| DE F9  | FDIVP             | Valid      | Valid          | Divide ST(1) by ST(0), store result    \n|        |                   |            |                | in ST(1), and pop the register stack.  \n| DA /6  | FIDIV m32int      | Valid      | Valid          | Divide ST(0) by m32int and store result\n|        |                   |            |                | in ST(0).                              \n| DE /6  | FIDIV m16int      | Valid      | Valid          | Divide ST(0) by m16int and store result\n|        |                   |            |                | in ST(0).                              \n\nDescription:\nDivides the destination operand by the source operand and stores the result\nin the destination location. The destination operand (dividend) is always in\nan FPU register; the source operand (divisor) can be a register or a memory\nlocation. Source operands in memory can be in single-precision or double-precision\nfloating-point format, word or doubleword integer format.\n\nThe no-operand version of the instruction divides the contents of the ST(1)\nregister by the contents of the ST(0) register. The one-operand version divides\nthe contents of the ST(0) register by the contents of a memory location (either\na floating-point or an integer value). The two-operand version, divides the\ncontents of the ST(0) register by the contents of the ST(i) register or vice\nversa.\n\nThe FDIVP instructions perform the additional operation of popping the FPU register\nstack after storing the result. To pop the register stack, the processor marks\nthe ST(0) register as empty and increments the stack pointer (TOP) by 1. The\nno-operand version of the floating-point divide instructions always results\nin the register stack being popped. In some assemblers, the mnemonic for this\ninstruction is FDIV rather than FDIVP.\n\nThe FIDIV instructions convert an integer source operand to double extended-precision\nfloating-point format before performing the division. When the source operand\nis an integer 0, it is treated as a +0.\n\nIf an unmasked divide-by-zero exception (#Z) is generated, no result is stored;\nif the exception is masked, an \u221e of the appropriate sign is stored in the destination\noperand.\n\nThe following table shows the results obtained when dividing various classes\nof numbers, assuming that neither overflow nor underflow occurs.\n\n\nTable 3-34. FDIV/FDIVP/FIDIV Results:\nDEST\n\n| \u2212 \u221e      | \u2212 F + 0 | \u2212 0 + 0| + 0 \u2212 0| + F \u2212 0 | + \u221e      | NaN NaN    \n| + \u221e      | + F     | + 0    | \u2212 0    | \u2212 F     | \u2212 \u221e      | NaN        \n| + \u221e+ \u221e\u2212 \u221e| + F ****| + 0    | \u2212 0    | \u2212 F ****| \u2212 \u221e\u2212 \u221e+ \u221e| NaN NaN NaN\n| \u2212 \u221e      | \u2212 F     | \u2212 0    | + 0    | + F     | + \u221e      | NaN        \n| \u2212 \u221e      | \u2212 F \u2212 0 | \u2212 0 \u2212 0| + 0 + 0| + F + 0 | + \u221e      | NaN NaN    \n| NaN      | NaN     | NaN    | NaN    | NaN     | NaN      | NaN        \nNotes: F Means finite floating-point value.\n\n| I * Indicates floating-point invalid-arithmetic-operand| Means integer.\n| (#IA) exception. ** Indicates floating-point           |               \n| zero-divide (#Z) exception.                            |               \nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF SRC = 0\n  THEN\n     #Z;\n  ELSE\n     IF Instruction is FIDIV\n       THEN\n          DEST <- DEST / ConvertToDoubleExtendedPrecisionFP(SRC);\n       ELSE (* Source operand is floating-point value *)\n          DEST <- DEST / SRC;\n     FI;\nFI;\nIF Instruction = FDIVP\n  THEN\n     PopRegisterStack;\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.              \n| #IA| Operand is an SNaN value or unsupported\n|    | format. \u00b1\u221e / \u00b1\u221e; \u00b10 / \u00b10               \n| #D | Source is a denormal value.            \n| #Z | DEST / \u00b10, where DEST is not equal to  \n|    | \u00b10.                                    \n| #U | Result is too small for destination    \n|    | format.                                \n| #O | Result is too large for destination    \n|    | format.                                \n| #P | Value cannot be represented exactly    \n|    | in destination format.                 \n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FDIV"
    }, 
    {
      "description": "-R:FDIV", 
      "mnem": "FDIVP"
    }, 
    {
      "description": "\nFDIVR/FDIVRP/FIDIVR - Reverse Divide:\n| Opcode | Instruction        | 64-Bit Mode| Compat/Leg Mode| Description                            \n| D8 /7  | FDIVR m32fp        | Valid      | Valid          | Divide m32fp by ST(0) and store result \n|        |                    |            |                | in ST(0).                              \n| DC /7  | FDIVR m64fp        | Valid      | Valid          | Divide m64fp by ST(0) and store result \n|        |                    |            |                | in ST(0).                              \n| D8 F8+i| FDIVR ST(0), ST(i) | Valid      | Valid          | Divide ST(i) by ST(0) and store result \n|        |                    |            |                | in ST(0).                              \n| DC F0+i| FDIVR ST(i), ST(0) | Valid      | Valid          | Divide ST(0) by ST(i) and store result \n|        |                    |            |                | in ST(i).                              \n| DE F0+i| FDIVRP ST(i), ST(0)| Valid      | Valid          | Divide ST(0) by ST(i), store result    \n|        |                    |            |                | in ST(i), and pop the register stack.  \n| DE F1  | FDIVRP             | Valid      | Valid          | Divide ST(0) by ST(1), store result    \n|        |                    |            |                | in ST(1), and pop the register stack.  \n| DA /7  | FIDIVR m32int      | Valid      | Valid          | Divide m32int by ST(0) and store result\n|        |                    |            |                | in ST(0).                              \n| DE /7  | FIDIVR m16int      | Valid      | Valid          | Divide m16int by ST(0) and store result\n|        |                    |            |                | in ST(0).                              \n\nDescription:\nDivides the source operand by the destination operand and stores the result\nin the destination location. The destination operand (divisor) is always in\nan FPU register; the source operand (dividend) can be a register or a memory\nlocation. Source operands in memory can be in single-precision or double-precision\nfloating-point format, word or doubleword integer format.\n\nThese instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV\ninstructions. They are provided to support more efficient coding.\n\nThe no-operand version of the instruction divides the contents of the ST(0)\nregister by the contents of the ST(1) register. The one-operand version divides\nthe contents of a memory location (either a floating-point or an integer value)\nby the contents of the ST(0) register. The two-operand version, divides the\ncontents of the ST(i) register by the contents of the ST(0) register or vice\nversa.\n\nThe FDIVRP instructions perform the additional operation of popping the FPU\nregister stack after storing the result. To pop the register stack, the processor\nmarks the ST(0) register as empty and increments the stack pointer (TOP) by\n1. The no-operand version of the floating-point divide instructions always results\nin the register stack being popped. In some assemblers, the mnemonic for this\ninstruction is FDIVR rather than FDIVRP.\n\nThe FIDIVR instructions convert an integer source operand to double extended-precision\nfloating-point format before performing the division.\n\nIf an unmasked divide-by-zero exception (#Z) is generated, no result is stored;\nif the exception is masked, an \u221e of the appropriate sign is stored in the destination\noperand.\n\nThe following table shows the results obtained when dividing various classes\nof numbers, assuming that neither overflow nor underflow occurs.\n\n\nTable 3-35. FDIVR/FDIVRP/FIDIVR Results:\nDEST\n\n| \u2212 \u221e     | \u2212 F + \u221e    | \u2212 0 + \u221e| + 0 \u2212 \u221e| + F \u2212 \u221e    | + \u221e     | NaN NaN    \n| +0      | + F        | **     | **     | \u2212 F        | \u22120      | NaN        \n| +0 +0 \u22120| + F + 0 \u2212 0| **     | **     | \u2212 F \u2212 0 + 0| \u22120 \u22120 +0| NaN NaN NaN\n| \u22120      | \u2212 F        | **     | **     | + F        | +0      | NaN        \n| \u22120      | \u2212 F \u2212 \u221e    | **\u2212 \u221e  | **+ \u221e  | + F + \u221e    | +0      | NaN NaN    \n| NaN     | NaN        | NaN    | NaN    | NaN        | NaN     | NaN        \nNotes: F Means finite floating-point value.\n\n| I * Indicates floating-point invalid-arithmetic-operand| Means integer.\n| (#IA) exception. ** Indicates floating-point           |               \n| zero-divide (#Z) exception.                            |               \nWhen the source operand is an integer 0, it is treated as a +0. This instruction's\noperation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF DEST = 0\n  THEN\n     #Z;\n  ELSE\n     IF Instruction = FIDIVR\n       THEN\n          DEST <- ConvertToDoubleExtendedPrecisionFP(SRC) / DEST;\n       ELSE (* Source operand is floating-point value *)\n          DEST <- SRC / DEST;\n     FI;\nFI;\nIF Instruction = FDIVRP\n  THEN\n     PopRegisterStack;\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.              \n| #IA| Operand is an SNaN value or unsupported\n|    | format. \u00b1\u221e / \u00b1\u221e; \u00b10 / \u00b10               \n| #D | Source is a denormal value.            \n| #Z | SRC / \u00b10, where SRC is not equal to    \n|    | \u00b10.                                    \n| #U | Result is too small for destination    \n|    | format.                                \n| #O | Result is too large for destination    \n|    | format.                                \n| #P | Value cannot be represented exactly    \n|    | in destination format.                 \n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FDIVR"
    }, 
    {
      "description": "-R:FDIVR", 
      "mnem": "FDIVRP"
    }, 
    {
      "description": "\nFFREE - Free Floating-Point Register:\n| Opcode | Instruction| 64-Bit Mode| Compat/Leg Mode| Description                 \n| DD C0+i| FFREE ST(i)| Valid      | Valid          | Sets tag for ST(i) to empty.\n\nDescription:\nSets the tag in the FPU tag register associated with register ST(i) to empty\n(11B). The contents of ST(i) and the FPU stack-top pointer (TOP) are not affected.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nTAG(i) <- 11B;\n\nFPU Flags Affected:\nC0, C1, C2, C3 undefined.\n\n\nFloating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FFREE"
    }, 
    {
      "description": "-R:FADD", 
      "mnem": "FIADD"
    }, 
    {
      "description": "\nFICOM/FICOMP - Compare Integer:\n| Opcode| Instruction  | 64-Bit Mode| Compat/Leg Mode| Description                            \n| DE /2 | FICOM m16int | Valid      | Valid          | Compare ST(0) with m16int.             \n| DA /2 | FICOM m32int | Valid      | Valid          | Compare ST(0) with m32int.             \n| DE /3 | FICOMP m16int| Valid      | Valid          | Compare ST(0) with m16int and pop stack\n|       |              |            |                | register.                              \n| DA /3 | FICOMP m32int| Valid      | Valid          | Compare ST(0) with m32int and pop stack\n|       |              |            |                | register.                              \n\nDescription:\nCompares the value in ST(0) with an integer source operand and sets the condition\ncode flags C0, C2, and C3 in the FPU status word according to the results (see\ntable below). The integer value is converted to double extendedprecision floating-point\nformat before the comparison is made.\n\n\nTable 3-36. FICOM/FICOMP Results:\n| Condition| C3 0 0 1| C2 0 0 0| C0 0 1 0\n| Unordered| 1       | 1       | 1       \nThese instructions perform an \u201cunordered comparison.\u201d An unordered comparison\nalso checks the class of the numbers being compared (see \u201cFXAM - Examine ModR/M\u201d\nin this chapter). If either operand is a NaN or is in an undefined format, the\ncondition flags are set to \u201cunordered.\u201d\n\nThe sign of zero is ignored, so that -0.0 \u2190 +0.0.\n\nThe FICOMP instructions pop the register stack following the comparison. To\npop the register stack, the processor marks the ST(0) register empty and increments\nthe stack pointer (TOP) by 1.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nCASE (relation of operands) OF\n  ST(0) > SRC:\n  ST(0) < SRC:\n  ST(0) = SRC:\n  Unordered:\nESAC;\nIF Instruction = FICOMP\n  THEN\n     PopRegisterStack;\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 0.                  \n| C0, C2, C3| See table on previous page.\n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.                \n| #IA| One or both operands are NaN values      \n|    | or have unsupported formats.             \n| #D | One or both operands are denormal values.\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FICOM"
    }, 
    {
      "description": "-R:FICOM", 
      "mnem": "FICOMP"
    }, 
    {
      "description": "-R:FDIV", 
      "mnem": "FIDIV"
    }, 
    {
      "description": "-R:FDIVR", 
      "mnem": "FIDIVR"
    }, 
    {
      "description": "\nFILD - Load Integer:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                             \n| DF /0 | FILD m16int| Valid      | Valid          | Push m16int onto the FPU register stack.\n| DB /0 | FILD m32int| Valid      | Valid          | Push m32int onto the FPU register stack.\n| DF /5 | FILD m64int| Valid      | Valid          | Push m64int onto the FPU register stack.\n\nDescription:\nConverts the signed-integer source operand into double extended-precision floating-point\nformat and pushes the value onto the FPU register stack. The source operand\ncan be a word, doubleword, or quadword integer. It is loaded without rounding\nerrors. The sign of the source operand is preserved.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nTOP <- TOP \u2212 1;\nST(0) <- ConvertToDoubleExtendedPrecisionFP(SRC);\n\nFPU Flags Affected:\n| C1        | Set to 1 if stack overflow occurred;\n|           | set to 0 otherwise.                 \n| C0, C2, C3| Undefined.                          \n\nFloating-Point Exceptions:\n| #IS| Stack overflow occurred.\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FILD"
    }, 
    {
      "description": "-R:FMUL", 
      "mnem": "FIMUL"
    }, 
    {
      "description": "\nFINCSTP - Increment Stack-Top Pointer:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                              \n| D9 F7 | FINCSTP    | Valid      | Valid          | Increment the TOP field in the FPU status\n|       |            |            |                | register.                                \n\nDescription:\nAdds one to the TOP field of the FPU status word (increments the top-of-stack\npointer). If the TOP field contains a 7, it is set to 0. The effect of this\ninstruction is to rotate the stack by one position. The contents of the FPU\ndata registers and tag register are not affected. This operation is not equivalent\nto popping the stack, because the tag for the previous top-of-stack register\nis not marked empty.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF TOP = 7\n  THEN TOP <- 0;\n  ELSE TOP <- TOP + 1;\nFI;\n\nFPU Flags Affected:\nThe C1 flag is set to 0. The C0, C2, and C3 flags are undefined.\n\n\nFloating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FINCSTP"
    }, 
    {
      "description": "\nFINIT/FNINIT - Initialize Floating-Point Unit:\n| Opcode  | Instruction| 64-Bit Mode| Compat/Leg Mode| Description                                \n| 9B DB E3| FINIT      | Valid      | Valid          | Initialize FPU after checking for pending  \n|         |            |            |                | unmasked floating-point exceptions.        \n| DB E3   | FNINIT*    | Valid      | Valid          | Initialize FPU without checking for        \n|         |            |            |                | pending unmasked floating-point exceptions.\nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nDescription:\nSets the FPU control, status, tag, instruction pointer, and data pointer registers\nto their default states. The FPU control word is set to 037FH (round to nearest,\nall exceptions masked, 64-bit precision). The status word is cleared (no exception\nflags set, TOP is set to 0). The data registers in the register stack are left\nunchanged, but they are all tagged as empty (11B). Both the instruction and\ndata pointers are cleared.\n\nThe FINIT instruction checks for and handles any pending unmasked floating-point\nexceptions before performing the initialization; the FNINIT instruction does\nnot.\n\nThe assembler issues two instructions for the FINIT instruction (an FWAIT instruction\nfollowed by an FNINIT instruction), and the processor executes each of these\ninstructions in separately. If an exception is generated for either of these\ninstructions, the save EIP points to the instruction that caused the exception.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nIA-32 Architecture Compatibility:\nWhen operating a Pentium or Intel486 processor in MS-DOS compatibility mode,\nit is possible (under unusual circumstances) for an FNINIT instruction to be\ninterrupted prior to being executed to handle a pending FPU exception. See the\nsection titled \u201cNo-Wait FPU Instructions Can Get FPU Interrupt in Window\u201d in\nAppendix D of the Intel\u00ae64 and IA-32 Architectures Software Developer's Manual,\nVolume 1, for a description of these circumstances. An FNINIT instruction cannot\nbe interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.\n\nIn the Intel387 math coprocessor, the FINIT/FNINIT instruction does not clear\nthe instruction and data pointers.\n\nThis instruction affects only the x87 FPU. It does not affect the XMM and MXCSR\nregisters.\n\nOperation:\n\nFPUControlWord <- 037FH;\nFPUStatusWord <- 0;\nFPUTagWord <- FFFFH;\nFPUDataPointer <- 0;\nFPUInstructionPointer <- 0;\nFPULastInstructionOpcode <- 0;\n\nFPU Flags Affected:\nC0, C1, C2, C3 set to 0.\n\n\nFloating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FINIT"
    }, 
    {
      "description": "\nFIST/FISTP - Store Integer:\n| Opcode| Instruction | 64-Bit Mode| Compat/Leg Mode| Description                           \n| DF /2 | FIST m16int | Valid      | Valid          | Store ST(0) in m16int.                \n| DB /2 | FIST m32int | Valid      | Valid          | Store ST(0) in m32int.                \n| DF /3 | FISTP m16int| Valid      | Valid          | Store ST(0) in m16int and pop register\n|       |             |            |                | stack.                                \n| DB /3 | FISTP m32int| Valid      | Valid          | Store ST(0) in m32int and pop register\n|       |             |            |                | stack.                                \n| DF /7 | FISTP m64int| Valid      | Valid          | Store ST(0) in m64int and pop register\n|       |             |            |                | stack.                                \n\nDescription:\nThe FIST instruction converts the value in the ST(0) register to a signed integer\nand stores the result in the destination operand. Values can be stored in word\nor doubleword integer format. The destination operand specifies the address\nwhere the first byte of the destination value is to be stored.\n\nThe FISTP instruction performs the same operation as the FIST instruction and\nthen pops the register stack. To pop the register stack, the processor marks\nthe ST(0) register as empty and increments the stack pointer (TOP) by 1. The\nFISTP instruction also stores values in quadword integer format.\n\nThe following table shows the results obtained when storing various classes\nof numbers in integer format.\n\n\nTable 3-37. FIST/FISTP Results:\n| ST(0)  | DEST \u2212 \u221e or Value Too Large for DEST   \n|        | Format                                 \n| F \u2264 \u22121 | \u2212 I **                                 \n| \u2212 0    | 0                                      \n| + 0 NaN| 0 **+ I + \u221e or Value Too Large for DEST\n|        | Format                                 \nNotes: F Means finite floating-point value.\n\n| I * Indicates floating-point invalid-operation| Means integer.\n| (#IA) exception. ** 0 or \u00b11, depending        |               \n| on the rounding mode.                         |               \nIf the source value is a non-integral value, it is rounded to an integer value,\naccording to the rounding mode specified by the RC field of the FPU control\nword.\n\nIf the converted value is too large for the destination format, or if the source\noperand is an \u221e, SNaN, QNAN, or is in an unsupported format, an invalid-arithmetic-operand\ncondition is signaled. If the invalid-operation exception is not masked, an\ninvalid-arithmetic-operand exception (#IA) is generated and no value is stored\nin the destination operand. If the invalid-operation exception is masked, the\ninteger indefinite value is stored in memory.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nDEST <- Integer(ST(0));\nIF Instruction = FISTP\n  THEN\n     PopRegisterStack;\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred. \n|           | Indicates rounding direction of if the\n|           | inexact exception (#P) is generated:  \n|           | 0 \u2190 not roundup; 1 \u2190 roundup. Set to  \n|           | 0 otherwise.                          \n| C0, C2, C3| Undefined.                            \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.                \n| #IA| Converted value is too large for the     \n|    | destination format. Source operand is    \n|    | an SNaN, QNaN, \u00b1\u221e, or unsupported format.\n| #P | Value cannot be represented exactly      \n|    | in destination format.                   \n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register is used to access           \n|                | memory and it contains a NULL segment          \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.            \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FIST"
    }, 
    {
      "description": "-R:FIST", 
      "mnem": "FISTP"
    }, 
    {
      "description": "\nFISTTP - Store Integer with Truncation:\n| Opcode| Instruction  | 64-Bit Mode| Compat/Leg Mode| Description                           \n| DF /1 | FISTTP m16int| Valid      | Valid          | Store ST(0) in m16int with truncation.\n| DB /1 | FISTTP m32int| Valid      | Valid          | Store ST(0) in m32int with truncation.\n| DD /1 | FISTTP m64int| Valid      | Valid          | Store ST(0) in m64int with truncation.\n\nDescription:\nFISTTP converts the value in ST into a signed integer using truncation (chop)\nas rounding mode, transfers the result to the destination, and pop ST. FISTTP\naccepts word, short integer, and long integer destinations.\n\nThe following table shows the results obtained when storing various classes\nof numbers in integer format.\n\n\nTable 3-38. FISTTP Results:\n| ST(0)                             | DEST     \n| Value Too Large for DEST Format   | \u2212 \u221e or   \n| \u2212 1                               | \u2212 I 0 + I\n| or Value Too Large for DEST Format| + \u221eNaN   \nNotes: F Means finite floating-point value. \u0399 Means integer. * Indicates floating-point\ninvalid-operation (#IA) exception.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nDEST <- ST;\npop ST;\n\nFlags Affected:\nC1 is cleared; C0, C2, C3 undefined.\n\n\nNumeric Exceptions:\nInvalid, Stack Invalid (stack underflow), Precision.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is in a nonwritable   \n|                | segment. For an illegal memory operand   \n|                | effective address in the CS, DS, ES,     \n|                | FS or GS segments.                       \n| #SS(0)         | For an illegal address in the SS segment.\n| #PF(fault-code)| For a page fault.                        \n| #AC(0)         | If alignment checking is enabled and     \n|                | an unaligned memory reference is made    \n|                | while the current privilege level is     \n|                | 3.                                       \n| #NM            | If CR0.EM[bit 2] = 1. If CR0.TS[bit      \n|                | 3] = 1.                                  \n| #UD            | If CPUID.01H:ECX.SSE3[bit 0] = 0. If     \n|                | the LOCK prefix is used.                 \n\nReal Address Mode Exceptions:\n| GP(0)| If any part of the operand would lie  \n|      | outside of the effective address space\n|      | from 0 to 0FFFFH.                     \n| #NM  | If CR0.EM[bit 2] = 1. If CR0.TS[bit   \n|      | 3] = 1.                               \n| #UD  | If CPUID.01H:ECX.SSE3[bit 0] = 0. If  \n|      | the LOCK prefix is used.              \n\nVirtual 8086 Mode Exceptions:\n| GP(0)          | If any part of the operand would lie  \n|                | outside of the effective address space\n|                | from 0 to 0FFFFH.                     \n| #NM            | If CR0.EM[bit 2] = 1. If CR0.TS[bit   \n|                | 3] = 1.                               \n| #UD            | If CPUID.01H:ECX.SSE3[bit 0] = 0. If  \n|                | the LOCK prefix is used.              \n| #PF(fault-code)| For a page fault.                     \n| #AC(0)         | For unaligned memory reference if the \n|                | current privilege is 3.               \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3. If the LOCK prefix is used.             \n", 
      "mnem": "FISTTP"
    }, 
    {
      "description": "-R:FSUB", 
      "mnem": "FISUB"
    }, 
    {
      "description": "-R:FSUBR", 
      "mnem": "FISUBR"
    }, 
    {
      "description": "\nFLD - Load Floating Point Value:\n| Opcode | Instruction| 64-Bit Mode| Compat/Leg Mode| Description                            \n| D9 /0  | FLD m32fp  | Valid      | Valid          | Push m32fp onto the FPU register stack.\n| DD /0  | FLD m64fp  | Valid      | Valid          | Push m64fp onto the FPU register stack.\n| DB /5  | FLD m80fp  | Valid      | Valid          | Push m80fp onto the FPU register stack.\n| D9 C0+i| FLD ST(i)  | Valid      | Valid          | Push ST(i) onto the FPU register stack.\n\nDescription:\nPushes the source operand onto the FPU register stack. The source operand can\nbe in single-precision, doubleprecision, or double extended-precision floating-point\nformat. If the source operand is in single-precision or double-precision floating-point\nformat, it is automatically converted to the double extended-precision floatingpoint\nformat before being pushed on the stack.\n\nThe FLD instruction can also push the value in a selected FPU register [ST(i)]\nonto the stack. Here, pushing register ST(0) duplicates the stack top.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF SRC is ST(i)\n  THEN\n     temp <- ST(i);\nFI;\nTOP <- TOP \u2212 1;\nIF SRC is memory-operand\n  THEN\n     ST(0) <- ConvertToDoubleExtendedPrecisionFP(SRC);\n  ELSE (* SRC is ST(i) *)\n     ST(0) <- temp;\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 1 if stack overflow occurred;\n|           | otherwise, set to 0.                \n| C0, C2, C3| Undefined.                          \n\nFloating-Point Exceptions:\n| #IS| Stack underflow or overflow occurred.         \n| #IA| Source operand is an SNaN. Does not           \n|    | occur if the source operand is in double      \n|    | extended-precision floating-point format      \n|    | (FLD m80fp or FLD ST(i)).                     \n| #D | Source operand is a denormal value.           \n|    | Does not occur if the source operand          \n|    | is in double extended-precision floating-point\n|    | format.                                       \n\nProtected Mode Exceptions:\n| #GP(0)         | If destination is located in a non-writable\n|                | segment. If a memory operand effective     \n|                | address is outside the CS, DS, ES, FS,     \n|                | or GS segment limit. If the DS, ES,        \n|                | FS, or GS register is used to access       \n|                | memory and it contains a NULL segment      \n|                | selector.                                  \n| #SS(0)         | If a memory operand effective address      \n|                | is outside the SS segment limit.           \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FLD"
    }, 
    {
      "description": "\nFLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ - Load Constant:\n| Opcode*| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                                \n| D9 E8  | FLD1       | Valid      | Valid          | Push +1.0 onto the FPU register stack.     \n| D9 E9  | FLDL2T     | Valid      | Valid          | Push log<sub>2</sub>10 onto the FPU        \n|        |            |            |                | register stack.                            \n| D9 EA  | FLDL2E     | Valid      | Valid          | Push log<sub>2</sub>e onto the FPU register\n|        |            |            |                | stack.                                     \n| D9 EB  | FLDPI      | Valid      | Valid          | Push \u03c0 onto the FPU register stack.        \n| D9 EC  | FLDLG2     | Valid      | Valid          | Push log<sub>10</sub>2 onto the FPU        \n|        |            |            |                | register stack.                            \n| D9 ED  | FLDLN2     | Valid      | Valid          | Push log<sub>e</sub>2 onto the FPU register\n|        |            |            |                | stack.                                     \n| D9 EE  | FLDZ       | Valid      | Valid          | Push +0.0 onto the FPU register stack.     \nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nDescription:\nPush one of seven commonly used constants (in double extended-precision floating-point\nformat) onto the FPU register stack. The constants that can be loaded with these\ninstructions include +1.0, +0.0, log<sub>2</sub>10, log<sub>2</sub>e, \u03c0, log<sub>10</sub>2,\nand log<sub>e</sub>2. For each constant, an internal 66-bit constant is rounded\n(as specified by the RC field in the FPU control word) to double extended-precision\nfloating-point format. The inexact-result exception (#P) is not generated as\na result of the rounding, nor is the C1 flag set in the x87 FPU status word\nif the value is rounded up.\n\nSee the section titled \u201cPi\u201d in Chapter 8 of the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1, for a description of the \u03c0 constant.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nIA-32 Architecture Compatibility:\nWhen the RC field is set to round-to-nearest, the FPU produces the same constants\nthat is produced by the Intel 8087 and Intel 287 math coprocessors.\n\nOperation:\n\nTOP <- TOP \u2212 1;\nST(0) <- CONSTANT;\n\nFPU Flags Affected:\n| C1        | Set to 1 if stack overflow occurred;\n|           | otherwise, set to 0.                \n| C0, C2, C3| Undefined.                          \n\nFloating-Point Exceptions:\n| #IS| Stack overflow occurred.\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FLD1"
    }, 
    {
      "description": "\nFLDCW - Load x87 FPU Control Word:\n| Opcode| Instruction | 64-Bit Mode| Compat/Leg Mode| Description                       \n| D9 /5 | FLDCW m2byte| Valid      | Valid          | Load FPU control word from m2byte.\n\nDescription:\nLoads the 16-bit source operand into the FPU control word. The source operand\nis a memory location. This instruction is typically used to establish or change\nthe FPU's mode of operation.\n\nIf one or more exception flags are set in the FPU status word prior to loading\na new FPU control word and the new control word unmasks one or more of those\nexceptions, a floating-point exception will be generated upon execution of the\nnext floating-point instruction (except for the no-wait floating-point instructions,\nsee the section titled \u201cSoftware Exception Handling\u201d in Chapter 8 of the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1). To avoid\nraising exceptions when changing FPU operating modes, clear any pending exceptions\n(using the FCLEX or FNCLEX instruction) before loading the new control word.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nFPUControlWord <- SRC;\n\nFPU Flags Affected:\nC0, C1, C2, C3 undefined.\n\n\nFloating-Point Exceptions:\nNone; however, this operation might unmask a pending exception in the FPU status\nword. That exception is then generated upon execution of the next \u201cwaiting\u201d\nfloating-point instruction.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address   \n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit. If the DS, ES, FS, or    \n|                | GS register is used to access memory    \n|                | and it contains a NULL segment selector.\n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made   \n|                | while the current privilege level is    \n|                | 3.                                      \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FLDCW"
    }, 
    {
      "description": "\nFLDENV - Load x87 FPU Environment:\n| Opcode| Instruction      | 64-Bit Mode| Compat/Leg Mode| Description                         \n| D9 /4 | FLDENV m14/28byte| Valid      | Valid          | Load FPU environment from m14byte or\n|       |                  |            |                | m28byte.                            \n\nDescription:\nLoads the complete x87 FPU operating environment from memory into the FPU registers.\nThe source operand specifies the first byte of the operating-environment data\nin memory. This data is typically written to the specified memory location by\na FSTENV or FNSTENV instruction.\n\nThe FPU operating environment consists of the FPU control word, status word,\ntag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through\n8-12 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1, show the layout in memory of the loaded environment, depending on the operating\nmode of the processor (protected or real) and the current operand-size attribute\n(16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.\n\nThe FLDENV instruction should be executed in the same operating mode as the\ncorresponding FSTENV/FNSTENV instruction.\n\nIf one or more unmasked exception flags are set in the new FPU status word,\na floating-point exception will be generated upon execution of the next floating-point\ninstruction (except for the no-wait floating-point instructions, see the section\ntitled \u201cSoftware Exception Handling\u201d in Chapter 8 of the Intel\u00ae 64 and IA-32\nArchitectures Software Developer's Manual, Volume 1). To avoid generating exceptions\nwhen loading a new environment, clear all the exception flags in the FPU status\nword that is being loaded.\n\nIf a page or limit fault occurs during the execution of this instruction, the\nstate of the x87 FPU registers as seen by the fault handler may be different\nthan the state being loaded from memory. In such situations, the fault handler\nshould ignore the status of the x87 FPU registers, handle the fault, and return.\nThe FLDENV instruction will then complete the loading of the x87 FPU registers\nwith no resulting context inconsistency.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nFPUControlWord <- SRC[FPUControlWord];\nFPUStatusWord <- SRC[FPUStatusWord];\nFPUTagWord <- SRC[FPUTagWord];\nFPUDataPointer <- SRC[FPUDataPointer];\nFPUInstructionPointer <- SRC[FPUInstructionPointer];\nFPULastInstructionOpcode <- SRC[FPULastInstructionOpcode];\n\nFPU Flags Affected:\nThe C0, C1, C2, C3 flags are loaded.\n\n\nFloating-Point Exceptions:\nNone; however, if an unmasked exception is loaded in the status word, it is\ngenerated upon execution of the next \u201cwaiting\u201d floating-point instruction.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address   \n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit. If the DS, ES, FS, or    \n|                | GS register is used to access memory    \n|                | and it contains a NULL segment selector.\n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made   \n|                | while the current privilege level is    \n|                | 3.                                      \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FLDENV"
    }, 
    {
      "description": "-R:FLD1", 
      "mnem": "FLDL2E"
    }, 
    {
      "description": "-R:FLD1", 
      "mnem": "FLDL2T"
    }, 
    {
      "description": "-R:FLD1", 
      "mnem": "FLDLG2"
    }, 
    {
      "description": "-R:FLD1", 
      "mnem": "FLDLN2"
    }, 
    {
      "description": "-R:FLD1", 
      "mnem": "FLDPI"
    }, 
    {
      "description": "-R:FLD1", 
      "mnem": "FLDZ"
    }, 
    {
      "description": "\nFMUL/FMULP/FIMUL - Multiply:\n| Opcode | Instruction       | 64-Bit Mode| Compat/Leg Mode| Description                              \n| D8 /1  | FMUL m32fp        | Valid      | Valid          | Multiply ST(0) by m32fp and store result \n|        |                   |            |                | in ST(0).                                \n| DC /1  | FMUL m64fp        | Valid      | Valid          | Multiply ST(0) by m64fp and store result \n|        |                   |            |                | in ST(0).                                \n| D8 C8+i| FMUL ST(0), ST(i) | Valid      | Valid          | Multiply ST(0) by ST(i) and store result \n|        |                   |            |                | in ST(0).                                \n| DC C8+i| FMUL ST(i), ST(0) | Valid      | Valid          | Multiply ST(i) by ST(0) and store result \n|        |                   |            |                | in ST(i).                                \n| DE C8+i| FMULP ST(i), ST(0)| Valid      | Valid          | Multiply ST(i) by ST(0), store result    \n|        |                   |            |                | in ST(i), and pop the register stack.    \n| DE C9  | FMULP             | Valid      | Valid          | Multiply ST(1) by ST(0), store result    \n|        |                   |            |                | in ST(1), and pop the register stack.    \n| DA /1  | FIMUL m32int      | Valid      | Valid          | Multiply ST(0) by m32int and store result\n|        |                   |            |                | in ST(0).                                \n| DE /1  | FIMUL m16int      | Valid      | Valid          | Multiply ST(0) by m16int and store result\n|        |                   |            |                | in ST(0).                                \n\nDescription:\nMultiplies the destination and source operands and stores the product in the\ndestination location. The destination operand is always an FPU data register;\nthe source operand can be an FPU data register or a memory location. Source\noperands in memory can be in single-precision or double-precision floating-point\nformat or in word or doubleword integer format.\n\nThe no-operand version of the instruction multiplies the contents of the ST(1)\nregister by the contents of the ST(0) register and stores the product in the\nST(1) register. The one-operand version multiplies the contents of the ST(0)\nregister by the contents of a memory location (either a floating point or an\ninteger value) and stores the product in the ST(0) register. The two-operand\nversion, multiplies the contents of the ST(0) register by the contents of the\nST(i) register, or vice versa, with the result being stored in the register\nspecified with the first operand (the destination operand).\n\nThe FMULP instructions perform the additional operation of popping the FPU register\nstack after storing the product. To pop the register stack, the processor marks\nthe ST(0) register as empty and increments the stack pointer (TOP) by 1. The\nno-operand version of the floating-point multiply instructions always results\nin the register stack being popped. In some assemblers, the mnemonic for this\ninstruction is FMUL rather than FMULP.\n\nThe FIMUL instructions convert an integer source operand to double extendedprecision\nfloating-point format before performing the multiplication.\n\nThe sign of the result is always the exclusive-OR of the source signs, even\nif one or more of the values being multiplied is 0 or \u221e. When the source operand\nis an integer 0, it is treated as a +0.\n\nThe following table shows the results obtained when multiplying various classes\nof numbers, assuming that neither overflow nor underflow occurs.\n\n\nTable 3-39. FMUL/FMULP/FIMUL Results:\nDEST\n\n| \u2212 \u221e+ \u221e| \u2212 F + \u221e    | \u2212 0     | + 0     | + F \u2212 \u221e    | + \u221e\u2212 \u221e| NaN NaN    \n| + \u221e   | + F        | +0      | \u22120      | \u2212 F        | \u2212 \u221e   | NaN        \n| + \u221e   | + F + 0 \u2212 0| +0 +0 \u22120| \u22120 \u22120 +0| \u2212 F \u2212 0 + 0| \u2212 \u221e   | NaN NaN NaN\n| \u2212\u221e    | \u2212 F        | \u22120      | +0      | + F        | +\u221e    | NaN        \n| \u2212\u221e\u2212\u221e  | \u2212 F \u2212 \u221e    | \u22120      | +0      | + F + \u221e    | +\u221e+\u221e  | NaN NaN    \n| NaN   | NaN        | NaN     | NaN     | NaN        | NaN   | NaN        \nNotes: F Means finite floating-point value.\n\n| I * Indicates invalid-arithmetic-operand| Means Integer.\n| (#IA) exception.                        |               \nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF Instruction = FIMUL\n  THEN\n     DEST <- DEST * ConvertToDoubleExtendedPrecisionFP(SRC);\n  ELSE (* Source operand is floating-point value *)\n     DEST <- DEST * SRC;\nFI;\nIF Instruction = FMULP\n  THEN\n     PopRegisterStack;\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.              \n| #IA| Operand is an SNaN value or unsupported\n|    | format. One operand is \u00b10 and the other\n|    | is \u00b1\u221e.                                 \n| #D | Source operand is a denormal value.    \n| #U | Result is too small for destination    \n|    | format.                                \n| #O | Result is too large for destination    \n|    | format.                                \n| #P | Value cannot be represented exactly    \n|    | in destination format.                 \n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address   \n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit. If the DS, ES, FS, or    \n|                | GS register is used to access memory    \n|                | and it contains a NULL segment selector.\n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made   \n|                | while the current privilege level is    \n|                | 3.                                      \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FMUL"
    }, 
    {
      "description": "-R:FMUL", 
      "mnem": "FMULP"
    }, 
    {
      "description": "-R:FCLEX", 
      "mnem": "FNCLEX"
    }, 
    {
      "description": "-R:FINIT", 
      "mnem": "FNINIT"
    }, 
    {
      "description": "\nFNOP - No Operation:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description               \n| D9 D0 | FNOP       | Valid      | Valid          | No operation is performed.\n\nDescription:\nPerforms no FPU operation. This instruction takes up space in the instruction\nstream but does not affect the FPU or machine context, except the EIP register.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nFPU Flags Affected:\nC0, C1, C2, C3 undefined.\n\n\nFloating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FNOP"
    }, 
    {
      "description": "-R:FSAVE", 
      "mnem": "FNSAVE"
    }, 
    {
      "description": "-R:FSTCW", 
      "mnem": "FNSTCW"
    }, 
    {
      "description": "-R:FSTENV", 
      "mnem": "FNSTENV"
    }, 
    {
      "description": "-R:FSTSW", 
      "mnem": "FNSTSW"
    }, 
    {
      "description": "\nFPATAN - Partial Arctangent:\n| Opcode*                              | Instruction| 64-Bit Mode| Compat/Leg Mode| Description                           \n| D9 F3 NOTES: * See IA-32 Architecture| FPATAN     | Valid      | Valid          | Replace ST(1) with arctan(ST(1)/ST(0))\n| Compatibility section below.         |            |            |                | and pop the register stack.           \n\nDescription:\nComputes the arctangent of the source operand in register ST(1) divided by the\nsource operand in register ST(0), stores the result in ST(1), and pops the FPU\nregister stack. The result in register ST(0) has the same sign as the source\noperand ST(1) and a magnitude less than +\u03c0.\n\nThe FPATAN instruction returns the angle between the X axis and the line from\nthe origin to the point (X,Y), where Y (the ordinate) is ST(1) and X (the abscissa)\nis ST(0). The angle depends on the sign of X and Y independently, not just on\nthe sign of the ratio Y/X. This is because a point (\u2212X,Y) is in the second quadrant,\nresulting in an angle between \u03c0/2 and \u03c0, while a point (X,\u2212Y) is in the fourth\nquadrant, resulting in an angle between 0 and \u2212\u03c0/2. A point (\u2212X,\u2212Y) is in the\nthird quadrant, giving an angle between \u2212\u03c0/2 and \u2212\u03c0.\n\nThe following table shows the results obtained when computing the arctangent\nof various classes of numbers, assuming that underflow does not occur.\n\n\nTable 3-40. FPATAN Results:\nST(0)\n\n| \u2212 \u221e    | \u2212 F       | \u2212 0  | + 0  | + F       | + \u221e   | NaN\n| \u2212 3\u03c0/4*| \u2212 \u03c0/2     | \u2212 \u03c0/2| \u2212 \u03c0/2| \u2212 \u03c0/2     | \u2212 \u03c0/4*| NaN\n| -p     | \u2212\u03c0 to \u2212\u03c0/2| \u2212\u03c0/2 | \u2212\u03c0/2 | \u2212\u03c0/2 to \u22120| - 0   | NaN\n| -p     | -p        | -p*  | \u2212 0* | \u2212 0       | \u2212 0   | NaN\n| +p     | + p       | + \u03c0* | + 0* | + 0       | + 0   | NaN\n| +p     | +\u03c0 to +\u03c0/2| + \u03c0/2| +\u03c0/2 | +\u03c0/2 to +0| + 0   | NaN\n| +3\u03c0/4* | +\u03c0/2      | +\u03c0/2 | +\u03c0/2 | + \u03c0/2     | + \u03c0/4*| NaN\n| NaN    | NaN       | NaN  | NaN  | NaN       | NaN   | NaN\nNotes: F Means finite floating-point value. * Table 8-10 in the Intel\u00ae 64 and\nIA-32 Architectures Software Developer's Manual, Volume 1, specifies that the\nratios 0/0 and \u221e/\u221egenerate the floating-point invalid arithmetic-operation exception\nand, if this exception is masked, the floating-point QNaN indefinite value is\nreturned. With the FPATAN instruction, the 0/0 or \u221e/\u221e value is actually not\ncalculated using division. Instead, the arctangent of the two variables is derived\nfrom a standard mathematical formulation that is generalized to allow complex\nnumbers as arguments. In this complex variable formulation, arctangent(0,0)\netc. has well defined values. These values are needed to develop a library to\ncompute transcendental functions with complex arguments, based on the FPU functions\nthat only allow floating-point values as arguments.\n\nThere is no restriction on the range of source operands that FPATAN can accept.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nIA-32 Architecture Compatibility:\nThe source operands for this instruction are restricted for the 80287 math coprocessor\nto the following range:\n\n0 \u2264 |ST(1)| < |ST(0)| < +\u221e\n\nOperation:\n\nST(1) <- arctan(ST(1) / ST(0));\nPopRegisterStack;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.                     \n| #IA| Source operand is an SNaN value or unsupported\n|    | format.                                       \n| #D | Source operand is a denormal value.           \n| #U | Result is too small for destination           \n|    | format.                                       \n| #P | Value cannot be represented exactly           \n|    | in destination format.                        \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FPATAN"
    }, 
    {
      "description": "\nFPREM - Partial Remainder:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                              \n| D9 F8 | FPREM      | Valid      | Valid          | Replace ST(0) with the remainder obtained\n|       |            |            |                | from dividing ST(0) by ST(1).            \n\nDescription:\nComputes the remainder obtained from dividing the value in the ST(0) register\n(the dividend) by the value in the ST(1) register (the divisor or modulus),\nand stores the result in ST(0). The remainder represents the following value:\n\nRemainder \u2190 ST(0) \u2212 (Q * ST(1))\n\nHere, Q is an integer value that is obtained by truncating the floating-point\nnumber quotient of [ST(0) / ST(1)]toward zero. The sign of the remainder is\nthe same as the sign of the dividend. The magnitude of the remainder is less\nthan that of the modulus, unless a partial remainder was computed (as described\nbelow).\n\nThis instruction produces an exact result; the inexact-result exception does\nnot occur and the rounding control has no effect. The following table shows\nthe results obtained when computing the remainder of various classes of numbers,\nassuming that underflow does not occur.\n\n\nTable 3-41. FPREM Results:\nST(1)\n\n| -\u221e-0 +0| -F -F or -0 -0 +0 +F or +0 NaN| -0 ****NaN| +0 ****NaN| +F -F or -0 -0 +0 +F or +0 NaN| +\u221eST(0) -0 +0 ST(0) NaN| NaN NaN NaN NaN NaN NaN NaN NaN\nNotes: F Means finite floating-point value. * Indicates floating-point invalid-arithmetic-operand\n(#IA) exception. ** Indicates floating-point zero-divide (#Z) exception.\n\nWhen the result is 0, its sign is the same as that of the dividend. When the\nmodulus is \u221e, the result is equal to the value in ST(0).\n\nThe FPREM instruction does not compute the remainder specified in IEEE Std 754.\nThe IEEE specified remainder can be computed with the FPREM1 instruction. The\nFPREM instruction is provided for compatibility with the Intel 8087 and Intel287\nmath coprocessors.\n\nThe FPREM instruction gets its name \u201cpartial remainder\u201d because of the way it\ncomputes the remainder. This instruction arrives at a remainder through iterative\nsubtraction. It can, however, reduce the exponent of ST(0) by no more than 63\nin one execution of the instruction. If the instruction succeeds in producing\na remainder that is less than the modulus, the operation is complete and the\nC2 flag in the FPU status word is cleared. Otherwise, C2 is set, and the result\nin ST(0) is called the partial remainder. The exponent of the partial remainder\nwill be less than the exponent of the original dividend by at least 32. Software\ncan re-execute the instruction (using the partial remainder in ST(0) as the\ndividend) until C2 is cleared. (Note that while executing such a remainder-computation\nloop, a higher-priority interrupting routine that needs the FPU can force a\ncontext switch in-between the instructions in the loop.)\n\nAn important use of the FPREM instruction is to reduce the arguments of periodic\nfunctions. When reduction is complete, the instruction stores the three least-significant\nbits of the quotient in the C3, C1, and C0 flags of the FPU\n\nstatus word. This information is important in argument reduction for the tangent\nfunction (using a modulus of \u03c0/4), because it locates the original angle in\nthe correct one of eight sectors of the unit circle.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nD <- exponent(ST(0)) - exponent(ST(1));\nIF D < 64\n  THEN\n     Q <- Integer(TruncateTowardZero(ST(0) / ST(1)));\n     ST(0) <- ST(0) - (ST(1) * Q);\n     C2 <- 0;\n     C0, C3, C1 <- LeastSignificantBits(Q); (* Q2, Q1, Q0 *)\n  ELSE\n     C2 <- 1;\n     N <- An implementation-dependent number between 32 and 63;\n     QQ <- Integer(TruncateTowardZero((ST(0)\n     ST(0) <- ST(0) - (ST(1) * QQ * 2(D \u2212 N));\nFI;\n\nFPU Flags Affected:\n| C0| Set to bit 2 (Q2) of the quotient.   \n| C1| Set to 0 if stack underflow occurred;\n|   | otherwise, set to least significant  \n|   | bit of quotient (Q0).                \n| C2| Set to 0 if reduction complete; set  \n|   | to 1 if incomplete.                  \n| C3| Set to bit 1 (Q1) of the quotient.   \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.               \n| #IA| Source operand is an SNaN value, modulus\n|    | is 0, dividend is \u221e, or unsupported     \n|    | format.                                 \n| #D | Source operand is a denormal value.     \n| #U | Result is too small for destination     \n|    | format.                                 \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FPREM"
    }, 
    {
      "description": "\nFPREM1 - Partial Remainder:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                           \n| D9 F5 | FPREM1     | Valid      | Valid          | Replace ST(0) with the IEEE remainder \n|       |            |            |                | obtained from dividing ST(0) by ST(1).\n\nDescription:\nComputes the IEEE remainder obtained from dividing the value in the ST(0) register\n(the dividend) by the value in the ST(1) register (the divisor or modulus),\nand stores the result in ST(0). The remainder represents the following value:\n\nRemainder \u2190 ST(0) \u2212 (Q * ST(1))\n\nHere, Q is an integer value that is obtained by rounding the floating-point\nnumber quotient of [ST(0) / ST(1)]toward the nearest integer value. The magnitude\nof the remainder is less than or equal to half the magnitude of the modulus,\nunless a partial remainder was computed (as described below).\n\nThis instruction produces an exact result; the precision (inexact) exception\ndoes not occur and the rounding control has no effect. The following table shows\nthe results obtained when computing the remainder of various classes of numbers,\nassuming that underflow does not occur.\n\n\nTable 3-42. FPREM1 Results:\nST(1)\n\n| \u2212 \u221e\u22120 +0| \u2212 F \u00b1F or \u22120 \u2212 0 + 0 \u00b1 F or + 0| \u2212 0 ****| + 0 ****| + F \u00b1 F or \u2212 0 \u2212 0 + 0 \u00b1 F or + 0| + \u221eST(0) -0 +0 ST(0)| NaN NaN NaN NaN NaN NaN NaN\n| NaN     | NaN                            | NaN     | NaN     | NaN                              | NaN                 | NaN                        \nNotes: F Means finite floating-point value. * Indicates floating-point invalid-arithmetic-operand\n(#IA) exception. ** Indicates floating-point zero-divide (#Z) exception.\n\nWhen the result is 0, its sign is the same as that of the dividend. When the\nmodulus is \u221e, the result is equal to the value in ST(0).\n\nThe FPREM1 instruction computes the remainder specified in IEEE Standard 754.\nThis instruction operates differently from the FPREM instruction in the way\nthat it rounds the quotient of ST(0) divided by ST(1) to an integer (see the\n\u201cOperation\u201d section below).\n\nLike the FPREM instruction, FPREM1 computes the remainder through iterative\nsubtraction, but can reduce the exponent of ST(0) by no more than 63 in one\nexecution of the instruction. If the instruction succeeds in producing a remainder\nthat is less than one half the modulus, the operation is complete and the C2\nflag in the FPU status word is cleared. Otherwise, C2 is set, and the result\nin ST(0) is called the partial remainder. The exponent of the partial remainder\nwill be less than the exponent of the original dividend by at least 32. Software\ncan re-execute the instruction (using the partial remainder in ST(0) as the\ndividend) until C2 is cleared. (Note that while executing such a remainder-computation\nloop, a higher-priority interrupting routine that needs the FPU can force a\ncontext switch in-between the instructions in the loop.)\n\nAn important use of the FPREM1 instruction is to reduce the arguments of periodic\nfunctions. When reduction is complete, the instruction stores the three least-significant\nbits of the quotient in the C3, C1, and C0 flags of the FPU\n\nstatus word. This information is important in argument reduction for the tangent\nfunction (using a modulus of \u03c0/4), because it locates the original angle in\nthe correct one of eight sectors of the unit circle.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nD <- exponent(ST(0)) - exponent(ST(1));\nIF D < 64\n  THEN\n     Q <- Integer(RoundTowardNearestInteger(ST(0) / ST(1)));\n     ST(0) <- ST(0) - (ST(1) * Q);\n     C2 <- 0;\n     C0, C3, C1 <- LeastSignificantBits(Q); (* Q2, Q1, Q0 *)\n  ELSE\n     C2 <- 1;\n     N <- An implementation-dependent number between 32 and 63;\n     QQ <- Integer(TruncateTowardZero((ST(0)\n     ST(0) <- ST(0) - (ST(1) * QQ * 2(D \u2212 N));\nFI;\n\nFPU Flags Affected:\n| C0| Set to bit 2 (Q2) of the quotient.   \n| C1| Set to 0 if stack underflow occurred;\n|   | otherwise, set to least significant  \n|   | bit of quotient (Q0).                \n| C2| Set to 0 if reduction complete; set  \n|   | to 1 if incomplete.                  \n| C3| Set to bit 1 (Q1) of the quotient.   \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.                    \n| #IA| Source operand is an SNaN value, modulus     \n|    | (divisor) is 0, dividend is \u221e, or unsupported\n|    | format.                                      \n| #D | Source operand is a denormal value.          \n| #U | Result is too small for destination          \n|    | format.                                      \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FPREM1"
    }, 
    {
      "description": "\nFPTAN - Partial Tangent:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                            \n| D9 F2 | FPTAN      | Valid      | Valid          | Replace ST(0) with its tangent and push\n|       |            |            |                | 1 onto the FPU stack.                  \n\nDescription:\nComputes the tangent of the source operand in register ST(0), stores the result\nin ST(0), and pushes a 1.0 onto the FPU register stack. The source operand must\nbe given in radians and must be less than \u00b1263. The following table shows the\nunmasked results obtained when computing the partial tangent of various classes\nof numbers, assuming that underflow does not occur.\n\n\nTable 3-43. FPTAN Results:\n| ST(0) SRC \u2212 \u221e| ST(0) DEST\n| \u2212 F          | \u2212 F to + F\n| \u2212 0          | -0        \n| + 0          | +0        \n| + F + \u221e      | \u2212 F to + F\n| NaN          | NaN       \nNotes: F Means finite floating-point value. * Indicates floating-point invalid-arithmetic-operand\n(#IA) exception.\n\nIf the source operand is outside the acceptable range, the C2 flag in the FPU\nstatus word is set, and the value in register ST(0) remains unchanged. The instruction\ndoes not raise an exception when the source operand is out of range. It is up\nto the program to check the C2 flag for out-of-range conditions. Source values\noutside the range \u2212263 to +263 can be reduced to the range of the instruction\nby subtracting an appropriate integer multiple of 2\u03c0 or by using the FPREM instruction\nwith a divisor of 2\u03c0. See the section titled \u201cPi\u201d in Chapter 8 of the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a discussion\nof the proper value to use for \u03c0 in performing such reductions.\n\nThe value 1.0 is pushed onto the register stack after the tangent has been computed\nto maintain compatibility with the Intel 8087 and Intel287 math coprocessors.\nThis operation also simplifies the calculation of other trigonometric functions.\nFor instance, the cotangent (which is the reciprocal of the tangent) can be\ncomputed by executing a FDIVR instruction after the FPTAN instruction.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF ST(0) < 263\n  THEN\n     C2 <- 0;\n     ST(0) <- tan(ST(0));\n     TOP <- TOP \u2212 1;\n     ST(0) <- 1.0;\n  ELSE (* Source operand is out-of-range *)\n     C2 <- 1;\nFI;\n\nFPU Flags Affected:\n| C1    | Set to 0 if stack underflow occurred;   \n|       | set to 1 if stack overflow occurred.    \n|       | Set if result was rounded up; cleared   \n|       | otherwise.                              \n| C2    | Set to 1 if outside range (\u2212263 < source\n|       | operand < +263); otherwise, set to 0.   \n| C0, C3| Undefined.                              \n\nFloating-Point Exceptions:\n| #IS| Stack underflow or overflow occurred.\n| #IA| Source operand is an SNaN value, \u221e,  \n|    | or unsupported format.               \n| #D | Source operand is a denormal value.  \n| #U | Result is too small for destination  \n|    | format.                              \n| #P | Value cannot be represented exactly  \n|    | in destination format.               \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FPTAN"
    }, 
    {
      "description": "\nFRNDINT - Round to Integer:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description               \n| D9 FC | FRNDINT    | Valid      | Valid          | Round ST(0) to an integer.\n\nDescription:\nRounds the source value in the ST(0) register to the nearest integral value,\ndepending on the current rounding mode (setting of the RC field of the FPU control\nword), and stores the result in ST(0).\n\nIf the source value is \u221e, the value is not changed. If the source value is not\nan integral value, the floating-point inexact-result exception (#P) is generated.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nST(0) <- RoundToIntegralValue(ST(0));\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.                     \n| #IA| Source operand is an SNaN value or unsupported\n|    | format.                                       \n| #D | Source operand is a denormal value.           \n| #P | Source operand is not an integral value.      \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FRNDINT"
    }, 
    {
      "description": "\nFRSTOR - Restore x87 FPU State:\n| Opcode| Instruction       | 64-Bit Mode| Compat/Leg Mode| Description                             \n| DD /4 | FRSTOR m94/108byte| Valid      | Valid          | Load FPU state from m94byte or m108byte.\n\nDescription:\nLoads the FPU state (operating environment and register stack) from the memory\narea specified with the source operand. This state data is typically written\nto the specified memory location by a previous FSAVE/FNSAVE instruction.\n\nThe FPU operating environment consists of the FPU control word, status word,\ntag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through\n8-12 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1, show the layout in memory of the stored environment, depending on the operating\nmode of the processor (protected or real) and the current operand-size attribute\n(16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used. The\ncontents of the FPU register stack are stored in the 80 bytes immediately following\nthe operating environment image.\n\nThe FRSTOR instruction should be executed in the same operating mode as the\ncorresponding FSAVE/FNSAVE instruction.\n\nIf one or more unmasked exception bits are set in the new FPU status word, a\nfloating-point exception will be generated. To avoid raising exceptions when\nloading a new operating environment, clear all the exception flags in the FPU\nstatus word that is being loaded.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nFPUControlWord <- SRC[FPUControlWord];\nFPUStatusWord <- SRC[FPUStatusWord];\nFPUTagWord <- SRC[FPUTagWord];\nFPUDataPointer <- SRC[FPUDataPointer];\nFPUInstructionPointer <- SRC[FPUInstructionPointer];\nFPULastInstructionOpcode <- SRC[FPULastInstructionOpcode];\nST(0) <- SRC[ST(0)];\nST(1) <- SRC[ST(1)];\nST(2) <- SRC[ST(2)];\nST(3) <- SRC[ST(3)];\nST(4) <- SRC[ST(4)];\nST(5) <- SRC[ST(5)];\nST(6) <- SRC[ST(6)];\nST(7) <- SRC[ST(7)];\n\nFPU Flags Affected:\nThe C0, C1, C2, C3 flags are loaded.\n\n\nFloating-Point Exceptions:\nNone; however, this operation might unmask an existing exception that has been\ndetected but not generated, because it was masked. Here, the exception is generated\nat the completion of the instruction.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address   \n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit. If the DS, ES, FS, or    \n|                | GS register is used to access memory    \n|                | and it contains a NULL segment selector.\n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made   \n|                | while the current privilege level is    \n|                | 3.                                      \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FRSTOR"
    }, 
    {
      "description": "\nFSAVE/FNSAVE - Store x87 FPU State:\n| Opcode        | Instruction                          | 64-Bit Mode| Compat/Leg Mode| Description                                  \n| 9B DD /6 DD /6| FSAVE m94/108byte FNSAVE* m94/108byte| Valid Valid| Valid Valid    | Store FPU state to m94byte or m108byte       \n|               |                                      |            |                | after checking for pending unmasked          \n|               |                                      |            |                | floating-point exceptions. Then re-initialize\n|               |                                      |            |                | the FPU. Store FPU environment to m94byte    \n|               |                                      |            |                | or m108byte without checking for pending     \n|               |                                      |            |                | unmasked floatingpoint exceptions. Then      \n|               |                                      |            |                | re-initialize the FPU.                       \nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nDescription:\nStores the current FPU state (operating environment and register stack) at the\nspecified destination in memory, and then re-initializes the FPU. The FSAVE\ninstruction checks for and handles pending unmasked floating-point exceptions\nbefore storing the FPU state; the FNSAVE instruction does not.\n\nThe FPU operating environment consists of the FPU control word, status word,\ntag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through\n8-12 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1, show the layout in memory of the stored environment, depending on the operating\nmode of the processor (protected or real) and the current operand-size attribute\n(16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used. The\ncontents of the FPU register stack are stored in the 80 bytes immediately follow\nthe operating environment image.\n\nThe saved image reflects the state of the FPU after all floating-point instructions\npreceding the FSAVE/FNSAVE instruction in the instruction stream have been executed.\n\nAfter the FPU state has been saved, the FPU is reset to the same default values\nit is set to with the FINIT/FNINIT instructions (see \u201cFINIT/FNINIT - Initialize\nFloating-Point Unit\u201d in this chapter).\n\nThe FSAVE/FNSAVE instructions are typically used when the operating system needs\nto perform a context switch, an exception handler needs to use the FPU, or an\napplication program needs to pass a \u201cclean\u201d FPU to a procedure.\n\nThe assembler issues two instructions for the FSAVE instruction (an FWAIT instruction\nfollowed by an FNSAVE instruction), and the processor executes each of these\ninstructions separately. If an exception is generated for either of these instructions,\nthe save EIP points to the instruction that caused the exception.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nIA-32 Architecture Compatibility:\nFor Intel math coprocessors and FPUs prior to the Intel Pentium processor, an\nFWAIT instruction should be executed before attempting to read from the memory\nimage stored with a prior FSAVE/FNSAVE instruction. This FWAIT instruction helps\nensure that the storage operation has been completed.\n\nWhen operating a Pentium or Intel486 processor in MS-DOS compatibility mode,\nit is possible (under unusual circumstances) for an FNSAVE instruction to be\ninterrupted prior to being executed to handle a pending FPU exception. See the\nsection titled \u201cNo-Wait FPU Instructions Can Get FPU Interrupt in Window\u201d in\nAppendix D of the Intel\u00ae64 and IA-32 Architectures Software Developer's Manual,\nVolume 1, for a description of these circumstances. An FNSAVE instruction cannot\nbe interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.\n\nOperation:\n\n(* Save FPU State and Registers *)\nDEST[FPUControlWord] <- FPUControlWord;\nDEST[FPUStatusWord] <- FPUStatusWord;\nDEST[FPUTagWord] <- FPUTagWord;\nDEST[FPUDataPointer] <- FPUDataPointer;\nDEST[FPUInstructionPointer] <- FPUInstructionPointer;\nDEST[FPULastInstructionOpcode] <- FPULastInstructionOpcode;\nDEST[ST(0)] <- ST(0);\nDEST[ST(1)] <- ST(1);\nDEST[ST(2)] <- ST(2);\nDEST[ST(3)] <- ST(3);\nDEST[ST(4)]<- ST(4);\nDEST[ST(5)] <- ST(5);\nDEST[ST(6)] <- ST(6);\nDEST[ST(7)] <- ST(7);\n(* Initialize FPU *)\nFPUControlWord <- 037FH;\nFPUStatusWord <- 0;\nFPUTagWord <- FFFFH;\nFPUDataPointer <- 0;\nFPUInstructionPointer <- 0;\nFPULastInstructionOpcode <- 0;\n\nFPU Flags Affected:\nThe C0, C1, C2, and C3 flags are saved and then cleared.\n\n\nFloating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If destination is located in a non-writable\n|                | segment. If a memory operand effective     \n|                | address is outside the CS, DS, ES, FS,     \n|                | or GS segment limit. If the DS, ES,        \n|                | FS, or GS register is used to access       \n|                | memory and it contains a NULL segment      \n|                | selector.                                  \n| #SS(0)         | If a memory operand effective address      \n|                | is outside the SS segment limit.           \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n", 
      "mnem": "FSAVE"
    }, 
    {
      "description": "\nFSCALE - Scale:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description          \n| D9 FD | FSCALE     | Valid      | Valid          | Scale ST(0) by ST(1).\n\nDescription:\nTruncates the value in the source operand (toward 0) to an integral value and\nadds that value to the exponent of the destination operand. The destination\nand source operands are floating-point values located in registers ST(0) and\nST(1), respectively. This instruction provides rapid multiplication or division\nby integral powers of 2. The following table shows the results obtained when\nscaling various classes of numbers, assuming that neither overflow nor underflow\noccurs.\n\n\nTable 3-44. FSCALE Results:\nST(1)\n\n| \u2212 \u221e| \u2212 F| \u2212 0| + 0| + F| + \u221e| NaN\n| NaN| \u2212 \u221e| \u2212 \u221e| \u2212 \u221e| \u2212 \u221e| \u2212 \u221e| NaN\n| \u2212 0| \u2212 F| \u2212 F| \u2212 F| \u2212 F| \u2212 \u221e| NaN\n| \u2212 0| \u2212 0| \u2212 0| \u2212 0| \u2212 0| NaN| NaN\n| + 0| + 0| + 0| + 0| + 0| NaN| NaN\n| + 0| + F| + F| + F| + F| + \u221e| NaN\n| NaN| + \u221e| + \u221e| + \u221e| + \u221e| + \u221e| NaN\n| NaN| NaN| NaN| NaN| NaN| NaN| NaN\nNotes: F Means finite floating-point value.\n\nIn most cases, only the exponent is changed and the mantissa (significand) remains\nunchanged. However, when the value being scaled in ST(0) is a denormal value,\nthe mantissa is also changed and the result may turn out to be a normalized\nnumber. Similarly, if overflow or underflow results from a scale operation,\nthe resulting mantissa will differ from the source's mantissa.\n\nThe FSCALE instruction can also be used to reverse the action of the FXTRACT\ninstruction, as shown in the following example: FXTRACT; FSCALE; FSTP ST(1);\n\nIn this example, the FXTRACT instruction extracts the significand and exponent\nfrom the value in ST(0) and stores them in ST(0) and ST(1) respectively. The\nFSCALE then scales the significand in ST(0) by the exponent in ST(1), recreating\nthe original value before the FXTRACT operation was performed. The FSTP ST(1)\ninstruction overwrites the exponent (extracted by the FXTRACT instruction) with\nthe recreated value, which returns the stack to its original state with only\none register [ST(0)] occupied.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nST(0) <- ST(0) * 2RoundTowardZero(ST(1));\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.                     \n| #IA| Source operand is an SNaN value or unsupported\n|    | format.                                       \n| #D | Source operand is a denormal value.           \n| #U | Result is too small for destination           \n|    | format.                                       \n| #O | Result is too large for destination           \n|    | format.                                       \n| #P | Value cannot be represented exactly           \n|    | in destination format.                        \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FSCALE"
    }, 
    {
      "description": "\nFSIN - Sine:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                 \n| D9 FE | FSIN       | Valid      | Valid          | Replace ST(0) with its sine.\n\nDescription:\nComputes the sine of the source operand in register ST(0) and stores the result\nin ST(0). The source operand must be given in radians and must be within the\nrange \u2212263 to +263. The following table shows the results obtained when taking\nthe sine of various classes of numbers, assuming that underflow does not occur.\n\n\nTable 3-45. FSIN Results:\n| SRC (ST(0)) \u2212 \u221e| DEST (ST(0))\n| \u2212 F            | \u2212 1 to + 1  \n| \u2212 0            | \u22120          \n| + 0            | +0          \n| + F + \u221e        | \u2212 1 to +1   \n| NaN            | NaN         \nNotes: F Means finite floating-point value. * Indicates floating-point invalid-arithmetic-operand\n(#IA) exception.\n\nIf the source operand is outside the acceptable range, the C2 flag in the FPU\nstatus word is set, and the value in register ST(0) remains unchanged. The instruction\ndoes not raise an exception when the source operand is out of range. It is up\nto the program to check the C2 flag for out-of-range conditions. Source values\noutside the range \u2212263 to +263 can be reduced to the range of the instruction\nby subtracting an appropriate integer multiple of 2\u03c0 or by using the FPREM instruction\nwith a divisor of 2\u03c0. See the section titled \u201cPi\u201d in Chapter 8 of the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a discussion\nof the proper value to use for \u03c0 in performing such reductions.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF -263 < ST(0) < 263\n  THEN\n     C2 <- 0;\n     ST(0) <- sin(ST(0));\n  ELSE (* Source operand out of range *)\n     C2 <- 1;\nFI;\n\nFPU Flags Affected:\n| C1    | Set to 0 if stack underflow occurred.   \n|       | Set if result was rounded up; cleared   \n|       | otherwise.                              \n| C2    | Set to 1 if outside range (\u2212263 < source\n|       | operand < +263); otherwise, set to 0.   \n| C0, C3| Undefined.                              \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.          \n| #IA| Source operand is an SNaN value, \u221e,\n|    | or unsupported format.             \n| #D | Source operand is a denormal value.\n| #P | Value cannot be represented exactly\n|    | in destination format.             \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FSIN"
    }, 
    {
      "description": "\nFSINCOS - Sine and Cosine:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                          \n| D9 FB | FSINCOS    | Valid      | Valid          | Compute the sine and cosine of ST(0);\n|       |            |            |                | replace ST(0) with the sine, and push\n|       |            |            |                | the cosine onto the register stack.  \n\nDescription:\nComputes both the sine and the cosine of the source operand in register ST(0),\nstores the sine in ST(0), and pushes the cosine onto the top of the FPU register\nstack. (This instruction is faster than executing the FSIN and FCOS instructions\nin succession.) The source operand must be given in radians and must be within\nthe range \u2212263 to +263. The following table shows the results obtained when\ntaking the sine and cosine of various classes of numbers, assuming that underflow\ndoes not occur.\n\n\nTable 3-46. FSINCOS Results:\n| SRC \u2212 \u221e| DEST ST(0) Sine\n| \u2212 F    | \u2212 1 to + 1     \n| \u2212 0    | \u2212 0            \n| + 0    | + 0            \n| + F + \u221e| \u2212 1 to + 1     \n| NaN    | NaN            \nNotes: F Means finite floating-point value. * Indicates floating-point invalid-arithmetic-operand\n(#IA) exception.\n\nIf the source operand is outside the acceptable range, the C2 flag in the FPU\nstatus word is set, and the value in register ST(0) remains unchanged. The instruction\ndoes not raise an exception when the source operand is out of range. It is up\nto the program to check the C2 flag for out-of-range conditions. Source values\noutside the range \u2212263 to +263 can be reduced to the range of the instruction\nby subtracting an appropriate integer multiple of 2\u03c0 or by using the FPREM instruction\nwith a divisor of 2\u03c0. See the section titled \u201cPi\u201d in Chapter 8 of the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a discussion\nof the proper value to use for \u03c0 in performing such reductions.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF ST(0) < 263\n  THEN\n     C2 <- 0;\n     TEMP <- cosine(ST(0));\n     ST(0) <- sine(ST(0));\n     TOP <- TOP \u2212 1;\n     ST(0) <- TEMP;\n  ELSE (* Source operand out of range *)\n     C2 <- 1;\nFI;\n\nFPU Flags Affected:\n| C1    | Set to 0 if stack underflow occurred;       \n|       | set to 1 of stack overflow occurs. Set      \n|       | if result was rounded up; cleared otherwise.\n| C2    | Set to 1 if outside range (\u2212263 < source    \n|       | operand < +263); otherwise, set to 0.       \n| C0, C3| Undefined.                                  \n\nFloating-Point Exceptions:\n| #IS| Stack underflow or overflow occurred.\n| #IA| Source operand is an SNaN value, \u221e,  \n|    | or unsupported format.               \n| #D | Source operand is a denormal value.  \n| #U | Result is too small for destination  \n|    | format.                              \n| #P | Value cannot be represented exactly  \n|    | in destination format.               \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FSINCOS"
    }, 
    {
      "description": "\nFSQRT - Square Root:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                             \n| D9 FA | FSQRT      | Valid      | Valid          | Computes square root of ST(0) and stores\n|       |            |            |                | the result in ST(0).                    \n\nDescription:\nComputes the square root of the source value in the ST(0) register and stores\nthe result in ST(0).\n\nThe following table shows the results obtained when taking the square root of\nvarious classes of numbers, assuming that neither overflow nor underflow occurs.\n\n\nTable 3-47. FSQRT Results:\n| SRC (ST(0)) \u2212 \u221e\u2212 F| DEST (ST(0))\n| \u2212 0               | \u22120          \n| + 0               | +0          \n| + F               | +F          \n| + \u221e               | +\u221e          \n| NaN               | NaN         \nNotes: F Means finite floating-point value. * Indicates floating-point invalid-arithmetic-operand\n(#IA) exception.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nST(0) <- SquareRoot(ST(0));\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.                     \n| #IA| Source operand is an SNaN value or unsupported\n|    | format. Source operand is a negative          \n|    | value (except for \u22120).                        \n| #D | Source operand is a denormal value.           \n| #P | Value cannot be represented exactly           \n|    | in destination format.                        \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FSQRT"
    }, 
    {
      "description": "\nFST/FSTP - Store Floating Point Value:\n| Opcode | Instruction| 64-Bit Mode| Compat/Leg Mode| Description                         \n| D9 /2  | FST m32fp  | Valid      | Valid          | Copy ST(0) to m32fp.                \n| DD /2  | FST m64fp  | Valid      | Valid          | Copy ST(0) to m64fp.                \n| DD D0+i| FST ST(i)  | Valid      | Valid          | Copy ST(0) to ST(i).                \n| D9 /3  | FSTP m32fp | Valid      | Valid          | Copy ST(0) to m32fp and pop register\n|        |            |            |                | stack.                              \n| DD /3  | FSTP m64fp | Valid      | Valid          | Copy ST(0) to m64fp and pop register\n|        |            |            |                | stack.                              \n| DB /7  | FSTP m80fp | Valid      | Valid          | Copy ST(0) to m80fp and pop register\n|        |            |            |                | stack.                              \n| DD D8+i| FSTP ST(i) | Valid      | Valid          | Copy ST(0) to ST(i) and pop register\n|        |            |            |                | stack.                              \n\nDescription:\nThe FST instruction copies the value in the ST(0) register to the destination\noperand, which can be a memory location or another register in the FPU register\nstack. When storing the value in memory, the value is converted to single-precision\nor double-precision floating-point format.\n\nThe FSTP instruction performs the same operation as the FST instruction and\nthen pops the register stack. To pop the register stack, the processor marks\nthe ST(0) register as empty and increments the stack pointer (TOP) by 1. The\nFSTP instruction can also store values in memory in double extended-precision\nfloating-point format.\n\nIf the destination operand is a memory location, the operand specifies the address\nwhere the first byte of the destination value is to be stored. If the destination\noperand is a register, the operand specifies a register in the register stack\nrelative to the top of the stack.\n\nIf the destination size is single-precision or double-precision, the significand\nof the value being stored is rounded to the width of the destination (according\nto the rounding mode specified by the RC field of the FPU control word), and\nthe exponent is converted to the width and bias of the destination format. If\nthe value being stored is too large for the destination format, a numeric overflow\nexception (#O) is generated and, if the exception is unmasked, no value is stored\nin the destination operand. If the value being stored is a denormal value, the\ndenormal exception (#D) is not generated. This condition is simply signaled\nas a numeric underflow exception (#U) condition.\n\nIf the value being stored is \u00b10, \u00b1\u221e, or a NaN, the least-significant bits of\nthe significand and the exponent are truncated to fit the destination format.\nThis operation preserves the value's identity as a 0, \u221e, or NaN.\n\nIf the destination operand is a non-empty register, the invalid-operation exception\nis not generated.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nDEST <- ST(0);\nIF Instruction = FSTP\n  THEN\n     PopRegisterStack;\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.     \n|           | Indicates rounding direction of if the    \n|           | floating-point inexact exception (#P)     \n|           | is generated: 0 \u2190not roundup; 1 \u2190 roundup.\n| C0, C2, C3| Undefined.                                \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.                         \n| #IA| If destination result is an SNaN value            \n|    | or unsupported format, except when the            \n|    | destination format is in double extended-precision\n|    | floating-point format.                            \n| #U | Result is too small for the destination           \n|    | format.                                           \n| #O | Result is too large for the destination           \n|    | format.                                           \n| #P | Value cannot be represented exactly               \n|    | in destination format.                            \n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register is used to access           \n|                | memory and it contains a NULL segment          \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.            \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FST"
    }, 
    {
      "description": "\nFSTCW/FNSTCW - Store x87 FPU Control Word:\n| Opcode  | Instruction   | 64-Bit Mode| Compat/Leg Mode| Description                                 \n| 9B D9 /7| FSTCW m2byte  | Valid      | Valid          | Store FPU control word to m2byte after      \n|         |               |            |                | checking for pending unmasked floating-point\n|         |               |            |                | exceptions.                                 \n| D9 /7   | FNSTCW* m2byte| Valid      | Valid          | Store FPU control word to m2byte without    \n|         |               |            |                | checking for pending unmasked floating-point\n|         |               |            |                | exceptions.                                 \nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nDescription:\nStores the current value of the FPU control word at the specified destination\nin memory. The FSTCW instruction checks for and handles pending unmasked floating-point\nexceptions before storing the control word; the FNSTCW instruction does not.\n\nThe assembler issues two instructions for the FSTCW instruction (an FWAIT instruction\nfollowed by an FNSTCW instruction), and the processor executes each of these\ninstructions in separately. If an exception is generated for either of these\ninstructions, the save EIP points to the instruction that caused the exception.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nIA-32 Architecture Compatibility:\nWhen operating a Pentium or Intel486 processor in MS-DOS compatibility mode,\nit is possible (under unusual circumstances) for an FNSTCW instruction to be\ninterrupted prior to being executed to handle a pending FPU exception. See the\nsection titled \u201cNo-Wait FPU Instructions Can Get FPU Interrupt in Window\u201d in\nAppendix D of the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 1, for a description of these circumstances. An FNSTCW instruction cannot\nbe interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.\n\nOperation:\n\nDEST <- FPUControlWord;\n\nFPU Flags Affected:\nThe C0, C1, C2, and C3 flags are undefined.\n\n\nFloating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register is used to access           \n|                | memory and it contains a NULL segment          \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.            \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FSTCW"
    }, 
    {
      "description": "\nFSTENV/FNSTENV - Store x87 FPU Environment:\n| Opcode        | Instruction                          | 64-Bit Mode| Compat/Leg Mode| Description                                \n| 9B D9 /6 D9 /6| FSTENV m14/28byte FNSTENV* m14/28byte| Valid Valid| Valid Valid    | Store FPU environment to m14byte or        \n|               |                                      |            |                | m28byte after checking for pending unmasked\n|               |                                      |            |                | floating-point exceptions. Then mask       \n|               |                                      |            |                | all floating-point exceptions. Store       \n|               |                                      |            |                | FPU environment to m14byte or m28byte      \n|               |                                      |            |                | without checking for pending unmasked      \n|               |                                      |            |                | floatingpoint exceptions. Then mask        \n|               |                                      |            |                | all floatingpoint exceptions.              \nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nDescription:\nSaves the current FPU operating environment at the memory location specified\nwith the destination operand, and then masks all floating-point exceptions.\nThe FPU operating environment consists of the FPU control word, status word,\ntag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through\n8-12 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1, show the layout in memory of the stored environment, depending on the operating\nmode of the processor (protected or real) and the current operand-size attribute\n(16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.\n\nThe FSTENV instruction checks for and handles any pending unmasked floating-point\nexceptions before storing the FPU environment; the FNSTENV instruction does\nnot. The saved image reflects the state of the FPU after all floating-point\ninstructions preceding the FSTENV/FNSTENV instruction in the instruction stream\nhave been executed.\n\nThese instructions are often used by exception handlers because they provide\naccess to the FPU instruction and data pointers. The environment is typically\nsaved in the stack. Masking all exceptions after saving the environment prevents\nfloating-point exceptions from interrupting the exception handler.\n\nThe assembler issues two instructions for the FSTENV instruction (an FWAIT instruction\nfollowed by an FNSTENV instruction), and the processor executes each of these\ninstructions separately. If an exception is generated for either of these instructions,\nthe save EIP points to the instruction that caused the exception.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nIA-32 Architecture Compatibility:\nWhen operating a Pentium or Intel486 processor in MS-DOS compatibility mode,\nit is possible (under unusual circumstances) for an FNSTENV instruction to be\ninterrupted prior to being executed to handle a pending FPU exception. See the\nsection titled \u201cNo-Wait FPU Instructions Can Get FPU Interrupt in Window\u201d in\nAppendix D of the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 1, for a description of these circumstances. An FNSTENV instruction cannot\nbe interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.\n\nOperation:\n\nDEST[FPUControlWord] <- FPUControlWord;\nDEST[FPUStatusWord] <- FPUStatusWord;\nDEST[FPUTagWord] <- FPUTagWord;\nDEST[FPUDataPointer] <- FPUDataPointer;\nDEST[FPUInstructionPointer] <- FPUInstructionPointer;\nDEST[FPULastInstructionOpcode] <- FPULastInstructionOpcode;\n\nFPU Flags Affected:\nThe C0, C1, C2, and C3 are undefined.\n\n\nFloating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register is used to access           \n|                | memory and it contains a NULL segment          \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.            \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FSTENV"
    }, 
    {
      "description": "-R:FST", 
      "mnem": "FSTP"
    }, 
    {
      "description": "\nFSTSW/FNSTSW - Store x87 FPU Status Word:\n| Opcode              | Instruction                       | 64-Bit Mode      | Compat/Leg Mode  | Description                                 \n| 9B DD /7            | FSTSW m2byte                      | Valid            | Valid            | Store FPU status word at m2byte after       \n|                     |                                   |                  |                  | checking for pending unmasked floating-point\n|                     |                                   |                  |                  | exceptions.                                 \n| 9B DF E0 DD /7 DF E0| FSTSW AX FNSTSW* m2byte FNSTSW* AX| Valid Valid Valid| Valid Valid Valid| Store FPU status word in AX register        \n|                     |                                   |                  |                  | after checking for pending unmasked         \n|                     |                                   |                  |                  | floating-point exceptions. Store FPU        \n|                     |                                   |                  |                  | status word at m2byte without checking      \n|                     |                                   |                  |                  | for pending unmasked floating-point         \n|                     |                                   |                  |                  | exceptions. Store FPU status word in        \n|                     |                                   |                  |                  | AX register without checking for pending    \n|                     |                                   |                  |                  | unmasked floating-point exceptions.         \nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nDescription:\nStores the current value of the x87 FPU status word in the destination location.\nThe destination operand can be either a two-byte memory location or the AX register.\nThe FSTSW instruction checks for and handles pending unmasked floating-point\nexceptions before storing the status word; the FNSTSW instruction does not.\n\nThe FNSTSW AX form of the instruction is used primarily in conditional branching\n(for instance, after an FPU comparison instruction or an FPREM, FPREM1, or FXAM\ninstruction), where the direction of the branch depends on the state of the\nFPU condition code flags. (See the section titled \u201cBranching and Conditional\nMoves on FPU Condition Codes\u201d in Chapter 8 of the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1.) This instruction can also be used to\ninvoke exception handlers (by examining the exception flags) in environments\nthat do not use interrupts. When the FNSTSW AX instruction is executed, the\nAX register is updated before the processor executes any further instructions.\nThe status stored in the AX register is thus guaranteed to be from the completion\nof the prior FPU instruction.\n\nThe assembler issues two instructions for the FSTSW instruction (an FWAIT instruction\nfollowed by an FNSTSW instruction), and the processor executes each of these\ninstructions separately. If an exception is generated for either of these instructions,\nthe save EIP points to the instruction that caused the exception.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nIA-32 Architecture Compatibility:\nWhen operating a Pentium or Intel486 processor in MS-DOS compatibility mode,\nit is possible (under unusual circumstances) for an FNSTSW instruction to be\ninterrupted prior to being executed to handle a pending FPU exception. See the\nsection titled \u201cNo-Wait FPU Instructions Can Get FPU Interrupt in Window\u201d in\nAppendix D of the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 1, for a description of these circumstances. An FNSTSW instruction cannot\nbe interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.\n\nOperation:\n\nDEST <- FPUStatusWord;\n\nFPU Flags Affected:\nThe C0, C1, C2, and C3 are undefined.\n\n\nFloating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register is used to access           \n|                | memory and it contains a NULL segment          \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.            \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FSTSW"
    }, 
    {
      "description": "\nFSUB/FSUBP/FISUB - Subtract:\n| Opcode | Instruction       | 64-Bit Mode| Compat/Leg Mode| Description                            \n| D8 /4  | FSUB m32fp        | Valid      | Valid          | Subtract m32fp from ST(0) and store    \n|        |                   |            |                | result in ST(0).                       \n| DC /4  | FSUB m64fp        | Valid      | Valid          | Subtract m64fp from ST(0) and store    \n|        |                   |            |                | result in ST(0).                       \n| D8 E0+i| FSUB ST(0), ST(i) | Valid      | Valid          | Subtract ST(i) from ST(0) and store    \n|        |                   |            |                | result in ST(0).                       \n| DC E8+i| FSUB ST(i), ST(0) | Valid      | Valid          | Subtract ST(0) from ST(i) and store    \n|        |                   |            |                | result in ST(i).                       \n| DE E8+i| FSUBP ST(i), ST(0)| Valid      | Valid          | Subtract ST(0) from ST(i), store result\n|        |                   |            |                | in ST(i), and pop register stack.      \n| DE E9  | FSUBP             | Valid      | Valid          | Subtract ST(0) from ST(1), store result\n|        |                   |            |                | in ST(1), and pop register stack.      \n| DA /4  | FISUB m32int      | Valid      | Valid          | Subtract m32int from ST(0) and store   \n|        |                   |            |                | result in ST(0).                       \n| DE /4  | FISUB m16int      | Valid      | Valid          | Subtract m16int from ST(0) and store   \n|        |                   |            |                | result in ST(0).                       \n\nDescription:\nSubtracts the source operand from the destination operand and stores the difference\nin the destination location. The destination operand is always an FPU data register;\nthe source operand can be a register or a memory location. Source operands in\nmemory can be in single-precision or double-precision floating-point format\nor in word or doubleword integer format.\n\nThe no-operand version of the instruction subtracts the contents of the ST(0)\nregister from the ST(1) register and stores the result in ST(1). The one-operand\nversion subtracts the contents of a memory location (either a floatingpoint\nor an integer value) from the contents of the ST(0) register and stores the\nresult in ST(0). The two-operand version, subtracts the contents of the ST(0)\nregister from the ST(i) register or vice versa.\n\nThe FSUBP instructions perform the additional operation of popping the FPU register\nstack following the subtraction. To pop the register stack, the processor marks\nthe ST(0) register as empty and increments the stack pointer (TOP) by 1. The\nno-operand version of the floating-point subtract instructions always results\nin the register stack being popped. In some assemblers, the mnemonic for this\ninstruction is FSUB rather than FSUBP.\n\nThe FISUB instructions convert an integer source operand to double extended-precision\nfloating-point format before performing the subtraction.\n\nTable 3-48 shows the results obtained when subtracting various classes of numbers\nfrom one another, assuming that neither overflow nor underflow occurs. Here,\nthe SRC value is subtracted from the DEST value (DEST \u2212 SRC =result).\n\nWhen the difference between two operands of like sign is 0, the result is +0,\nexcept for the round toward \u2212\u221e mode, in which case the result is \u22120. This instruction\nalso guarantees that +0 \u2212 (\u22120) = +0, and that \u22120 \u2212 (+0) = \u22120. When the source\noperand is an integer 0, it is treated as a +0.\n\nWhen one operand is \u221e, the result is \u221e of the expected sign. If both operands\nare \u221e of the same sign, an invalidoperation exception is generated.\n\n\nTable 3-48. FSUB/FSUBP/FISUB Results:\nSRC\n\n| \u2212 \u221e | \u2212 F or \u2212 I \u2212 \u221e| \u2212 0 \u2212 \u221e | + 0 \u2212 \u221e | + F or + I \u2212 \u221e| + \u221e\u2212 \u221e| NaN NaN\n| +\u221e  | \u00b1F or \u00b10      | DEST    | DEST    | \u2212 F           | \u2212 \u221e   | NaN    \n| +\u221e  | \u2212SRC          | \u00b10      | \u2212 0     | \u2212 SRC         | \u2212 \u221e   | NaN    \n| +\u221e  | \u2212SRC          | + 0     | \u00b10      | \u2212 SRC         | \u2212 \u221e   | NaN    \n| +\u221e+\u221e| + F + \u221e       | DEST + \u221e| DEST + \u221e| \u00b1F or \u00b10 + \u221e  | \u2212 \u221e   | NaN NaN\n| NaN | NaN           | NaN     | NaN     | NaN           | NaN   | NaN    \nNotes: F Means finite floating-point value.\n\n| I * Indicates floating-point invalid-arithmetic-operand| Means integer.\n| (#IA) exception.                                       |               \nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF Instruction = FISUB\n  THEN\n     DEST <- DEST \u2212 ConvertToDoubleExtendedPrecisionFP(SRC);\n  ELSE (* Source operand is floating-point value *)\n     DEST <- DEST \u2212 SRC;\nFI;\nIF Instruction = FSUBP\n  THEN\n     PopRegisterStack;\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.              \n| #IA| Operand is an SNaN value or unsupported\n|    | format. Operands are infinities of like\n|    | sign.                                  \n| #D | Source operand is a denormal value.    \n| #U | Result is too small for destination    \n|    | format.                                \n| #O | Result is too large for destination    \n|    | format.                                \n| #P | Value cannot be represented exactly    \n|    | in destination format.                 \n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address   \n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit. If the DS, ES, FS, or    \n|                | GS register is used to access memory    \n|                | and it contains a NULL segment selector.\n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made   \n|                | while the current privilege level is    \n|                | 3.                                      \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FSUB"
    }, 
    {
      "description": "-R:FSUB", 
      "mnem": "FSUBP"
    }, 
    {
      "description": "\nFSUBR/FSUBRP/FISUBR - Reverse Subtract:\n| Opcode | Instruction        | 64-Bit Mode| Compat/Leg Mode| Description                            \n| D8 /5  | FSUBR m32fp        | Valid      | Valid          | Subtract ST(0) from m32fp and store    \n|        |                    |            |                | result in ST(0).                       \n| DC /5  | FSUBR m64fp        | Valid      | Valid          | Subtract ST(0) from m64fp and store    \n|        |                    |            |                | result in ST(0).                       \n| D8 E8+i| FSUBR ST(0), ST(i) | Valid      | Valid          | Subtract ST(0) from ST(i) and store    \n|        |                    |            |                | result in ST(0).                       \n| DC E0+i| FSUBR ST(i), ST(0) | Valid      | Valid          | Subtract ST(i) from ST(0) and store    \n|        |                    |            |                | result in ST(i).                       \n| DE E0+i| FSUBRP ST(i), ST(0)| Valid      | Valid          | Subtract ST(i) from ST(0), store result\n|        |                    |            |                | in ST(i), and pop register stack.      \n| DE E1  | FSUBRP             | Valid      | Valid          | Subtract ST(1) from ST(0), store result\n|        |                    |            |                | in ST(1), and pop register stack.      \n| DA /5  | FISUBR m32int      | Valid      | Valid          | Subtract ST(0) from m32int and store   \n|        |                    |            |                | result in ST(0).                       \n| DE /5  | FISUBR m16int      | Valid      | Valid          | Subtract ST(0) from m16int and store   \n|        |                    |            |                | result in ST(0).                       \n\nDescription:\nSubtracts the destination operand from the source operand and stores the difference\nin the destination location. The destination operand is always an FPU register;\nthe source operand can be a register or a memory location. Source operands in\nmemory can be in single-precision or double-precision floating-point format\nor in word or doubleword integer format.\n\nThese instructions perform the reverse operations of the FSUB, FSUBP, and FISUB\ninstructions. They are provided to support more efficient coding.\n\nThe no-operand version of the instruction subtracts the contents of the ST(1)\nregister from the ST(0) register and stores the result in ST(1). The one-operand\nversion subtracts the contents of the ST(0) register from the contents of a\nmemory location (either a floating-point or an integer value) and stores the\nresult in ST(0). The two-operand version, subtracts the contents of the ST(i)\nregister from the ST(0) register or vice versa.\n\nThe FSUBRP instructions perform the additional operation of popping the FPU\nregister stack following the subtraction. To pop the register stack, the processor\nmarks the ST(0) register as empty and increments the stack pointer (TOP) by\n1. The no-operand version of the floating-point reverse subtract instructions\nalways results in the register stack being popped. In some assemblers, the mnemonic\nfor this instruction is FSUBR rather than FSUBRP.\n\nThe FISUBR instructions convert an integer source operand to double extended-precision\nfloating-point format before performing the subtraction.\n\nThe following table shows the results obtained when subtracting various classes\nof numbers from one another, assuming that neither overflow nor underflow occurs.\nHere, the DEST value is subtracted from the SRC value (SRC \u2212 DEST = result).\n\nWhen the difference between two operands of like sign is 0, the result is +0,\nexcept for the round toward \u2212\u221e mode, in which case the result is \u22120. This instruction\nalso guarantees that +0 \u2212 (\u22120) = +0, and that \u22120 \u2212 (+0) = \u22120. When the source\noperand is an integer 0, it is treated as a +0.\n\nWhen one operand is \u221e, the result is \u221e of the expected sign. If both operands\nare \u221e of the same sign, an invalidoperation exception is generated.\n\n\nTable 3-49. FSUBR/FSUBRP/FISUBR Results:\nSRC\n\n| \u2212 \u221e | \u2212F or \u2212I + \u221e| \u22120 + \u221e   | +0 + \u221e   | +F or +I + \u221e| + \u221e+ \u221e| NaN NaN\n| \u2212\u221e  | \u00b1F or \u00b10    | \u2212DEST    | \u2212DEST    | + F         | + \u221e   | NaN    \n| \u2212\u221e  | SRC         | \u00b10       | + 0      | SRC         | + \u221e   | NaN    \n| \u2212\u221e  | SRC         | \u2212 0      | \u00b10       | SRC         | + \u221e   | NaN    \n| \u2212\u221e\u2212\u221e| \u2212 F \u2212 \u221e     | \u2212DEST \u2212 \u221e| \u2212DEST \u2212 \u221e| \u00b1F or \u00b10 \u2212 \u221e| + \u221e   | NaN NaN\n| NaN | NaN         | NaN      | NaN      | NaN         | NaN   | NaN    \nNotes: F Means finite floating-point value.\n\n| I * Indicates floating-point invalid-arithmetic-operand| Means integer.\n| (#IA) exception.                                       |               \nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF Instruction = FISUBR\n  THEN\n     DEST <- ConvertToDoubleExtendedPrecisionFP(SRC) \u2212 DEST;\n  ELSE (* Source operand is floating-point value *)\n     DEST <- SRC \u2212 DEST; FI;\nIF Instruction = FSUBRP\n  THEN\n     PopRegisterStack; FI;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.              \n| #IA| Operand is an SNaN value or unsupported\n|    | format. Operands are infinities of like\n|    | sign.                                  \n| #D | Source operand is a denormal value.    \n| #U | Result is too small for destination    \n|    | format.                                \n| #O | Result is too large for destination    \n|    | format.                                \n| #P | Value cannot be represented exactly    \n|    | in destination format.                 \n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address   \n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit. If the DS, ES, FS, or    \n|                | GS register is used to access memory    \n|                | and it contains a NULL segment selector.\n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made   \n|                | while the current privilege level is    \n|                | 3.                                      \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.  \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #NM            | CR0.EM[bit 2] or CR0.TS[bit 3] = 1.        \n| #MF            | If there is a pending x87 FPU exception.   \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "FSUBR"
    }, 
    {
      "description": "-R:FSUBR", 
      "mnem": "FSUBRP"
    }, 
    {
      "description": "\nFTST - TEST:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description            \n| D9 E4 | FTST       | Valid      | Valid          | Compare ST(0) with 0.0.\n\nDescription:\nCompares the value in the ST(0) register with 0.0 and sets the condition code\nflags C0, C2, and C3 in the FPU status word according to the results (see table\nbelow).\n\n\nTable 3-50. FTST Results:\n| Condition| C3 0 0 1 1| C2 0 0 0 1| C0 0 1 0 1\nThis instruction performs an \u201cunordered comparison.\u201d An unordered comparison\nalso checks the class of the numbers being compared (see \u201cFXAM - Examine ModR/M\u201d\nin this chapter). If the value in register ST(0) is a NaN or is in an undefined\nformat, the condition flags are set to \u201cunordered\u201d and the invalid operation\nexception is generated.\n\nThe sign of zero is ignored, so that (- 0.0 \u2190 +0.0).\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nCASE (relation of operands) OF\n  Not comparable:\n  ST(0) > 0.0:\n  ST(0) < 0.0:\n  ST(0) = 0.0:\nESAC;\n\nFPU Flags Affected:\n| C1        | Set to 0.      \n| C0, C2, C3| See Table 3-50.\n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.              \n| #IA| The source operand is a NaN value or   \n|    | is in an unsupported format.           \n| #D | The source operand is a denormal value.\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FTST"
    }, 
    {
      "description": "\nFUCOM/FUCOMP/FUCOMPP - Unordered Compare Floating Point Values:\n| Opcode | Instruction | 64-Bit Mode| Compat/Leg Mode| Description                              \n| DD E0+i| FUCOM ST(i) | Valid      | Valid          | Compare ST(0) with ST(i).                \n| DD E1  | FUCOM       | Valid      | Valid          | Compare ST(0) with ST(1).                \n| DD E8+i| FUCOMP ST(i)| Valid      | Valid          | Compare ST(0) with ST(i) and pop register\n|        |             |            |                | stack.                                   \n| DD E9  | FUCOMP      | Valid      | Valid          | Compare ST(0) with ST(1) and pop register\n|        |             |            |                | stack.                                   \n| DA E9  | FUCOMPP     | Valid      | Valid          | Compare ST(0) with ST(1) and pop register\n|        |             |            |                | stack twice.                             \n\nDescription:\nPerforms an unordered comparison of the contents of register ST(0) and ST(i)\nand sets condition code flags C0, C2, and C3 in the FPU status word according\nto the results (see the table below). If no operand is specified, the contents\nof registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that\n-0.0 is equal to +0.0.\n\n\nTable 3-51. FUCOM/FUCOMP/FUCOMPP Results:\n| Comparison Results*| C3| C2| C0\n| ST0 > ST(i)        | 0 | 0 | 0 \n| ST0 < ST(i)        | 0 | 0 | 1 \n| ST0 = ST(i)        | 1 | 0 | 0 \n| Unordered          | 1 | 1 | 1 \nNotes: * Flags not set if unmasked invalid-arithmetic-operand (#IA) exception\nis generated.\n\nAn unordered comparison checks the class of the numbers being compared (see\n\u201cFXAM - Examine ModR/M\u201d in this chapter). The FUCOM/FUCOMP/FUCOMPP instructions\nperform the same operations as the FCOM/FCOMP/FCOMPP instructions. The only\ndifference is that the FUCOM/FUCOMP/FUCOMPP instructions raise the invalid-arithmeticoperand\nexception (#IA) only when either or both operands are an SNaN or are in an unsupported\nformat; QNaNs cause the condition code flags to be set to unordered, but do\nnot cause an exception to be generated. The FCOM/FCOMP/FCOMPP instructions raise\nan invalid-operation exception when either or both of the operands are a NaN\nvalue of any kind or are in an unsupported format.\n\nAs with the FCOM/FCOMP/FCOMPP instructions, if the operation results in an invalid-arithmetic-operand\nexception being raised, the condition code flags are set only if the exception\nis masked.\n\nThe FUCOMP instruction pops the register stack following the comparison operation\nand the FUCOMPP instruction pops the register stack twice following the comparison\noperation. To pop the register stack, the processor marks the ST(0) register\nas empty and increments the stack pointer (TOP) by 1.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nCASE (relation of operands) OF\n  ST > SRC:\n  ST < SRC:\n  ST = SRC:\nESAC;\nIF ST(0) or SRC = QNaN, but not SNaN or unsupported format\n  THEN\n     C3, C2, C0 <- 111;\n  ELSE (* ST(0) or SRC is SNaN or unsupported format *)\n     #IA;\n     IF FPUControlWord.IM = 1\n       THEN\n          C3, C2, C0 <- 111;\n     FI;\nFI;\nIF Instruction = FUCOMP\n  THEN\n     PopRegisterStack;\nFI;\nIF Instruction = FUCOMPP\n  THEN\n     PopRegisterStack;\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n| C0, C2, C3| See Table 3-51.                      \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.                \n| #IA| One or both operands are SNaN values     \n|    | or have unsupported formats. Detection   \n|    | of a QNaN value in and of itself does    \n|    | not raise an invalid-operand exception.  \n| #D | One or both operands are denormal values.\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FUCOM"
    }, 
    {
      "description": "-R:FCOMI", 
      "mnem": "FUCOMI"
    }, 
    {
      "description": "-R:FCOMI", 
      "mnem": "FUCOMIP"
    }, 
    {
      "description": "-R:FUCOM", 
      "mnem": "FUCOMP"
    }, 
    {
      "description": "-R:FUCOM", 
      "mnem": "FUCOMPP"
    }, 
    {
      "description": "-R:WAIT", 
      "mnem": "FWAIT"
    }, 
    {
      "description": "\nFXAM - Examine ModR/M:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                       \n| D9 E5 | FXAM       | Valid      | Valid          | Classify value or number in ST(0).\n\nDescription:\nExamines the contents of the ST(0) register and sets the condition code flags\nC0, C2, and C3 in the FPU status word to indicate the class of value or number\nin the register (see the table below).\n\n\nTable 3-52. FXAM Results:\n| Class| C3 0 0 0 0 1 1 1| C2 0 0 1 1 0 0 1| C0 0 1 0 1 0 1 0\nThe C1 flag is set to the sign of the value in ST(0), regardless of whether\nthe register is empty or full.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nC1 <- sign bit of ST; (* 0 for positive, 1 for negative *)\nCASE (class of value or number in ST(0)) OF\n  Unsupported:C3, C2, C0 <- 000;\n  NaN:\n  Normal:\n  Infinity:\n  Zero:\n  Empty:\n  Denormal:\nESAC;\n\nFPU Flags Affected:\n| C1        | Sign of value in ST(0).\n| C0, C2, C3| See Table 3-52.        \n\nFloating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FXAM"
    }, 
    {
      "description": "\nFXCH - Exchange Register Contents:\n| Opcode | Instruction| 64-Bit Mode| Compat/Leg Mode| Description                              \n| D9 C8+i| FXCH ST(i) | Valid      | Valid          | Exchange the contents of ST(0) and ST(i).\n| D9 C9  | FXCH       | Valid      | Valid          | Exchange the contents of ST(0) and ST(1).\n\nDescription:\nExchanges the contents of registers ST(0) and ST(i). If no source operand is\nspecified, the contents of ST(0) and ST(1) are exchanged.\n\nThis instruction provides a simple means of moving values in the FPU register\nstack to the top of the stack [ST(0)], so that they can be operated on by those\nfloating-point instructions that can only operate on values in ST(0). For example,\nthe following instruction sequence takes the square root of the third register\nfrom the top of the register stack: FXCH ST(3); FSQRT; FXCH ST(3);\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF (Number-of-operands) is 1\n  THEN\n     temp <- ST(0);\n     ST(0) <- SRC;\n     SRC <- temp;\n  ELSE\n     temp <- ST(0);\n     ST(0) <- ST(1);\n     ST(1) <- temp;\nFI;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred;\n|           | otherwise, set to 1.                 \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.\n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FXCH"
    }, 
    {
      "description": "\nFXRSTOR - Restore x87 FPU, MMX , XMM, and MXCSR State:\n| Opcode/Instruction                | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                             \n| 0F AE /1 FXRSTOR m512byte         | M    | Valid      | Valid          | Restore the x87 FPU, MMX, XMM, and MXCSR\n|                                   |      |            |                | register state from m512byte.           \n| REX.W+ 0F AE /1 FXRSTOR64 m512byte| M    | Valid      | N.E.           | Restore the x87 FPU, MMX, XMM, and MXCSR\n|                                   |      |            |                | register state from m512byte.           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nReloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte\nmemory image specified in the source operand. This data should have been written\nto memory previously using the FXSAVE instruction, and in the same format as\nrequired by the operating modes. The first byte of the data should be located\non a 16-byte boundary. There are three distinct layouts of the FXSAVE state\nmap: one for legacy and compatibility mode, a second format for 64-bit mode\nFXSAVE/FXRSTOR with REX.W=0, and the third format is for 64-bit mode with FXSAVE64/FXRSTOR64.\nTable 3-53 shows the layout of the legacy/compatibility mode state information\nin memory and describes the fields in the memory image for the FXRSTOR and FXSAVE\ninstructions. Table 3-56 shows the layout of the 64-bit mode state information\nwhen REX.W is set (FXSAVE64/FXRSTOR64). Table 3-57 shows the layout of the 64-bit\nmode state information when REX.W is clear (FXSAVE/FXRSTOR).\n\nThe state image referenced with an FXRSTOR instruction must have been saved\nusing an FXSAVE instruction or be in the same format as required by Table 3-53,\nTable 3-56, or Table 3-57. Referencing a state image saved with an FSAVE, FNSAVE\ninstruction or incompatible field layout will result in an incorrect state restoration.\n\nThe FXRSTOR instruction does not flush pending x87 FPU exceptions. To check\nand raise exceptions when loading x87 FPU state information with the FXRSTOR\ninstruction, use an FWAIT instruction after the FXRSTOR instruction.\n\nIf the OSFXSR bit in control register CR4 is not set, the FXRSTOR instruction\nmay not restore the states of the XMM and MXCSR registers. This behavior is\nimplementation dependent.\n\nIf the MXCSR state contains an unmasked exception with a corresponding status\nflag also set, loading the register with the FXRSTOR instruction will not result\nin a SIMD floating-point error condition being generated. Only the next occurrence\nof this unmasked exception will result in the exception being generated.\n\nBits 16 through 32 of the MXCSR register are defined as reserved and should\nbe set to 0. Attempting to write a 1 in any of these bits from the saved state\nimage will result in a general protection exception (#GP) being generated.\n\nBytes 464:511 of an FXSAVE image are available for software use. FXRSTOR ignores\nthe content of bytes 464:511 in an FXSAVE state image.\n\nOperation:\n\n(x87 FPU, MMX, XMM7-XMM0, MXCSR) <- Load(SRC);\n\nx87 FPU and SIMD Floating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | For an illegal memory operand effective     \n|                | address in the CS, DS, ES, FS or GS         \n|                | segments. If a memory operand is not        \n|                | aligned on a 16-byte boundary, regardless   \n|                | of segment. (See alignment check exception  \n|                | [#AC] below.) For an attempt to set         \n|                | reserved bits in MXCSR.                     \n| #SS(0)         | For an illegal address in the SS segment.   \n| #PF(fault-code)| For a page fault.                           \n| #NM            | If CR0.TS[bit 3] = 1. If CR0.EM[bit         \n|                | 2] = 1.                                     \n| #UD            | If CPUID.01H:EDX.FXSR[bit 24] = 0. If       \n|                | instruction is preceded by a LOCK prefix.   \n| #AC            | If this exception is disabled a general     \n|                | protection exception (#GP) is signaled      \n|                | if the memory operand is not aligned        \n|                | on a 16-byte boundary, as described         \n|                | above. If the alignment check exception     \n|                | (#AC) is enabled (and the CPL is 3),        \n|                | signaling of #AC is not guaranteed and      \n|                | may vary with implementation, as follows.   \n|                | In all implementations where #AC is         \n|                | not signaled, a general protection exception\n|                | is signaled in its place. In addition,      \n|                | the width of the alignment check may        \n|                | also vary with implementation. For instance,\n|                | for a given implementation, an alignment    \n|                | check exception might be signaled for       \n|                | a 2-byte misalignment, whereas a general    \n|                | protection exception might be signaled      \n|                | for all other misalignments (4-, 8-,        \n|                | or 16-byte misalignments).                  \n| #UD            | If the LOCK prefix is used.                 \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand is not aligned on     \n|    | a 16-byte boundary, regardless of segment.\n|    | If any part of the operand lies outside   \n|    | the effective address space from 0 to     \n|    | FFFFH. For an attempt to set reserved     \n|    | bits in MXCSR.                            \n| #NM| If CR0.TS[bit 3] = 1. If CR0.EM[bit       \n|    | 2] = 1.                                   \n| #UD| If CPUID.01H:EDX.FXSR[bit 24] = 0. If     \n|    | the LOCK prefix is used.                  \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in real address mode.\n\n| #PF(fault-code)| For a page fault.              \n| #AC            | For unaligned memory reference.\n| #UD            | If the LOCK prefix is used.    \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form. If memory operand is not aligned     \n|                | on a 16-byte boundary, regardless of       \n|                | segment. For an attempt to set reserved    \n|                | bits in MXCSR.                             \n| #PF(fault-code)| For a page fault.                          \n| #NM            | If CR0.TS[bit 3] = 1. If CR0.EM[bit        \n|                | 2] = 1.                                    \n| #UD            | If CPUID.01H:EDX.FXSR[bit 24] = 0. If      \n|                | instruction is preceded by a LOCK prefix.  \n| #AC            | If this exception is disabled a general    \n|                | protection exception (#GP) is signaled     \n|                | if the memory operand is not aligned       \n|                | on a 16-byte boundary, as described        \n|                | above. If the alignment check exception    \n|                | (#AC) is enabled (and the CPL is 3),       \n|                | signaling of #AC is not guaranteed and     \n|                | may vary with implementation, as follows.  \n|                | In all implementations where #AC is        \n|                | not signaled, a                            \ngeneral protection exception is signaled in its place. In addition, the width\nof the alignment check may also vary with implementation. For instance, for\na given implementation, an alignment check exception might be signaled for a\n2-byte misalignment, whereas a general protection exception might be signaled\nfor all other misalignments (4-, 8-, or 16-byte misalignments).\n\n", 
      "mnem": "FXRSTOR"
    }, 
    {
      "description": "\nFXSAVE - Save x87 FPU, MMX Technology, and SSE State:\n| Opcode/Instruction               | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F AE /0 FXSAVE m512byte         | M    | Valid      | Valid          | Save the x87 FPU, MMX, XMM, and MXCSR\n|                                  |      |            |                | register state to m512byte.          \n| REX.W+ 0F AE /0 FXSAVE64 m512byte| M    | Valid      | N.E.           | Save the x87 FPU, MMX, XMM, and MXCSR\n|                                  |      |            |                | register state to m512byte.          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nSaves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers\nto a 512-byte memory location specified in the destination operand. The content\nlayout of the 512 byte region depends on whether the processor is operating\nin non-64-bit operating modes or 64-bit sub-mode of IA-32e mode.\n\nBytes 464:511 are available to software use. The processor does not write to\nbytes 464:511 of an FXSAVE area.\n\nThe operation of FXSAVE in non-64-bit modes is described first.\n\n\nNon-64-Bit Mode Operation:\nTable 3-53 shows the layout of the state information in memory when the processor\nis operating in legacy modes.\n\n\nTable 3-53. Non-64-bit-Mode Layout of FXSAVE and FXRSTOR Memory Region:\n| 15 Rsvd| 14 MXCSR_MASK| 13 FPU CS Reserved Reserved Reserved| 12| 11 Table 3-53.| 10 FPU IP MXCSR| 9 Non-64-bit-Mode Layout of FXSAVE and| 8 XMM0 XMM1 XMM2 XMM3 XMM4 XMM5 XMM6| 7 FOP Rsrvd| 6| 5 Rsvd FPU DS ST0/MM0 ST1/MM1 ST2/MM2  | 4 FTW| 3 FSW| 2 FPU DP| 1 FCW| 0 0 16 32 48 64 80 96 112 128 144 160\n|        |              | Reserved Reserved Reserved Reserved |   |               |                | FXRSTOR                               | XMM7                                |            |  | ST3/MM3 ST4/MM4 ST5/MM5 ST6/MM6 ST7/MM7|      |      |         |      | 176 192 208 224 240 256 272          \n|        |              | Reserved                            |   |               |                |                                       |                                     |            |  |                                        |      |      |         |      |                                      \n\nMemory Region (Contd.):\n| 15| 14| 13| 12| 11| 10| 9| 8 Reserved Reserved Reserved Reserved| 7| 6| 5| 4| 3| 2| 1| 0 288 304 320 336 352 368 384 400 416\n|   |   |   |   |   |   |  | Reserved Reserved Reserved Reserved  |  |  |  |  |  |  |  | 432 448 464 480 496                  \n|   |   |   |   |   |   |  | Reserved Reserved Reserved Available |  |  |  |  |  |  |  |                                      \n|   |   |   |   |   |   |  | Available Available                  |  |  |  |  |  |  |  |                                      \nThe destination operand contains the first byte of the memory image, and it\nmust be aligned on a 16-byte boundary. A misaligned destination operand will\nresult in a general-protection (#GP) exception being generated (or in some cases,\nan alignment check exception [#AC]).\n\nThe FXSAVE instruction is used when an operating system needs to perform a context\nswitch or when an exception handler needs to save and examine the current state\nof the x87 FPU, MMX technology, and/or XMM and MXCSR registers.\n\nThe fields in Table 3-53 are defined in Table 3-54.\n\n\nTable 3-54. Field Definitions:\n| Field                  | Definition                                           \n| FCW                    | x87 FPU Control Word (16 bits). See                  \n|                        | Figure 8-6 in the Intel\u00ae 64 and IA-32                \n|                        | Architectures Software Developer's Manual,           \n|                        | Volume 1, for the layout of the x87                  \n|                        | FPU control word.                                    \n| FSW                    | x87 FPU Status Word (16 bits). See Figure            \n|                        | 8-4 in the Intel\u00ae 64 and IA-32 Architectures         \n|                        | Software Developer's Manual, Volume                  \n|                        | 1, for the layout of the x87 FPU status              \n|                        | word.                                                \n| Abridged FTW           | x87 FPU Tag Word (8 bits). The tag information       \n|                        | saved here is abridged, as described                 \n|                        | in the following paragraphs.                         \n| FOP                    | x87 FPU Opcode (16 bits). The lower                  \n|                        | 11 bits of this field contain the opcode,            \n|                        | upper 5 bits are reserved. See Figure                \n|                        | 8-8 in the Intel\u00ae 64 and IA-32 Architectures         \n|                        | Software Developer's Manual, Volume                  \n|                        | 1, for the layout of the x87 FPU opcode              \n|                        | field.                                               \n| FPU IP                 | x87 FPU Instruction Pointer Offset (32               \n|                        | bits). The contents of this field differ             \n|                        | depending on the current addressing                  \n|                        | mode (32-bit or 16-bit) of the processor             \n|                        | when the FXSAVE instruction was executed:            \n|                        | 32-bit mode  -  32-bit IP offset. 16-bit               \n|                        | mode  -  low 16 bits are IP offset; high               \n|                        | 16 bits are reserved. See \u201cx87 FPU Instruction       \n|                        | and Operand (Data) Pointers\u201d in Chapter              \n|                        | 8 of the Intel\u00ae 64 and IA-32 Architectures           \n|                        | Software Developer's Manual, Volume                  \n|                        | 1, for a description of the x87 FPU                  \n|                        | instruction pointer.                                 \n| FPU CS                 | x87 FPU Instruction Pointer Selector                 \n|                        | (16 bits). If CPUID.(EAX=07H,ECX=0H):EBX[bit         \n|                        | 13] = 1, the processor deprecates the                \n|                        | FPU CS and FPU DS values, and this field             \n|                        | is saved as 0000H. (Contd.)                          \n| Field                  | Definition                                           \n| FPU DP                 | x87 FPU Instruction Operand (Data) Pointer           \n|                        | Offset (32 bits). The contents of this               \n|                        | field differ depending on the current                \n|                        | addressing mode (32-bit or 16-bit) of                \n|                        | the processor when the FXSAVE instruction            \n|                        | was executed: 32-bit mode  -  32-bit DP                \n|                        | offset. 16-bit mode  -  low 16 bits are                \n|                        | DP offset; high 16 bits are reserved.                \n|                        | See \u201cx87 FPU Instruction and Operand                 \n|                        | (Data) Pointers\u201d in Chapter 8 of the                 \n|                        | Intel\u00ae 64 and IA-32 Architectures Software           \n|                        | Developer's Manual, Volume 1, for a                  \n|                        | description of the x87 FPU operand pointer.          \n| FPU DS                 | x87 FPU Instruction Operand (Data) Pointer           \n|                        | Selector (16 bits). If CPUID.(EAX=07H,ECX=0H):EBX[bit\n|                        | 13] = 1, the processor deprecates the                \n|                        | FPU CS and FPU DS values, and this field             \n|                        | is saved as 0000H.                                   \n| MXCSR                  | MXCSR Register State (32 bits). See                  \n|                        | Figure 10-3 in the Intel\u00ae 64 and IA-32               \n|                        | Architectures Software Developer's Manual,           \n|                        | Volume 1, for the layout of the MXCSR                \n|                        | register. If the OSFXSR bit in control               \n|                        | register CR4 is not set, the FXSAVE                  \n|                        | instruction may not save this register.              \n|                        | This behavior is implementation dependent.           \n| MXCSR_MASK             | MXCSR_MASK (32 bits). This mask can                  \n|                        | be used to adjust values written to                  \n|                        | the MXCSR register, ensuring that reserved           \n|                        | bits are set to 0. Set the mask bits                 \n|                        | and flags in MXCSR to the mode of operation          \n|                        | desired for SSE and SSE2 SIMD floating-point         \n|                        | instructions. See \u201cGuidelines for Writing            \n|                        | to the MXCSR Register\u201d in Chapter 11                 \n|                        | of the Intel\u00ae 64 and IA-32 Architectures             \n|                        | Software Developer's Manual, Volume                  \n|                        | 1, for instructions for how to determine             \n|                        | and use the MXCSR_MASK value.                        \n| ST0/MM0 through ST7/MM7| x87 FPU or MMX technology registers.                 \n|                        | These 80-bit fields contain the x87                  \n|                        | FPU data registers or the MMX technology             \n|                        | registers, depending on the state of                 \n|                        | the processor prior to the execution                 \n|                        | of the FXSAVE instruction. If the processor          \n|                        | had been executing x87 FPU instruction               \n|                        | prior to the FXSAVE instruction, the                 \n|                        | x87 FPU data registers are saved; if                 \n|                        | it had been executing MMX instructions               \n|                        | (or SSE or SSE2 instructions that operated           \n|                        | on the MMX technology registers), the                \n|                        | MMX technology registers are saved.                  \n|                        | When the MMX technology registers are                \n|                        | saved, the high 16 bits of the field                 \n|                        | are reserved.                                        \n| XMM0 through XMM7      | XMM registers (128 bits per field).                  \n|                        | If the OSFXSR bit in control register                \n|                        | CR4 is not set, the FXSAVE instruction               \n|                        | may not save these registers. This behavior          \n|                        | is implementation dependent.                         \nThe FXSAVE instruction saves an abridged version of the x87 FPU tag word in\nthe FTW field (unlike the FSAVE instruction, which saves the complete tag word).\nThe tag information is saved in physical register order (R0 through R7), rather\nthan in top-of-stack (TOS) order. With the FXSAVE instruction, however, only\na single bit (1 for valid or 0 for empty) is saved for each tag. For example,\nassume that the tag word is currently set as follows:\n\n| R7                                        | R6| R5| R4| R3| R2| R1| R0                                         \n| 11                                        | xx| xx| xx| 11| 11| 11| 11 Here, 11B indicates empty stack elements\n|                                           |   |   |   |   |   |   | and \u201cxx\u201d indicates valid (00B), zero       \n|                                           |   |   |   |   |   |   | (01B), or special (10B). For this example, \n|                                           |   |   |   |   |   |   | the FXSAVE instruction saves only the      \n|                                           |   |   |   |   |   |   | following 8 bits of information:           \n| R7                                        | R6| R5| R4| R3| R2| R1| R0                                         \n| 0 FXSAVE instruction does not check       | 1 | 1 | 1 | 0 | 0 | 0 | 0 Here, a 1 is saved for any valid,        \n| for pending unmasked floating-point       |   |   |   |   |   |   | zero, or special tag, and a 0 is saved     \n| exceptions. (The FXSAVE operation in      |   |   |   |   |   |   | for any empty tag. The operation of        \n| this regard is similar to the operation   |   |   |   |   |   |   | the FXSAVE instruction differs from        \n| of the FNSAVE instruction). After the     |   |   |   |   |   |   | that of the FSAVE instruction, the as      \n| FXSAVE instruction has saved the state    |   |   |   |   |   |   | follows: \u2022\u2022\u2022                               \n| of the x87 FPU, MMX technology, XMM,      |   |   |   |   |   |   |                                            \n| and MXCSR registers, the processor retains|   |   |   |   |   |   |                                            \n| the contents of the registers. Because    |   |   |   |   |   |   |                                            \n| of this behavior, the FXSAVE instruction  |   |   |   |   |   |   |                                            \n| cannot be used by an application program  |   |   |   |   |   |   |                                            \n| to pass a \u201cclean\u201d x87 FPU state to a      |   |   |   |   |   |   |                                            \n| procedure, since it retains the current   |   |   |   |   |   |   |                                            \n| state. To clean the x87 FPU state, an     |   |   |   |   |   |   |                                            \n| application must explicitly execute       |   |   |   |   |   |   |                                            \n| an FINIT instruction after an FXSAVE      |   |   |   |   |   |   |                                            \n| instruction to reinitialize the x87       |   |   |   |   |   |   |                                            \n| FPU state. The format of the memory       |   |   |   |   |   |   |                                            \n| image saved with the FXSAVE instruction   |   |   |   |   |   |   |                                            \n| is the same regardless of the current     |   |   |   |   |   |   |                                            \n| addressing mode (32-bit or 16-bit) and    |   |   |   |   |   |   |                                            \n| operating mode (protected, real address,  |   |   |   |   |   |   |                                            \n| or system management).                    |   |   |   |   |   |   |                                            \nThis behavior differs from the FSAVE instructions, where the memory image format\nis different depending on the addressing mode and operating mode. Because of\nthe different image formats, the memory image saved with the FXSAVE instruction\ncannot be restored correctly with the FRSTOR instruction, and likewise the state\nsaved with the FSAVE instruction cannot be restored correctly with the FXRSTOR\ninstruction.\n\nThe FSAVE format for FTW can be recreated from the FTW valid bits and the stored\n80-bit FP data (assuming the stored data was not the contents of MMX technology\nregisters) using Table 3-55.\n\n\nTable 3-55. Recreating FSAVE Format:\n| Exponent all 1's| Exponent all 0's| Fraction all 0's| J and M bits| FTW valid bit x87 FTW\n| 0               | 0               | 0               | 0x          | 10                   \n| 0               | 0               | 0               | 1x          | 00                   \n| 0               | 0               | 1               | 00          | 10                   \n| 0               | 0               | 1               | 10          | 00                   \n| 0               | 1               | 0               | 0x          | 10                   \n| 0               | 1               | 0               | 1x          | 10                   \n| 0               | 1               | 1               | 00          | 01                   \n| 0               | 1               | 1               | 10          | 10                   \n| 1               | 0               | 0               | 1x          | 10                   \n| 1               | 0               | 0               | 1x          | 10                   \n| 1               | 0               | 1               | 00          | 10                   \n| 1               | 0               | 1               | 10          | 10 11                \nThe J-bit is defined to be the 1-bit binary integer to the left of the decimal\nplace in the significand. The M-bit is defined to be the most significant bit\nof the fractional portion of the significand (i.e., the bit immediately to the\nright of the decimal place).\n\nWhen the M-bit is the most significant bit of the fractional portion of the\nsignificand, it must be 0 if the fraction is all 0's.\n\n\nIA-32e Mode Operation:\nIn compatibility sub-mode of IA-32e mode, legacy SSE registers, XMM0 through\nXMM7, are saved according to the legacy FXSAVE map. In 64-bit mode, all of the\nSSE registers, XMM0 through XMM15, are saved. Additionally, there are two different\nlayouts of the FXSAVE map in 64-bit mode, corresponding to FXSAVE64 (which requires\nREX.W=1) and FXSAVE (REX.W=0). In the FXSAVE64 map (Table 3-56), the FPU IP\nand FPU DP pointers are 64-bit wide. In the FXSAVE map for 64-bit mode (Table\n3-57), the FPU IP and FPU DP pointers are 32-bits.\n\n\nTable 3-56. Layout of the 64-bit-mode FXSAVE64 Map (requires REX.W = 1):\n| 15 MXCSR_MASK| 14| 13 Reserved Reserved Reserved Reserved| 12 FPU IP| 11| 10 MXCSR Table 3-56.| 9| 8 Layout of the 64-bit-mode FXSAVE64| 7 FOP| 6| 5 Reserved ST0/MM0 ST1/MM1 ST2/MM2 ST3/MM3| 4 FTW FPU DP| 3 FSW| 2| 1 FCW| 0 0 16 32 48 64 80 96 112\n|              |   | Reserved Reserved                     |          |   |                     |  | Map                                 |      |  | ST4/MM4 ST5/MM5                           |             |      |  |      |                          \n\n(requires REX.W = 1) (Contd.):\n| 15         | 14           | 13 Reserved Reserved                | 12| 11 Table 3-57.| 10                                       | 9 Layout of the 64-bit-mode FXSAVE Map| 8| 7 XMM0 XMM1 XMM2 XMM3 XMM4 XMM5 XMM6      | 6| 5 ST6/MM6 ST7/MM7                        | 4    | 3    | 2       | 1    | 0 128 144 160 176 192 208 224 240 256\n|            |              |                                     |   |               |                                          | (REX.W = 0)                           |  | XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13    |  |                                          |      |      |         |      | 272 288 304 320 336 352 368 384 400  \n|            |              |                                     |   |               |                                          |                                       |  | XMM14 XMM15 Reserved Reserved Reserved    |  |                                          |      |      |         |      | 416 432 448 464 480 496              \n|            |              |                                     |   |               |                                          |                                       |  | Available Available Available             |  |                                          |      |      |         |      |                                      \n| 15 Reserved| 14 MXCSR_MASK| 13 FPU CS Reserved Reserved Reserved| 12| 11            | 10 FPU IP MXCSR Layout of the 64-bit-mode| 9                                     | 8| 7 FOP Reserved XMM0                       | 6| 5 Reserved FPU DS ST0/MM0 ST1/MM1 ST2/MM2| 4 FTW| 3 FSW| 2 FPU DP| 1 FCW| 0 0 16 32 48 64 80 96 112 128 144 160\n|            |              | Reserved Reserved Reserved Reserved |   |               | FXSAVE Map (REX.W = 0) (Contd.) (Contd.) |                                       |  |                                           |  | ST3/MM3 ST4/MM4 ST5/MM5 ST6/MM6 ST7/MM7  |      |      |         |      |                                      \n|            |              | Reserved Table 3-57.                |   |               |                                          |                                       |  |                                           |  |                                          |      |      |         |      |                                      \n| 15         | 14           | 13                                  | 12| 11            | 10                                       | 9                                     | 8| 7 XMM1 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7      | 6| 5                                        | 4    | 3    | 2       | 1    | 0 176 192 208 224 240 256 272 288 304\n|            |              |                                     |   |               |                                          |                                       |  | XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14   |  |                                          |      |      |         |      | 320 336 352 368 384 400 416 432 448  \n|            |              |                                     |   |               |                                          |                                       |  | XMM15 Reserved Reserved Reserved Available|  |                                          |      |      |         |      | 464 480 496                          \n|            |              |                                     |   |               |                                          |                                       |  | Available Available                       |  |                                          |      |      |         |      |                                      \nOperation:\n\nIF 64-Bit Mode\n  THEN\n     IF REX.W = 1\n       THEN\n          DEST <- Save64BitPromotedFxsave(x87 FPU, MMX, XMM7-XMM0,\n          MXCSR);\n       ELSE\n          DEST <- Save64BitDefaultFxsave(x87 FPU, MMX, XMM7-XMM0, MXCSR);\n     FI;\n  ELSE\n     DEST <- SaveLegacyFxsave(x87 FPU, MMX, XMM7-XMM0, MXCSR);\nFI;\n\nProtected Mode Exceptions:\n| #GP(0)         | For an illegal memory operand effective     \n|                | address in the CS, DS, ES, FS or GS         \n|                | segments. If a memory operand is not        \n|                | aligned on a 16-byte boundary, regardless   \n|                | of segment. (See the description of         \n|                | the alignment check exception [#AC]         \n|                | below.)                                     \n| #SS(0)         | For an illegal address in the SS segment.   \n| #PF(fault-code)| For a page fault.                           \n| #NM            | If CR0.TS[bit 3] = 1. If CR0.EM[bit         \n|                | 2] = 1.                                     \n| #UD            | If CPUID.01H:EDX.FXSR[bit 24] = 0.          \n| #UD            | If the LOCK prefix is used.                 \n| #AC            | If this exception is disabled a general     \n|                | protection exception (#GP) is signaled      \n|                | if the memory operand is not aligned        \n|                | on a 16-byte boundary, as described         \n|                | above. If the alignment check exception     \n|                | (#AC) is enabled (and the CPL is 3),        \n|                | signaling of #AC is not guaranteed and      \n|                | may vary with implementation, as follows.   \n|                | In all implementations where #AC is         \n|                | not signaled, a general protection exception\n|                | is signaled in its place. In addition,      \n|                | the width of the alignment check may        \n|                | also vary with implementation. For instance,\n|                | for a given implementation, an alignment    \n|                | check exception might be signaled for       \n|                | a 2-byte misalignment, whereas a general    \n|                | protection exception might be signaled      \n|                | for all other misalignments (4-, 8-,        \n|                | or 16-byte misalignments).                  \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand is not aligned on     \n|    | a 16-byte boundary, regardless of segment.\n|    | If any part of the operand lies outside   \n|    | the effective address space from 0 to     \n|    | FFFFH.                                    \n| #NM| If CR0.TS[bit 3] = 1. If CR0.EM[bit       \n|    | 2] = 1.                                   \n| #UD| If CPUID.01H:EDX.FXSR[bit 24] = 0. If     \n|    | the LOCK prefix is used.                  \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in real address mode.\n\n| #PF(fault-code)| For a page fault.              \n| #AC            | For unaligned memory reference.\n| #UD            | If the LOCK prefix is used.    \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the         \n|                | SS segment is in a non-canonical form.      \n| #GP(0)         | If the memory address is in a non-canonical \n|                | form. If memory operand is not aligned      \n|                | on a 16-byte boundary, regardless of        \n|                | segment.                                    \n| #PF(fault-code)| For a page fault.                           \n| #NM            | If CR0.TS[bit 3] = 1. If CR0.EM[bit         \n|                | 2] = 1.                                     \n| #UD            | If CPUID.01H:EDX.FXSR[bit 24] = 0. If       \n|                | the LOCK prefix is used.                    \n| #AC            | If this exception is disabled a general     \n|                | protection exception (#GP) is signaled      \n|                | if the memory operand is not aligned        \n|                | on a 16-byte boundary, as described         \n|                | above. If the alignment check exception     \n|                | (#AC) is enabled (and the CPL is 3),        \n|                | signaling of #AC is not guaranteed and      \n|                | may vary with implementation, as follows.   \n|                | In all implementations where #AC is         \n|                | not signaled, a general protection exception\n|                | is signaled in its place. In addition,      \n|                | the width of the alignment check may        \n|                | also vary with implementation. For instance,\n|                | for a given implementation, an alignment    \n|                | check exception might be signaled for       \n|                | a 2-byte misalignment, whereas a general    \n|                | protection exception might be signaled      \n|                | for all other misalignments (4-, 8-,        \n|                | or 16-byte misalignments).                  \n\nImplementation Note:\nThe order in which the processor signals general-protection (#GP) and page-fault\n(#PF) exceptions when they both occur on an instruction boundary is given in\nTable 5-2 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 3B. This order vary for FXSAVE for different processor implementations.\n\n", 
      "mnem": "FXSAVE"
    }, 
    {
      "description": "\nFXTRACT - Extract Exponent and Significand:\n| Opcode/Instruction| 64-Bit Mode| Compat/Leg Mode| Description                               \n| D9 F4 FXTRACT     | Valid      | Valid          | Separate value in ST(0) into exponent     \n|                   |            |                | and significand, store exponent in ST(0), \n|                   |            |                | and push the significand onto the register\n|                   |            |                | stack.                                    \n\nDescription:\nSeparates the source value in the ST(0) register into its exponent and significand,\nstores the exponent in ST(0), and pushes the significand onto the register stack.\nFollowing this operation, the new top-of-stack register ST(0) contains the value\nof the original significand expressed as a floating-point value. The sign and\nsignificand of this value are the same as those found in the source operand,\nand the exponent is 3FFFH (biased value for a true exponent of zero). The ST(1)\nregister contains the value of the original operand's true (unbiased) exponent\nexpressed as a floating-point value. (The operation performed by this instruction\nis a superset of the IEEE-recommended logb(x) function.)\n\nThis instruction and the F2XM1 instruction are useful for performing power and\nrange scaling operations. The FXTRACT instruction is also useful for converting\nnumbers in double extended-precision floating-point format to decimal representations\n(e.g., for printing or displaying).\n\nIf the floating-point zero-divide exception (#Z) is masked and the source operand\nis zero, an exponent value of \u221e is stored in register ST(1) and 0 with the sign\nof the source operand is stored in register ST(0).\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nTEMP <- Significand(ST(0));\nST(0) <- Exponent(ST(0));\nTOP<- TOP \u2212 1;\nST(0) <- TEMP;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred;\n|           | set to 1 if stack overflow occurred. \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow or overflow occurred.         \n| #IA| Source operand is an SNaN value or unsupported\n|    | format.                                       \n| #Z | ST(0) operand is \u00b10.                          \n| #D | Source operand is a denormal value.           \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FXTRACT"
    }, 
    {
      "description": "\nFYL2X - Compute y * log2x:\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                                      \n| D9 F1 | FYL2X      | Valid      | Valid          | Replace ST(1) with (ST(1) * log<sub>2</sub>ST(0))\n|       |            |            |                | and pop the register stack.                      \n\nDescription:\nComputes (ST(1) * log<sub>2</sub> (ST(0))), stores the result in resister ST(1),\nand pops the FPU register stack. The source operand in ST(0) must be a non-zero\npositive number.\n\nThe following table shows the results obtained when taking the log of various\nclasses of numbers, assuming that neither overflow nor underflow occurs.\n\n\nTable 3-58. FYL2X Results:\nST(0)\n\n| \u2212 \u221e| \u2212 F| \u00b10 + \u221e****\u2212 \u221e| +0<+F<+1 + \u221e+ F + 0 \u2212 0 \u2212 F \u2212 \u221e| + 1 \u22120 \u22120 +0 +0| + F > + 1 \u2212 \u221e\u2212 F \u2212 0 + 0 + F + \u221e| + \u221e\u2212 \u221e\u2212 \u221e+\u221e+\u221e| NaN NaN NaN NaN NaN NaN NaN\n| NaN| NaN| NaN          | NaN                            | NaN            | NaN                             | NaN          | NaN                        \nNotes: F Means finite floating-point value. * Indicates floating-point invalid-operation\n(#IA) exception. ** Indicates floating-point zero-divide (#Z) exception.\n\nIf the divide-by-zero exception is masked and register ST(0) contains \u00b10, the\ninstruction returns \u221e with a sign that is the opposite of the sign of the source\noperand in register ST(1).\n\nThe FYL2X instruction is designed with a built-in multiplication to optimize\nthe calculation of logarithms with an arbitrary positive base (b):\n\nlog<sub>b</sub>x \u2190 (log<sub>2</sub>b)-1 * log<sub>2</sub>x\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nST(1) <- ST(1) * log<sub>2</sub>ST(0);\nPopRegisterStack;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.               \n| #IA| Either operand is an SNaN or unsupported\n|    | format. Source operand in register ST(0)\n|    | is a negative finite value (not -0).    \n| #Z | Source operand in register ST(0) is     \n|    | \u00b10.                                     \n| #D | Source operand is a denormal value.     \n| #U | Result is too small for destination     \n|    | format.                                 \n| #O | Result is too large for destination     \n|    | format.                                 \n| #P | Value cannot be represented exactly     \n|    | in destination format.                  \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FYL2X"
    }, 
    {
      "description": "\nFYL2XP1 - Compute y * log2(x +1):\n| Opcode| Instruction| 64-Bit Mode| Compat/Leg Mode| Description                                     \n| D9 F9 | FYL2XP1    | Valid      | Valid          | Replace ST(1) with ST(1) * log<sub>2</sub>(ST(0)\n|       |            |            |                | + 1.0) and pop the register stack.              \n\nDescription:\nComputes (ST(1) * log<sub>2</sub>(ST(0) + 1.0)), stores the result in register\nST(1), and pops the FPU register stack. The source operand in ST(0) must be\nin the range:\n\n| -(1 -| 2\u20442))to(1\u2212 \u221e       | 2\u20442) The source operand in ST(1) can       \n|      |                    | range from \u2212\u221e to +\u221e. If the ST(0) operand  \n|      |                    | is outside of its acceptable range,        \n|      |                    | the result is undefined and software       \n|      |                    | should not rely on an exception being      \n|      |                    | generated. Under some circumstances        \n|      |                    | exceptions may be generated when ST(0)     \n|      |                    | is out of range, but this behavior is      \n|      |                    | implementation specific and not guaranteed.\n|      |                    | The following table shows the results      \n|      |                    | obtained when taking the log epsilon       \n|      |                    | of various classes of numbers, assuming    \n|      |                    | that underflow does not occur. FYL2XP1     \n|      |                    | Results ST(0) NaN NaN                      \n| ST(1)| \u2212 F \u2212 0 +0 +F +\u221eNaN| NaN NaN NaN NaN NaN NaN                    \nNotes: F Means finite floating-point value. * Indicates floating-point invalid-operation\n(#IA) exception.\n\nThis instruction provides optimal accuracy for values of epsilon [the value\nin register ST(0)] that are close to 0. For small epsilon (\u03b5) values, more significant\ndigits can be retained by using the FYL2XP1 instruction than by using (\u03b5+1)\nas an argument to the FYL2X instruction. The (\u03b5+1) expression is commonly found\nin compound interest and annuity calculations. The result can be simply converted\ninto a value in another logarithm base by including a scale factor in the ST(1)\nsource operand. The following equation is used to calculate the scale factor\nfor a particular logarithm base, where n is the logarithm base desired for the\nresult of the FYL2XP1 instruction:\n\nscale factor \u2190 log<sub>n</sub> 2\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nST(1) <- ST(1) * log<sub>2</sub>(ST(0) + 1.0);\nPopRegisterStack;\n\nFPU Flags Affected:\n| C1        | Set to 0 if stack underflow occurred.\n|           | Set if result was rounded up; cleared\n|           | otherwise.                           \n| C0, C2, C3| Undefined.                           \n\nFloating-Point Exceptions:\n| #IS| Stack underflow occurred.                     \n| #IA| Either operand is an SNaN value or unsupported\n|    | format.                                       \n| #D | Source operand is a denormal value.           \n| #U | Result is too small for destination           \n|    | format.                                       \n| #O | Result is too large for destination           \n|    | format.                                       \n| #P | Value cannot be represented exactly           \n|    | in destination format.                        \n\nProtected Mode Exceptions:\n| #NM| CR0.EM[bit 2] or CR0.TS[bit 3] = 1.     \n| #MF| If there is a pending x87 FPU exception.\n| #UD| If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "FYL2XP1"
    }, 
    {
      "description": "\nHADDPD - Packed Double-FP Horizontal Add:\n| Opcode/Instruction                 | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                           \n| 66 0F 7C /r HADDPD xmm1, xmm2/m128 | RM   | V/V           | SSE3              | Horizontal add packed double-precision\n|                                    |      |               |                   | floating-point values from xmm2/m128  \n|                                    |      |               |                   | to xmm1.                              \n| VEX.NDS.128.66.0F.WIG 7C /r VHADDPD| RVM  | V/V           | AVX               | Horizontal add packed double-precision\n| xmm1,xmm2, xmm3/m128               |      |               |                   | floating-point values from xmm2 and   \n|                                    |      |               |                   | xmm3/mem.                             \n| VEX.NDS.256.66.0F.WIG 7C /r VHADDPD| RVM  | V/V           | AVX               | Horizontal add packed double-precision\n| ymm1, ymm2, ymm3/m256              |      |               |                   | floating-point values from ymm2 and   \n|                                    |      |               |                   | ymm3/mem.                             \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nAdds the double-precision floating-point values in the high and low quadwords\nof the destination operand and stores the result in the low quadword of the\ndestination operand.\n\nAdds the double-precision floating-point values in the high and low quadwords\nof the source operand and stores the result in the high quadword of the destination\noperand.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nSee Figure 3-15 for HADDPD; see Figure 3-16 for VHADDPD.\n\nHADDPD xmm1, xmm2/m128\n\nxmm2\n\n| [127:64]| [63:0]/m128                               \n| [127:64]| xmm1 Result: xmm1[63:0] + xmm1[127:64]xmm1\n| [127:64]| [63:0]                                    \nOM15993\n\n| Figure 3-15.| HADDPD - Packed Double-FP Horizontal Add\n| X3          | X0                                    \n| Y3          | Y0                                    \n| Y2 + Y3     | X0 + X1 VHADDPD operation             \n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit\nmemory location. The destination is not distinct from the first source XMM register\nand the upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. VEX.128 encoded version: the first source operand is an XMM\nregister or 128-bit memory location. The destination operand is an XMM register.\nThe upper bits (VLMAX-1:128) of the corresponding YMM register destination are\nzeroed. VEX.256 encoded version: The first source operand is a YMM register.\nThe second source operand can be a YMM register or a 256-bit memory location.\nThe destination operand is a YMM register.\n\nOperation:\n\nHADDPD (128-bit Legacy SSE version)\nDEST[63:0] <- SRC1[127:64] + SRC1[63:0]\nDEST[127:64] <- SRC2[127:64] + SRC2[63:0]\nDEST[VLMAX-1:128] (Unmodified)\nVHADDPD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[127:64] + SRC1[63:0]\nDEST[127:64] <- SRC2[127:64] + SRC2[63:0]\nDEST[VLMAX-1:128] <- 0\nVHADDPD (VEX.256 encoded version)\nDEST[63:0] <- SRC1[127:64] + SRC1[63:0]\nDEST[127:64] <- SRC2[127:64] + SRC2[63:0]\nDEST[191:128] <- SRC1[255:192] + SRC1[191:128]\nDEST[255:192] <- SRC2[255:192] + SRC2[191:128]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| VHADDPD:| __m256d _mm256_hadd_pd (__m256d a, __m256d\n|         | b);                                       \n| HADDPD: | __m128d _mm_hadd_pd (__m128d a, __m128d   \n|         | b);                                       \n\nExceptions:\nWhen the source operand is a memory operand, the operand must be aligned on\na 16-byte boundary or a generalprotection exception (#GP) will be generated.\n\n\nNumeric Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "HADDPD"
    }, 
    {
      "description": "\nHADDPS - Packed Single-FP Horizontal Add:\n| Opcode/Instruction                 | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                           \n| F2 0F 7C /r HADDPS xmm1, xmm2/m128 | RM   | V/V           | SSE3              | Horizontal add packed single-precision\n|                                    |      |               |                   | floating-point values from xmm2/m128  \n|                                    |      |               |                   | to xmm1.                              \n| VEX.NDS.128.F2.0F.WIG 7C /r VHADDPS| RVM  | V/V           | AVX               | Horizontal add packed single-precision\n| xmm1, xmm2, xmm3/m128              |      |               |                   | floating-point values from xmm2 and   \n|                                    |      |               |                   | xmm3/mem.                             \n| VEX.NDS.256.F2.0F.WIG 7C /r VHADDPS| RVM  | V/V           | AVX               | Horizontal add packed single-precision\n| ymm1, ymm2, ymm3/m256              |      |               |                   | floating-point values from ymm2 and   \n|                                    |      |               |                   | ymm3/mem.                             \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nAdds the single-precision floating-point values in the first and second dwords\nof the destination operand and stores the result in the first dword of the destination\noperand.\n\nAdds single-precision floating-point values in the third and fourth dword of\nthe destination operand and stores the result in the second dword of the destination\noperand.\n\nAdds single-precision floating-point values in the first and second dword of\nthe source operand and stores the result in the third dword of the destination\noperand.\n\nAdds single-precision floating-point values in the third and fourth dword of\nthe source operand and stores the result in the fourth dword of the destination\noperand.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nSee Figure 3-17 for HADDPS; see Figure 3-18 for VHADDPS.\n\nHADDPS xmm1, xmm2/m128\n\nxmm2/\n\n| [127:96]| [95:64]                                   | [63:32]                         | [31:0]m128                                \n| [127:96]| [95:64]xmm2/m128 [31:0] + xmm2/m128[63:32]| [63:32]xmm1[95:64] +xmm1[127:96]| xmm1 xmm2/m128 RESULT: [95:64] + xmm2/xmm1\n|         |                                           |                                 | m128[127:96]                              \n| [127:96]| [95:64]                                   | [63:32]                         | [31:0]                                    \nOM15994\n\n| Figure 3-17.| HADDPS - Packed Single-FP Horizontal Add\n| X7          | X0                                    \n| Y7          | Y0                                    \n| Y6+Y7       | X0+X1 VHADDPS operation               \n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit\nmemory location. The destination is not distinct from the first source XMM register\nand the upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. VEX.128 encoded version: the first source operand is an XMM\nregister or 128-bit memory location. The destination operand is an XMM register.\nThe upper bits (VLMAX-1:128) of the corresponding YMM register destination are\nzeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second\nsource operand can be a YMM register or a 256-bit memory location. The destination\noperand is a YMM register.\n\nOperation:\n\nHADDPS (128-bit Legacy SSE version)\nDEST[31:0] <- SRC1[63:32] + SRC1[31:0]\nDEST[63:32] <- SRC1[127:96] + SRC1[95:64]\nDEST[95:64] <- SRC2[63:32] + SRC2[31:0]\nDEST[127:96] <- SRC2[127:96] + SRC2[95:64]\nDEST[VLMAX-1:128] (Unmodified)\nVHADDPS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[63:32] + SRC1[31:0]\nDEST[63:32] <- SRC1[127:96] + SRC1[95:64]\nDEST[95:64] <- SRC2[63:32] + SRC2[31:0]\nDEST[127:96] <- SRC2[127:96] + SRC2[95:64]\nDEST[VLMAX-1:128] <- 0\nVHADDPS (VEX.256 encoded version)\nDEST[31:0] <- SRC1[63:32] + SRC1[31:0]\nDEST[63:32] <- SRC1[127:96] + SRC1[95:64]\nDEST[95:64] <- SRC2[63:32] + SRC2[31:0]\nDEST[127:96] <- SRC2[127:96] + SRC2[95:64]\nDEST[159:128] <- SRC1[191:160] + SRC1[159:128]\nDEST[191:160] <- SRC1[255:224] + SRC1[223:192]\nDEST[223:192] <- SRC2[191:160] + SRC2[159:128]\nDEST[255:224] <- SRC2[255:224] + SRC2[223:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| HADDPS: | __m128 _mm_hadd_ps (__m128 a, __m128   \n|         | b);                                    \n| VHADDPS:| __m256 _mm256_hadd_ps (__m256 a, __m256\n|         | b);                                    \n\nExceptions:\nWhen the source operand is a memory operand, the operand must be aligned on\na 16-byte boundary or a generalprotection exception (#GP) will be generated.\n\n\nNumeric Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "HADDPS"
    }, 
    {
      "description": "\nHLT - Halt:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description\n| F4    | HLT        | NP   | Valid      | Valid          | Halt       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nStops instruction execution and places the processor in a HALT state. An enabled\ninterrupt (including NMI and SMI), a debug exception, the BINIT# signal, the\nINIT# signal, or the RESET# signal will resume execution. If an interrupt (including\nNMI) is used to resume execution after a HLT instruction, the saved instruction\npointer (CS:EIP) points to the instruction following the HLT instruction.\n\nWhen a HLT instruction is executed on an Intel 64 or IA-32 processor supporting\nIntel Hyper-Threading Technology, only the logical processor that executes the\ninstruction is halted. The other logical processors in the physical processor\nremain active, unless they are each individually halted by executing a HLT instruction.\n\nThe HLT instruction is a privileged instruction. When the processor is running\nin protected or virtual-8086 mode, the privilege level of a program or procedure\nmust be 0 to execute the HLT instruction.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nEnter Halt state;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the current privilege level is not\n|       | 0.                                   \n| #UD   | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\nNone.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "HLT"
    }, 
    {
      "description": "\nHSUBPD - Packed Double-FP Horizontal Subtract:\n| Opcode/Instruction                 | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| 66 0F 7D /r HSUBPD xmm1, xmm2/m128 | RM   | V/V           | SSE3              | Horizontal subtract packed double-precision\n|                                    |      |               |                   | floating-point values from xmm2/m128       \n|                                    |      |               |                   | to xmm1.                                   \n| VEX.NDS.128.66.0F.WIG 7D /r VHSUBPD| RVM  | V/V           | AVX               | Horizontal subtract packed double-precision\n| xmm1,xmm2, xmm3/m128               |      |               |                   | floating-point values from xmm2 and        \n|                                    |      |               |                   | xmm3/mem.                                  \n| VEX.NDS.256.66.0F.WIG 7D /r VHSUBPD| RVM  | V/V           | AVX               | Horizontal subtract packed double-precision\n| ymm1, ymm2, ymm3/m256              |      |               |                   | floating-point values from ymm2 and        \n|                                    |      |               |                   | ymm3/mem.                                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nThe HSUBPD instruction subtracts horizontally the packed DP FP numbers of both\noperands.\n\nSubtracts the double-precision floating-point value in the high quadword of\nthe destination operand from the low quadword of the destination operand and\nstores the result in the low quadword of the destination operand.\n\nSubtracts the double-precision floating-point value in the high quadword of\nthe source operand from the low quadword of the source operand and stores the\nresult in the high quadword of the destination operand.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nSee Figure 3-19 for HSUBPD; see Figure 3-20 for VHSUBPD.\n\nHSUBPD xmm1, xmm2/m128\n\nxmm2\n\n| [127:64]| [63:0]/m128                               \n| [127:64]| xmm1 Result: xmm1[63:0] - xmm1[127:64]xmm1\n| [127:64]| [63:0]                                    \nOM15995\n\n| Figure 3-19.| HSUBPD - Packed Double-FP Horizontal Subtract\n| X3          | X0                                         \n| Y3          | Y0                                         \n| Y2 - Y3     | X0 - X1 VHSUBPD operation                  \n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit\nmemory location. The destination is not distinct from the first source XMM register\nand the upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. VEX.128 encoded version: the first source operand is an XMM\nregister or 128-bit memory location. The destination operand is an XMM register.\nThe upper bits (VLMAX-1:128) of the corresponding YMM register destination are\nzeroed. VEX.256 encoded version: The first source operand is a YMM register.\nThe second source operand can be a YMM register or a 256-bit memory location.\nThe destination operand is a YMM register.\n\nOperation:\n\nHSUBPD (128-bit Legacy SSE version)\nDEST[63:0] <- SRC1[63:0] - SRC1[127:64]\nDEST[127:64] <- SRC2[63:0] - SRC2[127:64]\nDEST[VLMAX-1:128] (Unmodified)\nVHSUBPD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0] - SRC1[127:64]\nDEST[127:64] <- SRC2[63:0] - SRC2[127:64]\nDEST[VLMAX-1:128] <- 0\nVHSUBPD (VEX.256 encoded version)\nDEST[63:0] <- SRC1[63:0] - SRC1[127:64]\nDEST[127:64] <- SRC2[63:0] - SRC2[127:64]\nDEST[191:128] <- SRC1[191:128] - SRC1[255:192]\nDEST[255:192] <- SRC2[191:128] - SRC2[255:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| HSUBPD: | __m128d _mm_hsub_pd(__m128d a, __m128d    \n|         | b)                                        \n| VHSUBPD:| __m256d _mm256_hsub_pd (__m256d a, __m256d\n|         | b);                                       \n\nExceptions:\nWhen the source operand is a memory operand, the operand must be aligned on\na 16-byte boundary or a generalprotection exception (#GP) will be generated.\n\n\nNumeric Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "HSUBPD"
    }, 
    {
      "description": "\nHSUBPS - Packed Single-FP Horizontal Subtract:\n| Opcode/Instruction                 | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| F2 0F 7D /r HSUBPS xmm1, xmm2/m128 | RM   | V/V           | SSE3              | Horizontal subtract packed single-precision\n|                                    |      |               |                   | floating-point values from xmm2/m128       \n|                                    |      |               |                   | to xmm1.                                   \n| VEX.NDS.128.F2.0F.WIG 7D /r VHSUBPS| RVM  | V/V           | AVX               | Horizontal subtract packed single-precision\n| xmm1, xmm2, xmm3/m128              |      |               |                   | floating-point values from xmm2 and        \n|                                    |      |               |                   | xmm3/mem.                                  \n| VEX.NDS.256.F2.0F.WIG 7D /r VHSUBPS| RVM  | V/V           | AVX               | Horizontal subtract packed single-precision\n| ymm1, ymm2, ymm3/m256              |      |               |                   | floating-point values from ymm2 and        \n|                                    |      |               |                   | ymm3/mem.                                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nSubtracts the single-precision floating-point value in the second dword of the\ndestination operand from the first dword of the destination operand and stores\nthe result in the first dword of the destination operand.\n\nSubtracts the single-precision floating-point value in the fourth dword of the\ndestination operand from the third dword of the destination operand and stores\nthe result in the second dword of the destination operand.\n\nSubtracts the single-precision floating-point value in the second dword of the\nsource operand from the first dword of the source operand and stores the result\nin the third dword of the destination operand.\n\nSubtracts the single-precision floating-point value in the fourth dword of the\nsource operand from the third dword of the source operand and stores the result\nin the fourth dword of the destination operand.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nSee Figure 3-21 for HSUBPS; see Figure 3-22 for VHSUBPS.\n\nHSUBPS xmm1, xmm2/m128\n\nxmm2/\n\n| [127:96]| [95:64]                                   | [63:32]                        | [31:0]m128                                \n| [127:96]| [95:64]xmm2/m128 [31:0] - xmm2/m128[63:32]| [63:32]xmm1[95:64] xmm1[127:96]| xmm1 xmm2/m128 RESULT: [95:64] - xmm2/xmm1\n|         |                                           |                                | m128[127:96]                              \n| [127:96]| [95:64]                                   | [63:32]                        | [31:0]                                    \nOM15996\n\n| Figure 3-21.| HSUBPS - Packed Single-FP Horizontal Subtract\n| X7          | X0                                         \n| Y7          | Y0                                         \n| Y6-Y7       | X0-X1 VHSUBPS operation                    \n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit\nmemory location. The destination is not distinct from the first source XMM register\nand the upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. VEX.128 encoded version: the first source operand is an XMM\nregister or 128-bit memory location. The destination operand is an XMM register.\nThe upper bits (VLMAX-1:128) of the corresponding YMM register destination are\nzeroed. VEX.256 encoded version: The first source operand is a YMM register.\nThe second source operand can be a YMM register or a 256-bit memory location.\nThe destination operand is a YMM register.\n\nOperation:\n\nHSUBPS (128-bit Legacy SSE version)\nDEST[31:0] <- SRC1[31:0] - SRC1[63:32]\nDEST[63:32] <- SRC1[95:64] - SRC1[127:96]\nDEST[95:64] <- SRC2[31:0] - SRC2[63:32]\nDEST[127:96] <- SRC2[95:64] - SRC2[127:96]\nDEST[VLMAX-1:128] (Unmodified)\nVHSUBPS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0] - SRC1[63:32]\nDEST[63:32] <- SRC1[95:64] - SRC1[127:96]\nDEST[95:64] <- SRC2[31:0] - SRC2[63:32]\nDEST[127:96] <- SRC2[95:64] - SRC2[127:96]\nDEST[VLMAX-1:128] <- 0\nVHSUBPS (VEX.256 encoded version)\nDEST[31:0] <- SRC1[31:0] - SRC1[63:32]\nDEST[63:32] <- SRC1[95:64] - SRC1[127:96]\nDEST[95:64] <- SRC2[31:0] - SRC2[63:32]\nDEST[127:96] <- SRC2[95:64] - SRC2[127:96]\nDEST[159:128] <- SRC1[159:128] - SRC1[191:160]\nDEST[191:160] <- SRC1[223:192] - SRC1[255:224]\nDEST[223:192] <- SRC2[159:128] - SRC2[191:160]\nDEST[255:224] <- SRC2[223:192] - SRC2[255:224]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| HSUBPS: | __m128 _mm_hsub_ps(__m128 a, __m128    \n|         | b);                                    \n| VHSUBPS:| __m256 _mm256_hsub_ps (__m256 a, __m256\n|         | b);                                    \n\nExceptions:\nWhen the source operand is a memory operand, the operand must be aligned on\na 16-byte boundary or a generalprotection exception (#GP) will be generated.\n\n\nNumeric Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "HSUBPS"
    }, 
    {
      "description": "\nIDIV - Signed Divide:\n| Opcode       | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                              \n| F6 /7        | IDIV r/m8  | M    | Valid      | Valid          | Signed divide AX by r/m8, with result    \n|              |            |      |            |                | stored in: AL \u2190 Quotient, AH \u2190 Remainder.\n| REX + F6 /7  | IDIV r/m8* | M    | Valid      | N.E.           | Signed divide AX by r/m8, with result    \n|              |            |      |            |                | stored in AL \u2190 Quotient, AH \u2190 Remainder. \n| F7 /7        | IDIV r/m16 | M    | Valid      | Valid          | Signed divide DX:AX by r/m16, with result\n|              |            |      |            |                | stored in AX \u2190 Quotient, DX \u2190 Remainder. \n| F7 /7        | IDIV r/m32 | M    | Valid      | Valid          | Signed divide EDX:EAX by r/m32, with     \n|              |            |      |            |                | result stored in EAX \u2190 Quotient, EDX     \n|              |            |      |            |                | \u2190 Remainder.                             \n| REX.W + F7 /7| IDIV r/m64 | M    | Valid      | N.E.           | Signed divide RDX:RAX by r/m64, with     \n|              |            |      |            |                | result stored in RAX \u2190 Quotient, RDX     \n|              |            |      |            |                | \u2190 Remainder.                             \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nDivides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) by the source\noperand (divisor) and stores the result in the AX (AH:AL), DX:AX, or EDX:EAX\nregisters. The source operand can be a general-purpose register or a memory\nlocation. The action of this instruction depends on the operand size (dividend/divisor).\n\nNon-integral results are truncated (chopped) towards 0. The remainder is always\nless than the divisor in magnitude. Overflow is indicated with the #DE (divide\nerror) exception rather than with the CF flag.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.R prefix permits access to additional registers (R8-R15). Use of the\nREX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied,\nthe instruction divides the signed value in RDX:RAX by the source operand. RAX\ncontains a 64-bit quotient; RDX contains a 64-bit remainder.\n\nSee the summary chart at the beginning of this section for encoding data and\nlimits. See Table 3-60.\n\n\nTable 3-60. IDIV Results:\n| Operand Size| Dividend AX DX:AX EDX:EAX RDX:RAX| Divisor r/m8 r/m16 r/m32 r/m64| Quotient AL AX EAX RAX| Remainder AH DX EDX RDX| Quotient Range \u2212128 to +127 \u221232,768   \n|             |                                  |                               |                       |                        | to +32,767 \u2212231 to 232 \u2212 1 \u2212263 to 264\n|             |                                  |                               |                       |                        | \u2212 1                                   \nOperation:\n\nIF SRC = 0\n  THEN #DE; (* Divide error *)\nFI;\nIF OperandSize = 8 (* Word/byte operation *)\n  THEN\n     temp <- AX / SRC; (* Signed division *)\n     IF (temp > 7FH) or (temp < 80H)\n     (* If a positive result is greater than 7FH or a negative result is less than 80H *)\n       THEN #DE; (* Divide error *)\n       ELSE\n          AL <- temp;\n          AH <- AX SignedModulus SRC;\n     FI;\n  ELSE IF OperandSize = 16 (* Doubleword/word operation *)\n     THEN\n       temp <- DX:AX / SRC; (* Signed division *)\n       IF (temp > 7FFFH) or (temp < 8000H)\n       (* If a positive result is greater than 7FFFH\n       or a negative result is less than 8000H *)\n          THEN\n             #DE; (* Divide error *)\n          ELSE\n             AX <- temp;\n             DX <- DX:AX SignedModulus SRC;\n       FI;\n     FI;\n  ELSE IF OperandSize = 32 (* Quadword/doubleword operation *)\n       temp <- EDX:EAX / SRC; (* Signed division *)\n       IF (temp > 7FFFFFFFH) or (temp < 80000000H)\n       (* If a positive result is greater than 7FFFFFFFH\n       or a negative result is less than 80000000H *)\n          THEN\n             #DE; (* Divide error *)\n          ELSE\n             EAX <- temp;\n             EDX <- EDXE:AX SignedModulus SRC;\n       FI;\n     FI;\n  ELSE IF OperandSize = 64 (* Doublequadword/quadword operation *)\n       temp <- RDX:RAX / SRC; (* Signed division *)\n       IF (temp > 7FFFFFFFFFFFFFFFH) or (temp < 8000000000000000H)\n       (* If a positive result is greater than 7FFFFFFFFFFFFFFFH\n       or a negative result is less than 8000000000000000H *)\n          THEN\n             #DE; (* Divide error *)\n          ELSE\n             RAX <- temp;\n             RDX <- RDE:RAX SignedModulus SRC;\n       FI;\n     FI;\nFI;\n\nFlags Affected:\nThe CF, OF, SF, ZF, AF, and PF flags are undefined.\n\n\nProtected Mode Exceptions:\n| #DE            | If the source operand (divisor) is 0.   \n|                | The signed result (quotient) is too     \n|                | large for the destination.              \n| #GP(0)         | If a memory operand effective address   \n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit. If the DS, ES, FS, or    \n|                | GS register is used to access memory    \n|                | and it contains a NULL segment selector.\n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made   \n|                | while the current privilege level is    \n|                | 3.                                      \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #DE| If the source operand (divisor) is 0.\nThe signed result (quotient) is too large for the destination.\n\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #DE| If the source operand (divisor) is 0.\nThe signed result (quotient) is too large for the destination.\n\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #DE            | If the source operand (divisor) is 0       \n|                | If the quotient is too large for the       \n|                | designated register.                       \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "IDIV"
    }, 
    {
      "description": "\nIMUL - Signed Multiply:\n| Opcode          | Instruction           | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                               \n| F6 /5           | IMUL r/m8*            | M    | Valid      | Valid          | AX\u2190 AL * r/m byte.                        \n| F7 /5           | IMUL r/m16            | M    | Valid      | Valid          | DX:AX \u2190 AX * r/m word.                    \n| F7 /5           | IMUL r/m32            | M    | Valid      | Valid          | EDX:EAX \u2190 EAX * r/m32.                    \n| REX.W + F7 /5   | IMUL r/m64            | M    | Valid      | N.E.           | RDX:RAX \u2190 RAX * r/m64.                    \n| 0F AF /r        | IMUL r16, r/m16       | RM   | Valid      | Valid          | word register \u2190 word register * r/m16.    \n| 0F AF /r        | IMUL r32, r/m32       | RM   | Valid      | Valid          | doubleword register \u2190 doubleword register \n|                 |                       |      |            |                | *r/m32.                                   \n| REX.W + 0F AF /r| IMUL r64, r/m64       | RM   | Valid      | N.E.           | Quadword register \u2190 Quadword register     \n|                 |                       |      |            |                | *r/m64.                                   \n| 6B /r ib        | IMUL r16, r/m16, imm8 | RMI  | Valid      | Valid          | word register \u2190 r/m16 * sign-extended     \n|                 |                       |      |            |                | immediate byte.                           \n| 6B /r ib        | IMUL r32, r/m32, imm8 | RMI  | Valid      | Valid          | doubleword register \u2190 r/m32 * signextended\n|                 |                       |      |            |                | immediate byte.                           \n| REX.W + 6B /r ib| IMUL r64, r/m64, imm8 | RMI  | Valid      | N.E.           | Quadword register \u2190 r/m64 * sign-extended \n|                 |                       |      |            |                | immediate byte.                           \n| 69 /r iw        | IMUL r16, r/m16, imm16| RMI  | Valid      | Valid          | word register \u2190 r/m16 * immediate word.   \n| 69 /r id        | IMUL r32, r/m32, imm32| RMI  | Valid      | Valid          | doubleword register \u2190 r/m32 * immediate   \n|                 |                       |      |            |                | doubleword.                               \n| REX.W + 69 /r id| IMUL r64, r/m64, imm32| RMI  | Valid      | N.E.           | Quadword register \u2190 r/m64 * immediate     \n|                 |                       |      |            |                | doubleword.                               \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3 | Operand 4\n| M    | ModRM:r/m (r, w)| NA           | NA        | NA       \n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA        | NA       \n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8/16/32| NA       \n\nDescription:\nPerforms a signed multiplication of two operands. This instruction has three\nforms, depending on the number of operands.\n\n - One-operand form  -  This form is identical to that used by the MUL instruction.\nHere, the source operand (in a general-purpose register or memory location)\nis multiplied by the value in the AL, AX, EAX, or RAX register (depending on\nthe operand size) and the product is stored in the AX, DX:AX, EDX:EAX, or RDX:RAX\nregisters, respectively.\n - Two-operand form  -  With this form the destination operand (the first operand)\nis multiplied by the source operand (second operand). The destination operand\nis a general-purpose register and the source operand is an immediate value,\na general-purpose register, or a memory location. The product is then stored\nin the destination operand location.\n - Three-operand form  -  This form requires a destination operand (the first operand)\nand two source operands (the second and the third operands). Here, the first\nsource operand (which can be a general-purpose register or a memory location)\nis multiplied by the second source operand (an immediate value). The product\nis then stored in the destination operand (a general-purpose register).\n\nWhen an immediate value is used as an operand, it is sign-extended to the length\nof the destination operand format.\n\nThe CF and OF flags are set when significant bit (including the sign bit) are\ncarried into the upper half of the result. The CF and OF flags are cleared when\nthe result (including the sign bit) fits exactly in the lower half of the result.\n\nThe three forms of the IMUL instruction are similar in that the length of the\nproduct is calculated to twice the length of the operands. With the one-operand\nform, the product is stored exactly in the destination. With the two- and three-\noperand forms, however, the result is truncated to the length of the destination\nbefore it is stored in the destination register. Because of this truncation,\nthe CF or OF flag should be tested to ensure that no significant bits are lost.\n\nThe two- and three-operand forms may also be used with unsigned operands because\nthe lower half of the product is the same regardless if the operands are signed\nor unsigned. The CF and OF flags, however, cannot be used to determine if the\nupper half of the result is non-zero.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.R prefix permits access to additional registers (R8-R15). Use of the\nREX.W prefix promotes operation to 64 bits. Use of REX.W modifies the three\nforms of the instruction as follows.\n\n - One-operand form  - The source operand (in a 64-bit general-purpose register or\nmemory location) is multiplied by the value in the RAX register and the product\nis stored in the RDX:RAX registers.\n - Two-operand form  -  The source operand is promoted to 64 bits if it is a register\nor a memory location. The destination operand is promoted to 64 bits.\n - Three-operand form  -  The first source operand (either a register or a memory\nlocation) and destination operand are promoted to 64 bits. If the source operand\nis an immediate, it is sign extended to 64 bits.\n\nOperation:\n\nIF (NumberOfOperands = 1)\n  THEN IF (OperandSize = 8)\n     THEN\n       AX <- AL * SRC (* Signed multiplication *)\n       IF AL = AX\n          THEN CF <- 0; OF <- 0;\n          ELSE CF <- 1; OF <- 1; FI;\n     ELSE IF OperandSize = 16\n       THEN\n          DX:AX <- AX * SRC (* Signed multiplication *)\n          IF sign_extend_to_32 (AX) = DX:AX\n             THEN CF <- 0; OF <- 0;\n             ELSE CF <- 1; OF <- 1; FI;\n       ELSE IF OperandSize = 32\n          THEN\n             EDX:EAX <- EAX * SRC (* Signed multiplication *)\n             IF EAX = EDX:EAX\n               THEN CF <- 0; OF <- 0;\n               ELSE CF <- 1; OF <- 1; FI;\n          ELSE (* OperandSize = 64 *)\n             RDX:RAX <- RAX * SRC (* Signed multiplication *)\n             IF RAX = RDX:RAX\n               THEN CF <- 0; OF <- 0;\n               ELSE CF <- 1; OF <- 1; FI;\n          FI;\n     FI;\n  ELSE IF (NumberOfOperands = 2)\n     THEN\n       temp <- DEST * SRC (* Signed multiplication; temp is double DEST size *)\n       DEST <- DEST * SRC (* Signed multiplication *)\n       IF temp != DEST\n          THEN CF <- 1; OF <- 1;\n          ELSE CF <- 0; OF <- 0; FI;\n     ELSE (* NumberOfOperands = 3 *)\n       DEST <- SRC1 * SRC2 (* Signed multiplication *)\n       temp <- SRC1 * SRC2 (* Signed multiplication; temp is double SRC1 size *)\n       IF temp != DEST\n          THEN CF <- 1; OF <- 1;\n          ELSE CF <- 0; OF <- 0; FI;\n  FI;\nFI;\n\nFlags Affected:\nFor the one operand form of the instruction, the CF and OF flags are set when\nsignificant bits are carried into the upper half of the result and cleared when\nthe result fits exactly in the lower half of the result. For the two- and three-operand\nforms of the instruction, the CF and OF flags are set when the result must be\ntruncated to fit in the destination operand size and cleared when the result\nfits exactly in the destination operand size. The SF, ZF, AF, and PF flags are\nundefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register is used to access memory \n|                | and it contains a NULL NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "IMUL"
    }, 
    {
      "description": "\nIN - Input from Port:\n| Opcode| Instruction | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| E4 ib | IN AL, imm8 | I    | Valid      | Valid          | Input byte from imm8 I/O port address \n|       |             |      |            |                | into AL.                              \n| E5 ib | IN AX, imm8 | I    | Valid      | Valid          | Input word from imm8 I/O port address \n|       |             |      |            |                | into AX.                              \n| E5 ib | IN EAX, imm8| I    | Valid      | Valid          | Input dword from imm8 I/O port address\n|       |             |      |            |                | into EAX.                             \n| EC    | IN AL,DX    | NP   | Valid      | Valid          | Input byte from I/O port in DX into   \n|       |             |      |            |                | AL.                                   \n| ED    | IN AX,DX    | NP   | Valid      | Valid          | Input word from I/O port in DX into   \n|       |             |      |            |                | AX.                                   \n| ED    | IN EAX,DX   | NP   | Valid      | Valid          | Input doubleword from I/O port in DX  \n|       |             |      |            |                | into EAX.                             \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| I    | imm8     | NA       | NA       | NA       \n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nCopies the value from the I/O port specified with the second operand (source\noperand) to the destination operand (first operand). The source operand can\nbe a byte-immediate or the DX register; the destination operand can be register\nAL, AX, or EAX, depending on the size of the port being accessed (8, 16, or\n32 bits, respectively). Using the DX register as a source operand allows I/O\nport addresses from 0 to 65,535 to be accessed; using a byte immediate allows\nI/O port addresses 0 to 255 to be accessed.\n\nWhen accessing an 8-bit I/O port, the opcode determines the port size; when\naccessing a 16- and 32-bit I/O port, the operand-size attribute determines the\nport size. At the machine code level, I/O instructions are shorter when accessing\n8-bit I/O ports. Here, the upper eight bits of the port address will be 0.\n\nThis instruction is only useful for accessing I/O ports located in the processor's\nI/O address space. See Chapter 16, \u201cInput/Output,\u201d in the Intel\u00ae 64 and IA-32\nArchitectures Software Developer's Manual, Volume 1, for more information on\naccessing I/O ports in the I/O address space.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nIF ((PE = 1) and ((CPL > IOPL) or (VM = 1)))\n  THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)\n     IF (Any I/O Permission Bit for I/O port being accessed = 1)\n       THEN (* I/O operation is not allowed *)\n          #GP(0);\n       ELSE ( * I/O operation is allowed *)\n          DEST <- SRC; (* Read from selected I/O port *)\n     FI;\n  ELSE (Real Mode or Protected Mode with CPL \u2264 IOPL *)\n     DEST <- SRC; (* Read from selected I/O port *)\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the CPL is greater than (has less       \n|       | privilege) the I/O privilege level (IOPL)  \n|       | and any of the corresponding I/O permission\n|       | bits in TSS for the I/O port being accessed\n|       | is 1.                                      \n| #UD   | If the LOCK prefix is used.                \n\nReal-Address Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If any of the I/O permission bits in   \n|                | the TSS for the I/O port being accessed\n|                | is 1.                                  \n| #PF(fault-code)| If a page fault occurs.                \n| #UD            | If the LOCK prefix is used.            \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)| If the CPL is greater than (has less       \n|       | privilege) the I/O privilege level (IOPL)  \n|       | and any of the corresponding I/O permission\n|       | bits in TSS for the I/O port being accessed\n|       | is 1.                                      \n| #UD   | If the LOCK prefix is used.                \n", 
      "mnem": "IN"
    }, 
    {
      "description": "\nINC - Increment by 1:\n| Opcode       | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                        \n| FE /0        | INC r/m8   | M    | Valid      | Valid          | Increment r/m byte by 1.           \n| REX + FE /0  | INC r/m8*  | M    | Valid      | N.E.           | Increment r/m byte by 1.           \n| FF /0        | INC r/m16  | M    | Valid      | Valid          | Increment r/m word by 1.           \n| FF /0        | INC r/m32  | M    | Valid      | Valid          | Increment r/m doubleword by 1.     \n| REX.W + FF /0| INC r/m64  | M    | Valid      | N.E.           | Increment r/m quadword by 1.       \n| 40+ rw**     | INC r16    | O    | N.E.       | Valid          | Increment word register by 1.      \n| 40+ rd       | INC r32    | O    | N.E.       | Valid          | Increment doubleword register by 1.\nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH. ** 40H through 47H are REX\nprefixes in 64-bit mode.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1         | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r, w)  | NA       | NA       | NA       \n| O    | opcode + rd (r, w)| NA       | NA       | NA       \n\nDescription:\nAdds 1 to the destination operand, while preserving the state of the CF flag.\nThe destination operand can be a register or a memory location. This instruction\nallows a loop counter to be updated without disturbing the CF flag. (Use a ADD\ninstruction with an immediate operand of 1 to perform an increment operation\nthat does updates the CF flag.)\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\nIn 64-bit mode, INC r16 and INC r32 are not encodable (because opcodes 40H through\n47H are REX prefixes). Otherwise, the instruction's 64-bit mode default operation\nsize is 32 bits. Use of the REX.R prefix permits access to additional registers\n(R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\n\nOperation:\n\nDEST <- DEST + 1;\n\nAFlags Affected:\nThe CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set according\nto the result.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination operand is located         \n|                | in a non-writable segment. If a memory        \n|                | operand effective address is outside          \n|                | the CS, DS, ES, FS, or GS segment limit.      \n|                | If the DS, ES, FS, or GS register is          \n|                | used to access memory and it contains         \n|                | a NULLsegment selector.                       \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "INC"
    }, 
    {
      "description": "\nINS/INSB/INSW/INSD - Input from Port to String:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                             \n| 6C    | INS m8, DX | NP   | Valid      | Valid          | Input byte from I/O port specified in   \n|       |            |      |            |                | DX into memory location specified in    \n|       |            |      |            |                | ES:(E)DI or RDI.*                       \n| 6D    | INS m16, DX| NP   | Valid      | Valid          | Input word from I/O port specified in   \n|       |            |      |            |                | DX into memory location specified in    \n|       |            |      |            |                | ES:(E)DI or RDI.1                       \n| 6D    | INS m32, DX| NP   | Valid      | Valid          | Input doubleword from I/O port specified\n|       |            |      |            |                | in DX into memory location specified    \n|       |            |      |            |                | in ES:(E)DI or RDI.1                    \n| 6C    | INSB       | NP   | Valid      | Valid          | Input byte from I/O port specified in   \n|       |            |      |            |                | DX into memory location specified with  \n|       |            |      |            |                | ES:(E)DI or RDI.1                       \n| 6D    | INSW       | NP   | Valid      | Valid          | Input word from I/O port specified in   \n|       |            |      |            |                | DX into memory location specified in    \n|       |            |      |            |                | ES:(E)DI or RDI.1                       \n| 6D    | INSD       | NP   | Valid      | Valid          | Input doubleword from I/O port specified\n|       |            |      |            |                | in DX into memory location specified    \n|       |            |      |            |                | in ES:(E)DI or RDI.1                    \nNotes: * In 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are\nsupported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes\nare supported.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nCopies the data from the I/O port specified with the source operand (second\noperand) to the destination operand (first operand). The source operand is an\nI/O port address (from 0 to 65,535) that is read from the DX register. The destination\noperand is a memory location, the address of which is read from either the ES:DI,\nES:EDI or the RDI registers (depending on the address-size attribute of the\ninstruction, 16, 32 or 64, respectively). (The ES segment cannot be overridden\nwith a segment override prefix.) The size of the I/O port being accessed (that\nis, the size of the source and destination operands) is determined by the opcode\nfor an 8-bit I/O port or by the operand-size attribute of the instruction for\na 16- or 32-bit I/O port.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \u201cexplicit-operands\u201d\nform and the \u201cnooperands\u201d form. The explicit-operands form (specified with the\nINS mnemonic) allows the source and destination operands to be specified explicitly.\nHere, the source operand must be \u201cDX,\u201d and the destination operand should be\na symbol that indicates the size of the I/O port and the destination address.\nThis explicit-operands form is provided to allow documentation; however, note\nthat the documentation provided by this form can be misleading. That is, the\ndestination operand symbol must specify the correct type (size) of the operand\n(byte, word, or doubleword), but it does not have to specify the correct location.\nThe location is always specified by the ES:(E)DI registers, which must be loaded\ncorrectly before the INS instruction is executed.\n\nThe no-operands form provides \u201cshort forms\u201d of the byte, word, and doubleword\nversions of the INS instructions. Here also DX is assumed by the processor to\nbe the source operand and ES:(E)DI is assumed to be the destination operand.\nThe size of the I/O port is specified with the choice of mnemonic: INSB (byte),\nINSW (word), or INSD (doubleword).\n\nAfter the byte, word, or doubleword is transfer from the I/O port to the memory\nlocation, the DI/EDI/RDI register is incremented or decremented automatically\naccording to the setting of the DF flag in the EFLAGS register. (If the DF flag\nis 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register\nis decremented.) The (E)DI register is incremented or decremented by 1 for byte\noperations, by 2 for word operations, or by 4 for doubleword operations.\n\nThe INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix\nfor block input of ECX bytes, words, or doublewords. See \u201cREP/REPE/REPZ /REPNE/REPNZ - Repeat\nString Operation Prefix\u201d in Chapter 4 of the Intel\u00ae64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 2B, for a description of the REP prefix.\n\nThese instructions are only useful for accessing I/O ports located in the processor's\nI/O address space. See Chapter 16, \u201cInput/Output,\u201d in the Intel\u00ae 64 and IA-32\nArchitectures Software Developer's Manual, Volume 1, for more information on\naccessing I/O ports in the I/O address space.\n\nIn 64-bit mode, default address size is 64 bits, 32 bit address size is supported\nusing the prefix 67H. The address of the memory destination is specified by\nRDI or EDI. 16-bit address size is not supported in 64-bit mode. The operand\nsize is not promoted.\n\nOperation:\n\nIF ((PE = 1) and ((CPL > IOPL) or (VM = 1)))\n  THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)\n     IF (Any I/O Permission Bit for I/O port being accessed = 1)\n       THEN (* I/O operation is not allowed *)\n          #GP(0);\n       ELSE (* I/O operation is allowed *)\n          DEST <- SRC; (* Read from I/O port *)\n     FI;\n  ELSE (Real Mode or Protected Mode with CPL IOPL *)\n     DEST <- SRC; (* Read from I/O port *)\nFI;\nNon-64-bit Mode:\nIF (Byte transfer)\n  THEN IF DF = 0\n     THEN (E)DI <- (E)DI + 1;\n     ELSE (E)DI <- (E)DI - 1; FI;\n  ELSE IF (Word transfer)\n     THEN IF DF = 0\n       THEN (E)DI <- (E)DI + 2;\n       ELSE (E)DI <- (E)DI - 2; FI;\n     ELSE (* Doubleword transfer *)\n       THEN IF DF = 0\n          THEN (E)DI <- (E)DI + 4;\n          ELSE (E)DI <- (E)DI - 4; FI;\n     FI;\nFI;\nFI64-bit Mode:\nIF (Byte transfer)\n  THEN IF DF = 0\n     THEN (E|R)DI <- (E|R)DI + 1;\n     ELSE (E|R)DI <- (E|R)DI - 1; FI;\n  ELSE IF (Word transfer)\n     THEN IF DF = 0\n       THEN (E)DI <- (E)DI + 2;\n       ELSE (E)DI <- (E)DI - 2; FI;\n     ELSE (* Doubleword transfer *)\n       THEN IF DF = 0\n          THEN (E|R)DI <- (E|R)DI + 4;\n          ELSE (E|R)DI <- (E|R)DI - 4; FI;\n     FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the CPL is greater than (has less       \n|                | privilege) the I/O privilege level (IOPL)  \n|                | and any of the corresponding I/O permission\n|                | bits in TSS for the I/O port being accessed\n|                | is 1. If the destination is located        \n|                | in a non-writable segment. If an illegal   \n|                | memory operand effective address in        \n|                | the ES segments is given.                  \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If any of the I/O permission bits in   \n|                | the TSS for the I/O port being accessed\n|                | is 1.                                  \n| #PF(fault-code)| If a page fault occurs.                \n| #AC(0)         | If alignment checking is enabled and   \n|                | an unaligned memory reference is made. \n| #UD            | If the LOCK prefix is used.            \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the CPL is greater than (has less       \n|                | privilege) the I/O privilege level (IOPL)  \n|                | and any of the corresponding I/O permission\n|                | bits in TSS for the I/O port being accessed\n|                | is 1. If the memory address is in a        \n|                | non-canonical form.                        \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "INS"
    }, 
    {
      "description": "-R:INS", 
      "mnem": "INSB"
    }, 
    {
      "description": "-R:INS", 
      "mnem": "INSD"
    }, 
    {
      "description": "\nINSERTPS  -  Insert Packed Single Precision Floating-Point Value:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                              \n| 66 0F 3A 21 /r ib INSERTPS xmm1, xmm2/m32,| RMI  | V/V           | SSE4_1            | Insert a single precision floating-point \n| imm8                                      |      |               |                   | value selected by imm8 from xmm2/m32     \n|                                           |      |               |                   | into xmm1 at the specified destination   \n|                                           |      |               |                   | element specified by imm8 and zero out   \n|                                           |      |               |                   | destination elements in xmm1 as indicated\n|                                           |      |               |                   | in imm8.                                 \n| VEX.NDS.128.66.0F3A.WIG 21 /r ib VINSERTPS| RVMI | V/V           | AVX               | Insert a single precision floating point \n| xmm1, xmm2, xmm3/m32, imm8                |      |               |                   | value selected by imm8 from xmm3/m32     \n|                                           |      |               |                   | and merge into xmm2 at the specified     \n|                                           |      |               |                   | destination element specified by imm8    \n|                                           |      |               |                   | and zero out destination elements in     \n|                                           |      |               |                   | xmm1 as indicated in imm8.               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\n(register source form) Select a single precision floating-point element from\nsecond source as indicated by Count_S bits of the immediate operand and insert\nit into the first source at the location indicated by the Count_D bits of the\nimmediate operand. Store in the destination and zero out destination elements\nbased on the ZMask bits of the immediate operand.\n\n(memory source form) Load a floating-point element from a 32-bit memory location\nand insert it into the first source at the location indicated by the Count_D\nbits of the immediate operand. Store in the destination and zero out destination\nelements based on the ZMask bits of the immediate operand.\n\n128-bit Legacy SSE version: The first source register is an XMM register. The\nsecond source operand is either an XMM register or a 32-bit memory location.\nThe destination is not distinct from the first source XMM register and the upper\nbits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version. The destination and first source register is an XMM\nregister. The second source operand is either an XMM register or a 32-bit memory\nlocation. The upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare zeroed. If VINSERTPS is encoded with VEX.L= 1, an attempt to execute the\ninstruction encoded with VEX.L= 1 will cause an #UD exception.\n\nOperation:\n\nINSERTPS (128-bit Legacy SSE version)\nIF (SRC = REG) THEN COUNT_S <- imm8[7:6]\n  ELSE COUNT_S <- 0\nCOUNT_D <- imm8[5:4]\nZMASK <- imm8[3:0]\nCASE (COUNT_S) OF\n  0: TMP <- SRC[31:0]\n  1: TMP <- SRC[63:32]\n  2: TMP <- SRC[95:64]\n  3: TMP <- SRC[127:96]\nESAC;\nCASE (COUNT_D) OF\n  0: TMP2[31:0] <- TMP\n     TMP2[127:32] <- DEST[127:32]\n  1: TMP2[63:32] <- TMP\n     TMP2[31:0] <- DEST[31:0]\n     TMP2[127:64] <- DEST[127:64]\n  2: TMP2[95:64] <- TMP\n     TMP2[63:0] <- DEST[63:0]\n     TMP2[127:96] <- DEST[127:96]\n  3: TMP2[127:96] <- TMP\n     TMP2[95:0] <- DEST[95:0]\nESAC;\nIF (ZMASK[0] = 1) THEN DEST[31:0] <- 00000000H\n  ELSE DEST[31:0] <- TMP2[31:0]\nIF (ZMASK[1] = 1) THEN DEST[63:32] <- 00000000H\n  ELSE DEST[63:32] <- TMP2[63:32]\nIF (ZMASK[2] = 1) THEN DEST[95:64] <- 00000000H\n  ELSE DEST[95:64] <- TMP2[95:64]\nIF (ZMASK[3] = 1) THEN DEST[127:96] <- 00000000H\n  ELSE DEST[127:96] <- TMP2[127:96]\nDEST[VLMAX-1:128] (Unmodified)\nVINSERTPS (VEX.128 encoded version)\nIF (SRC = REG) THEN COUNT_S <- imm8[7:6]\n  ELSE COUNT_S <- 0\nCOUNT_D <- imm8[5:4]\nZMASK <- imm8[3:0]\nCASE (COUNT_S) OF\n  0: TMP <- SRC2[31:0]\n  1: TMP <- SRC2[63:32]\n  2: TMP <- SRC2[95:64]\n  3: TMP <- SRC2[127:96]\nESAC;\nCASE (COUNT_D) OF\n  0: TMP2[31:0] <- TMP\n     TMP2[127:32] <- SRC1[127:32]\n  1: TMP2[63:32] <- TMP\n     TMP2[31:0] <- SRC1[31:0]\n     TMP2[127:64] <- SRC1[127:64]\n  2: TMP2[95:64] <- TMP\n     TMP2[63:0] <- SRC1[63:0]\n     TMP2[127:96] <- SRC1[127:96]\n  3: TMP2[127:96] <- TMP\n     TMP2[95:0] <- SRC1[95:0]\nESAC;\nIF (ZMASK[0] = 1) THEN DEST[31:0] <- 00000000H\n  ELSE DEST[31:0] <- TMP2[31:0]\nIF (ZMASK[1] = 1) THEN DEST[63:32] <- 00000000H\n  ELSE DEST[63:32] <- TMP2[63:32]\nIF (ZMASK[2] = 1) THEN DEST[95:64] <- 00000000H\n  ELSE DEST[95:64] <- TMP2[95:64]\nIF (ZMASK[3] = 1) THEN DEST[127:96] <- 00000000H\n  ELSE DEST[127:96] <- TMP2[127:96]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| INSERTPS:| __m128 _mm_insert_ps(__m128 dst, __m128\n|          | src, const int ndx);                   \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 5.\n\n", 
      "mnem": "INSERTPS"
    }, 
    {
      "description": "-R:INS", 
      "mnem": "INSW"
    }, 
    {
      "description": "-R:INT n", 
      "mnem": "INT 3"
    }, 
    {
      "description": "\nINT n/INTO/INT 3 - Call to Interrupt Procedure:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                         \n| CC    | INT 3      | NP   | Valid      | Valid          | Interrupt 3 - trap to debugger.       \n| CD ib | INT imm8   | I    | Valid      | Valid          | Interrupt vector number specified by\n|       |            |      |            |                | immediate byte.                     \n| CE    | INTO       | NP   | Invalid    | Valid          | Interrupt 4 - if overflow flag is 1.  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n| I    | imm8     | NA       | NA       | NA       \n\nDescription:\nThe INT n instruction generates a call to the interrupt or exception handler\nspecified with the destination operand (see the section titled \u201cInterrupts and\nExceptions\u201d in Chapter 6 of the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 1). The destination operand specifies an interrupt vector number\nfrom 0 to 255, encoded as an 8-bit unsigned intermediate value. Each interrupt\nvector number provides an index to a gate descriptor in the IDT. The first 32\ninterrupt vector numbers are reserved by Intel for system use. Some of these\ninterrupts are used for internally generated exceptions.\n\nThe INT n instruction is the general mnemonic for executing a software-generated\ncall to an interrupt handler. The INTO instruction is a special mnemonic for\ncalling overflow exception (#OF), interrupt vector number 4. The overflow interrupt\nchecks the OF flag in the EFLAGS register and calls the overflow interrupt handler\nif the OF flag is set to 1. (The INTO instruction cannot be used in 64-bit mode.)\n\nThe INT 3 instruction generates a special one byte opcode (CC) that is intended\nfor calling the debug exception handler. (This one byte form is valuable because\nit can be used to replace the first byte of any instruction with a breakpoint,\nincluding other one byte instructions, without over-writing other code). To\nfurther support its function as a debug breakpoint, the interrupt generated\nwith the CC opcode also differs from the regular software interrupts as follows:\n\n - Interrupt redirection does not happen when in VME mode; the interrupt is handled\nby a protected-mode handler.\n - The virtual-8086 mode IOPL checks do not occur. The interrupt is taken without\nfaulting at any IOPL level.\n\nNote that the \u201cnormal\u201d 2-byte opcode for INT 3 (CD03) does not have these special\nfeatures. Intel and Microsoft assemblers will not generate the CD03 opcode from\nany mnemonic, but this opcode can be created by direct numeric code definition\nor by self-modifying code.\n\nThe action of the INT n instruction (including the INTO and INT 3 instructions)\nis similar to that of a far call made with the CALL instruction. The primary\ndifference is that with the INT n instruction, the EFLAGS register is pushed\nonto the stack before the return address. (The return address is a far address\nconsisting of the current values of the CS and EIP registers.) Returns from\ninterrupt procedures are handled with the IRET instruction, which pops the EFLAGS\ninformation and return address from the stack.\n\nThe interrupt vector number specifies an interrupt descriptor in the interrupt\ndescriptor table (IDT); that is, it provides index into the IDT. The selected\ninterrupt descriptor in turn contains a pointer to an interrupt or exception\nhandler procedure. In protected mode, the IDT contains an array of 8-byte descriptors,\neach of which is an interrupt gate, trap gate, or task gate. In real-address\nmode, the IDT is an array of 4-byte far pointers (2-byte code segment selector\nand a 2-byte instruction pointer), each of which point directly to a procedure\nin the selected segment. (Note that in real-address mode, the IDT is called\nthe interrupt vector table, and its pointers are called interrupt vectors.)\n\nThe following decision table indicates which action in the lower portion of\nthe table is taken given the conditions in the upper portion of the table. Each\nY in the lower section of the decision table represents a procedure defined\nin\n\nthe \u201cOperation\u201d section for this instruction (except #GP).\n\n\nTable 3-61. Decision Table:\n| PE                                                            | 0| 1      | 1       | 1                      | 1                      | 1                      | 1                      | 1                      \n| VM                                                            | -| -      | -       | -                      | -                      | 0                      | 1                      | 1                      \n| IOPL                                                          | -| -      | -       | -                      | -                      | -                      | <3                     | =3                     \n| DPL/CPL RELATIONSHIP                                          | -| DPL<CPL| -       | DPL>CPL                | DPL=CPL or C           | DPL<CPL & NC           | -                      | -                      \n| INTERRUPT TYPE                                                | -| S/W    | -       | -                      | -                      | -                      | -                      | -                      \n| GATE TYPE REAL-ADDRESS-MODE PROTECTED-MODE                    | Y| Y Y    | Task Y Y| Trap or Interrupt Y Y Y| Trap or Interrupt Y Y Y| Trap or Interrupt Y Y Y| Trap or Interrupt Y Y Y| Trap or Interrupt Y Y Y\n| TRAP-OR-INTERRUPTGATE INTER-PRIVILEGE-LEVELINTERRUPT          |  |        |         |                        |                        |                        |                        |                        \n| INTRA-PRIVILEGE-LEVELINTERRUPT INTERRUPT-FROMVIRTUAL-8086-MODE|  |        |         |                        |                        |                        |                        |                        \n| TASK-GATE #GP                                                 |  |        |         |                        |                        |                        |                        |                        \nNotes: \n\n| \u2212| Don't Care.                         \n| Y| Yes, action taken. Action not taken.\nWhen the processor is executing in virtual-8086 mode, the IOPL determines the\naction of the INT n instruction. If the IOPL is less than 3, the processor generates\na #GP(selector) exception; if the IOPL is 3, the processor executes a protected\nmode interrupt to privilege level 0. The interrupt gate's DPL must be set to\n3 and the target CPL of the interrupt handler procedure must be 0 to execute\nthe protected mode interrupt to privilege level 0.\n\nThe interrupt descriptor table register (IDTR) specifies the base linear address\nand limit of the IDT. The initial base address value of the IDTR after the processor\nis powered up or reset is 0.\n\nOperation:\n\nThe following operational description applies not only to the INT n and INTO instructions, but also to external inter-\nrupts, nonmaskable interrupts (NMIs), and exceptions. Some of these events push onto the stack an error code.\nThe operational description specifies numerous checks whose failure may result in delivery of a nested exception.\nIn these cases, the original event is not delivered.\nThe operational description specifies the error code delivered by any nested exception. In some cases, the error\ncode is specified with a pseudofunction error_code(num,idt,ext), where idt and ext are bit values. The pseudofunc-\ntion produces an error code as follows: (1) if idt is 0, the error code is (num & FCH) | ext; (2) if idt is 1, the error\ncode is (num \u00ab 3) | 2 | ext.\nIn many cases, the pseudofunction error_code is invoked with a pseudovariable EXT. The value of EXT depends on\nthe nature of the event whose delivery encountered a nested exception: if that event is a software interrupt, EXT\nis 0; otherwise, EXT is 1.\nIF PE = 0\n  THEN\n     GOTO REAL-ADDRESS-MODE;\n  ELSE (* PE = 1 *)\n     IF (VM = 1 and IOPL < 3 AND INT n)\n       THEN\n          #GP(0); (* Bit 0 of error code is 0 because INT n *)\n       ELSE (* Protected mode, IA-32e mode, or virtual-8086 mode interrupt *)\n          IF (IA32_EFER.LMA = 0)\n             THEN (* Protected mode, or virtual-8086 mode interrupt *)\n               GOTO PROTECTED-MODE;\n          ELSE (* IA-32e mode interrupt *)\n             GOTO IA-32e-MODE;\n          FI;\n     FI;\nFI;\nREAL-ADDRESS-MODE:\n  IF ((vector_number \u00ab 2) + 3) is not within IDT limit\n     THEN #GP; FI;\n  IF stack not large enough for a 6-byte return information\n     THEN #SS; FI;\n  Push (EFLAGS[15:0]);\n  IF <- 0; (* Clear interrupt flag *)\n  TF <- 0; (* Clear trap flag *)\n  AC <- 0; (* Clear AC flag *)\n  Push(CS);\n  Push(IP);\n  (* No error codes are pushed in real-address mode*)\n  CS <- IDT(Descriptor (vector_number \u00ab 2), selector));\n  EIP <- IDT(Descriptor (vector_number \u00ab 2), offset)); (* 16 bit offset AND 0000FFFFH *)\nEND;\nPROTECTED-MODE:\n  IF ((vector_number \u00ab 3) + 7) is not within IDT limits\n  or selected IDT descriptor is not an interrupt-, trap-, or task-gate type\n     THEN #GP(error_code(vector_number,1,EXT)); FI;\n     (* idt operand to error_code set because vector is used *)\n  IF software interrupt (* Generated by INT n, INT3, or INTO *)\n     THEN\n       IF gate DPL < CPL (* PE = 1, DPL < CPL, software interrupt *)\n          THEN #GP(error_code(vector_number,1,0)); FI;\n          (* idt operand to error_code set because vector is used *)\n          (* ext operand to error_code is 0 because INT n, INT3, or INTO*)\n  FI;\n  IF gate not present\n     THEN #NP(error_code(vector_number,1,EXT)); FI;\n     (* idt operand to error_code set because vector is used *)\n  IF task gate (* Specified in the selected interrupt table descriptor *)\n     THEN GOTO TASK-GATE;\n     ELSE GOTO TRAP-OR-INTERRUPT-GATE; (* PE = 1, trap/interrupt gate *)\n  FI;\nEND;\nIA-32e-MODE:\n  IF INTO and CS.L = 1 (64-bit mode)\n     THEN #UD;\n  FI;\n  IF ((vector_number \u00ab 4) + 15) is not in IDT limits\n  or selected IDT descriptor is not an interrupt-, or trap-gate type\n     THEN #GP(error_code(vector_number,1,EXT));\n     (* idt operand to error_code set because vector is used *)\n  FI;\n  IF software interrupt (* Generated by INT n, INT 3, or INTO *)\n     THEN\n       IF gate DPL < CPL (* PE = 1, DPL < CPL, software interrupt *)\n          THEN #GP(error_code(vector_number,1,0));\n          (* idt operand to error_code set because vector is used *)\n          (* ext operand to error_code is 0 because INT n, INT3, or INTO*)\n       FI;\n  FI;\n  IF gate not present\n     THEN #NP(error_code(vector_number,1,EXT));\n     (* idt operand to error_code set because vector is used *)\n  FI;\n  GOTO TRAP-OR-INTERRUPT-GATE; (* Trap/interrupt gate *)\nEND;\nTASK-GATE: (* PE = 1, task gate *)\n  Read TSS selector in task gate (IDT descriptor);\n     IF local/global bit is set to local or index not within GDT limits\n       THEN #GP(error_code(TSS selector,0,EXT)); FI;\n       (* idt operand to error_code is 0 because selector is used *)\n     Access TSS descriptor in GDT;\n     IF TSS descriptor specifies that the TSS is busy (low-order 5 bits set to 00001)\n       THEN #GP(TSS selector,0,EXT)); FI;\n       (* idt operand to error_code is 0 because selector is used *)\n     IF TSS not present\n       THEN #NP(TSS selector,0,EXT)); FI;\n       (* idt operand to error_code is 0 because selector is used *)\n  SWITCH-TASKS (with nesting) to TSS;\n  IF interrupt caused by fault with error code\n     THEN\n       IF stack limit does not allow push of error code\n          THEN #SS(EXT); FI;\n       Push(error code);\n  FI;\n  IF EIP not within code segment limit\n     THEN #GP(EXT); FI;\nEND;\nTRAP-OR-INTERRUPT-GATE:\n  Read new code-segment selector for trap or interrupt gate (IDT descriptor);\n  IF new code-segment selector is NULL\n     THEN #GP(EXT); FI; (* Error code contains NULL selector *)\n  IF new code-segment selector is not within its descriptor table limits\n     THEN #GP(error_code(new code-segment selector,0,EXT)); FI;\n     (* idt operand to error_code is 0 because selector is used *)\n  Read descriptor referenced by new code-segment selector;\n  IF descriptor does not indicate a code segment or new code-segment DPL > CPL\n     THEN #GP(error_code(new code-segment selector,0,EXT)); FI;\n     (* idt operand to error_code is 0 because selector is used *)\n  IF new code-segment descriptor is not present,\n     THEN #NP(error_code(new code-segment selector,0,EXT)); FI;\n     (* idt operand to error_code is 0 because selector is used *)\n  IF new code segment is non-conforming with DPL < CPL\n     THEN\n       IF VM = 0\n          THEN\n             GOTO INTER-PRIVILEGE-LEVEL-INTERRUPT;\n             (* PE = 1, VM = 0, interrupt or trap gate, nonconforming code segment,\n             DPL < CPL *)\n          ELSE (* VM = 1 *)\n             IF new code-segment DPL != 0\n               THEN #GP(error_code(new code-segment selector,0,EXT));\n               (* idt operand to error_code is 0 because selector is used *)\n             GOTO INTERRUPT-FROM-VIRTUAL-8086-MODE; FI;\n             (* PE = 1, interrupt or trap gate, DPL < CPL, VM = 1 *)\n       FI;\n     ELSE (* PE = 1, interrupt or trap gate, DPL \u2265 CPL *)\n       IF VM = 1\n          THEN #GP(error_code(new code-segment selector,0,EXT));\n          (* idt operand to error_code is 0 because selector is used *)\n       IF new code segment is conforming or new code-segment DPL = CPL\n          THEN\n             GOTO INTRA-PRIVILEGE-LEVEL-INTERRUPT;\n          ELSE (* PE = 1, interrupt or trap gate, nonconforming code segment, DPL > CPL *)\n             #GP(error_code(new code-segment selector,0,EXT));\n             (* idt operand to error_code is 0 because selector is used *)\n       FI;\n  FI;\nEND;\nINTER-PRIVILEGE-LEVEL-INTERRUPT:\n  (* PE = 1, interrupt or trap gate, non-conforming code segment, DPL < CPL *)\n  IF (IA32_EFER.LMA = 0) (* Not IA-32e mode *)\n     THEN\n     (* Identify stack-segment selector for new privilege level in current TSS *)\n       IF current TSS is 32-bit\n          THEN\n             TSSstackAddress <- (new code-segment DPL \u00ab 3) + 4;\n             IF (TSSstackAddress + 5) > current TSS limit\n               THEN #TS(error_code(current TSS selector,0,EXT)); FI;\n               (* idt operand to error_code is 0 because selector is used *)\n             NewSS <- 2 bytes loaded from (TSS base + TSSstackAddress + 4);\n             NewESP <- 4 bytes loaded from (TSS base + TSSstackAddress);\n          ELSE\n             TSSstackAddress <- (new code-segment DPL \u00ab 2) + 2\n             IF (TSSstackAddress + 3) > current TSS limit\n               THEN #TS(error_code(current TSS selector,0,EXT)); FI;\n               (* idt operand to error_code is 0 because selector is used *)\n             NewSS <- 2 bytes loaded from (TSS base + TSSstackAddress + 2);\n             NewESP <- 2 bytes loaded from (TSS base + TSSstackAddress);\n       FI;\n       IF NewSS is NULL\n          THEN #TS(EXT); FI;\n       IF NewSS index is not within its descriptor-table limits\n       or NewSS RPL != new code-segment DPL\n          THEN #TS(error_code(NewSS,0,EXT)); FI;\n          (* idt operand to error_code is 0 because selector is used *)\n       Read new stack-segment descriptor for NewSS in GDT or LDT;\n       IF new stack-segment DPL != new code-segment DPL\n       or new stack-segment Type does not indicate writable data segment\n          THEN #TS(error_code(NewSS,0,EXT)); FI;\n          (* idt operand to error_code is 0 because selector is used *)\n       IF NewSS is not present\n          THEN #SS(error_code(NewSS,0,EXT)); FI;\n          (* idt operand to error_code is 0 because selector is used *)\n     ELSE (* IA-32e mode *)\n       IF IDT-gate IST = 0\n          THEN TSSstackAddress <- (new code-segment DPL \u00ab 3) + 4;\n          ELSE TSSstackAddress <- (IDT gate IST \u00ab 3) + 28;\n       FI;\n       IF (TSSstackAddress + 7) > current TSS limit\n          THEN #TS(error_code(current TSS selector,0,EXT); FI;\n          (* idt operand to error_code is 0 because selector is used *)\n       NewRSP <- 8 bytes loaded from (current TSS base + TSSstackAddress);\n       NewSS <- new code-segment DPL; (* NULL selector with RPL = new CPL *)\n  FI;\n  IF IDT gate is 32-bit\n       THEN\n          IF new stack does not have room for 24 bytes (error code pushed)\n          or 20 bytes (no error code pushed)\n             THEN #SS(error_code(NewSS,0,EXT)); FI;\n             (* idt operand to error_code is 0 because selector is used *)\n       FI\n     ELSE\n       IF IDT gate is 16-bit\n          THEN\n             IF new stack does not have room for 12 bytes (error code pushed)\n             or 10 bytes (no error code pushed);\n               THEN #SS(error_code(NewSS,0,EXT)); FI;\n               (* idt operand to error_code is 0 because selector is used *)\n       ELSE (* 64-bit IDT gate*)\n          IF StackAddress is non-canonical\n             THEN #SS(EXT); FI; (* Error code contains NULL selector *)\n     FI;\n  FI;\n  IF (IA32_EFER.LMA = 0) (* Not IA-32e mode *)\n     THEN\n       IF instruction pointer from IDT gate is not within new code-segment limits\n          THEN #GP(EXT); FI; (* Error code contains NULL selector *)\n       ESP <- NewESP;\n       SS <- NewSS; (* Segment descriptor information also loaded *)\n     ELSE (* IA-32e mode *)\n       IF instruction pointer from IDT gate contains a non-canonical address\n          THEN #GP(EXT); FI; (* Error code contains NULL selector *)\n       RSP <- NewRSP & FFFFFFFFFFFFFFF0H;\n       SS <- NewSS;\n  FI;\n  IF IDT gate is 32-bit\n     THEN\n       CS:EIP <- Gate(CS:EIP); (* Segment descriptor information also loaded *)\n     ELSE\n       IF IDT gate 16-bit\n          THEN\n             CS:IP <- Gate(CS:IP);\n             (* Segment descriptor information also loaded *)\n          ELSE (* 64-bit IDT gate *)\n             CS:RIP <- Gate(CS:RIP);\n             (* Segment descriptor information also loaded *)\n       FI;\n  FI;\n  IF IDT gate is 32-bit\n       THEN\n          Push(far pointer to old stack);\n          (* Old SS and ESP, 3 words padded to 4 *)\n          Push(EFLAGS);\n          Push(far pointer to return instruction);\n          (* Old CS and EIP, 3 words padded to 4 *)\n          Push(ErrorCode); (* If needed, 4 bytes *)\n       ELSE\n          IF IDT gate 16-bit\n             THEN\n               Push(far pointer to old stack);\n               (* Old SS and SP, 2 words *)\n               Push(EFLAGS(15-0]);\n               Push(far pointer to return instruction);\n               (* Old CS and IP, 2 words *)\n               Push(ErrorCode); (* If needed, 2 bytes *)\n             ELSE (* 64-bit IDT gate *)\n               Push(far pointer to old stack);\n               (* Old SS and SP, each an 8-byte push *)\n               Push(RFLAGS); (* 8-byte push *)\n               Push(far pointer to return instruction);\n               (* Old CS and RIP, each an 8-byte push *)\n               Push(ErrorCode); (* If needed, 8-bytes *)\n       FI;\n  FI;\n  CPL <- new code-segment DPL;\n  CS(RPL) <- CPL;\n  IF IDT gate is interrupt gate\n     THEN IF <- 0 (* Interrupt flag set to 0, interrupts disabled *); FI;\n  TF <- 0;\n  VM <- 0;\n  RF <- 0;\n  NT <- 0;\nEND;\nINTERRUPT-FROM-VIRTUAL-8086-MODE:\n  (* Identify stack-segment selector for privilege level 0 in current TSS *)\n  IF current TSS is 32-bit\n     THEN\n       IF TSS limit < 9\n          THEN #TS(error_code(current TSS selector,0,EXT)); FI;\n          (* idt operand to error_code is 0 because selector is used *)\n       NewSS <- 2 bytes loaded from (current TSS base + 8);\n       NewESP <- 4 bytes loaded from (current TSS base + 4);\n     ELSE (* current TSS is 16-bit *)\n       IF TSS limit < 5\n          THEN #TS(error_code(current TSS selector,0,EXT)); FI;\n          (* idt operand to error_code is 0 because selector is used *)\n       NewSS <- 2 bytes loaded from (current TSS base + 4);\n       NewESP <- 2 bytes loaded from (current TSS base + 2);\n  FI;\n  IF NewSS is NULL\n     THEN #TS(EXT); FI; (* Error code contains NULL selector *)\n  IF NewSS index is not within its descriptor table limits\n  or NewSS RPL != 0\n     THEN #TS(error_code(NewSS,0,EXT)); FI;\n     (* idt operand to error_code is 0 because selector is used *)\n  Read new stack-segment descriptor for NewSS in GDT or LDT;\n  IF new stack-segment DPL != 0 or stack segment does not indicate writable data segment\n     THEN #TS(error_code(NewSS,0,EXT)); FI;\n     (* idt operand to error_code is 0 because selector is used *)\n  IF new stack segment not present\n     THEN #SS(error_code(NewSS,0,EXT)); FI;\n     (* idt operand to error_code is 0 because selector is used *)\n  IF IDT gate is 32-bit\n     THEN\n       IF new stack does not have room for 40 bytes (error code pushed)\n       or 36 bytes (no error code pushed)\n          THEN #SS(error_code(NewSS,0,EXT)); FI;\n          (* idt operand to error_code is 0 because selector is used *)\n     ELSE (* IDT gate is 16-bit)\n       IF new stack does not have room for 20 bytes (error code pushed)\n       or 18 bytes (no error code pushed)\n          THEN #SS(error_code(NewSS,0,EXT)); FI;\n          (* idt operand to error_code is 0 because selector is used *)\n  FI;\n  IF instruction pointer from IDT gate is not within new code-segment limits\n     THEN #GP(EXT); FI; (* Error code contains NULL selector *)\n  tempEFLAGS <- EFLAGS;\n  VM <- 0;\n  TF <- 0;\n  RF <- 0;\n  NT <- 0;\n  IF service through interrupt gate\n     THEN IF = 0; FI;\n  TempSS <- SS;\n  TempESP <- ESP;\n  SS <- NewSS;\n  ESP <- NewESP;\n  (* Following pushes are 16 bits for 16-bit IDT gates and 32 bits for 32-bit IDT gates;\n  Segment selector pushes in 32-bit mode are padded to two words *)\n  Push(GS);\n  Push(FS);\n  Push(DS);\n  Push(ES);\n  Push(TempSS);\n  Push(TempESP);\n  Push(TempEFlags);\n  Push(CS);\n  Push(EIP);\n  GS <- 0; (* Segment registers made NULL, invalid for use in protected mode *)\n  FS <- 0;\n  DS <- 0;\n  ES <- 0;\n  CS:IP <- Gate(CS); (* Segment descriptor information also loaded *)\n  IF OperandSize = 32\n     THEN\n       EIP <- Gate(instruction pointer);\n     ELSE (* OperandSize is 16 *)\n       EIP <- Gate(instruction pointer) AND 0000FFFFH;\n  FI;\n  (* Start execution of new routine in Protected Mode *)\nEND;\nINTRA-PRIVILEGE-LEVEL-INTERRUPT:\n  (* PE = 1, DPL = CPL or conforming segment *)\n  IF IA32_EFER.LMA = 1 (* IA-32e mode *)\n     IF IDT-descriptor IST != 0\n       THEN\n          TSSstackAddress <- (IDT-descriptor IST \u00ab 3) + 28;\n          IF (TSSstackAddress + 7) > TSS limit\n             THEN #TS(error_code(current TSS selector,0,EXT)); FI;\n             (* idt operand to error_code is 0 because selector is used *)\n          NewRSP <- 8 bytes loaded from (current TSS base + TSSstackAddress);\n  FI;\n  IF 32-bit gate (* implies IA32_EFER.LMA = 0 *)\n     THEN\n       IF current stack does not have room for 16 bytes (error code pushed)\n       or 12 bytes (no error code pushed)\n          THEN #SS(EXT); FI; (* Error code contains NULL selector *)\n     ELSE IF 16-bit gate (* implies IA32_EFER.LMA = 0 *)\n       IF current stack does not have room for 8 bytes (error code pushed)\n       or 6 bytes (no error code pushed)\n          THEN #SS(EXT); FI; (* Error code contains NULL selector *)\n     ELSE (* IA32_EFER.LMA = 1, 64-bit gate*)\n          IF NewRSP contains a non-canonical address\n             THEN #SS(EXT); (* Error code contains NULL selector *)\n     FI;\n  FI;\n  IF (IA32_EFER.LMA = 0) (* Not IA-32e mode *)\n     THEN\n       IF instruction pointer from IDT gate is not within new code-segment limit\n          THEN #GP(EXT); FI; (* Error code contains NULL selector *)\n     ELSE\n       IF instruction pointer from IDT gate contains a non-canonical address\n          THEN #GP(EXT); FI; (* Error code contains NULL selector *)\n       RSP <- NewRSP & FFFFFFFFFFFFFFF0H;\n  FI;\n  IF IDT gate is 32-bit (* implies IA32_EFER.LMA = 0 *)\n     THEN\n       Push (EFLAGS);\n       Push (far pointer to return instruction); (* 3 words padded to 4 *)\n       CS:EIP <- Gate(CS:EIP); (* Segment descriptor information also loaded *)\n       Push (ErrorCode); (* If any *)\n     ELSE\n       IF IDT gate is 16-bit (* implies IA32_EFER.LMA = 0 *)\n          THEN\n             Push (FLAGS);\n             Push (far pointer to return location); (* 2 words *)\n             CS:IP <- Gate(CS:IP);\n             (* Segment descriptor information also loaded *)\n             Push (ErrorCode); (* If any *)\n          ELSE (* IA32_EFER.LMA = 1, 64-bit gate*)\n             Push(far pointer to old stack);\n             (* Old SS and SP, each an 8-byte push *)\n             Push(RFLAGS); (* 8-byte push *)\n             Push(far pointer to return instruction);\n             (* Old CS and RIP, each an 8-byte push *)\n             Push(ErrorCode); (* If needed, 8 bytes *)\n             CS:RIP <- GATE(CS:RIP);\n             (* Segment descriptor information also loaded *)\n       FI;\n  FI;\n  CS(RPL) <- CPL;\n  IF IDT gate is interrupt gate\n     THEN IF <- 0; FI; (* Interrupt flag set to 0; interrupts disabled *)\n  TF <- 0;\n  NT <- 0;\n  VM <- 0;\n  RF <- 0;\nEND;\n\nFlags Affected:\nThe EFLAGS register is pushed onto the stack. The IF, TF, NT, AC, RF, and VM\nflags may be cleared, depending on the mode of operation of the processor when\nthe INT instruction is executed (see the \u201cOperation\u201d section). If the interrupt\nuses a task gate, any flags may be set or cleared, controlled by the EFLAGS\nimage in the new task's TSS.\n\n\nProtected Mode Exceptions:\n| #GP(error_code)| If the instruction pointer in the IDT          \n|                | or in the interrupt-, trap-, or task           \n|                | gate is beyond the code segment limits.        \n|                | If the segment selector in the interrupt-,     \n|                | trap-, or task gate is NULL. If an interrupt-, \n|                | trap-, or task gate, code segment, or          \n|                | TSS segment selector index is outside          \n|                | its descriptor table limits. If the            \n|                | interrupt vector number is outside the         \n|                | IDT limits. If an IDT descriptor is            \n|                | not an interrupt-, trap-, or task-descriptor.  \n|                | If an interrupt is generated by the            \n|                | INT n, INT 3, or INTO instruction and          \n|                | the DPL of an interrupt-, trap-, or            \n|                | task-descriptor is less than the CPL.          \n|                | If the segment selector in an interrupt-       \n|                | or trap-gate does not point to a segment       \n|                | descriptor for a code segment. If the          \n|                | segment selector for a TSS has its local/global\n|                | bit set for local. If a TSS segment            \n|                | descriptor specifies that the TSS is           \n|                | busy or not available.                         \n| #SS(error_code)| If pushing the return address, flags,          \n|                | or error code onto the stack exceeds           \n|                | the bounds of the stack segment and            \n|                | no stack switch occurs. If the SS register     \n|                | is being loaded and the segment pointed        \n|                | to is marked not present.                      \nIf pushing the return address, flags, error code, or stack segment pointer exceeds\nthe bounds of the new stack segment when a stack switch occurs.\n\n| #NP(error_code)| If code segment, interrupt-, trap-,          \n|                | or task gate, or TSS is not present.         \n| #TS(error_code)| If the RPL of the stack segment selector     \n|                | in the TSS is not equal to the DPL of        \n|                | the code segment being accessed by the       \n|                | interrupt or trap gate. If DPL of the        \n|                | stack segment descriptor pointed to          \n|                | by the stack segment selector in the         \n|                | TSS is not equal to the DPL of the code      \n|                | segment descriptor for the interrupt         \n|                | or trap gate. If the stack segment selector  \n|                | in the TSS is NULL. If the stack segment     \n|                | for the TSS is not a writable data segment.  \n|                | If segment-selector index for stack          \n|                | segment is outside descriptor table          \n|                | limits.                                      \n| #PF(fault-code)| If a page fault occurs.                      \n| #UD            | If the LOCK prefix is used.                  \n| #AC(EXT)       | If alignment checking is enabled, the        \n|                | gate DPL is 3, and a stack push is unaligned.\n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address \n|    | is outside the CS, DS, ES, FS, or GS  \n|    | segment limit. If the interrupt vector\n|    | number is outside the IDT limits.     \n| #SS| If stack limit violation on push. If  \n|    | pushing the return address, flags, or \n|    | error code onto the stack exceeds the \n|    | bounds of the stack segment.          \n| #UD| If the LOCK prefix is used.           \n\nVirtual-8086 Mode Exceptions:\n| #GP(error_code)| (For INT n, INTO, or BOUND instruction)         \n|                | If the IOPL is less than 3 or the DPL           \n|                | of the interrupt, trap-, or task-gate           \n|                | descriptor is not equal to 3. If the            \n|                | instruction pointer in the IDT or in            \n|                | the interrupt-, trap-, or task gate             \n|                | is beyond the code segment limits. If           \n|                | the segment selector in the interrupt-,         \n|                | trap-, or task gate is NULL. If a interrupt-,   \n|                | trap-, or task gate, code segment, or           \n|                | TSS segment selector index is outside           \n|                | its descriptor table limits. If the             \n|                | interrupt vector number is outside the          \n|                | IDT limits. If an IDT descriptor is             \n|                | not an interrupt-, trap-, or task-descriptor.   \n|                | If an interrupt is generated by the             \n|                | INT n instruction and the DPL of an             \n|                | interrupt-, trap-, or taskdescriptor            \n|                | is less than the CPL. If the segment            \n|                | selector in an interrupt- or trap-gate          \n|                | does not point to a segment descriptor          \n|                | for a code segment. If the segment selector     \n|                | for a TSS has its local/global bit set          \n|                | for local.                                      \n| #SS(error_code)| If the SS register is being loaded and          \n|                | the segment pointed to is marked not            \n|                | present. If pushing the return address,         \n|                | flags, error code, stack segment pointer,       \n|                | or data segments exceeds the bounds             \n|                | of the stack segment.                           \n| #NP(error_code)| If code segment, interrupt-, trap-,             \n|                | or task gate, or TSS is not present.            \n| #TS(error_code)| If the RPL of the stack segment selector        \n|                | in the TSS is not equal to the DPL of           \n|                | the code segment being accessed by the          \n|                | interrupt or trap gate. If DPL of the           \n|                | stack segment descriptor for the TSS's          \n|                | stack segment is not equal to the DPL           \n|                | of the code segment descriptor for the          \n|                | interrupt or trap gate. If the stack            \n|                | segment selector in the TSS is NULL.            \n|                | If the stack segment for the TSS is             \n|                | not a writable data segment. If segment-selector\n|                | index for stack segment is outside descriptor   \n|                | table limits.                                   \n| #PF(fault-code)| If a page fault occurs.                         \n| #BP            | If the INT 3 instruction is executed.           \n| #OF            | If the INTO instruction is executed             \n|                | and the OF flag is set.                         \n| #UD            | If the LOCK prefix is used.                     \n| #AC(EXT)       | If alignment checking is enabled, the           \n|                | gate DPL is 3, and a stack push is unaligned.   \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(error_code)| If the instruction pointer in the 64-bit     \n|                | interrupt gate or 64-bit trap gate is        \n|                | non-canonical. If the segment selector       \n|                | in the 64-bit interrupt or trap gate         \n|                | is NULL. If the interrupt vector number      \n|                | is outside the IDT limits. If the interrupt  \n|                | vector number points to a gate which         \n|                | is in non-canonical space. If the interrupt  \n|                | vector number points to a descriptor         \n|                | which is not a 64-bit interrupt gate         \n|                | or 64bit trap gate. If the descriptor        \n|                | pointed to by the gate selector is outside   \n|                | the descriptor table limit. If the descriptor\n|                | pointed to by the gate selector is in        \n|                | non-canonical space. If the descriptor       \n|                | pointed to by the gate selector is not       \n|                | a code segment. If the descriptor pointed    \n|                | to by the gate selector doesn't have         \n|                | the L-bit set, or has both the Lbit          \n|                | and D-bit set. If the descriptor pointed     \n|                | to by the gate selector has DPL > CPL.       \n| #SS(error_code)| If a push of the old EFLAGS, CS selector,    \n|                | EIP, or error code is in non-canonical       \n|                | space with no stack switch. If a push        \n|                | of the old SS selector, ESP, EFLAGS,         \n|                | CS selector, EIP, or error code is in        \n|                | non-canonical space on a stack switch        \n|                | (either CPL change or no-CPL with IST).      \n| #NP(error_code)| If the 64-bit interrupt-gate, 64-bit         \n|                | trap-gate, or code segment is not present.   \n| #TS(error_code)| If an attempt to load RSP from the TSS       \n|                | causes an access to non-canonical space.     \n|                | If the RSP from the TSS is outside descriptor\n|                | table limits.                                \n| #PF(fault-code)| If a page fault occurs.                      \n| #UD            | If the LOCK prefix is used.                  \n| #AC(EXT)       | If alignment checking is enabled, the        \n|                | gate DPL is 3, and a stack push is unaligned.\n", 
      "mnem": "INT n"
    }, 
    {
      "description": "-R:INT n", 
      "mnem": "INTO"
    }, 
    {
      "description": "\nINVD - Invalidate Internal Caches:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                             \n| 0F 08 | INVD       | NP   | Valid      | Valid          | Flush internal caches; initiate flushing\n|       |            |      |            |                | of external caches.                     \nNotes: * See the IA-32 Architecture Compatibility section below.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nInvalidates (flushes) the processor's internal caches and issues a special-function\nbus cycle that directs external caches to also flush themselves. Data held in\ninternal caches is not written back to main memory.\n\nAfter executing this instruction, the processor does not wait for the external\ncaches to complete their flushing operation before proceeding with instruction\nexecution. It is the responsibility of hardware to respond to the cache flush\nsignal.\n\nThe INVD instruction is a privileged instruction. When the processor is running\nin protected mode, the CPL of a program or procedure must be 0 to execute this\ninstruction.\n\nThe INVD instruction may be used when the cache is used as temporary memory\nand the cache contents need to be invalidated rather than written back to memory.\nWhen the cache is used as temporary memory, no external device should be actively\nwriting data to main memory.\n\nUse this instruction with care. Data cached internally and not written back\nto main memory will be lost. Note that any data from an external device to main\nmemory (for example, via a PCIWrite) can be temporarily stored in the caches;\nthese data can be lost when an INVD instruction is executed. Unless there is\na specific requirement or benefit to flushing caches without writing back modified\ncache lines (for example, temporary memory, testing, or fault recovery where\ncache coherency with main memory is not a concern), software should instead\nuse the WBINVD instruction.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nIA-32 Architecture Compatibility:\nThe INVD instruction is implementation dependent; it may be implemented differently\non different families of Intel 64 or IA-32 processors. This instruction is not\nsupported on IA-32 processors earlier than the Intel486 processor.\n\nOperation:\n\nFlush(InternalCaches);\nSignalFlush(ExternalCaches);\nContinue (* Continue execution *)\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the current privilege level is not\n|       | 0.                                   \n| #UD   | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| The INVD instruction cannot be executed\n|       | in virtual-8086 mode.                  \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "INVD"
    }, 
    {
      "description": "\nINVLPG - Invalidate TLB Entry:\n| Opcode | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                \n| 0F 01/7| INVLPG m   | M    | Valid      | Valid          | Invalidate TLB Entry for page that contains\n|        |            |      |            |                | m.                                         \nNotes: * See the IA-32 Architecture Compatibility section below.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nInvalidates (flushes) the translation lookaside buffer (TLB) entry specified\nwith the source operand. The source operand is a memory address. The processor\ndetermines the page that contains that address and flushes the TLB entry for\nthat page.\n\nThe INVLPG instruction is a privileged instruction. When the processor is running\nin protected mode, the CPL must be 0 to execute this instruction.\n\nThe INVLPG instruction normally flushes the TLB entry only for the specified\npage; however, in some cases, it may flush more entries, even the entire TLB.\nThe instruction is guaranteed to invalidates only TLB entries associated with\nthe current PCID. (If PCIDs are disabled  -  CR4.PCIDE = 0  -  the current PCID\nis 000H.) The instruction also invalidates any global TLB entries for the specified\npage, regardless of PCID.\n\nFor more details on operations that flush the TLB, see \u201cMOV - Move to/from Control\nRegisters\u201d and Section 4.10.4.1, \u201cOperations that Invalidate TLBs and Paging-Structure\nCaches,\u201d of the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 3A.\n\nThis instruction's operation is the same in all non-64-bit modes. It also operates\nthe same in 64-bit mode, except if the memory address is in non-canonical form.\nIn this case, INVLPG is the same as a NOP.\n\n\nIA-32 Architecture Compatibility:\nThe INVLPG instruction is implementation dependent, and its function may be\nimplemented differently on different families of Intel 64 or IA-32 processors.\nThis instruction is not supported on IA-32 processors earlier than the Intel486\nprocessor.\n\nOperation:\n\nFlush(RelevantTLBEntries);\nContinue; (* Continue execution *)\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the current privilege level is not    \n|       | 0.                                       \n| #UD   | Operand is a register. If the LOCK prefix\n|       | is used.                                 \n\nReal-Address Mode Exceptions:\n| #UD| Operand is a register. If the LOCK prefix\n|    | is used.                                 \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| The INVLPG instruction cannot be executed\n|       | at the virtual-8086 mode.                \n\n64-Bit Mode Exceptions:\n| #GP(0)| If the current privilege level is not    \n|       | 0.                                       \n| #UD   | Operand is a register. If the LOCK prefix\n|       | is used.                                 \n", 
      "mnem": "INVLPG"
    }, 
    {
      "description": "\nINVPCID - Invalidate Process-Context Identifier:\n| Opcode/Instruction              | Op/En| 64/32bit Mode| CPUID Feature Flag| Description                                  \n| 66 0F 38 82 /r INVPCID r32, m128| RM   | NE/V         | INVPCID           | Invalidates entries in the TLBs and          \n|                                 |      |              |                   | paging-structure caches based on invalidation\n|                                 |      |              |                   | type in r32 and descriptor in m128.          \n| 66 0F 38 82 /r INVPCID r64, m128| RM   | V/NE         | INVPCID           | Invalidates entries in the TLBs and          \n|                                 |      |              |                   | paging-structure caches based on invalidation\n|                                 |      |              |                   | type in r64 and descriptor in m128.          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (R)| ModRM:r/m (R)| NA       | NA       \n\nDescription:\nInvalidates mappings in the translation lookaside buffers (TLBs) and paging-structure\ncaches based on processcontext identifier (PCID). (See Section 4.10, \u201cCaching\nTranslation Information,\u201d in Intel 64 and IA-32 Architecture Software Developer's\nManual, Volume 3A.) Invalidation is based on the INVPCID type specified in the\nregister operand and the INVPCID descriptor specified in the memory operand.\n\nOutside 64-bit mode, the register operand is always 32 bits, regardless of the\nvalue of CS.D. In 64-bit mode the register operand has 64 bits.\n\nThere are four INVPCID types currently defined:\n\n - Individual-address invalidation: If the INVPCID type is 0, the logical processor\ninvalidates mappings - except global translations - for the linear address and PCID\nspecified in the INVPCID descriptor. In some cases, the instruction may invalidate\nglobal translations or mappings for other linear addresses (or other PCIDs)\nas well.\n - Single-context invalidation: If the INVPCID type is 1, the logical processor\ninvalidates all mappings - except global translations - associated with the PCID\nspecified in the INVPCID descriptor. In some cases, the instruction may invalidate\nglobal translations or mappings for other PCIDs as well.\n - All-context invalidation, including global translations: If the INVPCID type\nis 2, the logical processor invalidates all mappings - including global translations - associated\nwith any PCID.\n - All-context invalidation: If the INVPCID type is 3, the logical processor invalidates\nall mappings - except global translations - associated with any PCID. In some case,\nthe instruction may invalidate global translations as well.\n\nThe INVPCID descriptor comprises 128 bits and consists of a PCID and a linear\naddress as shown in Figure 3-23. For INVPCID type 0, the processor uses the\nfull 64 bits of the linear address even outside 64-bit mode; the linear address\nis not used for other INVPCID types.\n\n| 127 Linear Address| 6463 Reserved (must be zero) Figure| 1211 PCID INVPCID Descriptor| 0\n|                   | 3-23.                              |                             |  \nIf CR4.PCIDE = 0, a logical processor does not cache information for any PCID\nother than 000H. In this case, executions with INVPCID types 0 and 1 are allowed\nonly if the PCID specified in the INVPCID descriptor is 000H;\n\nexecutions with INVPCID types 2 and 3 invalidate mappings only for PCID 000H.\nNote that CR4.PCIDE must be 0 outside 64-bit mode (see Chapter 4.10.1, \u201cProcess-Context\nIdentifiers (PCIDs)\u201a\u201d of the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A).\n\nOperation:\n\nINVPCID_TYPE <- value of register operand;\nINVPCID_DESC <- value of memory operand;\nCASE INVPCID_TYPE OF\n  0:\n     PCID <- INVPCID_DESC[11:0];\n     L_ADDR <- INVPCID_DESC[127:64];\n     Invalidate mappings for L_ADDR associated with PCID except global translations;\n     BREAK;\n  1:\n     PCID <- INVPCID_DESC[11:0];\n     Invalidate all mappings associated with PCID except global translations;\n     BREAK;\n  2:\n     Invalidate all mappings for all PCIDs, including global translations;\n     BREAK;\n  3:\n     Invalidate all mappings for all PCIDs except global translations;\n     BREAK;\nESAC;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| INVPCID:| void _invpcid(unsigned __int32 type,\n|         | void * descriptor);                 \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the current privilege level is not     \n|                | 0. If the memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS      \n|                | segment limit. If the DS, ES, FS, or      \n|                | GS register contains an unusable segment. \n|                | If the source operand is located in       \n|                | an execute-only code segment. If an       \n|                | invalid type is specified in the register \n|                | operand, i.e., INVPCID_TYPE > 3. If       \n|                | bits 63:12 of INVPCID_DESC are not all    \n|                | zero. If INVPCID_TYPE is either 0 or      \n|                | 1 and INVPCID_DESC[11:0] is not zero.     \n|                | If INVPCID_TYPE is 0 and the linear       \n|                | address in INVPCID_DESC[127:64] is not    \n|                | canonical.                                \n| #PF(fault-code)| If a page fault occurs in accessing       \n|                | the memory operand.                       \n| #SS(0)         | If the memory operand effective address   \n|                | is outside the SS segment limit. If       \n|                | the SS register contains an unusable      \n|                | segment.                                  \n| #UD            | If if CPUID.(EAX=07H, ECX=0H):EBX.INVPCID \n|                | (bit 10) = 0. If the LOCK prefix is       \n|                | used.                                     \n\nReal-Address Mode Exceptions:\n| #GP| If an invalid type is specified in the\n|    | register operand, i.e., INVPCID_TYPE  \n|    | > 3. If bits 63:12 of INVPCID_DESC are\n|    | not all zero.                         \nIf INVPCID_TYPE is either 0 or 1 and INVPCID_DESC[11:0] is not zero. If INVPCID_TYPE\nis 0 and the linear address in INVPCID_DESC[127:64] is not canonical.\n\n| #UD| If CPUID.(EAX=07H, ECX=0H):EBX.INVPCID\n|    | (bit 10) = 0. If the LOCK prefix is   \n|    | used.                                 \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| The INVPCID instruction is not recognized\n|       | in virtual-8086 mode.                    \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the current privilege level is not         \n|                | 0. If the memory operand is in the CS,        \n|                | DS, ES, FS, or GS segments and the memory     \n|                | address is in a non-canonical form.           \n|                | If an invalid type is specified in the        \n|                | register operand, i.e., INVPCID_TYPE          \n|                | > 3. If bits 63:12 of INVPCID_DESC are        \n|                | not all zero. If CR4.PCIDE=0, INVPCID_TYPE    \n|                | is either 0 or 1, and INVPCID_DESC[11:0]      \n|                | is not zero. If INVPCID_TYPE is 0 and         \n|                | the linear address in INVPCID_DESC[127:64]    \n|                | is not canonical.                             \n| #PF(fault-code)| If a page fault occurs in accessing           \n|                | the memory operand.                           \n| #SS(0)         | If the memory destination operand is          \n|                | in the SS segment and the memory address      \n|                | is in a noncanonical form.                    \n| #UD            | If the LOCK prefix is used. If CPUID.(EAX=07H,\n|                | ECX=0H):EBX.INVPCID (bit 10) = 0.             \n", 
      "mnem": "INVPCID"
    }, 
    {
      "description": "\nIRET/IRETD - Interrupt Return:\n| Opcode    | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                            \n| CF        | IRET       | NP   | Valid      | Valid          | Interrupt return (16-bit operand size).\n| CF        | IRETD      | NP   | Valid      | Valid          | Interrupt return (32-bit operand size).\n| REX.W + CF| IRETQ      | NP   | Valid      | N.E.           | Interrupt return (64-bit operand size).\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nReturns program control from an exception or interrupt handler to a program\nor procedure that was interrupted by an exception, an external interrupt, or\na software-generated interrupt. These instructions are also used to perform\na return from a nested task. (A nested task is created when a CALL instruction\nis used to initiate a task switch or when an interrupt or exception causes a\ntask switch to an interrupt or exception handler.) See the section titled \u201cTask\nLinking\u201d in Chapter 7 of the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\nIRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt\nreturn double) is intended for use when returning from an interrupt when using\nthe 32-bit operand size; however, most assemblers use the IRET mnemonic interchangeably\nfor both operand sizes.\n\nIn Real-Address Mode, the IRET instruction preforms a far return to the interrupted\nprogram or procedure. During this operation, the processor pops the return instruction\npointer, return code segment selector, and EFLAGS image from the stack to the\nEIP, CS, and EFLAGS registers, respectively, and then resumes execution of the\ninterrupted program or procedure.\n\nIn Protected Mode, the action of the IRET instruction depends on the settings\nof the NT (nested task) and VM flags in the EFLAGS register and the VM flag\nin the EFLAGS image stored on the current stack. Depending on the setting of\nthese flags, the processor performs the following types of interrupt returns:\n\n - Return from virtual-8086 mode.\n - Return to virtual-8086 mode.\n - Intra-privilege level return.\n - Inter-privilege level return.\n - Return from nested task (task switch).\n\nIf the NT flag (EFLAGS register) is cleared, the IRET instruction performs a\nfar return from the interrupt procedure, without a task switch. The code segment\nbeing returned to must be equally or less privileged than the interrupt handler\nroutine (as indicated by the RPL field of the code segment selector popped from\nthe stack).\n\nAs with a real-address mode interrupt return, the IRET instruction pops the\nreturn instruction pointer, return code segment selector, and EFLAGS image from\nthe stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes\nexecution of the interrupted program or procedure. If the return is to another\nprivilege level, the IRET instruction also pops the stack pointer and SS from\nthe stack, before resuming program execution. If the return is to virtual-8086\nmode, the processor also pops the data segment registers from the stack.\n\nIf the NT flag is set, the IRET instruction performs a task switch (return)\nfrom a nested task (a task called with a CALL instruction, an interrupt, or\nan exception) back to the calling or interrupted task. The updated state of\nthe task executing the IRET instruction is saved in its TSS. If the task is\nre-entered later, the code that follows the IRET instruction is executed.\n\nIf the NT flag is set and the processor is in IA-32e mode, the IRET instruction\ncauses a general protection exception.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.W prefix promotes operation to 64 bits (IRETQ). See the summary chart\nat the beginning of this section for encoding data and limits.\n\nSee \u201cChanges to Instruction Behavior in VMX Non-Root Operation\u201d in Chapter 25\nof the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n3C, for more information about the behavior of this instruction in VMX non-root\noperation.\n\nOperation:\n\nIF PE = 0\n  THEN\n     GOTO REAL-ADDRESS-MODE;\n  ELSE\n     IF (IA32_EFER.LMA = 0)\n          THEN (* Protected mode *)\n             GOTO PROTECTED-MODE;\n          ELSE (* IA-32e mode *)\n             GOTO IA-32e-MODE;\n     FI;\nFI;\nREAL-ADDRESS-MODE;\n  IF OperandSize = 32\n     THEN\n       IF top 12 bytes of stack not within stack limits\n          THEN #SS; FI;\n       tempEIP <- 4 bytes at end of stack\n       IF tempEIP[31:16] is not zero THEN #GP(0); FI;\n       EIP <- Pop();\n       CS <- Pop(); (* 32-bit pop, high-order 16 bits discarded *)\n       tempEFLAGS <- Pop();\n       EFLAGS <- (tempEFLAGS AND 257FD5H) OR (EFLAGS AND 1A0000H);\n     ELSE (* OperandSize = 16 *)\n       IF top 6 bytes of stack are not within stack limits\n          THEN #SS; FI;\n       EIP <- Pop(); (* 16-bit pop; clear upper 16 bits *)\n       CS <- Pop(); (* 16-bit pop *)\n       EFLAGS[15:0] <- Pop();\n  FI;\n  END;\nPROTECTED-MODE:\n  IF VM = 1 (* Virtual-8086 mode: PE = 1, VM = 1 *)\n     THEN\n       GOTO RETURN-FROM-VIRTUAL-8086-MODE; (* PE = 1, VM = 1 *)\n  FI;\n  IF NT = 1\n     THEN\n       GOTO TASK-RETURN; (* PE = 1, VM = 0, NT = 1 *)\n  FI;\n  IF OperandSize = 32\n     THEN\n       IF top 12 bytes of stack not within stack limits\n          THEN #SS(0); FI;\n       tempEIP <- Pop();\n       tempCS <- Pop();\n       tempEFLAGS <- Pop();\n     ELSE (* OperandSize = 16 *)\n       IF top 6 bytes of stack are not within stack limits\n          THEN #SS(0); FI;\n       tempEIP <- Pop();\n       tempCS <- Pop();\n       tempEFLAGS <- Pop();\n       tempEIP <- tempEIP AND FFFFH;\n       tempEFLAGS <- tempEFLAGS AND FFFFH;\n  FI;\n  IF tempEFLAGS(VM) = 1 and CPL = 0\n     THEN\n       GOTO RETURN-TO-VIRTUAL-8086-MODE;\n     ELSE\n       GOTO PROTECTED-MODE-RETURN;\n  FI;\nIA-32e-MODE:\n  IF NT = 1\n     THEN #GP(0);\n  ELSE IF OperandSize = 32\n     THEN\n       IF top 12 bytes of stack not within stack limits\n          THEN #SS(0); FI;\n       tempEIP <- Pop();\n       tempCS <- Pop();\n       tempEFLAGS <- Pop();\n     ELSE IF OperandSize = 16\n       THEN\n          IF top 6 bytes of stack are not within stack limits\n             THEN #SS(0); FI;\n          tempEIP <- Pop();\n          tempCS <- Pop();\n          tempEFLAGS <- Pop();\n          tempEIP <- tempEIP AND FFFFH;\n          tempEFLAGS <- tempEFLAGS AND FFFFH;\n       FI;\n     ELSE (* OperandSize = 64 *)\n       THEN\n             tempRIP <- Pop();\n             tempCS <- Pop();\n             tempEFLAGS <- Pop();\n             tempRSP <- Pop();\n             tempSS <- Pop();\n  FI;\n  GOTO IA-32e-MODE-RETURN;\nRETURN-FROM-VIRTUAL-8086-MODE:\n(* Processor is in virtual-8086 mode when IRET is executed and stays in virtual-8086 mode *)\n  IF IOPL = 3 (* Virtual mode: PE = 1, VM = 1, IOPL = 3 *)\n     THEN IF OperandSize = 32\n       THEN\n          IF top 12 bytes of stack not within stack limits\n             THEN #SS(0); FI;\n          IF instruction pointer not within code segment limits\n             THEN #GP(0); FI;\n          EIP <- Pop();\n          CS <- Pop(); (* 32-bit pop, high-order 16 bits discarded *)\n          EFLAGS <- Pop();\n          (* VM, IOPL,VIP and VIF EFLAG bits not modified by pop *)\n       ELSE (* OperandSize = 16 *)\n          IF top 6 bytes of stack are not within stack limits\n             THEN #SS(0); FI;\n          IF instruction pointer not within code segment limits\n             THEN #GP(0); FI;\n          EIP <- Pop();\n          EIP <- EIP AND 0000FFFFH;\n          CS <- Pop(); (* 16-bit pop *)\n          EFLAGS[15:0] <- Pop(); (* IOPL in EFLAGS not modified by pop *)\n       FI;\n     ELSE\n       #GP(0); (* Trap to virtual-8086 monitor: PE = 1, VM = 1, IOPL < 3 *)\n  FI;\nEND;\nRETURN-TO-VIRTUAL-8086-MODE:\n  (* Interrupted procedure was in virtual-8086 mode: PE = 1, CPL=0, VM = 1 in flag image *)\n  IF top 24 bytes of stack are not within stack segment limits\n     THEN #SS(0); FI;\n  IF instruction pointer not within code segment limits\n     THEN #GP(0); FI;\n  CS <- tempCS;\n  EIP <- tempEIP & FFFFH;\n  EFLAGS <- tempEFLAGS;\n  TempESP <- Pop();\n  TempSS <- Pop();\n  ES <- Pop(); (* Pop 2 words; throw away high-order word *)\n  DS <- Pop(); (* Pop 2 words; throw away high-order word *)\n  FS <- Pop(); (* Pop 2 words; throw away high-order word *)\n  GS <- Pop(); (* Pop 2 words; throw away high-order word *)\n  SS:ESP <- TempSS:TempESP;\n  CPL <- 3;\n  (* Resume execution in Virtual-8086 mode *)\nEND;\nTASK-RETURN: (* PE = 1, VM = 0, NT = 1 *)\n  Read segment selector in link field of current TSS;\n  IF local/global bit is set to local\n  or index not within GDT limits\n     THEN #TS (TSS selector); FI;\n  Access TSS for task specified in link field of current TSS;\n  IF TSS descriptor type is not TSS or if the TSS is marked not busy\n     THEN #TS (TSS selector); FI;\n  IF TSS not present\n     THEN #NP(TSS selector); FI;\n  SWITCH-TASKS (without nesting) to TSS specified in link field of current TSS;\n  Mark the task just abandoned as NOT BUSY;\n  IF EIP is not within code segment limit\n     THEN #GP(0); FI;\nEND;\nPROTECTED-MODE-RETURN: (* PE = 1 *)\n  IF return code segment selector is NULL\n     THEN GP(0); FI;\n  IF return code segment selector addresses descriptor beyond descriptor table limit\n     THEN GP(selector); FI;\n  Read segment descriptor pointed to by the return code segment selector;\n  IF return code segment descriptor is not a code segment\n     THEN #GP(selector); FI;\n  IF return code segment selector RPL < CPL\n     THEN #GP(selector); FI;\n  IF return code segment descriptor is conforming\n  and return code segment DPL > return code segment selector RPL\n     THEN #GP(selector); FI;\n  IF return code segment descriptor is not present\n     THEN #NP(selector); FI;\n  IF return code segment selector RPL > CPL\n     THEN GOTO RETURN-OUTER-PRIVILEGE-LEVEL;\n     ELSE GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL; FI;\nEND;\nRETURN-TO-SAME-PRIVILEGE-LEVEL: (* PE = 1, RPL = CPL *)\n  IF new mode != 64-Bit Mode\n     THEN\n       IF tempEIP is not within code segment limits\n          THEN #GP(0); FI;\n       EIP <- tempEIP;\n     ELSE (* new mode = 64-bit mode *)\n       IF tempRIP is non-canonical\n             THEN #GP(0); FI;\n       RIP <- tempRIP;\n  FI;\n  CS <- tempCS; (* Segment descriptor information also loaded *)\n  EFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) <- tempEFLAGS;\n  IF OperandSize = 32 or OperandSize = 64\n     THEN EFLAGS(RF, AC, ID) <- tempEFLAGS; FI;\n  IF CPL \u2264 IOPL\n     THEN EFLAGS(IF) <- tempEFLAGS; FI;\n  IF CPL = 0\n     THEN (* VM = 0 in flags image *)\n     EFLAGS(IOPL) <- tempEFLAGS;\n     IF OperandSize = 32 or OperandSize = 64\n       THEN EFLAGS(VIF, VIP) <- tempEFLAGS; FI;\n  FI;\nEND;\nRETURN-TO-OUTER-PRIVILEGE-LEVEL:\n  IF OperandSize = 32\n     THEN\n       IF top 8 bytes on stack are not within limits\n          THEN #SS(0); FI;\n     ELSE (* OperandSize = 16 *)\n       IF top 4 bytes on stack are not within limits\n          THEN #SS(0); FI;\n  FI;\n  Read return segment selector;\n  IF stack segment selector is NULL\n     THEN #GP(0); FI;\n  IF return stack segment selector index is not within its descriptor table limits\n     THEN #GP(SSselector); FI;\n  Read segment descriptor pointed to by return segment selector;\n  IF stack segment selector RPL != RPL of the return code segment selector\n  or the stack segment descriptor does not indicate a a writable data segment;\n  or the stack segment DPL != RPL of the return code segment selector\n     THEN #GP(SS selector); FI;\n  IF stack segment is not present\n     THEN #SS(SS selector); FI;\n  IF new mode != 64-Bit Mode\n     THEN\n       IF tempEIP is not within code segment limits\n          THEN #GP(0); FI;\n       EIP <- tempEIP;\n     ELSE (* new mode = 64-bit mode *)\n       IF tempRIP is non-canonical\n             THEN #GP(0); FI;\n       RIP <- tempRIP;\n  FI;\n  CS <- tempCS;\n  EFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) <- tempEFLAGS;\n  IF OperandSize = 32\n     THEN EFLAGS(RF, AC, ID) <- tempEFLAGS; FI;\n  IF CPL \u2264 IOPL\n     THEN EFLAGS(IF) <- tempEFLAGS; FI;\n  IF CPL = 0\n     THEN\n       EFLAGS(IOPL) <- tempEFLAGS;\n       IF OperandSize = 32\n          THEN EFLAGS(VM, VIF, VIP) <- tempEFLAGS; FI;\n       IF OperandSize = 64\n          THEN EFLAGS(VIF, VIP) <- tempEFLAGS; FI;\n  FI;\n  CPL <- RPL of the return code segment selector;\n  FOR each of segment register (ES, FS, GS, and DS)\n     DO\n       IF segment register points to data or non-conforming code segment\n       and CPL > segment descriptor DPL (* Stored in hidden part of segment register *)\n          THEN (* Segment register invalid *)\n             SegmentSelector <- 0; (* NULL segment selector *)\n       FI;\n     OD;\nEND;\nIA-32e-MODE-RETURN: (* IA32_EFER.LMA = 1, PE = 1 *)\n  IF ( (return code segment selector is NULL) or (return RIP is non-canonical) or\n       (SS selector is NULL going back to compatibility mode) or\n       (SS selector is NULL going back to CPL3 64-bit mode) or\n       (RPL <> CPL going back to non-CPL3 64-bit mode for a NULL SS selector) )\n     THEN GP(0); FI;\n  IF return code segment selector addresses descriptor beyond descriptor table limit\n     THEN GP(selector); FI;\n  Read segment descriptor pointed to by the return code segment selector;\n  IF return code segment descriptor is not a code segment\n     THEN #GP(selector); FI;\n  IF return code segment selector RPL < CPL\n     THEN #GP(selector); FI;\n  IF return code segment descriptor is conforming\n  and return code segment DPL > return code segment selector RPL\n     THEN #GP(selector); FI;\n  IF return code segment descriptor is not present\n     THEN #NP(selector); FI;\n  IF return code segment selector RPL > CPL\n     THEN GOTO RETURN-OUTER-PRIVILEGE-LEVEL;\n     ELSE GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL; FI;\nEND;\n\nFlags Affected:\nAll the flags and fields in the EFLAGS register are potentially modified, depending\non the mode of operation of the processor. If performing a return from a nested\ntask to a previous task, the EFLAGS register will be modified according to the\nEFLAGS image stored in the previous task's TSS.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the return code or stack segment               \n|                | selector is NULL. If the return instruction       \n|                | pointer is not within the return code             \n|                | segment limit.                                    \n| #GP(selector)  | If a segment selector index is outside            \n|                | its descriptor table limits. If the               \n|                | return code segment selector RPL is               \n|                | less than the CPL. If the DPL of a conforming-code\n|                | segment is greater than the return code           \n|                | segment selector RPL. If the DPL for              \n|                | a nonconforming-code segment is not               \n|                | equal to the RPL of the code segment              \n|                | selector. If the stack segment descriptor         \n|                | DPL is not equal to the RPL of the return         \n|                | code segment selector. If the stack               \n|                | segment is not a writable data segment.           \n|                | If the stack segment selector RPL is              \n|                | not equal to the RPL of the return code           \n|                | segment selector. If the segment descriptor       \n|                | for a code segment does not indicate              \n|                | it is a code segment. If the segment              \n|                | selector for a TSS has its local/global           \n|                | bit set for local. If a TSS segment               \n|                | descriptor specifies that the TSS is              \n|                | not busy. If a TSS segment descriptor             \n|                | specifies that the TSS is not available.          \n| #SS(0)         | If the top bytes of stack are not within          \n|                | stack limits.                                     \n| #NP(selector)  | If the return code or stack segment               \n|                | is not present.                                   \n| #PF(fault-code)| If a page fault occurs.                           \n| #AC(0)         | If an unaligned memory reference occurs           \n|                | when the CPL is 3 and alignment checking          \n|                | is enabled.                                       \n| #UD            | If the LOCK prefix is used.                       \n\nReal-Address Mode Exceptions:\n| #GP| If the return instruction pointer is     \n|    | not within the return code segment limit.\n| #SS| If the top bytes of stack are not within \n|    | stack limits.                            \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| If the return instruction pointer is     \n|       | not within the return code segment limit.\nIF IOPL not equal to 3.\n\n| #PF(fault-code)| If a page fault occurs.                 \n| #SS(0)         | If the top bytes of stack are not within\n|                | stack limits.                           \n| #AC(0)         | If an unaligned memory reference occurs \n|                | and alignment checking is enabled.      \n| #UD            | If the LOCK prefix is used.             \n\nCompatibility Mode Exceptions:\n| #GP(0) Other exceptions same as in Protected| If EFLAGS.NT[bit 14] = 1.\n| Mode.                                       |                          \n\n64-Bit Mode Exceptions:\n| #GP(0)         | If EFLAGS.NT[bit 14] = 1. If the return    \n|                | code segment selector is NULL. If the      \n|                | stack segment selector is NULL going       \n|                | back to compatibility mode. If the stack   \n|                | segment selector is NULL going back        \n|                | to CPL3 64-bit mode. If a NULL stack       \n|                | segment selector RPL is not equal to       \n|                | CPL going back to non-CPL3 64-bit mode.    \n|                | If the return instruction pointer is       \n|                | not within the return code segment limit.  \n|                | If the return instruction pointer is       \n|                | non-canonical.                             \n| #GP(Selector)  | If a segment selector index is outside     \n|                | its descriptor table limits. If a segment  \n|                | descriptor memory address is non-canonical.\n|                | If the segment descriptor for a code       \n|                | segment does not indicate it is a code     \n|                | segment. If the proposed new code segment  \n|                | descriptor has both the D-bit and L-bit    \n|                | set. If the DPL for a nonconforming-code   \n|                | segment is not equal to the RPL of the     \n|                | code segment selector. If CPL is greater   \n|                | than the RPL of the code segment selector. \n|                | If the DPL of a conforming-code segment    \n|                | is greater than the return code segment    \n|                | selector RPL. If the stack segment is      \n|                | not a writable data segment. If the        \n|                | stack segment descriptor DPL is not        \n|                | equal to the RPL of the return code        \n|                | segment selector. If the stack segment     \n|                | selector RPL is not equal to the RPL       \n|                | of the return code segment selector.       \n| #SS(0)         | If an attempt to pop a value off the       \n|                | stack violates the SS limit. If an attempt \n|                | to pop a value off the stack causes        \n|                | a non-canonical address to be referenced.  \n| #NP(selector)  | If the return code or stack segment        \n|                | is not present.                            \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If an unaligned memory reference occurs    \n|                | when the CPL is 3 and alignment checking   \n|                | is enabled.                                \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "IRET"
    }, 
    {
      "description": "-R:IRET", 
      "mnem": "IRETD"
    }, 
    {
      "description": "-R:IRET", 
      "mnem": "IRETQ"
    }, 
    {
      "description": "\nJMP - Jump:\n| Opcode       | Instruction | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                               \n| EB cb        | JMP rel8    | D    | Valid      | Valid          | Jump short, RIP = RIP + 8-bit displacement\n|              |             |      |            |                | sign extended to 64-bits                  \n| E9 cw        | JMP rel16   | D    | N.S.       | Valid          | Jump near, relative, displacement relative\n|              |             |      |            |                | to next instruction. Not supported in     \n|              |             |      |            |                | 64-bit mode.                              \n| E9 cd        | JMP rel32   | D    | Valid      | Valid          | Jump near, relative, RIP = RIP + 32-bit   \n|              |             |      |            |                | displacement sign extended to 64-bits     \n| FF /4        | JMP r/m16   | M    | N.S.       | Valid          | Jump near, absolute indirect, address     \n|              |             |      |            |                | = zeroextended r/m16. Not supported       \n|              |             |      |            |                | in 64-bit mode.                           \n| FF /4        | JMP r/m32   | M    | N.S.       | Valid          | Jump near, absolute indirect, address     \n|              |             |      |            |                | given in r/m32. Not supported in 64-bit   \n|              |             |      |            |                | mode.                                     \n| FF /4        | JMP r/m64   | M    | Valid      | N.E.           | Jump near, absolute indirect, RIP =       \n|              |             |      |            |                | 64-Bit offset from register or memory     \n| EA cd        | JMP ptr16:16| D    | Inv.       | Valid          | Jump far, absolute, address given in      \n|              |             |      |            |                | operand                                   \n| EA cp        | JMP ptr16:32| D    | Inv.       | Valid          | Jump far, absolute, address given in      \n|              |             |      |            |                | operand                                   \n| FF /5        | JMP m16:16  | D    | Valid      | Valid          | Jump far, absolute indirect, address      \n|              |             |      |            |                | given in m16:16                           \n| FF /5        | JMP m16:32  | D    | Valid      | Valid          | Jump far, absolute indirect, address      \n|              |             |      |            |                | given in m16:32.                          \n| REX.W + FF /5| JMP m16:64  | D    | Valid      | N.E.           | Jump far, absolute indirect, address      \n|              |             |      |            |                | given in m16:64.                          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| D    | Offset       | NA       | NA       | NA       \n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nTransfers program control to a different point in the instruction stream without\nrecording return information. The destination (target) operand specifies the\naddress of the instruction being jumped to. This operand can be an immediate\nvalue, a general-purpose register, or a memory location.\n\nThis instruction can be used to execute four different types of jumps:\n\n - Near jump - A jump to an instruction within the current code segment (the segment\ncurrently pointed to by the CS register), sometimes referred to as an intrasegment\njump.\n - Short jump - A near jump where the jump range is limited to -128 to +127 from\nthe current EIP value.\n - Far jump - A jump to an instruction located in a different segment than the current\ncode segment but at the same privilege level, sometimes referred to as an intersegment\njump.\n - Task switch - A jump to an instruction located in a different task.\n\nA task switch can only be executed in protected mode (see Chapter 7, in the\nIntel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, for\ninformation on performing task switches with the JMP instruction).\n\nNear and Short Jumps. When executing a near jump, the processor jumps to the\naddress (within the current code segment) that is specified with the target\noperand. The target operand specifies either an absolute offset (that is an\noffset from the base of the code segment) or a relative offset (a signed displacement\nrelative to the current\n\nvalue of the instruction pointer in the EIP register). A near jump to a relative\noffset of 8-bits (rel8) is referred to as a short jump. The CS register is not\nchanged on near and short jumps.\n\nAn absolute offset is specified indirectly in a general-purpose register or\na memory location (r/m16 or r/m32). The operand-size attribute determines the\nsize of the target operand (16 or 32 bits). Absolute offsets are loaded directly\ninto the EIP register. If the operand-size attribute is 16, the upper two bytes\nof the EIP register are cleared, resulting in a maximum instruction pointer\nsize of 16 bits.\n\nA relative offset (rel8, rel16, or rel32) is generally specified as a label\nin assembly code, but at the machine code level, it is encoded as a signed 8-,\n16-, or 32-bit immediate value. This value is added to the value in the EIP\nregister. (Here, the EIP register contains the address of the instruction following\nthe JMP instruction). When using relative offsets, the opcode (for short vs.\nnear jumps) and the operand-size attribute (for near relative jumps) determines\nthe size of the target operand (8, 16, or 32 bits).\n\nFar Jumps in Real-Address or Virtual-8086 Mode. When executing a far jump in\nreal-address or virtual-8086 mode, the processor jumps to the code segment and\noffset specified with the target operand. Here the target operand specifies\nan absolute far address either directly with a pointer (ptr16:16 or ptr16:32)\nor indirectly with a memory location (m16:16 or m16:32). With the pointer method,\nthe segment and address of the called procedure is encoded in the instruction,\nusing a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address\nimmediate. With the indirect method, the target operand specifies a memory location\nthat contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size)\nfar address. The far address is loaded directly into the CS and EIP registers.\nIf the operand-size attribute is 16, the upper two bytes of the EIP register\nare cleared.\n\nFar Jumps in Protected Mode. When the processor is operating in protected mode,\nthe JMP instruction can be used to perform the following three types of far\njumps:\n\n - A far jump to a conforming or non-conforming code segment.\n - A far jump through a call gate.\n - A task switch.\n\n(The JMP instruction cannot be used to perform inter-privilege-level far jumps.)\n\nIn protected mode, the processor always uses the segment selector part of the\nfar address to access the corresponding descriptor in the GDT or LDT. The descriptor\ntype (code segment, call gate, task gate, or TSS) and access rights determine\nthe type of jump to be performed.\n\nIf the selected descriptor is for a code segment, a far jump to a code segment\nat the same privilege level is performed. (If the selected code segment is at\na different privilege level and the code segment is non-conforming, a general-protection\nexception is generated.) A far jump to the same privilege level in protected\nmode is very similar to one carried out in real-address or virtual-8086 mode.\nThe target operand specifies an absolute far address either directly with a\npointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16\nor m16:32). The operand-size attribute determines the size of the offset (16\nor 32 bits) in the far address. The new code segment selector and its descriptor\nare loaded into CS register, and the offset from the instruction is loaded into\nthe EIP register. Note that a call gate (described in the next paragraph) can\nalso be used to perform far call to a code segment at the same privilege level.\nUsing this mechanism provides an extra level of indirection and is the preferred\nmethod of making jumps between 16-bit and 32-bit code segments.\n\nWhen executing a far jump through a call gate, the segment selector specified\nby the target operand identifies the call gate. (The offset part of the target\noperand is ignored.) The processor then jumps to the code segment specified\nin the call gate descriptor and begins executing the instruction at the offset\nspecified in the call gate. No stack switch occurs. Here again, the target operand\ncan specify the far address of the call gate either directly with a pointer\n(ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32).\n\nExecuting a task switch with the JMP instruction is somewhat similar to executing\na jump through a call gate. Here the target operand specifies the segment selector\nof the task gate for the task being switched to (and the offset part of the\ntarget operand is ignored). The task gate in turn points to the TSS for the\ntask, which contains the segment selectors for the task's code and stack segments.\nThe TSS also contains the EIP value for the next instruction that was to be\nexecuted before the task was suspended. This instruction pointer value is loaded\ninto the EIP register so that the task begins executing again at this next instruction.\n\nThe JMP instruction can also specify the segment selector of the TSS directly,\nwhich eliminates the indirection of the task gate. See Chapter 7 in Intel\u00ae 64\nand IA-32 Architectures Software Developer's Manual, Volume 3A, for detailed\ninformation on the mechanics of a task switch.\n\nNote that when you execute at task switch with a JMP instruction, the nested\ntask flag (NT) is not set in the EFLAGS register and the new TSS's previous\ntask link field is not loaded with the old task's TSS selector. A return to\nthe previous task can thus not be carried out by executing the IRET instruction.\nSwitching tasks with the JMP instruction differs in this regard from the CALL\ninstruction which does set the NT flag and save the previous task link information,\nallowing a return to the calling task with an IRET instruction.\n\nIn 64-Bit Mode  -  The instruction's operation size is fixed at 64 bits. If a\nselector points to a gate, then RIP equals the 64-bit displacement taken from\ngate; else RIP equals the zero-extended offset from the far pointer referenced\nin the instruction.\n\nSee the summary chart at the beginning of this section for encoding data and\nlimits.\n\nOperation:\n\nIF near jump\n  IF 64-bit Mode\n     THEN\n       IF near relative jump\n        THEN\n          tempRIP <- RIP + DEST; (* RIP is instruction following JMP instruction*)\n        ELSE (* Near absolute jump *)\n          tempRIP <- DEST;\n       FI;\n     ELSE\n       IF near relative jump\n        THEN\n          tempEIP <- EIP + DEST; (* EIP is instruction following JMP instruction*)\n        ELSE (* Near absolute jump *)\n          tempEIP <- DEST;\n       FI;\n  FI;\n  IF (IA32_EFER.LMA = 0 or target mode = Compatibility mode)\n  and tempEIP outside code segment limit\n     THEN #GP(0); FI\n  IF 64-bit mode and tempRIP is not canonical\n     THEN #GP(0);\n  FI;\n  IF OperandSize = 32\n     THEN\n       EIP <- tempEIP;\n     ELSE\n       IF OperandSize = 16\n          THEN (* OperandSize = 16 *)\n             EIP <- tempEIP AND 0000FFFFH;\n          ELSE (* OperandSize = 64)\n             RIP <- tempRIP;\n       FI;\n  FI;\nFI;\nIF far jump and (PE = 0 or (PE = 1 AND VM = 1)) (* Real-address or virtual-8086 mode *)\n  THEN\n     tempEIP <- DEST(Offset); (* DEST is ptr16:32 or [m16:32] *)\n     IF tempEIP is beyond code segment limit\n       THEN #GP(0); FI;\n     CS <- DEST(segment selector); (* DEST is ptr16:32 or [m16:32] *)\n     IF OperandSize = 32\n        THEN\n          EIP <- tempEIP; (* DEST is ptr16:32 or [m16:32] *)\n        ELSE (* OperandSize = 16 *)\n          EIP <- tempEIP AND 0000FFFFH; (* Clear upper 16 bits *)\n     FI;\nFI;\nIF far jump and (PE = 1 and VM = 0)\n(* IA-32e mode or protected mode, not virtual-8086 mode *)\n  THEN\n     IF effective address in the CS, DS, ES, FS, GS, or SS segment is illegal\n     or segment selector in target operand NULL\n          THEN #GP(0); FI;\n     IF segment selector index not within descriptor table limits\n       THEN #GP(new selector); FI;\n     Read type and access rights of segment descriptor;\n     IF (EFER.LMA = 0)\n       THEN\n          IF segment type is not a conforming or nonconforming code\n          segment, call gate, task gate, or TSS\n             THEN #GP(segment selector); FI;\n       ELSE\n          IF segment type is not a conforming or nonconforming code segment\n          call gate\n             THEN #GP(segment selector); FI;\n     FI;\n     Depending on type and access rights:\n       GO TO CONFORMING-CODE-SEGMENT;\n       GO TO NONCONFORMING-CODE-SEGMENT;\n       GO TO CALL-GATE;\n       GO TO TASK-GATE;\n       GO TO TASK-STATE-SEGMENT;\n  ELSE\n     #GP(segment selector);\nFI;\nCONFORMING-CODE-SEGMENT:\n  IF L-Bit = 1 and D-BIT = 1 and IA32_EFER.LMA = 1\n     THEN GP(new code segment selector); FI;\n  IF DPL > CPL\n     THEN #GP(segment selector); FI;\n  IF segment not present\n     THEN #NP(segment selector); FI;\n  tempEIP <- DEST(Offset);\n  IF OperandSize = 16\n     THEN tempEIP <- tempEIP AND 0000FFFFH;\n  FI;\n  IF (IA32_EFER.LMA = 0 or target mode = Compatibility mode) and\n  tempEIP outside code segment limit\n     THEN #GP(0); FI\n  IF tempEIP is non-canonical\n     THEN #GP(0); FI;\n  CS <- DEST[segment selector]; (* Segment descriptor information also loaded *)\n  CS(RPL) <- CPL\n  EIP <- tempEIP;\nEND;\nNONCONFORMING-CODE-SEGMENT:\n  IF L-Bit = 1 and D-BIT = 1 and IA32_EFER.LMA = 1\n     THEN GP(new code segment selector); FI;\n  IF (RPL > CPL) OR (DPL != CPL)\n     THEN #GP(code segment selector); FI;\n  IF segment not present\n     THEN #NP(segment selector); FI;\n  tempEIP <- DEST(Offset);\n  IF OperandSize = 16\n     THEN tempEIP <- tempEIP AND 0000FFFFH; FI;\n  IF (IA32_EFER.LMA = 0 OR target mode = Compatibility mode)\n  and tempEIP outside code segment limit\n     THEN #GP(0); FI\n  IF tempEIP is non-canonical THEN #GP(0); FI;\n  CS <- DEST[segment selector]; (* Segment descriptor information also loaded *)\n  CS(RPL) <- CPL;\n  EIP <- tempEIP;\nEND;\nCALL-GATE:\n  IF call gate DPL < CPL\n  or call gate DPL < call gate segment-selector RPL\n       THEN #GP(call gate selector); FI;\n  IF call gate not present\n     THEN #NP(call gate selector); FI;\n  IF call gate code-segment selector is NULL\n     THEN #GP(0); FI;\n  IF call gate code-segment selector index outside descriptor table limits\n     THEN #GP(code segment selector); FI;\n  Read code segment descriptor;\n  IF code-segment segment descriptor does not indicate a code segment\n  or code-segment segment descriptor is conforming and DPL > CPL\n  or code-segment segment descriptor is non-conforming and DPL != CPL\n       THEN #GP(code segment selector); FI;\n  IF IA32_EFER.LMA = 1 and (code-segment descriptor is not a 64-bit code segment\n  or code-segment segment descriptor has both L-Bit and D-bit set)\n       THEN #GP(code segment selector); FI;\n  IF code segment is not present\n     THEN #NP(code-segment selector); FI;\n  IF instruction pointer is not within code-segment limit\n     THEN #GP(0); FI;\n  tempEIP <- DEST(Offset);\n  IF GateSize = 16\n     THEN tempEIP <- tempEIP AND 0000FFFFH; FI;\n  IF (IA32_EFER.LMA = 0 OR target mode = Compatibility mode) AND tempEIP\n  outside code segment limit\n     THEN #GP(0); FI\n  CS <- DEST[SegmentSelector); (* Segment descriptor information also loaded *)\n  CS(RPL) <- CPL;\n  EIP <- tempEIP;\nEND;\nTASK-GATE:\n  IF task gate DPL < CPL\n  or task gate DPL < task gate segment-selector RPL\n     THEN #GP(task gate selector); FI;\n  IF task gate not present\n     THEN #NP(gate selector); FI;\n  Read the TSS segment selector in the task-gate descriptor;\n  IF TSS segment selector local/global bit is set to local\n  or index not within GDT limits\n  or TSS descriptor specifies that the TSS is busy\n     THEN #GP(TSS selector); FI;\n  IF TSS not present\n     THEN #NP(TSS selector); FI;\n  SWITCH-TASKS to TSS;\n  IF EIP not within code segment limit\n     THEN #GP(0); FI;\nEND;\nTASK-STATE-SEGMENT:\n  IF TSS DPL < CPL\n  or TSS DPL < TSS segment-selector RPL\n  or TSS descriptor indicates TSS not available\n     THEN #GP(TSS selector); FI;\n  IF TSS is not present\n     THEN #NP(TSS selector); FI;\n  SWITCH-TASKS to TSS;\n  IF EIP not within code segment limit\n     THEN #GP(0); FI;\nEND;\n\nFlags Affected:\nAll flags are affected if a task switch occurs; no flags are affected if a task\nswitch does not occur.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If offset in target operand, call gate,     \n|                | or TSS is beyond the code segment limits.   \n|                | If the segment selector in the destination  \n|                | operand, call gate, task gate, or TSS       \n|                | is NULL. If a memory operand effective      \n|                | address is outside the CS, DS, ES, FS,      \n|                | or GS segment limit. If the DS, ES,         \n|                | FS, or GS register is used to access        \n|                | memory and it contains a NULL segment       \n|                | selector.                                   \n| #GP(selector)  | If the segment selector index is outside    \n|                | descriptor table limits. If the segment     \n|                | descriptor pointed to by the segment        \n|                | selector in the destination operand         \n|                | is not for a conforming-code segment,       \n|                | nonconforming-code segment, call gate,      \n|                | task gate, or task state segment. If        \n|                | the DPL for a nonconforming-code segment    \n|                | is not equal to the CPL (When not using     \n|                | a call gate.) If the RPL for the segment's  \n|                | segment selector is greater than the        \n|                | CPL. If the DPL for a conforming-code       \n|                | segment is greater than the CPL. If         \n|                | the DPL from a call-gate, task-gate,        \n|                | or TSS segment descriptor is less than      \n|                | the CPL or than the RPL of the call-gate,   \n|                | task-gate, or TSS's segment selector.       \n|                | If the segment descriptor for selector      \n|                | in a call gate does not indicate it         \n|                | is a code segment. If the segment descriptor\n|                | for the segment selector in a task gate     \n|                | does not indicate an available TSS.         \n|                | If the segment selector for a TSS has       \n|                | its local/global bit set for local.         \n|                | If a TSS segment descriptor specifies       \n|                | that the TSS is busy or not available.      \n| #SS(0)         | If a memory operand effective address       \n|                | is outside the SS segment limit.            \n| #NP (selector) | If the code segment being accessed is       \n|                | not present. If call gate, task gate,       \n|                | or TSS not present.                         \n| #PF(fault-code)| If a page fault occurs.                     \n| #AC(0)         | If alignment checking is enabled and        \n|                | an unaligned memory reference is made       \n|                | while the current privilege level is        \n|                | 3. (Only occurs when fetching target        \n|                | from memory.)                               \n| #UD            | If the LOCK prefix is used.                 \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address       \n|    | is outside the CS, DS, ES, FS, or GS        \n|    | segment limit. If a memory operand effective\n|    | address is outside the CS, DS, ES, FS,      \n|    | or GS segment limit.                        \n| #SS| If a memory operand effective address       \n|    | is outside the SS segment limit.            \n| #UD| If the LOCK prefix is used.                 \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If the target operand is beyond the     \n|                | code segment limits. If a memory operand\n|                | effective address is outside the CS,    \n|                | DS, ES, FS, or GS segment limit.        \n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made.  \n|                | (Only occurs when fetching target from  \n|                | memory.)                                \n| #UD            | If the LOCK prefix is used.             \n\nCompatibility Mode Exceptions:\nSame as 64-bit mode exceptions.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)       | If a memory address is non-canonical.      \n|              | If target offset in destination operand    \n|              | is non-canonical. If target offset in      \n|              | destination operand is beyond the new      \n|              | code segment limit. If the segment selector\n|              | in the destination operand is NULL.        \n|              | If the code segment selector in the        \n|              | 64-bit gate is NULL.                       \n| #GP(selector)| If the code segment or 64-bit call gate    \n|              | is outside descriptor table limits.        \n|              | If the code segment or 64-bit call gate    \n|              | overlaps non-canonical space. If the       \n|              | segment descriptor from a 64-bit call      \n|              | gate is in non-canonical space. If the     \n|              | segment descriptor pointed to by the       \n|              | segment selector in the destination        \n|              | operand is not for a conforming-code       \n|              | segment, nonconforming-code segment,       \n|              | 64-bit call gate. If the segment descriptor\n|              | pointed to by the segment selector in      \n|              | the destination operand is a code segment, \n|              | and has both the D-bit and the L-bit       \n|              | set. If the DPL for a nonconforming-code   \n|              | segment is not equal to the CPL, or        \n|              | the RPL for the segment's segment selector \n|              | is greater than the CPL. If the DPL        \n|              | for a conforming-code segment is greater   \n|              | than the CPL. If the DPL from a 64-bit     \n|              | call-gate is less than the CPL or than     \n|              | the RPL of the 64-bit call-gate. If        \n|              | the upper type field of a 64-bit call      \n|              | gate is not 0x0. If the segment selector   \n|              | from a 64-bit call gate is beyond the      \n|              | descriptor table limits. If the code       \n|              | segment descriptor pointed to by the       \n|              | selector in the 64-bit gate doesn't        \n|              | have the Lbit set and the D-bit clear.     \n|              | If the segment descriptor for a segment    \n|              | selector from the 64-bit call gate does    \n|              | not indicate it is a code segment.         \nIf the code segment is non-confirming and CPL != DPL. If the code segment is\nconfirming and CPL < DPL.\n\n| #NP(selector)  | If a code segment or 64-bit call gate   \n|                | is not present.                         \n| #UD            | (64-bit mode only) If a far jump is     \n|                | direct to an absolute address in memory.\n|                | If the LOCK prefix is used.             \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made   \n|                | while the current privilege level is    \n|                | 3.                                      \n", 
      "mnem": "JMP"
    }, 
    {
      "description": "\nJcc - Jump if Condition Is Met:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                 \n| 77 cb   | JA rel8    | D    | Valid      | Valid          | Jump short if above (CF=0 and ZF=0).        \n| 73 cb   | JAE rel8   | D    | Valid      | Valid          | Jump short if above or equal (CF=0).        \n| 72 cb   | JB rel8    | D    | Valid      | Valid          | Jump short if below (CF=1).                 \n| 76 cb   | JBE rel8   | D    | Valid      | Valid          | Jump short if below or equal (CF=1 or       \n|         |            |      |            |                | ZF=1).                                      \n| 72 cb   | JC rel8    | D    | Valid      | Valid          | Jump short if carry (CF=1).                 \n| E3 cb   | JCXZ rel8  | D    | N.E.       | Valid          | Jump short if CX register is 0.             \n| E3 cb   | JECXZ rel8 | D    | Valid      | Valid          | Jump short if ECX register is 0.            \n| E3 cb   | JRCXZ rel8 | D    | Valid      | N.E.           | Jump short if RCX register is 0.            \n| 74 cb   | JE rel8    | D    | Valid      | Valid          | Jump short if equal (ZF=1).                 \n| 7F cb   | JG rel8    | D    | Valid      | Valid          | Jump short if greater (ZF=0 and SF=OF).     \n| 7D cb   | JGE rel8   | D    | Valid      | Valid          | Jump short if greater or equal (SF=OF).     \n| 7C cb   | JL rel8    | D    | Valid      | Valid          | Jump short if less (SF!= OF).                \n| 7E cb   | JLE rel8   | D    | Valid      | Valid          | Jump short if less or equal (ZF=1 or        \n|         |            |      |            |                | SF!= OF).                                    \n| 76 cb   | JNA rel8   | D    | Valid      | Valid          | Jump short if not above (CF=1 or ZF=1).     \n| 72 cb   | JNAE rel8  | D    | Valid      | Valid          | Jump short if not above or equal (CF=1).    \n| 73 cb   | JNB rel8   | D    | Valid      | Valid          | Jump short if not below (CF=0).             \n| 77 cb   | JNBE rel8  | D    | Valid      | Valid          | Jump short if not below or equal (CF=0      \n|         |            |      |            |                | and ZF=0).                                  \n| 73 cb   | JNC rel8   | D    | Valid      | Valid          | Jump short if not carry (CF=0).             \n| 75 cb   | JNE rel8   | D    | Valid      | Valid          | Jump short if not equal (ZF=0).             \n| 7E cb   | JNG rel8   | D    | Valid      | Valid          | Jump short if not greater (ZF=1 or SF!=      \n|         |            |      |            |                | OF).                                        \n| 7C cb   | JNGE rel8  | D    | Valid      | Valid          | Jump short if not greater or equal (SF!=     \n|         |            |      |            |                | OF).                                        \n| 7D cb   | JNL rel8   | D    | Valid      | Valid          | Jump short if not less (SF=OF).             \n| 7F cb   | JNLE rel8  | D    | Valid      | Valid          | Jump short if not less or equal (ZF=0       \n|         |            |      |            |                | and SF=OF).                                 \n| 71 cb   | JNO rel8   | D    | Valid      | Valid          | Jump short if not overflow (OF=0).          \n| 7B cb   | JNP rel8   | D    | Valid      | Valid          | Jump short if not parity (PF=0).            \n| 79 cb   | JNS rel8   | D    | Valid      | Valid          | Jump short if not sign (SF=0).              \n| 75 cb   | JNZ rel8   | D    | Valid      | Valid          | Jump short if not zero (ZF=0).              \n| 70 cb   | JO rel8    | D    | Valid      | Valid          | Jump short if overflow (OF=1).              \n| 7A cb   | JP rel8    | D    | Valid      | Valid          | Jump short if parity (PF=1).                \n| 7A cb   | JPE rel8   | D    | Valid      | Valid          | Jump short if parity even (PF=1).           \n| 7B cb   | JPO rel8   | D    | Valid      | Valid          | Jump short if parity odd (PF=0).            \n| 78 cb   | JS rel8    | D    | Valid      | Valid          | Jump short if sign (SF=1).                  \n| 74 cb   | JZ rel8    | D    | Valid      | Valid          | Jump short if zero (ZF \u2190 1).                \n| 0F 87 cw| JA rel16   | D    | N.S.       | Valid          | Jump near if above (CF=0 and ZF=0).         \n|         |            |      |            |                | Not supported in 64-bit mode.               \n| 0F 87 cd| JA rel32   | D    | Valid      | Valid          | Jump near if above (CF=0 and ZF=0).         \n| 0F 83 cw| JAE rel16  | D    | N.S.       | Valid          | Jump near if above or equal (CF=0).         \n|         |            |      |            |                | Not supported in 64-bit mode.               \n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                 \n| 0F 83 cd| JAE rel32  | D    | Valid      | Valid          | Jump near if above or equal (CF=0).         \n| 0F 82 cw| JB rel16   | D    | N.S.       | Valid          | Jump near if below (CF=1). Not supported    \n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 82 cd| JB rel32   | D    | Valid      | Valid          | Jump near if below (CF=1).                  \n| 0F 86 cw| JBE rel16  | D    | N.S.       | Valid          | Jump near if below or equal (CF=1 or        \n|         |            |      |            |                | ZF=1). Not supported in 64-bit mode.        \n| 0F 86 cd| JBE rel32  | D    | Valid      | Valid          | Jump near if below or equal (CF=1 or        \n|         |            |      |            |                | ZF=1).                                      \n| 0F 82 cw| JC rel16   | D    | N.S.       | Valid          | Jump near if carry (CF=1). Not supported    \n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 82 cd| JC rel32   | D    | Valid      | Valid          | Jump near if carry (CF=1).                  \n| 0F 84 cw| JE rel16   | D    | N.S.       | Valid          | Jump near if equal (ZF=1). Not supported    \n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 84 cd| JE rel32   | D    | Valid      | Valid          | Jump near if equal (ZF=1).                  \n| 0F 84 cw| JZ rel16   | D    | N.S.       | Valid          | Jump near if 0 (ZF=1). Not supported        \n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 84 cd| JZ rel32   | D    | Valid      | Valid          | Jump near if 0 (ZF=1).                      \n| 0F 8F cw| JG rel16   | D    | N.S.       | Valid          | Jump near if greater (ZF=0 and SF=OF).      \n|         |            |      |            |                | Not supported in 64-bit mode.               \n| 0F 8F cd| JG rel32   | D    | Valid      | Valid          | Jump near if greater (ZF=0 and SF=OF).      \n| 0F 8D cw| JGE rel16  | D    | N.S.       | Valid          | Jump near if greater or equal (SF=OF).      \n|         |            |      |            |                | Not supported in 64-bit mode.               \n| 0F 8D cd| JGE rel32  | D    | Valid      | Valid          | Jump near if greater or equal (SF=OF).      \n| 0F 8C cw| JL rel16   | D    | N.S.       | Valid          | Jump near if less (SF!= OF). Not supported   \n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 8C cd| JL rel32   | D    | Valid      | Valid          | Jump near if less (SF!= OF).                 \n| 0F 8E cw| JLE rel16  | D    | N.S.       | Valid          | Jump near if less or equal (ZF=1 or         \n|         |            |      |            |                | SF!= OF). Not supported in 64-bit mode.      \n| 0F 8E cd| JLE rel32  | D    | Valid      | Valid          | Jump near if less or equal (ZF=1 or         \n|         |            |      |            |                | SF!= OF).                                    \n| 0F 86 cw| JNA rel16  | D    | N.S.       | Valid          | Jump near if not above (CF=1 or ZF=1).      \n|         |            |      |            |                | Not supported in 64-bit mode.               \n| 0F 86 cd| JNA rel32  | D    | Valid      | Valid          | Jump near if not above (CF=1 or ZF=1).      \n| 0F 82 cw| JNAE rel16 | D    | N.S.       | Valid          | Jump near if not above or equal (CF=1).     \n|         |            |      |            |                | Not supported in 64-bit mode.               \n| 0F 82 cd| JNAE rel32 | D    | Valid      | Valid          | Jump near if not above or equal (CF=1).     \n| 0F 83 cw| JNB rel16  | D    | N.S.       | Valid          | Jump near if not below (CF=0). Not supported\n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 83 cd| JNB rel32  | D    | Valid      | Valid          | Jump near if not below (CF=0).              \n| 0F 87 cw| JNBE rel16 | D    | N.S.       | Valid          | Jump near if not below or equal (CF=0       \n|         |            |      |            |                | and ZF=0). Not supported in 64-bit mode.    \n| 0F 87 cd| JNBE rel32 | D    | Valid      | Valid          | Jump near if not below or equal (CF=0       \n|         |            |      |            |                | and ZF=0).                                  \n| 0F 83 cw| JNC rel16  | D    | N.S.       | Valid          | Jump near if not carry (CF=0). Not supported\n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 83 cd| JNC rel32  | D    | Valid      | Valid          | Jump near if not carry (CF=0).              \n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                 \n| 0F 85 cw| JNE rel16  | D    | N.S.       | Valid          | Jump near if not equal (ZF=0). Not supported\n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 85 cd| JNE rel32  | D    | Valid      | Valid          | Jump near if not equal (ZF=0).              \n| 0F 8E cw| JNG rel16  | D    | N.S.       | Valid          | Jump near if not greater (ZF=1 or SF!=       \n|         |            |      |            |                | OF). Not supported in 64-bit mode.          \n| 0F 8E cd| JNG rel32  | D    | Valid      | Valid          | Jump near if not greater (ZF=1 or SF!=       \n|         |            |      |            |                | OF).                                        \n| 0F 8C cw| JNGE rel16 | D    | N.S.       | Valid          | Jump near if not greater or equal (SF!=      \n|         |            |      |            |                | OF). Not supported in 64-bit mode.          \n| 0F 8C cd| JNGE rel32 | D    | Valid      | Valid          | Jump near if not greater or equal (SF!=      \n|         |            |      |            |                | OF).                                        \n| 0F 8D cw| JNL rel16  | D    | N.S.       | Valid          | Jump near if not less (SF=OF). Not supported\n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 8D cd| JNL rel32  | D    | Valid      | Valid          | Jump near if not less (SF=OF).              \n| 0F 8F cw| JNLE rel16 | D    | N.S.       | Valid          | Jump near if not less or equal (ZF=0        \n|         |            |      |            |                | and SF=OF). Not supported in 64-bit         \n|         |            |      |            |                | mode.                                       \n| 0F 8F cd| JNLE rel32 | D    | Valid      | Valid          | Jump near if not less or equal (ZF=0        \n|         |            |      |            |                | and SF=OF).                                 \n| 0F 81 cw| JNO rel16  | D    | N.S.       | Valid          | Jump near if not overflow (OF=0). Not       \n|         |            |      |            |                | supported in 64-bit mode.                   \n| 0F 81 cd| JNO rel32  | D    | Valid      | Valid          | Jump near if not overflow (OF=0).           \n| 0F 8B cw| JNP rel16  | D    | N.S.       | Valid          | Jump near if not parity (PF=0). Not         \n|         |            |      |            |                | supported in 64-bit mode.                   \n| 0F 8B cd| JNP rel32  | D    | Valid      | Valid          | Jump near if not parity (PF=0).             \n| 0F 89 cw| JNS rel16  | D    | N.S.       | Valid          | Jump near if not sign (SF=0). Not supported \n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 89 cd| JNS rel32  | D    | Valid      | Valid          | Jump near if not sign (SF=0).               \n| 0F 85 cw| JNZ rel16  | D    | N.S.       | Valid          | Jump near if not zero (ZF=0). Not supported \n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 85 cd| JNZ rel32  | D    | Valid      | Valid          | Jump near if not zero (ZF=0).               \n| 0F 80 cw| JO rel16   | D    | N.S.       | Valid          | Jump near if overflow (OF=1). Not supported \n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 80 cd| JO rel32   | D    | Valid      | Valid          | Jump near if overflow (OF=1).               \n| 0F 8A cw| JP rel16   | D    | N.S.       | Valid          | Jump near if parity (PF=1). Not supported   \n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 8A cd| JP rel32   | D    | Valid      | Valid          | Jump near if parity (PF=1).                 \n| 0F 8A cw| JPE rel16  | D    | N.S.       | Valid          | Jump near if parity even (PF=1). Not        \n|         |            |      |            |                | supported in 64-bit mode.                   \n| 0F 8A cd| JPE rel32  | D    | Valid      | Valid          | Jump near if parity even (PF=1).            \n| 0F 8B cw| JPO rel16  | D    | N.S.       | Valid          | Jump near if parity odd (PF=0). Not         \n|         |            |      |            |                | supported in 64-bit mode.                   \n| 0F 8B cd| JPO rel32  | D    | Valid      | Valid          | Jump near if parity odd (PF=0).             \n| 0F 88 cw| JS rel16   | D    | N.S.       | Valid          | Jump near if sign (SF=1). Not supported     \n|         |            |      |            |                | in 64bit mode.                              \n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                 \n| 0F 88 cd| JS rel32   | D    | Valid      | Valid          | Jump near if sign (SF=1).                   \n| 0F 84 cw| JZ rel16   | D    | N.S.       | Valid          | Jump near if 0 (ZF=1). Not supported        \n|         |            |      |            |                | in 64-bit mode.                             \n| 0F 84 cd| JZ rel32   | D    | Valid      | Valid          | Jump near if 0 (ZF=1).                      \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| D    | Offset   | NA       | NA       | NA       \n\nDescription:\nChecks the state of one or more of the status flags in the EFLAGS register (CF,\nOF, PF, SF, and ZF) and, if the flags are in the specified state (condition),\nperforms a jump to the target instruction specified by the destination operand.\nA condition code (cc) is associated with each instruction to indicate the condition\nbeing tested for. If the condition is not satisfied, the jump is not performed\nand execution continues with the instruction following the Jcc instruction.\n\nThe target instruction is specified with a relative offset (a signed offset\nrelative to the current value of the instruction pointer in the EIP register).\nA relative offset (rel8, rel16, or rel32) is generally specified as a label\nin assembly code, but at the machine code level, it is encoded as a signed,\n8-bit or 32-bit immediate value, which is added to the instruction pointer.\nInstruction coding is most efficient for offsets of -128 to +127. If the operand-size\nattribute is 16, the upper two bytes of the EIP register are cleared, resulting\nin a maximum instruction pointer size of 16 bits.\n\nThe conditions for each Jcc mnemonic are given in the \u201cDescription\u201d column of\nthe table on the preceding page. The terms \u201cless\u201d and \u201cgreater\u201d are used for\ncomparisons of signed integers and the terms \u201cabove\u201d and \u201cbelow\u201d are used for\nunsigned integers.\n\nBecause a particular state of the status flags can sometimes be interpreted\nin two ways, two mnemonics are defined for some opcodes. For example, the JA\n(jump if above) instruction and the JNBE (jump if not below or equal) instruction\nare alternate mnemonics for the opcode 77H.\n\nThe Jcc instruction does not support far jumps (jumps to other code segments).\nWhen the target for the conditional jump is in a different segment, use the\nopposite condition from the condition being tested for the Jcc instruction,\nand then access the target with an unconditional far jump (JMP instruction)\nto the other segment. For example, the following conditional far jump is illegal:\nJZ FARLABEL;\n\nTo accomplish this far jump, use the following two instructions: JNZ BEYOND;\nJMP FARLABEL; BEYOND:\n\nThe JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because\nthey do not check status flags. Instead, they check RCX, ECX or CX for 0. The\nregister checked is determined by the address-size attribute. These instructions\nare useful when used at the beginning of a loop that terminates with a conditional\nloop instruction (such as LOOPNE). They can be used to prevent an instruction\nsequence from entering a loop when RCX, ECX or CX is 0. This would cause the\nloop to execute 264, 232 or 64K times (not zero times).\n\nAll conditional jumps are converted to code fetches of one or two cache lines,\nregardless of jump address or cacheability.\n\nIn 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit\noffset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign\nextended to 64-bits.\n\nOperation:\n\nIF condition\n  THEN\n     tempEIP <- EIP + SignExtend(DEST);\n     IF OperandSize = 16\n       THEN tempEIP <- tempEIP AND 0000FFFFH;\n     FI;\n  IF tempEIP is not within code segment limit\n     THEN #GP(0);\n     ELSE EIP <- tempEIP\n  FI;\nFI;\n\nProtected Mode Exceptions:\n| #GP(0)| If the offset being jumped to is beyond\n|       | the limits of the CS segment.          \n| #UD   | If the LOCK prefix is used.            \n\nReal-Address Mode Exceptions:\n| #GP| If the offset being jumped to is beyond   \n|    | the limits of the CS segment or is outside\n|    | of the effective address space from       \n|    | 0 to FFFFH. This condition can occur      \n|    | if a 32-bit address size override prefix  \n|    | is used.                                  \n| #UD| If the LOCK prefix is used.               \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in real address mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)| If the memory address is in a non-canonical\n|       | form.                                      \n| #UD   | If the LOCK prefix is used.                \n", 
      "mnem": "Jcc"
    }, 
    {
      "description": "\nLAHF - Load Status Flags into AH Register:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                             \n| 9F    | LAHF       | NP   | Invalid*   | Valid          | Load: AH \u2190 EFLAGS(SF:ZF:0:AF:0:PF:1:CF).\nNotes: *Valid in specific steppings. See Description section.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nThis instruction executes as described above in compatibility mode and legacy\nmode. It is valid in 64-bit mode only if CPUID.80000001H:ECX.LAHF-SAHF[bit 0]\n= 1.\n\nOperation:\n\nIF 64-Bit Mode\n  THEN\n     IF CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1;\n       THEN AH <- RFLAGS(SF:ZF:0:AF:0:PF:1:CF);\n       ELSE #UD;\n     FI;\n  ELSE\n     AH <- EFLAGS(SF:ZF:0:AF:0:PF:1:CF);\nFI;\n\nFlags Affected:\nNone. The state of the flags in the EFLAGS register is not affected.\n\n\nProtected Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #UD| If CPUID.80000001H:ECX.LAHF-SAHF[bit\n|    | 0] = 0. If the LOCK prefix is used. \n", 
      "mnem": "LAHF"
    }, 
    {
      "description": "\nLAR - Load Access Rights Byte:\n| Opcode  | Instruction      | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                              \n| 0F 02 /r| LAR r16, r16/m16 | RM   | Valid      | Valid          | r16 \u2190 access rights referenced by r16/m16\n| 0F 02 /r| LAR reg, r32/m161| RM   | Valid      | Valid          | reg \u2190 access rights referenced by r32/m16\nNotes: 1. For all loads (regardless of source or destination sizing) only bits\n16-0 are used. Other bits are ignored.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nLoads the access rights from the segment descriptor specified by the second\noperand (source operand) into the first operand (destination operand) and sets\nthe ZF flag in the flag register. The source operand (which can be a register\nor a memory location) contains the segment selector for the segment descriptor\nbeing accessed. If the source operand is a memory address, only 16 bits of data\nare accessed. The destination operand is a generalpurpose register.\n\nThe processor performs access checks as part of the loading process. Once loaded\nin the destination register, software can perform additional checks on the access\nrights information.\n\nThe access rights for a segment descriptor include fields located in the second\ndoubleword (bytes 4-7) of the segment descriptor. The following fields are loaded\nby the LAR instruction:\n\n - Bits 7:0 are returned as 0\n - Bits 11:8 return the segment type.\n - Bit 12 returns the S flag.\n - Bits 14:13 return the DPL.\n - Bit 15 returns the P flag.\n - The following fields are returned only if the operand size is greater than 16\nbits:  - Bits 19:16 are undefined.  - Bit 20 returns the software-available bit\nin the descriptor.  - Bit 21 returns the L flag.  - Bit 22 returns the D/B flag.\n - Bit 23 returns the G flag.  - Bits 31:24 are returned as 0.\n\nThis instruction performs the following checks before it loads the access rights\nin the destination register:\n\n - Checks that the segment selector is not NULL.\n - Checks that the segment selector points to a descriptor that is within the limits\nof the GDT or LDT being accessed\n - Checks that the descriptor type is valid for this instruction. All code and\ndata segment descriptors are valid for (can be accessed with) the LAR instruction.\nThe valid system segment and gate descriptor types are given in Table 3-62.\n - If the segment is not a conforming code segment, it checks that the specified\nsegment descriptor is visible at the CPL (that is, if the CPL and the RPL of\nthe segment selector are less than or equal to the DPL of the segment selector).\n\nIf the segment descriptor cannot be accessed or is an invalid type for the instruction,\nthe ZF flag is cleared and no access rights are loaded in the destination operand.\n\nThe LAR instruction can only be executed in protected mode and IA-32e mode.\n\n\nTable 3-62. Segment and Gate Types:\n| Type                   | Protected Mode Valid| IA-32e Mode Valid\n| Reserved               | No                  | No               \n| Available 16-bit TSS   | Yes                 | No               \n| LDT                    | Yes                 | No               \n| Busy 16-bit TSS        | Yes                 | No               \n| 16-bit call gate       | Yes                 | No               \n| 16-bit/32-bit task gate| Yes                 | No               \n| 16-bit interrupt gate  | No                  | No               \n| 16-bit trap gate       | No                  | No               \n| Reserved               | No                  | No               \n| Available 32-bit TSS   | Yes                 | Yes              \n| Reserved               | No                  | No               \n| Busy 32-bit TSS        | Yes                 | Yes              \n| 32-bit call gate       | Yes                 | Yes              \n| Reserved               | No                  | No               \n| 32-bit interrupt gate  | No                  | No               \n| 32-bit trap gate       | No                  | No               \nOperation:\n\nIF Offset(SRC) > descriptor table limit\n  THEN\n     ZF <- 0;\n  ELSE\n     SegmentDescriptor <- descriptor referenced by SRC;\n     IF SegmentDescriptor(Type) != conforming code segment\n     and (CPL > DPL) or (RPL > DPL)\n     or SegmentDescriptor(Type) is not valid for instruction\n       THEN\n          ZF <- 0;\n       ELSE\n          DEST <- access rights from SegmentDescriptor as given in Description section;\n          ZF <- 1;\n     FI;\nFI;\n\nFlags Affected:\nThe ZF flag is set to 1 if the access rights are loaded successfully; otherwise,\nit is cleared to 0.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address   \n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit. If the DS, ES, FS, or    \n|                | GS register is used to access memory    \n|                | and it contains a NULL segment selector.\n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | the memory operand effective address    \n|                | is unaligned while the current privilege\n|                | level is 3.                             \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #UD| The LAR instruction is not recognized\n|    | in real-address mode.                \n\nVirtual-8086 Mode Exceptions:\n| #UD| The LAR instruction cannot be executed\n|    | in virtual-8086 mode.                 \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If the memory operand effective address         \n|                | referencing the SS segment is in a non-canonical\n|                | form.                                           \n| #GP(0)         | If the memory operand effective address         \n|                | is in a non-canonical form.                     \n| #PF(fault-code)| If a page fault occurs.                         \n| #AC(0)         | If alignment checking is enabled and            \n|                | the memory operand effective address            \n|                | is unaligned while the current privilege        \n|                | level is 3.                                     \n| #UD            | If the LOCK prefix is used.                     \n", 
      "mnem": "LAR"
    }, 
    {
      "description": "\nLDDQU - Load Unaligned Integer 128 Bits:\n| Opcode/Instruction                  | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                            \n| F2 0F F0 /r LDDQU xmm1, mem         | RM   | V/V           | SSE3              | Load unaligned data from mem and return\n|                                     |      |               |                   | double quadword in xmm1.               \n| VEX.128.F2.0F.WIG F0 /r VLDDQU xmm1,| RM   | V/V           | AVX               | Load unaligned packed integer values   \n| m128                                |      |               |                   | from mem to xmm1.                      \n| VEX.256.F2.0F.WIG F0 /r VLDDQU ymm1,| RM   | V/V           | AVX               | Load unaligned packed integer values   \n| m256                                |      |               |                   | from mem to ymm1.                      \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nThe instruction is functionally similar to (V)MOVDQU ymm/xmm, m256/m128 for\nloading from memory. That is: 32/16 bytes of data starting at an address specified\nby the source memory operand (second operand) are fetched from memory and placed\nin a destination register (first operand). The source operand need not be aligned\non a 32/16-byte boundary. Up to 64/32 bytes may be loaded from memory; this\nis implementation dependent.\n\nThis instruction may improve performance relative to (V)MOVDQU if the source\noperand crosses a cache line boundary. In situations that require the data loaded\nby (V)LDDQU be modified and stored to the same location, use (V)MOVDQU or (V)MOVDQA\ninstead of (V)LDDQU. To move a double quadword to or from memory locations that\nare known to be aligned on 16-byte boundaries, use the (V)MOVDQA instruction.\n\n\nImplementation Notes:\n - If the source is aligned to a 32/16-byte boundary, based on the implementation,\nthe 32/16 bytes may be loaded more than once. For that reason, the usage of\n(V)LDDQU should be avoided when using uncached or write-combining (WC) memory\nregions. For uncached or WC memory regions, keep using (V)MOVDQU.\n - This instruction is a replacement for (V)MOVDQU (load) in situations where cache\nline splits significantly affect performance. It should not be used in situations\nwhere store-load forwarding is performance critical. If performance of store-load\nforwarding is critical to the application, use (V)MOVDQA store-load pairs when\ndata is 256/128-bit aligned or (V)MOVDQU store-load pairs when data is 256/128-bit\nunaligned.\n - If the memory address is not aligned on 32/16-byte boundary, some implementations\nmay load up to 64/32 bytes and return 32/16 bytes in the destination. Some processor\nimplementations may issue multiple loads to access the appropriate 32/16 bytes.\nDevelopers of multi-threaded or multi-processor software should be aware that\non these processors the loads will be performed in a non-atomic way.\n - If alignment checking is enabled (CR0.AM = 1, RFLAGS.AC = 1, and CPL = 3), an\nalignment-check exception (#AC) may or may not be generated (depending on processor\nimplementation) when the memory address is not aligned on an 8-byte boundary.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). Note: In VEX-encoded versions, VEX.vvvv is reserved\nand must be 1111b otherwise instructions will #UD.\n\nOperation:\n\nLDDQU (128-bit Legacy SSE version)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] (Unmodified)\nVLDDQU (VEX.128 encoded version)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] <- 0\nVLDDQU (VEX.256 encoded version)\nDEST[255:0] <- SRC[255:0]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| LDDQU:| __m128i _mm_lddqu_si128 (__m128i * p);\n| LDDQU:| __m256i _mm256_lddqu_si256 (__m256i   \n|       | * p);                                 \n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; Note treatment of #AC varies.\n\n", 
      "mnem": "LDDQU"
    }, 
    {
      "description": "\nLDMXCSR - Load MXCSR Register:\n| Opcode/Instruction              | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                  \n| 0F,AE,/2 LDMXCSR m32            | M    | V/V           | SSE               | Load MXCSR register from m32.\n| VEX.LZ.0F.WIG AE /2 VLDMXCSR m32| M    | V/V           | AVX               | Load MXCSR register from m32.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nLoads the source operand into the MXCSR control/status register. The source\noperand is a 32-bit memory location. See \u201cMXCSR Control and Status Register\u201d\nin Chapter 10, of the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 1, for a description of the MXCSR register and its contents.\n\nThe LDMXCSR instruction is typically used in conjunction with the (V)STMXCSR\ninstruction, which stores the contents of the MXCSR register in memory.\n\nThe default MXCSR value at reset is 1F80H.\n\nIf a (V)LDMXCSR instruction clears a SIMD floating-point exception mask bit\nand sets the corresponding exception flag bit, a SIMD floating-point exception\nwill not be immediately generated. The exception will be generated only upon\nthe execution of the next instruction that meets both conditions below:\n\n - the instruction must operate on an XMM or YMM register operand,\n - the instruction causes that particular SIMD floating-point exception to be reported.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\nIf VLDMXCSR is encoded with VEX.L= 1, an attempt to execute the instruction\nencoded with VEX.L= 1 will cause an #UD exception.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise\ninstructions will #UD.\n\nOperation:\n\nMXCSR <- m32;\n\nC/C++ Compiler Intrinsic Equivalent:\n_mm_setcsr(unsigned int i)\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #GP| For an attempt to set reserved bits\n|    | in MXCSR.                          \n| #UD| If VEX.vvvv != 1111B.              \n", 
      "mnem": "LDMXCSR"
    }, 
    {
      "description": "\nLDS/LES/LFS/LGS/LSS - Load Far Pointer:\n| Opcode        | Instruction   | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                              \n| C5 /r         | LDS r16,m16:16| RM   | Invalid    | Valid          | Load DS:r16 with far pointer from memory.\n| C5 /r         | LDS r32,m16:32| RM   | Invalid    | Valid          | Load DS:r32 with far pointer from memory.\n| 0F B2 /r      | LSS r16,m16:16| RM   | Valid      | Valid          | Load SS:r16 with far pointer from memory.\n| 0F B2 /r      | LSS r32,m16:32| RM   | Valid      | Valid          | Load SS:r32 with far pointer from memory.\n| REX + 0F B2 /r| LSS r64,m16:64| RM   | Valid      | N.E.           | Load SS:r64 with far pointer from memory.\n| C4 /r         | LES r16,m16:16| RM   | Invalid    | Valid          | Load ES:r16 with far pointer from memory.\n| C4 /r         | LES r32,m16:32| RM   | Invalid    | Valid          | Load ES:r32 with far pointer from memory.\n| 0F B4 /r      | LFS r16,m16:16| RM   | Valid      | Valid          | Load FS:r16 with far pointer from memory.\n| 0F B4 /r      | LFS r32,m16:32| RM   | Valid      | Valid          | Load FS:r32 with far pointer from memory.\n| REX + 0F B4 /r| LFS r64,m16:64| RM   | Valid      | N.E.           | Load FS:r64 with far pointer from memory.\n| 0F B5 /r      | LGS r16,m16:16| RM   | Valid      | Valid          | Load GS:r16 with far pointer from memory.\n| 0F B5 /r      | LGS r32,m16:32| RM   | Valid      | Valid          | Load GS:r32 with far pointer from memory.\n| REX + 0F B5 /r| LGS r64,m16:64| RM   | Valid      | N.E.           | Load GS:r64 with far pointer from memory.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nLoads a far pointer (segment selector and offset) from the second operand (source\noperand) into a segment register and the first operand (destination operand).\nThe source operand specifies a 48-bit or a 32-bit pointer in memory depending\non the current setting of the operand-size attribute (32 bits or 16 bits, respectively).\nThe instruction opcode and the destination operand specify a segment register/general-purpose\nregister pair. The 16bit segment selector from the source operand is loaded\ninto the segment register specified with the opcode (DS, SS, ES, FS, or GS).\nThe 32-bit or 16-bit offset is loaded into the register specified with the destination\noperand.\n\nIf one of these instructions is executed in protected mode, additional information\nfrom the segment descriptor pointed to by the segment selector in the source\noperand is loaded in the hidden part of the selected segment register.\n\nAlso in protected mode, a NULL selector (values 0000 through 0003) can be loaded\ninto DS, ES, FS, or GS registers without causing a protection exception. (Any\nsubsequent reference to a segment whose corresponding segment register is loaded\nwith a NULL selector, causes a general-protection exception (#GP) and no memory\nreference to the segment occurs.)\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.W promotes operation to specify a source operand\nreferencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory. Using\na REX prefix in the form of REX.R permits access to additional registers (R8-R15).\nSee the summary chart at the beginning of this section for encoding data and\nlimits.\n\nOperation:\n\n64-BIT_MODE\n  IF SS is loaded\n     THEN\n       IF SegmentSelector = NULL and ( (RPL = 3) or\n             (RPL != 3 and RPL != CPL) )\n          THEN #GP(0);\n       ELSE IF descriptor is in non-canonical space\n          THEN #GP(0); FI;\n       ELSE IF Segment selector index is not within descriptor table limits\n             or segment selector RPL != CPL\n             or access rights indicate nonwritable data segment\n             or DPL != CPL\n          THEN #GP(selector); FI;\n       ELSE IF Segment marked not present\n          THEN #SS(selector); FI;\n       FI;\n       SS <- SegmentSelector(SRC);\n       SS <- SegmentDescriptor([SRC]);\n  ELSE IF attempt to load DS, or ES\n     THEN #UD;\n  ELSE IF FS, or GS is loaded with non-NULL segment selector\n     THEN IF Segment selector index is not within descriptor table limits\n       or access rights indicate segment neither data nor readable code segment\n       or segment is data or nonconforming-code segment\n       and ( RPL > DPL or CPL > DPL)\n          THEN #GP(selector); FI;\n       ELSE IF Segment marked not present\n          THEN #NP(selector); FI;\n       FI;\n       SegmentRegister <- SegmentSelector(SRC) ;\n       SegmentRegister <- SegmentDescriptor([SRC]);\n     FI;\n  ELSE IF FS, or GS is loaded with a NULL selector:\n     THEN\n       SegmentRegister <- NULLSelector;\n       SegmentRegister(DescriptorValidBit) <- 0; FI; (* Hidden flag;\n          not accessible by software *)\n  FI;\n  DEST <- Offset(SRC);\nPREOTECTED MODE OR COMPATIBILITY MODE;\n  IF SS is loaded\n     THEN\n       IF SegementSelector = NULL\n          THEN #GP(0);\n       ELSE IF Segment selector index is not within descriptor table limits\n             or segment selector RPL != CPL\n             or access rights indicate nonwritable data segment\n             or DPL != CPL\n          THEN #GP(selector); FI;\n       ELSE IF Segment marked not present\n          THEN #SS(selector); FI;\n       FI;\n       SS <- SegmentSelector(SRC);\n       SS <- SegmentDescriptor([SRC]);\n  ELSE IF DS, ES, FS, or GS is loaded with non-NULL segment selector\n     THEN IF Segment selector index is not within descriptor table limits\n       or access rights indicate segment neither data nor readable code segment\n       or segment is data or nonconforming-code segment\n       and (RPL > DPL or CPL > DPL)\n          THEN #GP(selector); FI;\n       ELSE IF Segment marked not present\n          THEN #NP(selector); FI;\n       FI;\n       SegmentRegister <- SegmentSelector(SRC) AND RPL;\n       SegmentRegister <- SegmentDescriptor([SRC]);\n     FI;\n  ELSE IF DS, ES, FS, or GS is loaded with a NULL selector:\n     THEN\n       SegmentRegister <- NULLSelector;\n       SegmentRegister(DescriptorValidBit) <- 0; FI; (* Hidden flag;\n          not accessible by software *)\n  FI;\n  DEST <- Offset(SRC);\nReal-Address or Virtual-8086 Mode\n  SegmentRegister <- SegmentSelector(SRC); FI;\n  DEST <- Offset(SRC);\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #UD            | If source operand is not a memory location.   \n|                | If the LOCK prefix is used.                   \n| #GP(0)         | If a NULL selector is loaded into the         \n|                | SS register. If a memory operand effective    \n|                | address is outside the CS, DS, ES, FS,        \n|                | or GS segment limit. If the DS, ES,           \n|                | FS, or GS register is used to access          \n|                | memory and it contains a NULL segment         \n|                | selector.                                     \n| #GP(selector)  | If the SS register is being loaded and        \n|                | any of the following is true: the segment     \n|                | selector index is not within the descriptor   \n|                | table limits, the segment selector RPL        \n|                | is not equal to CPL, the segment is           \n|                | a non-writable data segment, or DPL           \n|                | is not equal to CPL. If the DS, ES,           \n|                | FS, or GS register is being loaded with       \n|                | a non-NULL segment selector and any           \n|                | of the following is true: the segment         \n|                | selector index is not within descriptor       \n|                | table limits, the segment is neither          \n|                | a data nor a readable code segment,           \n|                | or the segment is a data or nonconforming-code\n|                | segment and both RPL and CPL are greater      \n|                | than DPL.                                     \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #SS(selector)  | If the SS register is being loaded and        \n|                | the segment is marked not present.            \n| #NP(selector)  | If DS, ES, FS, or GS register is being        \n|                | loaded with a non-NULL segment selector       \n|                | and the segment is marked not present.        \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address      \n|    | is outside the CS, DS, ES, FS, or GS       \n|    | segment limit.                             \n| #SS| If a memory operand effective address      \n|    | is outside the SS segment limit.           \n| #UD| If source operand is not a memory location.\n|    | If the LOCK prefix is used.                \n\nVirtual-8086 Mode Exceptions:\n| #UD            | If source operand is not a memory location.\n|                | If the LOCK prefix is used.                \n| #GP(0)         | If a memory operand effective address      \n|                | is outside the CS, DS, ES, FS, or GS       \n|                | segment limit.                             \n| #SS(0)         | If a memory operand effective address      \n|                | is outside the SS segment limit.           \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made.     \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the memory address is in a non-canonical\n|                | form. If a NULL selector is attempted      \n|                | to be loaded into the SS register in       \n|                | compatibility mode. If a NULL selector     \n|                | is attempted to be loaded into the SS      \n|                | register in CPL3 and 64-bit mode. If       \n|                | a NULL selector is attempted to be loaded  \n|                | into the SS register in non-CPL3 and       \n|                | 64-bit mode where its RPL is not equal     \n|                | to CPL.                                    \n| #GP(Selector)  | If the FS, or GS register is being loaded  \n|                | with a non-NULL segment selector and       \n|                | any of the following is true: the segment  \n|                | selector index is not within descriptor    \n|                | table limits, the memory address of        \n|                | the descriptor is non-canonical, the       \n|                | segment is neither a data nor a readable   \n|                | code segment, or the segment is a data     \n|                | or nonconforming-code segment and both     \n|                | RPL and CPL are greater than DPL. If       \n|                | the SS register is being loaded and        \n|                | any of the following is true: the segment  \n|                | selector index is not within the descriptor\n|                | table limits, the memory address of        \n|                | the descriptor is non-canonical, the       \n|                | segment selector RPL is not equal to       \n|                | CPL, the segment is a nonwritable data     \n|                | segment, or DPL is not equal to CPL.       \n| #SS(0)         | If a memory operand effective address      \n|                | is non-canonical                           \n| #SS(Selector)  | If the SS register is being loaded and     \n|                | the segment is marked not present.         \n| #NP(selector)  | If FS, or GS register is being loaded      \n|                | with a non-NULL segment selector and       \n|                | the segment is marked not present.         \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If source operand is not a memory location.\n|                | If the LOCK prefix is used.                \n", 
      "mnem": "LDS"
    }, 
    {
      "description": "\nLEA - Load Effective Address:\n| Opcode       | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                              \n| 8D /r        | LEA r16,m  | RM   | Valid      | Valid          | Store effective address for m in register\n|              |            |      |            |                | r16.                                     \n| 8D /r        | LEA r32,m  | RM   | Valid      | Valid          | Store effective address for m in register\n|              |            |      |            |                | r32.                                     \n| REX.W + 8D /r| LEA r64,m  | RM   | Valid      | N.E.           | Store effective address for m in register\n|              |            |      |            |                | r64.                                     \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nComputes the effective address of the second operand (the source operand) and\nstores it in the first operand (destination operand). The source operand is\na memory address (offset part) specified with one of the processors addressing\nmodes; the destination operand is a general-purpose register. The address-size\nand operand-size attributes affect the action performed by this instruction,\nas shown in the following table. The operand-size attribute of the instruction\nis determined by the chosen register; the address-size attribute is determined\nby the attribute of the code segment.\n\n\nTable 3-63. Non-64-bit Mode LEA Operation with Address and Operand Size Attributes:\n| Operand Size 16 16 32 32| Address Size 16-bit effective address        | Action Performed\n|                         | is calculated and stored in requested        |                 \n|                         | 16-bit register destination. 32-bit          |                 \n|                         | effective address is calculated. The         |                 \n|                         | lower 16 bits of the address are stored      |                 \n|                         | in the requested 16-bit register destination.|                 \n|                         | 16-bit effective address is calculated.      |                 \n|                         | The 16-bit address is zero-extended          |                 \n|                         | and stored in the requested 32-bit register  |                 \n|                         | destination. 32-bit effective address        |                 \n|                         | is calculated and stored in the requested    |                 \n|                         | 32-bit register destination.                 |                 \nDifferent assemblers may use different algorithms based on the size attribute\nand symbolic reference of the source operand.\n\nIn 64-bit mode, the instruction's destination operand is governed by operand\nsize attribute, the default operand size is 32 bits. Address calculation is\ngoverned by address size attribute, the default address size is 64-bits. In\n64bit mode, address size of 16 bits is not encodable. See Table 3-64.\n\n\nTable 3-64. 64-bit Mode LEA Operation with Address and Operand Size Attributes:\n| Operand Size 16 16 32 32 64 64| Address Size 32-bit effective address       | Action Performed\n|                               | is calculated (using 67H prefix). The       |                 \n|                               | lower 16 bits of the address are stored     |                 \n|                               | in the requested 16-bit register destination|                 \n|                               | (using 66H prefix). 64-bit effective        |                 \n|                               | address is calculated (default address      |                 \n|                               | size). The lower 16 bits of the address     |                 \n|                               | are stored in the requested 16-bit register |                 \n|                               | destination (using 66H prefix). 32-bit      |                 \n|                               | effective address is calculated (using      |                 \n|                               | 67H prefix) and stored in the requested     |                 \n|                               | 32-bit register destination. 64-bit         |                 \n|                               | effective address is calculated (default    |                 \n|                               | address size) and the lower 32 bits         |                 \n|                               | of the address are stored in the requested  |                 \n|                               | 32-bit register destination. 32-bit         |                 \n|                               | effective address is calculated (using      |                 \n|                               | 67H prefix), zero-extended to 64-bits,      |                 \n|                               | and stored in the requested 64-bit register |                 \n|                               | destination (using REX.W). 64-bit effective |                 \n|                               | address is calculated (default address      |                 \n|                               | size) and all 64-bits of the address        |                 \n|                               | are stored in the requested 64-bit register |                 \n|                               | destination (using REX.W).                  |                 \nOperation:\n\nIF OperandSize = 16 and AddressSize = 16\n  THEN\n     DEST <- EffectiveAddress(SRC); (* 16-bit address *)\n  ELSE IF OperandSize = 16 and AddressSize = 32\n     THEN\n       temp <- EffectiveAddress(SRC); (* 32-bit address *)\n       DEST <- temp[0:15]; (* 16-bit address *)\n     FI;\n  ELSE IF OperandSize = 32 and AddressSize = 16\n     THEN\n       temp <- EffectiveAddress(SRC); (* 16-bit address *)\n       DEST <- ZeroExtend(temp); (* 32-bit address *)\n     FI;\n  ELSE IF OperandSize = 32 and AddressSize = 32\n     THEN\n       DEST <- EffectiveAddress(SRC); (* 32-bit address *)\n     FI;\n  ELSE IF OperandSize = 16 and AddressSize = 64\n     THEN\n       temp <- EffectiveAddress(SRC); (* 64-bit address *)\n       DEST <- temp[0:15]; (* 16-bit address *)\n     FI;\n  ELSE IF OperandSize = 32 and AddressSize = 64\n     THEN\n       temp <- EffectiveAddress(SRC); (* 64-bit address *)\n       DEST <- temp[0:31]; (* 16-bit address *)\n     FI;\n  ELSE IF OperandSize = 64 and AddressSize = 64\n     THEN\n       DEST <- EffectiveAddress(SRC); (* 64-bit address *)\n     FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #UD| If source operand is not a memory location.\n|    | If the LOCK prefix is used.                \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "LEA"
    }, 
    {
      "description": "\nLEAVE - High Level Procedure Exit:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                  \n| C9    | LEAVE      | NP   | Valid      | Valid          | Set SP to BP, then pop BP.   \n| C9    | LEAVE      | NP   | N.E.       | Valid          | Set ESP to EBP, then pop EBP.\n| C9    | LEAVE      | NP   | Valid      | N.E.           | Set RSP to RBP, then pop RBP.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nReleases the stack frame set up by an earlier ENTER instruction. The LEAVE instruction\ncopies the frame pointer (in the EBP register) into the stack pointer register\n(ESP), which releases the stack space allocated to the stack frame. The old\nframe pointer (the frame pointer for the calling procedure that was saved by\nthe ENTER instruction) is then popped from the stack into the EBP register,\nrestoring the calling procedure's stack frame.\n\nA RET instruction is commonly executed following a LEAVE instruction to return\nprogram control to the calling procedure.\n\nSee \u201cProcedure Calls for Block-Structured Languages\u201d in Chapter 7 of the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1, for detailed\ninformation on the use of the ENTER and LEAVE instructions.\n\nIn 64-bit mode, the instruction's default operation size is 64 bits; 32-bit\noperation cannot be encoded. See the summary chart at the beginning of this\nsection for encoding data and limits.\n\nOperation:\n\nIF StackAddressSize = 32\n  THEN\n     ESP <- EBP;\n  ELSE IF StackAddressSize = 64\n     THEN RSP <- RBP; FI;\n  ELSE IF StackAddressSize = 16\n     THEN SP <- BP; FI;\nFI;\nIF OperandSize = 32\n  THEN EBP <- Pop();\n  ELSE IF OperandSize = 64\n     THEN RBP <- Pop(); FI;\n  ELSE IF OperandSize = 16\n     THEN BP <- Pop(); FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #SS(0)         | If the EBP register points to a location\n|                | that is not within the limits of the    \n|                | current stack segment.                  \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made   \n|                | while the current privilege level is    \n|                | 3.                                      \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #GP| If the EBP register points to a location\n|    | outside of the effective address space  \n|    | from 0 to FFFFH.                        \n| #UD| If the LOCK prefix is used.             \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If the EBP register points to a location\n|                | outside of the effective address space  \n|                | from 0 to FFFFH.                        \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made.  \n| #UD            | If the LOCK prefix is used.             \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)| If the stack address is in a non-canonical\n|       | form.                                     \n| #AC(0)| If alignment checking is enabled and      \n|       | an unaligned memory reference is made     \n|       | while the current privilege level is      \n|       | 3.                                        \n| #UD   | If the LOCK prefix is used.               \n", 
      "mnem": "LEAVE"
    }, 
    {
      "description": "-R:LDS", 
      "mnem": "LES"
    }, 
    {
      "description": "\nLFENCE - Load Fence:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                \n| 0F AE /5| LFENCE     | NP   | Valid      | Valid          | Serializes load operations.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nPerforms a serializing operation on all load-from-memory instructions that were\nissued prior the LFENCE instruction. Specifically, LFENCE does not execute until\nall prior instructions have completed locally, and no later instruction begins\nexecution until LFENCE completes. In particular, an instruction that loads from\nmemory and that precedes an LFENCE receives data from memory prior to completion\nof the LFENCE. (An LFENCE that follows an instruction that stores to memory\nmight complete before the data being stored have become globally visible.) Instructions\nfollowing an LFENCE may be fetched from memory before the LFENCE, but they will\nnot execute until the LFENCE completes.\n\nWeakly ordered memory types can be used to achieve higher processor performance\nthrough such techniques as out-of-order issue and speculative reads. The degree\nto which a consumer of data recognizes or knows that the data is weakly ordered\nvaries among applications and may be unknown to the producer of this data. The\nLFENCE instruction provides a performance-efficient way of ensuring load ordering\nbetween routines that produce weaklyordered results and routines that consume\nthat data.\n\nProcessors are free to fetch and cache data speculatively from regions of system\nmemory that use the WB, WC, and WT memory types. This speculative fetching can\noccur at any time and is not tied to instruction execution. Thus, it is not\nordered with respect to executions of the LFENCE instruction; data can be brought\ninto the caches speculatively just before, during, or after the execution of\nan LFENCE instruction.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nWait_On_Following_Instructions_Until(preceding_instructions_complete);\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nvoid _mm_lfence(void)\n\n\nExceptions (All Modes of Operation):\n| #UD| If CPUID.01H:EDX.SSE2[bit 26] = 0. If\n|    | the LOCK prefix is used.             \n", 
      "mnem": "LFENCE"
    }, 
    {
      "description": "-R:LDS", 
      "mnem": "LFS"
    }, 
    {
      "description": "\nLGDT/LIDT - Load Global/Interrupt Descriptor Table Register:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description      \n| 0F 01 /2| LGDT m16&32| M    | N.E.       | Valid          | Load m into GDTR.\n| 0F 01 /3| LIDT m16&32| M    | N.E.       | Valid          | Load m into IDTR.\n| 0F 01 /2| LGDT m16&64| M    | Valid      | N.E.           | Load m into GDTR.\n| 0F 01 /3| LIDT m16&64| M    | Valid      | N.E.           | Load m into IDTR.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nLoads the values in the source operand into the global descriptor table register\n(GDTR) or the interrupt descriptor table register (IDTR). The source operand\nspecifies a 6-byte memory location that contains the base address (a linear\naddress) and the limit (size of table in bytes) of the global descriptor table\n(GDT) or the interrupt descriptor table (IDT). If operand-size attribute is\n32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32bit\nbase address (upper 4 bytes of the data operand) are loaded into the register.\nIf the operand-size attribute is 16 bits, a 16-bit limit (lower 2 bytes) and\na 24-bit base address (third, fourth, and fifth byte) are loaded. Here, the\nhigh-order byte of the operand is not used and the high-order byte of the base\naddress in the GDTR or IDTR is filled with zeros.\n\nThe LGDT and LIDT instructions are used only in operating-system software; they\nare not used in application programs. They are the only instructions that directly\nload a linear address (that is, not a segment-relative address) and a limit\nin protected mode. They are commonly executed in real-address mode to allow\nprocessor initialization prior to switching to protected mode.\n\nIn 64-bit mode, the instruction's operand size is fixed at 8+2 bytes (an 8-byte\nbase and a 2-byte limit). See the summary chart at the beginning of this section\nfor encoding data and limits.\n\nSee \u201cSGDT - Store Global Descriptor Table Register\u201d in Chapter 4, Intel\u00ae 64 and\nIA-32 Architectures Software Developer's Manual, Volume 2B, for information\non storing the contents of the GDTR and IDTR.\n\nOperation:\n\nIF Instruction is LIDT\n  THEN\n     IF OperandSize = 16\n       THEN\n          IDTR(Limit) <- SRC[0:15];\n          IDTR(Base) <- SRC[16:47] AND 00FFFFFFH;\n       ELSE IF 32-bit Operand Size\n          THEN\n             IDTR(Limit) <- SRC[0:15];\n             IDTR(Base) <- SRC[16:47];\n          FI;\n       ELSE IF 64-bit Operand Size (* In 64-Bit Mode *)\n          THEN\n             IDTR(Limit) <- SRC[0:15];\n             IDTR(Base) <- SRC[16:79];\n          FI;\n     FI;\n  ELSE (* Instruction is LGDT *)\n     IF OperandSize = 16\n       THEN\n          GDTR(Limit) <- SRC[0:15];\n          GDTR(Base) <- SRC[16:47] AND 00FFFFFFH;\n       ELSE IF 32-bit Operand Size\n          THEN\n             GDTR(Limit) <- SRC[0:15];\n             GDTR(Base) <- SRC[16:47];\n          FI;\n       ELSE IF 64-bit Operand Size (* In 64-Bit Mode *)\n          THEN\n             GDTR(Limit) <- SRC[0:15];\n             GDTR(Base) <- SRC[16:79];\n          FI;\n     FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #UD            | If source operand is not a memory location.\n|                | If the LOCK prefix is used.                \n| #GP(0)         | If the current privilege level is not      \n|                | 0. If a memory operand effective address   \n|                | is outside the CS, DS, ES, FS, or GS       \n|                | segment limit. If the DS, ES, FS, or       \n|                | GS register is used to access memory       \n|                | and it contains a NULL segment selector.   \n| #SS(0)         | If a memory operand effective address      \n|                | is outside the SS segment limit.           \n| #PF(fault-code)| If a page fault occurs.                    \n\nReal-Address Mode Exceptions:\n| #UD| If source operand is not a memory location.\n|    | If the LOCK prefix is used.                \n| #GP| If a memory operand effective address      \n|    | is outside the CS, DS, ES, FS, or GS       \n|    | segment limit.                             \n| #SS| If a memory operand effective address      \n|    | is outside the SS segment limit.           \n\nVirtual-8086 Mode Exceptions:\n| #UD   | If source operand is not a memory location.\n|       | If the LOCK prefix is used.                \n| #GP(0)| The LGDT and LIDT instructions are not     \n|       | recognized in virtual-8086 mode.           \n| #GP   | If the current privilege level is not      \n|       | 0.                                         \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the current privilege level is not         \n|                | 0. If the memory address is in a non-canonical\n|                | form.                                         \n| #UD            | If source operand is not a memory location.   \n|                | If the LOCK prefix is used.                   \n| #PF(fault-code)| If a page fault occurs.                       \n", 
      "mnem": "LGDT"
    }, 
    {
      "description": "-R:LDS", 
      "mnem": "LGS"
    }, 
    {
      "description": "-R:LGDT", 
      "mnem": "LIDT"
    }, 
    {
      "description": "\nLLDT - Load Local Descriptor Table Register:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| 0F 00 /2| LLDT r/m16 | M    | Valid      | Valid          | Load segment selector r/m16 into LDTR.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nLoads the source operand into the segment selector field of the local descriptor\ntable register (LDTR). The source operand (a general-purpose register or a memory\nlocation) contains a segment selector that points to a local descriptor table\n(LDT). After the segment selector is loaded in the LDTR, the processor uses\nthe segment selector to locate the segment descriptor for the LDT in the global\ndescriptor table (GDT). It then loads the segment limit and base address for\nthe LDT from the segment descriptor into the LDTR. The segment registers DS,\nES, SS, FS, GS, and CS are not affected by this instruction, nor is the LDTR\nfield in the task state segment (TSS) for the current task.\n\nIf bits 2-15 of the source operand are 0, LDTR is marked invalid and the LLDT\ninstruction completes silently. However, all subsequent references to descriptors\nin the LDT (except by the LAR, VERR, VERW or LSL instructions) cause a general\nprotection exception (#GP).\n\nThe operand-size attribute has no effect on this instruction.\n\nThe LLDT instruction is provided for use in operating-system software; it should\nnot be used in application programs. This instruction can only be executed in\nprotected mode or 64-bit mode.\n\nIn 64-bit mode, the operand size is fixed at 16 bits.\n\nOperation:\n\nIF SRC(Offset) > descriptor table limit\n  THEN #GP(segment selector); FI;\nIF segment selector is valid\n  Read segment descriptor;\n  IF SegmentDescriptor(Type) != LDT\n     THEN #GP(segment selector); FI;\n  IF segment descriptor is not present\n     THEN #NP(segment selector); FI;\n  LDTR(SegmentSelector) <- SRC;\n  LDTR(SegmentDescriptor) <- GDTSegmentDescriptor;\nELSE LDTR <- INVALID\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the current privilege level is not   \n|                | 0. If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit. If the DS, ES, FS, or    \n|                | GS register contains a NULL segment     \n|                | selector.                               \n| #GP(selector)  | If the selector operand does not point  \n|                | into the Global Descriptor Table or     \n|                | if the entry in the GDT is not a Local  \n|                | Descriptor Table. Segment selector is   \n|                | beyond GDT limit.                       \n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #NP(selector)  | If the LDT descriptor is not present.   \n| #PF(fault-code)| If a page fault occurs.                 \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #UD| The LLDT instruction is not recognized\n|    | in real-address mode.                 \n\nVirtual-8086 Mode Exceptions:\n| #UD| The LLDT instruction is not recognized\n|    | in virtual-8086 mode.                 \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the current privilege level is not         \n|                | 0. If the memory address is in a non-canonical\n|                | form.                                         \n| #GP(selector)  | If the selector operand does not point        \n|                | into the Global Descriptor Table or           \n|                | if the entry in the GDT is not a Local        \n|                | Descriptor Table. Segment selector is         \n|                | beyond GDT limit.                             \n| #NP(selector)  | If the LDT descriptor is not present.         \n| #PF(fault-code)| If a page fault occurs.                       \n| #UD            | If the LOCK prefix is used.                   \n", 
      "mnem": "LLDT"
    }, 
    {
      "description": "\nLMSW - Load Machine Status Word:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F 01 /6| LMSW r/m16 | M    | Valid      | Valid          | Loads r/m16 in machine status word of\n|         |            |      |            |                | CR0.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nLoads the source operand into the machine status word, bits 0 through 15 of\nregister CR0. The source operand can be a 16-bit general-purpose register or\na memory location. Only the low-order 4 bits of the source operand (which contains\nthe PE, MP, EM, and TS flags) are loaded into CR0. The PG, CD, NW, AM, WP, NE,\nand ET flags of CR0 are not affected. The operand-size attribute has no effect\non this instruction.\n\nIf the PE flag of the source operand (bit 0) is set to 1, the instruction causes\nthe processor to switch to protected mode. While in protected mode, the LMSW\ninstruction cannot be used to clear the PE flag and force a switch back to real-address\nmode.\n\nThe LMSW instruction is provided for use in operating-system software; it should\nnot be used in application programs. In protected or virtual-8086 mode, it can\nonly be executed at CPL 0.\n\nThis instruction is provided for compatibility with the Intel 286 processor;\nprograms and procedures intended to run on the Pentium 4, Intel Xeon, P6 family,\nPentium, Intel486, and Intel386 processors should use the MOV (control registers)\ninstruction to load the whole CR0 register. The MOV CR0 instruction can be used\nto set and clear the PE flag in CR0, allowing a procedure or program to switch\nbetween protected and real-address modes.\n\nThis instruction is a serializing instruction.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\nNote that the operand size is fixed at 16 bits.\n\nSee \u201cChanges to Instruction Behavior in VMX Non-Root Operation\u201d in Chapter 25\nof the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n3C, for more information about the behavior of this instruction in VMX non-root\noperation.\n\nOperation:\n\nCR0[0:3] <- SRC[0:3];\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the current privilege level is not   \n|                | 0. If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit. If the DS, ES, FS, or    \n|                | GS register is used to access memory    \n|                | and it contains a NULL segment selector.\n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #PF(fault-code)| If a page fault occurs.                 \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit.                       \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #UD            | If the LOCK prefix is used.          \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the current privilege level is not         \n|                | 0. If the memory address is in a non-canonical\n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #UD            | If the LOCK prefix is used.                   \n", 
      "mnem": "LMSW"
    }, 
    {
      "description": "\nLOCK - Assert LOCK# Signal Prefix:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                         \n| F0    | LOCK       | NP   | Valid      | Valid          | Asserts LOCK# signal for duration of\n|       |            |      |            |                | the accompanying instruction.       \nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nCauses the processor's LOCK# signal to be asserted during execution of the accompanying\ninstruction (turns the instruction into an atomic instruction). In a multiprocessor\nenvironment, the LOCK# signal ensures that the processor has exclusive use of\nany shared memory while the signal is asserted.\n\nNote that, in later Intel 64 and IA-32 processors (including the Pentium 4,\nIntel Xeon, and P6 family processors), locking may occur without the LOCK# signal\nbeing asserted. See the \u201cIA-32 Architecture Compatibility\u201d section below.\n\nThe LOCK prefix can be prepended only to the following instructions and only\nto those forms of the instructions where the destination operand is a memory\noperand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, CMPXCHG16B, DEC, INC,\nNEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. If the LOCK prefix is used with\none of these instructions and the source operand is a memory operand, an undefined\nopcode exception (#UD) may be generated. An undefined opcode exception will\nalso be generated if the LOCK prefix is used with any instruction not in the\nabove list. The XCHG instruction always asserts the LOCK# signal regardless\nof the presence or absence of the LOCK prefix.\n\nThe LOCK prefix is typically used with the BTS instruction to perform a read-modify-write\noperation on a memory location in shared memory environment.\n\nThe integrity of the LOCK prefix is not affected by the alignment of the memory\nfield. Memory locking is observed for arbitrarily misaligned fields.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nIA-32 Architecture Compatibility:\nBeginning with the P6 family processors, when the LOCK prefix is prefixed to\nan instruction and the memory area being accessed is cached internally in the\nprocessor, the LOCK# signal is generally not asserted. Instead, only the processor's\ncache is locked. Here, the processor's cache coherency mechanism ensures that\nthe operation is carried out atomically with regards to memory. See \u201cEffects\nof a Locked Operation on Internal Processor Caches\u201din Chapter 8 of Intel\u00ae 64\nand IA-32 Architectures Software Developer's Manual, Volume 3A, the for more\ninformation on locking of caches.\n\nOperation:\n\nAssertLOCK#(DurationOfAccompaningInstruction);\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #UD| If the LOCK prefix is used with an instruction\n|    | not listed: ADD, ADC, AND, BTC, BTR,          \n|    | BTS, CMPXCHG, CMPXCH8B, CMPXCHG16B,           \n|    | DEC, INC, NEG, NOT, OR, SBB, SUB, XOR,        \n|    | XADD, XCHG. Other exceptions can be           \n|    | generated by the instruction when the         \n|    | LOCK prefix is applied.                       \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "LOCK"
    }, 
    {
      "description": "\nLODS/LODSB/LODSW/LODSD/LODSQ - Load String:\n| Opcode    | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                            \n| AC        | LODS m8    | NP   | Valid      | Valid          | For legacy mode, Load byte at address  \n|           |            |      |            |                | DS:(E)SI into AL. For 64-bit mode load \n|           |            |      |            |                | byte at address (R)SI into AL.         \n| AD        | LODS m16   | NP   | Valid      | Valid          | For legacy mode, Load word at address  \n|           |            |      |            |                | DS:(E)SI into AX. For 64-bit mode load \n|           |            |      |            |                | word at address (R)SI into AX.         \n| AD        | LODS m32   | NP   | Valid      | Valid          | For legacy mode, Load dword at address \n|           |            |      |            |                | DS:(E)SI into EAX. For 64-bit mode load\n|           |            |      |            |                | dword at address (R)SI into EAX.       \n| REX.W + AD| LODS m64   | NP   | Valid      | N.E.           | Load qword at address (R)SI into RAX.  \n| AC        | LODSB      | NP   | Valid      | Valid          | For legacy mode, Load byte at address  \n|           |            |      |            |                | DS:(E)SI into AL. For 64-bit mode load \n|           |            |      |            |                | byte at address (R)SI into AL.         \n| AD        | LODSW      | NP   | Valid      | Valid          | For legacy mode, Load word at address  \n|           |            |      |            |                | DS:(E)SI into AX. For 64-bit mode load \n|           |            |      |            |                | word at address (R)SI into AX.         \n| AD        | LODSD      | NP   | Valid      | Valid          | For legacy mode, Load dword at address \n|           |            |      |            |                | DS:(E)SI into EAX. For 64-bit mode load\n|           |            |      |            |                | dword at address (R)SI into EAX.       \n| REX.W + AD| LODSQ      | NP   | Valid      | N.E.           | Load qword at address (R)SI into RAX.  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nLoads a byte, word, or doubleword from the source operand into the AL, AX, or\nEAX register, respectively. The source operand is a memory location, the address\nof which is read from the DS:ESI or the DS:SI registers (depending on the address-size\nattribute of the instruction, 32 or 16, respectively). The DS segment may be\noverridden with a segment override prefix.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \u201cexplicit-operands\u201d\nform and the \u201cnooperands\u201d form. The explicit-operands form (specified with the\nLODS mnemonic) allows the source operand to be specified explicitly. Here, the\nsource operand should be a symbol that indicates the size and location of the\nsource value. The destination operand is then automatically selected to match\nthe size of the source operand (the AL register for byte operands, AX for word\noperands, and EAX for doubleword operands). This explicit-operands form is provided\nto allow documentation; however, note that the documentation provided by this\nform can be misleading. That is, the source operand symbol must specify the\ncorrect type (size) of the operand (byte, word, or doubleword), but it does\nnot have to specify the correct location. The location is always specified by\nthe DS:(E)SI registers, which must be loaded correctly before the load string\ninstruction is executed.\n\nThe no-operands form provides \u201cshort forms\u201d of the byte, word, and doubleword\nversions of the LODS instructions. Here also DS:(E)SI is assumed to be the source\noperand and the AL, AX, or EAX register is assumed to be the destination operand.\nThe size of the source and destination operands is selected with the mnemonic:\nLODSB (byte loaded into register AL), LODSW (word loaded into AX), or LODSD\n(doubleword loaded into EAX).\n\nAfter the byte, word, or doubleword is transferred from the memory location\ninto the AL, AX, or EAX register, the (E)SI register is incremented or decremented\nautomatically according to the setting of the DF flag in the EFLAGS register.\n(If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1,\nthe ESI register is decremented.) The (E)SI register is incremented or decremented\nby 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.\n\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ\nload the quadword at address (R)SI into RAX. The (R)SI register is then incremented\nor decremented automatically according to the setting of the DF flag in the\nEFLAGS register.\n\nThe LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix\nfor block loads of ECX bytes, words, or doublewords. More often, however, these\ninstructions are used within a LOOP construct because\n\n| further processing of the data moved        | usually necessary before the next transfer\n| into the register is See \u201cREP/REPE/REPZ     | can be made.                              \n| /REPNE/REPNZ - Repeat String Operation        |                                           \n| Prefix\u201d in Chapter 4 of the Intel\u00ae 64       |                                           \n| and IA-32 Architectures Software Developer's|                                           \n| Manual, Volume 2B, for a description        |                                           \n| of the REP prefix.                          |                                           \nOperation:\n\nIF AL <- SRC; (* Byte load *)\n  THEN AL <- SRC; (* Byte load *)\n     IF DF = 0\n       THEN (E)SI <- (E)SI + 1;\n       ELSE (E)SI <- (E)SI - 1;\n     FI;\nELSE IF AX <- SRC; (* Word load *)\n  THEN IF DF = 0\n       THEN (E)SI <- (E)SI + 2;\n       ELSE (E)SI <- (E)SI - 2;\n     IF;\n  FI;\nELSE IF EAX <- SRC; (* Doubleword load *)\n  THEN IF DF = 0\n       THEN (E)SI <- (E)SI + 4;\n       ELSE (E)SI <- (E)SI - 4;\n     FI;\n  FI;\nELSE IF RAX <- SRC; (* Quadword load *)\n  THEN IF DF = 0\n       THEN (R)SI <- (R)SI + 8;\n       ELSE (R)SI <- (R)SI - 8;\n     FI;\n  FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "LODS"
    }, 
    {
      "description": "-R:LODS", 
      "mnem": "LODSB"
    }, 
    {
      "description": "-R:LODS", 
      "mnem": "LODSD"
    }, 
    {
      "description": "-R:LODS", 
      "mnem": "LODSQ"
    }, 
    {
      "description": "-R:LODS", 
      "mnem": "LODSW"
    }, 
    {
      "description": "\nLOOP/LOOPcc - Loop According to ECX Counter:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                         \n| E2 cb | LOOP rel8  | D    | Valid      | Valid          | Decrement count; jump short if count\n|       |            |      |            |                | != 0.                                \n| E1 cb | LOOPE rel8 | D    | Valid      | Valid          | Decrement count; jump short if count\n|       |            |      |            |                | != 0 and ZF = 1.                     \n| E0 cb | LOOPNE rel8| D    | Valid      | Valid          | Decrement count; jump short if count\n|       |            |      |            |                | != 0 and ZF = 0.                     \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| D    | Offset   | NA       | NA       | NA       \n\nDescription:\nPerforms a loop operation using the RCX, ECX or CX register as a counter (depending\non whether address size is 64 bits, 32 bits, or 16 bits). Note that the LOOP\ninstruction ignores REX.W; but 64-bit address size can be over-ridden using\na 67H prefix.\n\nEach time the LOOP instruction is executed, the count register is decremented,\nthen checked for 0. If the count is 0, the loop is terminated and program execution\ncontinues with the instruction following the LOOP instruction. If the count\nis not zero, a near jump is performed to the destination (target) operand, which\nis presumably the instruction at the beginning of the loop.\n\nThe target instruction is specified with a relative offset (a signed offset\nrelative to the current value of the instruction pointer in the IP/EIP/RIP register).\nThis offset is generally specified as a label in assembly code, but at the machine\ncode level, it is encoded as a signed, 8-bit immediate value, which is added\nto the instruction pointer. Offsets of -128 to +127 are allowed with this instruction.\n\nSome forms of the loop instruction (LOOPcc) also accept the ZF flag as a condition\nfor terminating the loop before the count reaches zero. With these forms of\nthe instruction, a condition code (cc) is associated with each instruction to\nindicate the condition being tested for. Here, the LOOPcc instruction itself\ndoes not affect the state of the ZF flag; the ZF flag is changed by other instructions\nin the loop.\n\nOperation:\n\nIF (AddressSize = 32)\n  THEN Count is ECX;\nELSE IF (AddressSize = 64)\n  Count is RCX;\nELSE Count is CX;\nFI;\nCount <- Count - 1;\nIF Instruction is not LOOP\n  THEN\n     IF (Instruction <- LOOPE) or (Instruction <- LOOPZ)\n       THEN IF (ZF = 1) and (Count != 0)\n             THEN BranchCond <- 1;\n             ELSE BranchCond <- 0;\n          FI;\n       ELSE (Instruction = LOOPNE) or (Instruction = LOOPNZ)\n          IF (ZF = 0 ) and (Count != 0)\n             THEN BranchCond <- 1;\n             ELSE BranchCond <- 0;\n          FI;\n     FI;\n  ELSE (* Instruction = LOOP *)\n     IF (Count != 0)\n       THEN BranchCond <- 1;\n       ELSE BranchCond <- 0;\n     FI;\nFI;\nIF BranchCond = 1\n  THEN\n     IF OperandSize = 32\n       THEN EIP <- EIP + SignExtend(DEST);\n       ELSE IF OperandSize = 64\n          THEN RIP <- RIP + SignExtend(DEST);\n          FI;\n       ELSE IF OperandSize = 16\n          THEN EIP <- EIP AND 0000FFFFH;\n          FI;\n     FI;\n     IF OperandSize = (32 or 64)\n       THEN IF (R/E)IP < CS.Base or (R/E)IP > CS.Limit\n          #GP; FI;\n          FI;\n     FI;\n  ELSE\n     Terminate loop and continue program execution at (R/E)IP;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the offset being jumped to is beyond\n|       | the limits of the CS segment.          \n| #UD   | If the LOCK prefix is used.            \n\nReal-Address Mode Exceptions:\n| #GP| If the offset being jumped to is beyond   \n|    | the limits of the CS segment or is outside\n|    | of the effective address space from       \n|    | 0 to FFFFH. This condition can occur      \n|    | if a 32-bit address size override prefix  \n|    | is used.                                  \n| #UD| If the LOCK prefix is used.               \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in real address mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)| If the offset being jumped to is in\n|       | a non-canonical form.              \n| #UD   | If the LOCK prefix is used.        \n", 
      "mnem": "LOOP"
    }, 
    {
      "description": "-R:LOOP", 
      "mnem": "LOOPcc"
    }, 
    {
      "description": "\nLSL - Load Segment Limit:\n| Opcode          | Instruction      | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                        \n| 0F 03 /r        | LSL r16, r16/m16 | RM   | Valid      | Valid          | Load: r16 \u2190 segment limit, selector\n|                 |                  |      |            |                | r16/m16.                           \n| 0F 03 /r        | LSL r32, r32/m16*| RM   | Valid      | Valid          | Load: r32 \u2190 segment limit, selector\n|                 |                  |      |            |                | r32/m16.                           \n| REX.W + 0F 03 /r| LSL r64, r32/m16*| RM   | Valid      | Valid          | Load: r64 \u2190 segment limit, selector\n|                 |                  |      |            |                | r32/m16                            \nNotes: * For all loads (regardless of destination sizing), only bits 16-0 are\nused. Other bits are ignored.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nLoads the unscrambled segment limit from the segment descriptor specified with\nthe second operand (source operand) into the first operand (destination operand)\nand sets the ZF flag in the EFLAGS register. The source operand (which can be\na register or a memory location) contains the segment selector for the segment\ndescriptor being accessed. The destination operand is a general-purpose register.\n\nThe processor performs access checks as part of the loading process. Once loaded\nin the destination register, software can compare the segment limit with the\noffset of a pointer.\n\nThe segment limit is a 20-bit value contained in bytes 0 and 1 and in the first\n4 bits of byte 6 of the segment descriptor. If the descriptor has a byte granular\nsegment limit (the granularity flag is set to 0), the destination operand is\nloaded with a byte granular value (byte limit). If the descriptor has a page\ngranular segment limit (the granularity flag is set to 1), the LSL instruction\nwill translate the page granular limit (page limit) into a byte limit before\nloading it into the destination operand. The translation is performed by shifting\nthe 20-bit \u201craw\u201d limit left 12 bits and filling the low-order 12 bits with 1s.\n\nWhen the operand size is 32 bits, the 32-bit byte limit is stored in the destination\noperand. When the operand size is 16 bits, a valid 32-bit limit is computed;\nhowever, the upper 16 bits are truncated and only the low-order 16 bits are\nloaded into the destination operand.\n\nThis instruction performs the following checks before it loads the segment limit\ninto the destination register:\n\n - Checks that the segment selector is not NULL.\n - Checks that the segment selector points to a descriptor that is within the limits\nof the GDT or LDT being accessed\n - Checks that the descriptor type is valid for this instruction. All code and\ndata segment descriptors are valid for (can be accessed with) the LSL instruction.\nThe valid special segment and gate descriptor types are given in the following\ntable.\n - If the segment is not a conforming code segment, the instruction checks that\nthe specified segment descriptor is visible at the CPL (that is, if the CPL\nand the RPL of the segment selector are less than or equal to the DPL of the\nsegment selector).\n\nIf the segment descriptor cannot be accessed or is an invalid type for the instruction,\nthe ZF flag is cleared and no value is loaded in the destination operand.\n\n\nTable 3-65. Segment and Gate Descriptor Types:\n| Type                   | Protected Mode Valid| IA-32e Mode Valid\n| Reserved               | No                  | Yes descriptor   \n| Available 16-bit TSS   | Yes                 | No               \n| LDT                    | Yes                 | Yes              \n| Busy 16-bit TSS        | Yes                 | No               \n| 16-bit call gate       | No                  | No               \n| 16-bit/32-bit task gate| No                  | No               \n| 16-bit interrupt gate  | No                  | No               \n| 16-bit trap gate       | No                  | No               \n| Reserved               | No                  | No               \n| Available 32-bit TSS   | Yes                 | Yes              \n| Reserved               | No                  | No               \n| Busy 32-bit TSS        | Yes                 | Yes              \n| 32-bit call gate       | No                  | No               \n| Reserved               | No                  | No               \n| 32-bit interrupt gate  | No                  | No               \n| 32-bit trap gate       | No                  | No               \nOperation:\n\nIF SRC(Offset) > descriptor table limit\n  THEN ZF <- 0; FI;\nRead segment descriptor;\nIF SegmentDescriptor(Type) != conforming code segment\nand (CPL > DPL) OR (RPL > DPL)\nor Segment type is not valid for instruction\n     THEN\n       ZF <- 0;\n     ELSE\n       temp <- SegmentLimit([SRC]);\n       IF (G <- 1)\n          THEN temp <- ShiftLeft(12, temp) OR 00000FFFH;\n       ELSE IF OperandSize = 32\n          THEN DEST <- temp; FI;\n       ELSE IF OperandSize = 64 (* REX.W used *)\n          THEN DEST (* Zero-extended *) <- temp; FI;\n       ELSE (* OperandSize = 16 *)\n          DEST <- temp AND FFFFH;\n       FI;\nFI;\n\nFlags Affected:\nThe ZF flag is set to 1 if the segment limit is loaded successfully; otherwise,\nit is set to 0.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address   \n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit. If the DS, ES, FS, or    \n|                | GS register is used to access memory    \n|                | and it contains a NULL segment selector.\n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | the memory operand effective address    \n|                | is unaligned while the current privilege\n|                | level is 3.                             \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #UD| The LSL instruction cannot be executed\n|    | in real-address mode.                 \n\nVirtual-8086 Mode Exceptions:\n| #UD| The LSL instruction cannot be executed\n|    | in virtual-8086 mode.                 \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If the memory operand effective address         \n|                | referencing the SS segment is in a non-canonical\n|                | form.                                           \n| #GP(0)         | If the memory operand effective address         \n|                | is in a non-canonical form.                     \n| #PF(fault-code)| If a page fault occurs.                         \n| #AC(0)         | If alignment checking is enabled and            \n|                | the memory operand effective address            \n|                | is unaligned while the current privilege        \n|                | level is 3.                                     \n| #UD            | If the LOCK prefix is used.                     \n", 
      "mnem": "LSL"
    }, 
    {
      "description": "-R:LDS", 
      "mnem": "LSS"
    }, 
    {
      "description": "\nLTR - Load Task Register:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                   \n| 0F 00 /3| LTR r/m16  | M    | Valid      | Valid          | Load r/m16 into task register.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nLoads the source operand into the segment selector field of the task register.\nThe source operand (a generalpurpose register or a memory location) contains\na segment selector that points to a task state segment (TSS). After the segment\nselector is loaded in the task register, the processor uses the segment selector\nto locate the segment descriptor for the TSS in the global descriptor table\n(GDT). It then loads the segment limit and base address for the TSS from the\nsegment descriptor into the task register. The task pointed to by the task register\nis marked busy, but a switch to the task does not occur.\n\nThe LTR instruction is provided for use in operating-system software; it should\nnot be used in application programs. It can only be executed in protected mode\nwhen the CPL is 0. It is commonly used in initialization code to establish the\nfirst task to be executed.\n\nThe operand-size attribute has no effect on this instruction.\n\nIn 64-bit mode, the operand size is still fixed at 16 bits. The instruction\nreferences a 16-byte descriptor to load the 64-bit base.\n\nOperation:\n\nIF SRC is a NULL selector\n  THEN #GP(0);\nIF SRC(Offset) > descriptor table limit OR IF SRC(type) != global\n  THEN #GP(segment selector); FI;\nRead segment descriptor;\nIF segment descriptor is not for an available TSS\n  THEN #GP(segment selector); FI;\nIF segment descriptor is not present\n  THEN #NP(segment selector); FI;\nTSSsegmentDescriptor(busy) <- 1;\n(* Locked read-modify-write operation on the entire descriptor when setting busy flag *)\nTaskRegister(SegmentSelector) <- SRC;\nTaskRegister(SegmentDescriptor) <- TSSSegmentDescriptor;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the current privilege level is not     \n|                | 0. If a memory operand effective address  \n|                | is outside the CS, DS, ES, FS, or GS      \n|                | segment limit. If the source operand      \n|                | contains a NULL segment selector. If      \n|                | the DS, ES, FS, or GS register is used    \n|                | to access memory and it contains a NULL   \n|                | segment selector.                         \n| #GP(selector)  | If the source selector points to a segment\n|                | that is not a TSS or to one for a task    \n|                | that is already busy. If the selector     \n|                | points to LDT or is beyond the GDT limit. \n| #NP(selector)  | If the TSS is marked not present.         \n| #SS(0)         | If a memory operand effective address     \n|                | is outside the SS segment limit.          \n| #PF(fault-code)| If a page fault occurs.                   \n| #UD            | If the LOCK prefix is used.               \n\nReal-Address Mode Exceptions:\n| #UD| The LTR instruction is not recognized\n|    | in real-address mode.                \n\nVirtual-8086 Mode Exceptions:\n| #UD| The LTR instruction is not recognized\n|    | in virtual-8086 mode.                \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the current privilege level is not         \n|                | 0. If the memory address is in a non-canonical\n|                | form. If the source operand contains          \n|                | a NULL segment selector.                      \n| #GP(selector)  | If the source selector points to a segment    \n|                | that is not a TSS or to one for a task        \n|                | that is already busy. If the selector         \n|                | points to LDT or is beyond the GDT limit.     \n|                | If the descriptor type of the upper           \n|                | 8-byte of the 16-byte descriptor is           \n|                | non-zero.                                     \n| #NP(selector)  | If the TSS is marked not present.             \n| #PF(fault-code)| If a page fault occurs.                       \n| #UD            | If the LOCK prefix is used.                   \n", 
      "mnem": "LTR"
    }, 
    {
      "description": "\nLZCNT -  Count the Number of Leading Zero Bits:\n| Opcode/Instruction                  | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                          \n| F3 0F BD /r LZCNT r16, r/m16        | RM   | V/V            | LZCNT             | Count the number of leading zero bits\n|                                     |      |                |                   | in r/m16, return result in r16.      \n| F3 0F BD /r LZCNT r32, r/m32        | RM   | V/V            | LZCNT             | Count the number of leading zero bits\n|                                     |      |                |                   | in r/m32, return result in r32.      \n| REX.W + F3 0F BD /r LZCNT r64, r/m64| RM   | V/N.E.         | LZCNT             | Count the number of leading zero bits\n|                                     |      |                |                   | in r/m64, return result in r64.      \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nCounts the number of leading most significant zero bits in a source operand\n(second operand) returning the result into a destination (first operand). LZCNT\ndiffers from BSR. For example, LZCNT will produce the operand size when the\ninput operand is zero. It should be noted that on processors that do not support\nLZCNT, the instruction byte encoding is executed as BSR. In 64-bit mode 64-bit\noperand size requires REX.W=1.\n\nOperation:\n\ntemp <- OperandSize - 1\nDEST <- 0\nWHILE (temp >= 0) AND (Bit(SRC, temp) = 0)\nDO\n  temp <- temp - 1\n  DEST <- DEST+ 1\nOD\nIF DEST = OperandSize\n  CF <- 1\nELSE\n  CF <- 0\nFI\nIF DEST = 0\n  ZF <- 1\nELSE\n  ZF <- 0\nFI\n\nFlags Affected:\nZF flag is set to 1 in case of zero output (most significant bit of the source\nis set), and to 0 otherwise, CF flag is set to 1 if input was zero and cleared\notherwise. OF, SF, PF and AF flags are undefined.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| LZCNT:| unsigned __int32 _lzcnt_u32(unsigned\n|       | __int32 src);                       \n| LZCNT:| unsigned __int64 _lzcnt_u64(unsigned\n|       | __int64 src);                       \n\nProtected Mode Exceptions:\n| #GP(0)          | For an illegal memory operand effective    \n|                 | address in the CS, DS, ES, FS or GS        \n|                 | segments. If the DS, ES, FS, or GS register\n|                 | is used to access memory and it contains   \n|                 | a null segment selector.                   \n| #SS(0)          | For an illegal address in the SS segment.  \n| #PF (fault-code)| For a page fault.                          \n| #AC(0)          | If alignment checking is enabled and       \n|                 | an unaligned memory reference is made      \n|                 | while the current privilege level is       \n|                 | 3.                                         \n\nReal-Address Mode Exceptions:\n| #GP(0)| If any part of the operand lies outside  \n|       | of the effective address space from      \n|       | 0 to 0FFFFH.                             \n| #SS(0)| For an illegal address in the SS segment.\n\nVirtual 8086 Mode Exceptions:\n| #GP(0)          | If any part of the operand lies outside  \n|                 | of the effective address space from      \n|                 | 0 to 0FFFFH.                             \n| #SS(0)          | For an illegal address in the SS segment.\n| #PF (fault-code)| For a page fault.                        \n| #AC(0)          | If alignment checking is enabled and     \n|                 | an unaligned memory reference is made    \n|                 | while the current privilege level is     \n|                 | 3.                                       \n\nCompatibility Mode Exceptions:\nSame exceptions as in Protected Mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)          | If the memory address is in a non-canonical\n|                 | form.                                      \n| #SS(0)          | If a memory address referencing the        \n|                 | SS segment is in a non-canonical form.     \n| #PF (fault-code)| For a page fault.                          \n| #AC(0)          | If alignment checking is enabled and       \n|                 | an unaligned memory reference is made      \n|                 | while the current privilege level is       \n|                 | 3.                                         \n", 
      "mnem": "LZCNT"
    }, 
    {
      "description": "\nMASKMOVDQU - Store Selected Bytes of Double Quadword:\n| Opcode/Instruction                 | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                         \n| 66 0F F7 /r MASKMOVDQU xmm1, xmm2  | RM   | V/V           | SSE2              | Selectively write bytes from xmm1 to\n|                                    |      |               |                   | memory location using the byte mask \n|                                    |      |               |                   | in xmm2. The default memory location\n|                                    |      |               |                   | is specified by DS:DI/EDI/RDI.      \n| VEX.128.66.0F.WIG F7 /r VMASKMOVDQU| RM   | V/V           | AVX               | Selectively write bytes from xmm1 to\n| xmm1, xmm2                         |      |               |                   | memory location using the byte mask \n|                                    |      |               |                   | in xmm2. The default memory location\n|                                    |      |               |                   | is specified by DS:DI/EDI/RDI.      \n\nInstruction Operand Encoding1:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nStores selected bytes from the source operand (first operand) into an 128-bit\nmemory location. The mask operand (second operand) selects which bytes from\nthe source operand are written to memory. The source and mask operands are XMM\nregisters. The memory location specified by the effective address in the DI/EDI/RDI\nregister (the default segment register is DS, but this may be overridden with\na segment-override prefix). The memory location does not need to be aligned\non a natural boundary. (The size of the store address depends on the address-size\nattribute.)\n\nThe most significant bit in each byte of the mask operand determines whether\nthe corresponding byte in the source operand is written to the corresponding\nbyte location in memory: 0 indicates no write and 1 indicates write.\n\nThe MASKMOVDQU instruction generates a non-temporal hint to the processor to\nminimize cache pollution. The non-temporal hint is implemented by using a write\ncombining (WC) memory type protocol (see \u201cCaching of Temporal vs. Non-Temporal\nData\u201d in Chapter 10, of the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 1). Because the WC protocol uses a weakly-ordered memory consistency\nmodel, a fencing operation implemented with the SFENCE or MFENCE instruction\nshould be used in conjunction with MASKMOVDQU instructions if multiple processors\nmight use different memory types to read/write the destination memory locations.\n\nBehavior with a mask of all 0s is as follows:\n\n - No data will be written to memory.\n - Signaling of breakpoints (code or data) is not guaranteed; different processor\nimplementations may signal or not signal these breakpoints.\n - Exceptions associated with addressing memory and page faults may still be signaled\n(implementation dependent).\n - If the destination memory region is mapped as UC or WP, enforcement of associated\nsemantics for these memory types is not guaranteed (that is, is reserved) and\nis implementation-specific.\n\nThe MASKMOVDQU instruction can be used to improve performance of algorithms\nthat need to merge data on a byte-by-byte basis. MASKMOVDQU should not cause\na read for ownership; doing so generates unnecessary bandwidth since data is\nto be written directly using the byte-mask without allocating old data prior\nto the store.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). Note: In VEX-encoded versions, VEX.vvvv is reserved\nand must be 1111b otherwise instructions will #UD. If VMASKMOVDQU is encoded\nwith VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will\ncause an #UD exception.\n\n1.ModRM.MOD = 011B required\n\nOperation:\n\nIF (MASK[7] = 1)\n  THEN DEST[DI/EDI] <- SRC[7:0] ELSE (* Memory location unchanged *); FI;\nIF (MASK[15] = 1)\n  THEN DEST[DI/EDI +1] <- SRC[15:8] ELSE (* Memory location unchanged *); FI;\n  (* Repeat operation for 3rd through 14th bytes in source operand *)\nIF (MASK[127] = 1)\n  THEN DEST[DI/EDI +15] <- SRC[127:120] ELSE (* Memory location unchanged *); FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nvoid _mm_maskmoveu_si128(__m128i d, __m128i n, char * p)\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L= 1 If VEX.vvvv != 1111B.\n", 
      "mnem": "MASKMOVDQU"
    }, 
    {
      "description": "\nMASKMOVQ - Store Selected Bytes of Quadword:\n| Opcode/Instruction        | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                        \n| 0F F7 /r MASKMOVQ mm1, mm2| RM   | Valid      | Valid          | Selectively write bytes from mm1 to\n|                           |      |            |                | memory location using the byte mask\n|                           |      |            |                | in mm2. The default memory location\n|                           |      |            |                | is specified by DS:DI/EDI/RDI.     \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nStores selected bytes from the source operand (first operand) into a 64-bit\nmemory location. The mask operand (second operand) selects which bytes from\nthe source operand are written to memory. The source and mask operands are MMX\ntechnology registers. The memory location specified by the effective address\nin the DI/EDI/RDI register (the default segment register is DS, but this may\nbe overridden with a segment-override prefix). The memory location does not\nneed to be aligned on a natural boundary. (The size of the store address depends\non the address-size attribute.)\n\nThe most significant bit in each byte of the mask operand determines whether\nthe corresponding byte in the source operand is written to the corresponding\nbyte location in memory: 0 indicates no write and 1 indicates write.\n\nThe MASKMOVQ instruction generates a non-temporal hint to the processor to minimize\ncache pollution. The nontemporal hint is implemented by using a write combining\n(WC) memory type protocol (see \u201cCaching of Temporal vs. Non-Temporal Data\u201d in\nChapter 10, of the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 1). Because the WC protocol uses a weakly-ordered memory consistency\nmodel, a fencing operation implemented with the SFENCE or MFENCE instruction\nshould be used in conjunction with MASKMOVQ instructions if multiple processors\nmight use different memory types to read/write the destination memory locations.\n\nThis instruction causes a transition from x87 FPU to MMX technology state (that\nis, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is\nset to all 0s [valid]).\n\nThe behavior of the MASKMOVQ instruction with a mask of all 0s is as follows:\n\n - No data will be written to memory.\n - Transition from x87 FPU to MMX technology state will occur.\n - Exceptions associated with addressing memory and page faults may still be signaled\n(implementation dependent).\n - Signaling of breakpoints (code or data) is not guaranteed (implementation dependent).\n - If the destination memory region is mapped as UC or WP, enforcement of associated\nsemantics for these memory types is not guaranteed (that is, is reserved) and\nis implementation-specific.\n\nThe MASKMOVQ instruction can be used to improve performance for algorithms that\nneed to merge data on a byteby-byte basis. It should not cause a read for ownership;\ndoing so generates unnecessary bandwidth since data is to be written directly\nusing the byte-mask without allocating old data prior to the store. In 64-bit\nmode, the memory address is specified by DS:RDI.\n\nOperation:\n\nIF (MASK[7] = 1)\n  THEN DEST[DI/EDI] <- SRC[7:0] ELSE (* Memory location unchanged *); FI;\nIF (MASK[15] = 1)\n  THEN DEST[DI/EDI +1] <- SRC[15:8] ELSE (* Memory location unchanged *); FI;\n  (* Repeat operation for 3rd through 6th bytes in source operand *)\nIF (MASK[63] = 1)\n  THEN DEST[DI/EDI +15] <- SRC[63:56] ELSE (* Memory location unchanged *); FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nvoid _mm_maskmove_si64(__m64d, __m64n, char * p)\n\n\nOther Exceptions:\nSee Table 22-8, \u201cException Conditions for Legacy SIMD/MMX Instructions without\nFP Exception,\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n", 
      "mnem": "MASKMOVQ"
    }, 
    {
      "description": "\nMAXPD - Return Maximum Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                               \n| 66 0F 5F /r MAXPD xmm1, xmm2/m128            | RM   | V/V           | SSE2              | Return the maximum double-precision       \n|                                              |      |               |                   | floating-point values between xmm2/m128   \n|                                              |      |               |                   | and xmm1.                                 \n| VEX.NDS.128.66.0F.WIG 5F /r VMAXPD xmm1,xmm2,| RVM  | V/V           | AVX               | Return the maximum double-precision       \n| xmm3/m128                                    |      |               |                   | floating-point values between xmm2 and    \n|                                              |      |               |                   | xmm3/mem.                                 \n| VEX.NDS.256.66.0F.WIG 5F /r VMAXPD ymm1,     | RVM  | V/V           | AVX               | Return the maximum packed double-precision\n| ymm2, ymm3/m256                              |      |               |                   | floating-point values between ymm2 and    \n|                                              |      |               |                   | ymm3/mem.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an SIMD compare of the packed double-precision floating-point values\nin the first source operand and the second source operand and returns the maximum\nvalue for each pair of values to the destination operand. If the values being\ncompared are both 0.0s (of either sign), the value in the second operand (source\noperand) is returned. If a value in the second operand is an SNaN, that SNaN\nis forwarded unchanged to the destination (that is, a QNaN version of the SNaN\nis not returned). If only one value is a NaN (SNaN or QNaN) for this instruction,\nthe second operand (source operand), either a NaN or a valid floating-point\nvalue, is written to the result. If instead of this behavior, it is required\nthat the NaN source operand (from either the first or second operand) be returned,\nthe action of MAXPD can be emulated using a sequence of instructions, such as,\na comparison followed by AND, ANDN and OR.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The second source can be\nan XMM register or an 128-bit memory location. The destination is not distinct\nfrom the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are unmodified. VEX.128 encoded version: the first\nsource operand is an XMM register or 128-bit memory location. The destination\noperand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are zeroed. VEX.256 encoded version: The first source\noperand is a YMM register. The second source operand can be a YMM register or\na 256-bit memory location. The destination operand is a YMM register.\n\nOperation:\n\nMAX(SRC1, SRC2)\n{\n  IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST <- SRC2;\n     ELSE IF (SRC1 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF (SRC2 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF (SRC1 > SRC2) THEN DEST <- SRC1;\n     ELSE DEST <- SRC2;\n  FI;\n}\nMAXPD (128-bit Legacy SSE version)\nDEST[63:0] <- MAX(DEST[63:0], SRC[63:0])\nDEST[127:64] <- MAX(DEST[127:64], SRC[127:64])\nDEST[VLMAX-1:128] (Unmodified)\nVMAXPD (VEX.128 encoded version)\nDEST[63:0] <- MAX(SRC1[63:0], SRC2[63:0])\nDEST[127:64] <- MAX(SRC1[127:64], SRC2[127:64])\nDEST[VLMAX-1:128] <- 0\nVMAXPD (VEX.256 encoded version)\nDEST[63:0] <- MAX(SRC1[63:0], SRC2[63:0])\nDEST[127:64] <- MAX(SRC1[127:64], SRC2[127:64])\nDEST[191:128] <- MAX(SRC1[191:128], SRC2[191:128])\nDEST[255:192] <- MAX(SRC1[255:192], SRC2[255:192])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MAXPD: | __m128d _mm_max_pd(__m128d a, __m128d    \n|        | b);                                      \n| VMAXPD:| __m256d _mm256_max_pd (__m256d a, __m256d\n|        | b);                                      \n\nSIMD Floating-Point Exceptions:\nInvalid (including QNaN source operand), Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "MAXPD"
    }, 
    {
      "description": "\nMAXPS - Return Maximum Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                               \n| 0F 5F /r MAXPS xmm1, xmm2/m128            | RM   | V/V           | SSE               | Return the maximum single-precision       \n|                                           |      |               |                   | floatingpoint values between xmm2/m128    \n|                                           |      |               |                   | and xmm1.                                 \n| VEX.NDS.128.0F.WIG 5F /r VMAXPS xmm1,xmm2,| RVM  | V/V           | AVX               | Return the maximum single-precision       \n| xmm3/m128                                 |      |               |                   | floatingpoint values between xmm2 and     \n|                                           |      |               |                   | xmm3/mem.                                 \n| VEX.NDS.256.0F.WIG 5F /r VMAXPS ymm1,     | RVM  | V/V           | AVX               | Return the maximum single double-precision\n| ymm2, ymm3/m256                           |      |               |                   | floating-point values between ymm2 and    \n|                                           |      |               |                   | ymm3/mem.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an SIMD compare of the packed single-precision floating-point values\nin the first source operand and the second source operand and returns the maximum\nvalue for each pair of values to the destination operand. If the values being\ncompared are both 0.0s (of either sign), the value in the second operand (source\noperand) is returned. If a value in the second operand is an SNaN, that SNaN\nis forwarded unchanged to the destination (that is, a QNaN version of the SNaN\nis not returned). If only one value is a NaN (SNaN or QNaN) for this instruction,\nthe second operand (source operand), either a NaN or a valid floating-point\nvalue, is written to the result. If instead of this behavior, it is required\nthat the NaN source operand (from either the first or second operand) be returned,\nthe action of MAXPS can be emulated using a sequence of instructions, such as,\na comparison followed by AND, ANDN and OR.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The second source can be\nan XMM register or an 128-bit memory location. The destination is not distinct\nfrom the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are unmodified. VEX.128 encoded version: the first\nsource operand is an XMM register or 128-bit memory location. The destination\noperand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are zeroed. VEX.256 encoded version: The first source\noperand is a YMM register. The second source operand can be a YMM register or\na 256-bit memory location. The destination operand is a YMM register.\n\nOperation:\n\nMAX(SRC1, SRC2)\n{\n  IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST <- SRC2;\n     ELSE IF (SRC1 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF SRC2 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF (SRC1 > SRC2) THEN DEST <- SRC1;\n     ELSE DEST <- SRC2;\n  FI;\n}\nMAXPS (128-bit Legacy SSE version)\nDEST[31:0] <- MAX(DEST[31:0], SRC[31:0])\nDEST[63:32] <- MAX(DEST[63:32], SRC[63:32])\nDEST[95:64] <- MAX(DEST[95:64], SRC[95:64])\nDEST[127:96] <- MAX(DEST[127:96], SRC[127:96])\nDEST[VLMAX-1:128] (Unmodified)\nVMAXPS (VEX.128 encoded version)\nDEST[31:0] <- MAX(SRC1[31:0], SRC2[31:0])\nDEST[63:32] <- MAX(SRC1[63:32], SRC2[63:32])\nDEST[95:64] <- MAX(SRC1[95:64], SRC2[95:64])\nDEST[127:96] <- MAX(SRC1[127:96], SRC2[127:96])\nDEST[VLMAX-1:128] <- 0\nVMAXPS (VEX.256 encoded version)\nDEST[31:0] <- MAX(SRC1[31:0], SRC2[31:0])\nDEST[63:32] <- MAX(SRC1[63:32], SRC2[63:32])\nDEST[95:64] <- MAX(SRC1[95:64], SRC2[95:64])\nDEST[127:96] <- MAX(SRC1[127:96], SRC2[127:96])\nDEST[159:128] <- MAX(SRC1[159:128], SRC2[159:128])\nDEST[191:160] <- MAX(SRC1[191:160], SRC2[191:160])\nDEST[223:192] <- MAX(SRC1[223:192], SRC2[223:192])\nDEST[255:224] <- MAX(SRC1[255:224], SRC2[255:224])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MAXPS: | __m128 _mm_max_ps (__m128 a, __m128   \n|        | b);                                   \n| VMAXPS:| __m256 _mm256_max_ps (__m256 a, __m256\n|        | b);                                   \n\nSIMD Floating-Point Exceptions:\nInvalid (including QNaN source operand), Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "MAXPS"
    }, 
    {
      "description": "\nMAXSD - Return Maximum Scalar Double-Precision Floating-Point Value:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                               \n| F2 0F 5F /r MAXSD xmm1, xmm2/m64        | RM   | V/V           | SSE2              | Return the maximum scalar double-precision\n|                                         |      |               |                   | floating-point value between xmm2/mem64   \n|                                         |      |               |                   | and xmm1.                                 \n| VEX.NDS.LIG.F2.0F.WIG 5F /r VMAXSD xmm1,| RVM  | V/V           | AVX               | Return the maximum scalar double-precision\n| xmm2, xmm3/m64                          |      |               |                   | floating-point value between xmm3/mem64   \n|                                         |      |               |                   | and xmm2.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nCompares the low double-precision floating-point values in the first source\noperand and second the source operand, and returns the maximum value to the\nlow quadword of the destination operand. The second source operand can be an\nXMM register or a 64-bit memory location. The first source and destination operands\nare XMM registers. When the second source operand is a memory operand, only\n64 bits are accessed. The high quadword of the destination operand is copied\nfrom the same bits of first source operand. If the values being compared are\nboth 0.0s (of either sign), the value in the second source operand is returned.\nIf a value in the second source operand is an SNaN, that SNaN is returned unchanged\nto the destination (that is, a QNaN version of the SNaN is not returned). If\nonly one value is a NaN (SNaN or QNaN) for this instruction, the second source\noperand, either a NaN or a valid floating-point value, is written to the result.\nIf instead of this behavior, it is required that the NaN of either source operand\nbe returned, the action of MAXSD can be emulated using a sequence of instructions,\nsuch as, a comparison followed by AND, ANDN and OR. The second source operand\ncan be an XMM register or a 64-bit memory location. The first source and destination\noperands are XMM registers.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The destination and first\nsource operand are the same. Bits (VLMAX-1:64) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: Bits (127:64) of the XMM\nregister destination are copied from corresponding bits in the first source\noperand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nOperation:\n\nMAX(SRC1, SRC2)\n{\n  IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST <- SRC2;\n     ELSE IF (SRC1 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF SRC2 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF (SRC1 > SRC2) THEN DEST <- SRC1;\n     ELSE DEST <- SRC2;\n  FI;\n}\nMAXSD (128-bit Legacy SSE version)\nDEST[63:0] <-MAX(DEST[63:0], SRC[63:0])\nDEST[VLMAX-1:64] (Unmodified)\nVMAXSD (VEX.128 encoded version)\nDEST[63:0] <-MAX(SRC1[63:0], SRC2[63:0])\nDEST[127:64] <-SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MAXSD:| __m128d _mm_max_sd(__m128d a, __m128d\n|       | b)                                   \n\nSIMD Floating-Point Exceptions:\nInvalid (including QNaN source operand), Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "MAXSD"
    }, 
    {
      "description": "\nMAXSS - Return Maximum Scalar Single-Precision Floating-Point Value:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                               \n| F3 0F 5F /r MAXSS xmm1, xmm2/m32        | RM   | V/V           | SSE               | Return the maximum scalar single-precision\n|                                         |      |               |                   | floating-point value between xmm2/mem32   \n|                                         |      |               |                   | and xmm1.                                 \n| VEX.NDS.LIG.F3.0F.WIG 5F /r VMAXSS xmm1,| RVM  | V/V           | AVX               | Return the maximum scalar single-precision\n| xmm2, xmm3/m32                          |      |               |                   | floating-point value between xmm3/mem32   \n|                                         |      |               |                   | and xmm2.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nCompares the low single-precision floating-point values in the first source\noperand and the second source operand, and returns the maximum value to the\nlow doubleword of the destination operand. If the values being compared are\nboth 0.0s (of either sign), the value in the second source operand is returned.\nIf a value in the second source operand is an SNaN, that SNaN is returned unchanged\nto the destination (that is, a QNaN version of the SNaN is not returned). If\nonly one value is a NaN (SNaN or QNaN) for this instruction, the second source\noperand, either a NaN or a valid floating-point value, is written to the result.\nIf instead of this behavior, it is required that the NaN from either source\noperand be returned, the action of MAXSS can be emulated using a sequence of\ninstructions, such as, a comparison followed by AND, ANDN and OR. The second\nsource operand can be an XMM register or a 32-bit memory location. The first\nsource and destination operands are XMM registers.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The destination and first\nsource operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: Bits (127:32) of the XMM\nregister destination are copied from corresponding bits in the first source\noperand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nOperation:\n\nMAX(SRC1, SRC2)\n{\n  IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST <- SRC2;\n     ELSE IF (SRC1 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF SRC2 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF (SRC1 > SRC2) THEN DEST <- SRC1;\n     ELSE DEST <- SRC2;\n  FI;\n}\nMAXSS (128-bit Legacy SSE version)\nDEST[31:0] <-MAX(DEST[31:0], SRC[31:0])\nDEST[VLMAX-1:32] (Unmodified)\nVMAXSS (VEX.128 encoded version)\nDEST[31:0] <-MAX(SRC1[31:0], SRC2[31:0])\nDEST[127:32] <-SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n__m128d _mm_max_ss(__m128d a, __m128d b)\n\n\nSIMD Floating-Point Exceptions:\nInvalid (including QNaN source operand), Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "MAXSS"
    }, 
    {
      "description": "\nMFENCE - Memory Fence:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F AE /6| MFENCE     | NP   | Valid      | Valid          | Serializes load and store operations.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nPerforms a serializing operation on all load-from-memory and store-to-memory\ninstructions that were issued prior the MFENCE instruction. This serializing\noperation guarantees that every load and store instruction that precedes the\nMFENCE instruction in program order becomes globally visible before any load\nor store instruction that follows the MFENCE instruction.1 The MFENCE instruction\nis ordered with respect to all load and store instructions, other MFENCE instructions,\nany LFENCE and SFENCE instructions, and any serializing instructions (such as\nthe CPUID instruction). MFENCE does not serialize the instruction stream.\n\nWeakly ordered memory types can be used to achieve higher processor performance\nthrough such techniques as out-of-order issue, speculative reads, write-combining,\nand write-collapsing. The degree to which a consumer of data recognizes or knows\nthat the data is weakly ordered varies among applications and may be unknown\nto the producer of this data. The MFENCE instruction provides a performance-efficient\nway of ensuring load and store ordering between routines that produce weakly-ordered\nresults and routines that consume that data.\n\nProcessors are free to fetch and cache data speculatively from regions of system\nmemory that use the WB, WC, and WT memory types. This speculative fetching can\noccur at any time and is not tied to instruction execution. Thus, it is not\nordered with respect to executions of the MFENCE instruction; data can be brought\ninto the caches speculatively just before, during, or after the execution of\nan MFENCE instruction.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nWait_On_Following_Loads_And_Stores_Until(preceding_loads_and_stores_globally_visible);\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nvoid _mm_mfence(void)\n\n\nExceptions (All Modes of Operation):\n| #UD| If CPUID.01H:EDX.SSE2[bit 26] = 0. If     \n|    | the LOCK prefix is used.                  \n| 1. | A load instruction is considered to       \n|    | become globally visible when the value    \n|    | to be loaded into its destination register\n|    | is determined.                            \n", 
      "mnem": "MFENCE"
    }, 
    {
      "description": "\nMINPD - Return Minimum Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                               \n| 66 0F 5D /r MINPD xmm1, xmm2/m128            | RM   | V/V           | SSE2              | Return the minimum double-precision       \n|                                              |      |               |                   | floating-point values between xmm2/m128   \n|                                              |      |               |                   | and xmm1.                                 \n| VEX.NDS.128.66.0F.WIG 5D /r VMINPD xmm1,xmm2,| RVM  | V/V           | AVX               | Return the minimum double-precision       \n| xmm3/m128                                    |      |               |                   | floatingpoint values between xmm2 and     \n|                                              |      |               |                   | xmm3/mem.                                 \n| VEX.NDS.256.66.0F.WIG 5D /r VMINPD ymm1,     | RVM  | V/V           | AVX               | Return the minimum packed double-precision\n| ymm2, ymm3/m256                              |      |               |                   | floating-point values between ymm2 and    \n|                                              |      |               |                   | ymm3/mem.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an SIMD compare of the packed double-precision floating-point values\nin the first source operand and the second source operand and returns the minimum\nvalue for each pair of values to the destination operand. If the values being\ncompared are both 0.0s (of either sign), the value in the second operand (source\noperand) is returned. If a value in the second operand is an SNaN, that SNaN\nis forwarded unchanged to the destination (that is, a QNaN version of the SNaN\nis not returned). If only one value is a NaN (SNaN or QNaN) for this instruction,\nthe second operand (source operand), either a NaN or a valid floating-point\nvalue, is written to the result. If instead of this behavior, it is required\nthat the NaN source operand (from either the first or second operand) be returned,\nthe action of MINPD can be emulated using a sequence of instructions, such as,\na comparison followed by AND, ANDN and OR.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The second source can be\nan XMM register or an 128-bit memory location. The destination is not distinct\nfrom the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are unmodified. VEX.128 encoded version: the first\nsource operand is an XMM register or 128-bit memory location. The destination\noperand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are zeroed.\n\nOperation:\n\nMIN(SRC1, SRC2)\n{\n  IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST <- SRC2;\n     ELSE IF (SRC1 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF (SRC2 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF (SRC1 < SRC2) THEN DEST <- SRC1;\n     ELSE DEST <- SRC2;\n  FI;\n}\nMINPD (128-bit Legacy SSE version)\nDEST[63:0] <- MIN(SRC1[63:0], SRC2[63:0])\nDEST[127:64] <- MIN(SRC1[127:64], SRC2[127:64])\nDEST[VLMAX-1:128] (Unmodified)\nVMINPD (VEX.128 encoded version)\nDEST[63:0] <- MIN(SRC1[63:0], SRC2[63:0])\nDEST[127:64] <- MIN(SRC1[127:64], SRC2[127:64])\nDEST[VLMAX-1:128] <- 0\nVMINPD (VEX.256 encoded version)\nDEST[63:0] <- MIN(SRC1[63:0], SRC2[63:0])\nDEST[127:64] <- MIN(SRC1[127:64], SRC2[127:64])\nDEST[191:128] <- MIN(SRC1[191:128], SRC2[191:128])\nDEST[255:192] <- MIN(SRC1[255:192], SRC2[255:192])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MINPD: | __m128d _mm_min_pd(__m128d a, __m128d    \n|        | b);                                      \n| VMINPD:| __m256d _mm256_min_pd (__m256d a, __m256d\n|        | b);                                      \n\nSIMD Floating-Point Exceptions:\nInvalid (including QNaN source operand), Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "MINPD"
    }, 
    {
      "description": "\nMINPS - Return Minimum Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                               \n| 0F 5D /r MINPS xmm1, xmm2/m128            | RM   | V/V           | SSE               | Return the minimum single-precision       \n|                                           |      |               |                   | floatingpoint values between xmm2/m128    \n|                                           |      |               |                   | and xmm1.                                 \n| VEX.NDS.128.0F.WIG 5D /r VMINPS xmm1,xmm2,| RVM  | V/V           | AVX               | Return the minimum single-precision       \n| xmm3/m128                                 |      |               |                   | floatingpoint values between xmm2 and     \n|                                           |      |               |                   | xmm3/mem.                                 \n| VEX.NDS.256.0F.WIG 5D /r VMINPS ymm1,     | RVM  | V/V           | AVX               | Return the minimum single double-precision\n| ymm2, ymm3/m256                           |      |               |                   | floating-point values between ymm2 and    \n|                                           |      |               |                   | ymm3/mem.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an SIMD compare of the packed single-precision floating-point values\nin the first source operand and the second source operand and returns the minimum\nvalue for each pair of values to the destination operand. If the values being\ncompared are both 0.0s (of either sign), the value in the second operand (source\noperand) is returned. If a value in the second operand is an SNaN, that SNaN\nis forwarded unchanged to the destination (that is, a QNaN version of the SNaN\nis not returned). If only one value is a NaN (SNaN or QNaN) for this instruction,\nthe second operand (source operand), either a NaN or a valid floating-point\nvalue, is written to the result. If instead of this behavior, it is required\nthat the NaN source operand (from either the first or second operand) be returned,\nthe action of MINPS can be emulated using a sequence of instructions, such as,\na comparison followed by AND, ANDN and OR.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The second source can be\nan XMM register or an 128-bit memory location. The destination is not distinct\nfrom the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are unmodified. VEX.128 encoded version: the first\nsource operand is an XMM register or 128-bit memory location. The destination\noperand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are zeroed. VEX.256 encoded version: The first source\noperand is a YMM register. The second source operand can be a YMM register or\na 256-bit memory location. The destination operand is a YMM register.\n\nOperation:\n\nMIN(SRC1, SRC2)\n{\n  IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST <- SRC2;\n     ELSE IF (SRC1 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF (SRC2 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF (SRC1 < SRC2) THEN DEST <- SRC1;\n     ELSE DEST <- SRC2;\n  FI;\n}\nMINPS (128-bit Legacy SSE version)\nDEST[31:0] <- MIN(SRC1[31:0], SRC2[31:0])\nDEST[63:32] <- MIN(SRC1[63:32], SRC2[63:32])\nDEST[95:64] <- MIN(SRC1[95:64], SRC2[95:64])\nDEST[127:96] <- MIN(SRC1[127:96], SRC2[127:96])\nDEST[VLMAX-1:128] (Unmodified)\nVMINPS (VEX.128 encoded version)\nDEST[31:0] <- MIN(SRC1[31:0], SRC2[31:0])\nDEST[63:32] <- MIN(SRC1[63:32], SRC2[63:32])\nDEST[95:64] <- MIN(SRC1[95:64], SRC2[95:64])\nDEST[127:96] <- MIN(SRC1[127:96], SRC2[127:96])\nDEST[VLMAX-1:128] <- 0\nVMINPS (VEX.256 encoded version)\nDEST[31:0] <- MIN(SRC1[31:0], SRC2[31:0])\nDEST[63:32] <- MIN(SRC1[63:32], SRC2[63:32])\nDEST[95:64] <- MIN(SRC1[95:64], SRC2[95:64])\nDEST[127:96] <- MIN(SRC1[127:96], SRC2[127:96])\nDEST[159:128] <- MIN(SRC1[159:128], SRC2[159:128])\nDEST[191:160] <- MIN(SRC1[191:160], SRC2[191:160])\nDEST[223:192] <- MIN(SRC1[223:192], SRC2[223:192])\nDEST[255:224] <- MIN(SRC1[255:224], SRC2[255:224])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MINPS: | __m128d _mm_min_ps(__m128d a, __m128d \n|        | b);                                   \n| VMINPS:| __m256 _mm256_min_ps (__m256 a, __m256\n|        | b);                                   \n\nSIMD Floating-Point Exceptions:\nInvalid (including QNaN source operand), Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "MINPS"
    }, 
    {
      "description": "\nMINSD - Return Minimum Scalar Double-Precision Floating-Point Value:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                               \n| F2 0F 5D /r MINSD xmm1, xmm2/m64        | RM   | V/V           | SSE2              | Return the minimum scalar double-precision\n|                                         |      |               |                   | floating-point value between xmm2/mem64   \n|                                         |      |               |                   | and xmm1.                                 \n| VEX.NDS.LIG.F2.0F.WIG 5D /r VMINSD xmm1,| RVM  | V/V           | AVX               | Return the minimum scalar double precision\n| xmm2, xmm3/m64                          |      |               |                   | floating-point value between xmm3/mem64   \n|                                         |      |               |                   | and xmm2.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nCompares the low double-precision floating-point values in the first source\noperand and the second source operand, and returns the minimum value to the\nlow quadword of the destination operand. When the source operand is a memory\noperand, only the 64 bits are accessed. The high quadword of the destination\noperand is copied from the same bits in the first source operand. If the values\nbeing compared are both 0.0s (of either sign), the value in the second source\noperand is returned. If a value in the second source operand is an SNaN, that\nSNaN is returned unchanged to the destination (that is, a QNaN version of the\nSNaN is not returned). If only one value is a NaN (SNaN or QNaN) for this instruction,\nthe second source operand, either a NaN or a valid floating-point value, is\nwritten to the result. If instead of this behavior, it is required that the\nNaN source operand (from either the first or second source) be returned, the\naction of MINSD can be emulated using a sequence of instructions, such as, a\ncomparison followed by AND, ANDN and OR. The second source operand can be an\nXMM register or a 64-bit memory location. The first source and destination operands\nare XMM registers.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The destination and first\nsource operand are the same. Bits (VLMAX-1:64) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: Bits (127:64) of the XMM\nregister destination are copied from corresponding bits in the first source\noperand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nOperation:\n\nMIN(SRC1, SRC2)\n{\n  IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST <- SRC2;\n     ELSE IF (SRC1 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF SRC2 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF (SRC1 < SRC2) THEN DEST <- SRC1;\n     ELSE DEST <- SRC2;\n  FI;\n}\nMINSD (128-bit Legacy SSE version)\nDEST[63:0] <- MIN(SRC1[63:0], SRC2[63:0])\nDEST[VLMAX-1:64] (Unmodified)\nMINSD (VEX.128 encoded version)\nDEST[63:0] <- MIN(SRC1[63:0], SRC2[63:0])\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MINSD:| __m128d _mm_min_sd(__m128d a, __m128d\n|       | b)                                   \n\nSIMD Floating-Point Exceptions:\nInvalid (including QNaN source operand), Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "MINSD"
    }, 
    {
      "description": "\nMINSS - Return Minimum Scalar Single-Precision Floating-Point Value:\n| Opcode/Instruction                           | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                               \n| F3 0F 5D /r MINSS xmm1, xmm2/m32             | RM   | V/V           | SSE               | Return the minimum scalar single-precision\n|                                              |      |               |                   | floating-point value between xmm2/mem32   \n|                                              |      |               |                   | and xmm1.                                 \n| VEX.NDS.LIG.F3.0F.WIG 5D /r VMINSS xmm1,xmm2,| RVM  | V/V           | AVX               | Return the minimum scalar single precision\n| xmm3/m32                                     |      |               |                   | floating-point value between xmm3/mem32   \n|                                              |      |               |                   | and xmm2.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nCompares the low single-precision floating-point values in the first source\noperand and the second source operand and returns the minimum value to the low\ndoubleword of the destination operand. If the values being compared are both\n0.0s (of either sign), the value in the second source operand is returned. If\na value in the second operand is an SNaN, that SNaN is returned unchanged to\nthe destination (that is, a QNaN version of the SNaN is not returned). If only\none value is a NaN (SNaN or QNaN) for this instruction, the second source operand,\neither a NaN or a valid floating-point value, is written to the result. If instead\nof this behavior, it is required that the NaN in either source operand be returned,\nthe action of MINSD can be emulated using a sequence of instructions, such as,\na comparison followed by AND, ANDN and OR. The second source operand can be\nan XMM register or a 32-bit memory location. The first source and destination\noperands are XMM registers.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The destination and first\nsource operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: Bits (127:32) of the XMM\nregister destination are copied from corresponding bits in the first source\noperand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nOperation:\n\nMIN(SRC1, SRC2)\n{\n  IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST <- SRC2;\n     ELSE IF (SRC1 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF SRC2 = SNaN) THEN DEST <- SRC2; FI;\n     ELSE IF (SRC1 < SRC2) THEN DEST <- SRC1;\n     ELSE DEST <- SRC2;\n  FI;\n}\nMINSS (128-bit Legacy SSE version)\nDEST[31:0] <- MIN(SRC1[31:0], SRC2[31:0])\nDEST[VLMAX-1:32] (Unmodified)\nVMINSS (VEX.128 encoded version)\nDEST[31:0] <- MIN(SRC1[31:0], SRC2[31:0])\nDEST[127:32] <- SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MINSS:| __m128d _mm_min_ss(__m128d a, __m128d\n|       | b)                                   \n\nSIMD Floating-Point Exceptions:\nInvalid (including QNaN source operand), Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "MINSS"
    }, 
    {
      "description": "\nMONITOR - Set Up Monitor Address:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                            \n| 0F 01 C8| MONITOR    | NP   | Valid      | Valid          | Sets up a linear address range to be   \n|         |            |      |            |                | monitored by hardware and activates    \n|         |            |      |            |                | the monitor. The address range should  \n|         |            |      |            |                | be a writeback memory caching type.    \n|         |            |      |            |                | The address is DS:EAX (DS:RAX in 64-bit\n|         |            |      |            |                | mode).                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nThe MONITOR instruction arms address monitoring hardware using an address specified\nin EAX (the address range that the monitoring hardware checks for store operations\ncan be determined by using CPUID). A store to an address within the specified\naddress range triggers the monitoring hardware. The state of monitor hardware\nis used by MWAIT.\n\nThe content of EAX is an effective address (in 64-bit mode, RAX is used). By\ndefault, the DS segment is used to create a linear address that is monitored.\nSegment overrides can be used.\n\nECX and EDX are also used. They communicate other information to MONITOR. ECX\nspecifies optional extensions. EDX specifies optional hints; it does not change\nthe architectural behavior of the instruction. For the Pentium 4 processor (family\n15, model 3), no extensions or hints are defined. Undefined hints in EDX are\nignored by the processor; undefined extensions in ECX raises a general protection\nfault.\n\nThe address range must use memory of the write-back type. Only write-back memory\nwill correctly trigger the monitoring hardware. Additional information on determining\nwhat address range to use in order to prevent false wake-ups is described in\nChapter 8, \u201cMultiple-Processor Management\u201d of the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 3A.\n\nThe MONITOR instruction is ordered as a load operation with respect to other\nmemory transactions. The instruction is subject to the permission checking and\nfaults associated with a byte load. Like a load, MONITOR sets the A-bit but\nnot the D-bit in page tables.\n\nCPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT\nin the processor. When set, MONITOR may be executed only at privilege level\n0 (use at any other privilege level results in an invalid-opcode exception).\nThe operating system or system BIOS may disable this instruction by using the\nIA32_MISC_ENABLE MSR; disabling MONITOR clears the CPUID feature flag and causes\nexecution to generate an invalid-opcode exception.\n\nThe instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nMONITOR sets up an address range for the monitor hardware using the content of EAX (RAX in 64-bit mode) as an\neffective address and puts the monitor hardware in armed state. Always use memory of the write-back caching\ntype. A store to the specified address range will trigger the monitor hardware. The content of ECX and EDX are\nused to communicate other information to the monitor hardware.\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MONITOR:| void _mm_monitor(void const *p, unsigned\n|         | extensions,unsigned hints)              \n\nNumeric Exceptions:\nNone\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the value in EAX is outside the CS, \n|                | DS, ES, FS, or GS segment limit. If    \n|                | the DS, ES, FS, or GS register is used \n|                | to access memory and it contains a NULL\n|                | segment selector. If ECX != 0.          \n| #SS(0)         | If the value in EAX is outside the SS  \n|                | segment limit.                         \n| #PF(fault-code)| For a page fault.                      \n| #UD            | If CPUID.01H:ECX.MONITOR[bit 3] = 0.   \n|                | If current privilege level is not 0.   \n\nReal Address Mode Exceptions:\n| #GP| If the CS, DS, ES, FS, or GS register     \n|    | is used to access memory and the value    \n|    | in EAX is outside of the effective address\n|    | space from 0 to FFFFH. If ECX != 0.        \n| #SS| If the SS register is used to access      \n|    | memory and the value in EAX is outside    \n|    | of the effective address space from       \n|    | 0 to FFFFH.                               \n| #UD| If CPUID.01H:ECX.MONITOR[bit 3] = 0.      \n\nVirtual 8086 Mode Exceptions:\n| #UD| The MONITOR instruction is not recognized              \n|    | in virtual-8086 mode (even if CPUID.01H:ECX.MONITOR[bit\n|    | 3] = 1).                                               \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the linear address of the operand \n|                | in the CS, DS, ES, FS, or GS segment \n|                | is in a non-canonical form. If RCX != \n|                | 0.                                   \n| #SS(0)         | If the SS register is used to access \n|                | memory and the value in EAX is in a  \n|                | non-canonical form.                  \n| #PF(fault-code)| For a page fault.                    \n| #UD            | If the current privilege level is not\n|                | 0. If CPUID.01H:ECX.MONITOR[bit 3] = \n|                | 0.                                   \n", 
      "mnem": "MONITOR"
    }, 
    {
      "description": "\nMOV - Move:\n| Opcode                   | Instruction                   | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                               \n| 88 /r REX + 88 /r        | MOV r/m8,r8 MOV r/m8***,r8*** | MR MR| Valid Valid| Valid N.E.     | Move r8 to r/m8. Move r8 to r/m8.         \n| 89 /r                    | MOV r/m16,r16                 | MR   | Valid      | Valid          | Move r16 to r/m16.                        \n| 89 /r                    | MOV r/m32,r32                 | MR   | Valid      | Valid          | Move r32 to r/m32.                        \n| REX.W + 89 /r            | MOV r/m64,r64                 | MR   | Valid      | N.E.           | Move r64 to r/m64.                        \n| 8A /r                    | MOV r8,r/m8                   | RM   | Valid      | Valid          | Move r/m8 to r8.                          \n| REX + 8A /r              | MOV r8***,r/m8***             | RM   | Valid      | N.E.           | Move r/m8 to r8.                          \n| 8B /r                    | MOV r16,r/m16                 | RM   | Valid      | Valid          | Move r/m16 to r16.                        \n| 8B /r                    | MOV r32,r/m32                 | RM   | Valid      | Valid          | Move r/m32 to r32.                        \n| REX.W + 8B /r            | MOV r64,r/m64                 | RM   | Valid      | N.E.           | Move r/m64 to r64.                        \n| 8C /r                    | MOV r/m16,Sreg**              | MR   | Valid      | Valid          | Move segment register to r/m16.           \n| REX.W + 8C /r            | MOV r/m64,Sreg**              | MR   | Valid      | Valid          | Move zero extended 16-bit segment register\n|                          |                               |      |            |                | to r/m64.                                 \n| 8E /r                    | MOV Sreg,r/m16**              | RM   | Valid      | Valid          | Move r/m16 to segment register.           \n| REX.W + 8E /r            | MOV Sreg,r/m64**              | RM   | Valid      | Valid          | Move lower 16 bits of r/m64 to segment    \n|                          |                               |      |            |                | register.                                 \n| A0                       | MOV AL,moffs8*                | FD   | Valid      | Valid          | Move byte at (seg:offset) to AL.          \n| REX.W + A0               | MOV AL,moffs8*                | FD   | Valid      | N.E.           | Move byte at (offset) to AL.              \n| A1                       | MOV AX,moffs16*               | FD   | Valid      | Valid          | Move word at (seg:offset) to AX.          \n| A1                       | MOV EAX,moffs32*              | FD   | Valid      | Valid          | Move doubleword at (seg:offset) to EAX.   \n| REX.W + A1               | MOV RAX,moffs64*              | FD   | Valid      | N.E.           | Move quadword at (offset) to RAX.         \n| A2 REX.W + A2            | MOV moffs8,AL MOV moffs8***,AL| TD TD| Valid Valid| Valid N.E.     | Move AL to (seg:offset). Move AL to       \n|                          |                               |      |            |                | (offset).                                 \n| A3                       | MOV moffs16*,AX               | TD   | Valid      | Valid          | Move AX to (seg:offset).                  \n| A3                       | MOV moffs32*,EAX              | TD   | Valid      | Valid          | Move EAX to (seg:offset).                 \n| REX.W + A3               | MOV moffs64*,RAX              | TD   | Valid      | N.E.           | Move RAX to (offset).                     \n| B0+ rb ib REX + B0+ rb ib| MOV r8, imm8 MOV r8***, imm8  | OI OI| Valid Valid| Valid N.E.     | Move imm8 to r8. Move imm8 to r8.         \n| B8+ rw iw                | MOV r16, imm16                | OI   | Valid      | Valid          | Move imm16 to r16.                        \n| B8+ rd id                | MOV r32, imm32                | OI   | Valid      | Valid          | Move imm32 to r32.                        \n| REX.W + B8+ rd io        | MOV r64, imm64                | OI   | Valid      | N.E.           | Move imm64 to r64.                        \n| C6 /0 ib                 | MOV r/m8, imm8                | MI   | Valid      | Valid          | Move imm8 to r/m8.                        \n| REX + C6 /0 ib           | MOV r/m8***, imm8             | MI   | Valid      | N.E.           | Move imm8 to r/m8.                        \n| C7 /0 iw                 | MOV r/m16, imm16              | MI   | Valid      | Valid          | Move imm16 to r/m16.                      \n| C7 /0 id                 | MOV r/m32, imm32              | MI   | Valid      | Valid          | Move imm32 to r/m32.                      \n| REX.W + C7 /0 io         | MOV r/m64, imm32              | MI   | Valid      | N.E.           | Move imm32 sign extended to 64-bits       \n|                          |                               |      |            |                | to r/m64.                                 \nNotes: * The moffs8, moffs16, moffs32 and moffs64 operands specify a simple\noffset relative to the segment base, where 8, 16, 32 and 64 refer to the size\nof the data. The address-size attribute of the instruction determines the size\nof the offset, either 16, 32 or 64 bits. ** In 32-bit mode, the assembler may\ninsert the 16-bit operand-size prefix with this instruction (see the following\n\u201cDescription\u201d section for further information). ***In 64-bit mode, r/m8 can\nnot be encoded to access the following byte registers if a REX prefix is used:\nAH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1      | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (w)  | ModRM:reg (r)| NA       | NA       \n| RM   | ModRM:reg (w)  | ModRM:r/m (r)| NA       | NA       \n| FD   | AL/AX/EAX/RAX  | Moffs        | NA       | NA       \n| TD   | Moffs (w)      | AL/AX/EAX/RAX| NA       | NA       \n| OI   | opcode + rd (w)| imm8/16/32/64| NA       | NA       \n| MI   | ModRM:r/m (w)  | imm8/16/32/64| NA       | NA       \n\nDescription:\nCopies the second operand (source operand) to the first operand (destination\noperand). The source operand can be an immediate value, general-purpose register,\nsegment register, or memory location; the destination register can be a general-purpose\nregister, segment register, or memory location. Both operands must be the same\nsize, which can be a byte, a word, a doubleword, or a quadword.\n\nThe MOV instruction cannot be used to load the CS register. Attempting to do\nso results in an invalid opcode exception (#UD). To load the CS register, use\nthe far JMP, CALL, or RET instruction.\n\nIf the destination operand is a segment register (DS, ES, FS, GS, or SS), the\nsource operand must be a valid segment selector. In protected mode, moving a\nsegment selector into a segment register automatically causes the segment descriptor\ninformation associated with that segment selector to be loaded into the hidden\n(shadow) part of the segment register. While loading this information, the segment\nselector and segment descriptor information is validated (see the \u201cOperation\u201d\nalgorithm below). The segment descriptor data is obtained from the GDT or LDT\nentry for the specified segment selector.\n\nA NULL segment selector (values 0000-0003) can be loaded into the DS, ES, FS,\nand GS registers without causing a protection exception. However, any subsequent\nattempt to reference a segment whose corresponding segment register is loaded\nwith a NULL value causes a general protection exception (#GP) and no memory\nreference occurs.\n\nLoading the SS register with a MOV instruction inhibits all interrupts until\nafter the execution of the next instruction. This operation allows a stack pointer\nto be loaded into the ESP register with the next instruction (MOV ESP, stack-pointer\nvalue) before an interrupt occurs1. Be aware that the LSS instruction offers\na more efficient method of loading the SS and ESP registers.\n\nWhen operating in 32-bit mode and moving data between a segment register and\na general-purpose register, the 32-bit IA-32 processors do not require the use\nof the 16-bit operand-size prefix (a byte with the value 66H) with\n\n| 1.| If a code instruction breakpoint (for      \n|   | debug) is placed on an instruction located \n|   | immediately after a MOV SS instruction,    \n|   | the breakpoint may not be triggered.       \n|   | However, in a sequence of instructions     \n|   | that load the SS register, only the        \n|   | first instruction in the sequence is       \n|   | guaranteed to delay an interrupt. In       \n|   | the following sequence, interrupts may     \n|   | be recognized before MOV ESP, EBP executes:\n|   | MOV SS, EDX MOV SS, EAX MOV ESP, EBP       \nthis instruction, but most assemblers will insert it if the standard form of\nthe instruction is used (for example, MOV DS, AX). The processor will execute\nthis instruction correctly, but it will usually require an extra clock. With\nmost assemblers, using the instruction form MOV DS, EAX will avoid this unneeded\n66H prefix. When the processor executes the instruction with a 32-bit general-purpose\nregister, it assumes that the 16 least-significant bits of the general-purpose\nregister are the destination or source operand. If the register is a destination\noperand, the resulting value in the two high-order bytes of the register is\nimplementation dependent. For the Pentium 4, Intel Xeon, and P6 family processors,\nthe two high-order bytes are filled with zeros; for earlier 32-bit IA-32 processors,\nthe two high order bytes are undefined.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.R prefix permits access to additional registers (R8-R15). Use of the\nREX.W prefix promotes operation to 64 bits. See the summary chart at the beginning\nof this section for encoding data and limits.\n\nOperation:\n\nDEST <- SRC;\nLoading a segment register while in protected mode results in special checks and actions, as described in the\nfollowing listing. These checks are performed on the segment selector and the segment descriptor to which it\npoints.\nIF SS is loaded\n  THEN\n     IF segment selector is NULL\n       THEN #GP(0); FI;\n     IF segment selector index is outside descriptor table limits\n     or segment selector's RPL != CPL\n     or segment is not a writable data segment\n     or DPL != CPL\n       THEN #GP(selector); FI;\n     IF segment not marked present\n       THEN #SS(selector);\n       ELSE\n          SS <- segment selector;\n          SS <- segment descriptor; FI;\nFI;\nIF DS, ES, FS, or GS is loaded with non-NULL selector\nTHEN\n  IF segment selector index is outside descriptor table limits\n  or segment is not a data or readable code segment\n  or ((segment is a data or nonconforming code segment)\n  or ((RPL > DPL) and (CPL > DPL))\n     THEN #GP(selector); FI;\n  IF segment not marked present\n     THEN #NP(selector);\n     ELSE\n       SegmentRegister <- segment selector;\n       SegmentRegister <- segment descriptor; FI;\nFI;\nIF DS, ES, FS, or GS is loaded with NULL selector\n  THEN\n     SegmentRegister <- segment selector;\n     SegmentRegister <- segment descriptor;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If attempt is made to load SS register        \n|                | with NULL segment selector. If the destination\n|                | operand is in a non-writable segment.         \n|                | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit. If the DS, ES, FS, or          \n|                | GS register contains a NULL segment           \n|                | selector.                                     \n| #GP(selector)  | If segment selector index is outside          \n|                | descriptor table limits. If the SS register   \n|                | is being loaded and the segment selector's    \n|                | RPL and the segment descriptor's DPL          \n|                | are not equal to the CPL. If the SS           \n|                | register is being loaded and the segment      \n|                | pointed to is a non-writable data segment.    \n|                | If the DS, ES, FS, or GS register is          \n|                | being loaded and the segment pointed          \n|                | to is not a data or readable code segment.    \n|                | If the DS, ES, FS, or GS register is          \n|                | being loaded and the segment pointed          \n|                | to is a data or nonconforming code segment,   \n|                | but both the RPL and the CPL are greater      \n|                | than the DPL.                                 \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #SS(selector)  | If the SS register is being loaded and        \n|                | the segment pointed to is marked not          \n|                | present.                                      \n| #NP            | If the DS, ES, FS, or GS register is          \n|                | being loaded and the segment pointed          \n|                | to is marked not present.                     \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If attempt is made to load the CS register.   \n|                | If the LOCK prefix is used.                   \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address      \n|    | is outside the CS, DS, ES, FS, or GS       \n|    | segment limit.                             \n| #SS| If a memory operand effective address      \n|    | is outside the SS segment limit.           \n| #UD| If attempt is made to load the CS register.\n|    | If the LOCK prefix is used.                \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address      \n|                | is outside the CS, DS, ES, FS, or GS       \n|                | segment limit.                             \n| #SS(0)         | If a memory operand effective address      \n|                | is outside the SS segment limit.           \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made.     \n| #UD            | If attempt is made to load the CS register.\n|                | If the LOCK prefix is used.                \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the memory address is in a non-canonical     \n|                | form. If an attempt is made to load             \n|                | SS register with NULL segment selector          \n|                | when CPL = 3. If an attempt is made             \n|                | to load SS register with NULL segment           \n|                | selector when CPL < 3 and CPL != RPL.            \n| #GP(selector)  | If segment selector index is outside            \n|                | descriptor table limits. If the memory          \n|                | access to the descriptor table is non-canonical.\n|                | If the SS register is being loaded and          \n|                | the segment selector's RPL and the segment      \n|                | descriptor's DPL are not equal to the           \n|                | CPL. If the SS register is being loaded         \n|                | and the segment pointed to is a nonwritable     \n|                | data segment. If the DS, ES, FS, or             \n|                | GS register is being loaded and the             \n|                | segment pointed to is not a data or             \n|                | readable code segment. If the DS, ES,           \n|                | FS, or GS register is being loaded and          \n|                | the segment pointed to is a data or             \n|                | nonconforming code segment, but both            \n|                | the RPL and the CPL are greater than            \n|                | the DPL.                                        \n| #SS(0)         | If the stack address is in a non-canonical      \n|                | form.                                           \n| #SS(selector)  | If the SS register is being loaded and          \n|                | the segment pointed to is marked not            \n|                | present.                                        \n| #PF(fault-code)| If a page fault occurs.                         \n| #AC(0)         | If alignment checking is enabled and            \n|                | an unaligned memory reference is made           \n|                | while the current privilege level is            \n|                | 3.                                              \n| #UD            | If attempt is made to load the CS register.     \n|                | If the LOCK prefix is used.                     \n\nMOV - Move to/from Control Registers:\n| Opcode/Instruction                 | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| 0F 20/r MOV r32, CR0-CR7           | MR   | N.E.       | Valid          | Move control register to r32.         \n| 0F 20/r MOV r64, CR0-CR7 REX.R + 0F| MR MR| Valid Valid| N.E. N.E.      | Move extended control register to r64.\n| 20 /0 MOV r64, CR8                 |      |            |                | Move extended CR8 to r64.1            \n| 0F 22 /r MOV CR0-CR7, r32          | RM   | N.E.       | Valid          | Move r32 to control register.         \n| 0F 22 /r MOV CR0-CR7, r64          | RM   | Valid      | N.E.           | Move r64 to extended control register.\n| REX.R + 0F 22 /0 MOV CR8, r64      | RM   | Valid      | N.E.           | Move r64 to extended CR8.1            \n\nNOTE::\n| 1.| MOV CR* instructions, except for MOV  \n|   | CR8, are serializing instructions. MOV\n|   | CR8 is not architecturally defined as \n|   | a serializing instruction. For more   \n|   | information, see Chapter 8 in Intel\u00ae  \n|   | 64 and IA-32 Architectures Software   \n|   | Developer's Manual, Volume 3A.        \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nMoves the contents of a control register (CR0, CR2, CR3, CR4, or CR8) to a general-purpose\nregister or the contents of a general purpose register to a control register.\nThe operand size for these instructions is always 32 bits in non-64-bit modes,\nregardless of the operand-size attribute. (See \u201cControl Registers\u201d in Chapter\n2 of the Intel\u00ae64 and IA-32 Architectures Software Developer's Manual, Volume\n3A, for a detailed description of the flags and fields in the control registers.)\nThis instruction can be executed only when the current privilege level is 0.\n\nAt the opcode level, the reg field within the ModR/M byte specifies which of\nthe control registers is loaded or read. The 2 bits in the mod field are ignored.\nThe r/m field specifies the general-purpose register loaded or read. Attempts\nto reference CR1, CR5, CR6, CR7, and CR9-CR15 result in undefined opcode (#UD)\nexceptions.\n\nWhen loading control registers, programs should not attempt to change the reserved\nbits; that is, always set reserved bits to the value previously read. An attempt\nto change CR4's reserved bits will cause a general protection fault. Reserved\nbits in CR0 and CR3 remain clear after any load of those registers; attempts\nto set them have no impact. On Pentium 4, Intel Xeon and P6 family processors,\nCR0.ET remains set after any load of CR0; attempts to clear this bit have no\nimpact.\n\nIn certain cases, these instructions have the side effect of invalidating entries\nin the TLBs and the paging-structure caches. See Section 4.10.4.1, \u201cOperations\nthat Invalidate TLBs and Paging-Structure Caches,\u201d in the Intel\u00ae 64 and IA-32\nArchitectures Software Developer's Manual, Volume 3A for details.\n\nThe following side effects are implementation-specific for the Pentium 4, Intel\nXeon, and P6 processor family: when modifying PE or PG in register CR0, or PSE\nor PAE in register CR4, all TLB entries are flushed, including global entries.\nSoftware should not depend on this functionality in all Intel 64 or IA-32 processors.\n\nIn 64-bit mode, the instruction's default operation size is 64 bits. The REX.R\nprefix must be used to access CR8. Use of REX.B permits access to additional\nregisters (R8-R15). Use of the REX.W prefix or 66H prefix is ignored. Use of\n\nthe REX.R prefix to specify a register other than CR8 causes an invalid-opcode\nexception. See the summary chart at the beginning of this section for encoding\ndata and limits.\n\nIf CR4.PCIDE = 1, bit 63 of the source operand to MOV to CR3 determines whether\nthe instruction invalidates entries in the TLBs and the paging-structure caches\n(see Section 4.10.4.1, \u201cOperations that Invalidate TLBs and Paging-Structure\nCaches,\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 3A). The instruction does not modify bit 63 of CR3, which is reserved\nand always 0.\n\nSee \u201cChanges to Instruction Behavior in VMX Non-Root Operation\u201d in Chapter 25\nof the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n3C, for more information about the behavior of this instruction in VMX non-root\noperation.\n\nOperation:\n\nDEST <- SRC;\n\nFlags Affected:\nThe OF, SF, ZF, AF, PF, and CF flags are undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the current privilege level is not    \n|       | 0. If an attempt is made to write invalid\n|       | bit combinations in CR0 (such as setting \n|       | the PG flag to 1 when the PE flag is     \n|       | set to 0, or setting the CD flag to      \n|       | 0 when the NW flag is set to 1). If      \n|       | an attempt is made to write a 1 to any   \n|       | reserved bit in CR4. If an attempt is    \n|       | made to write 1 to CR4.PCIDE. If any     \n|       | of the reserved bits are set in the      \n|       | page-directory pointers table (PDPT)     \n|       | and the loading of a control register    \n|       | causes the PDPT to be loaded into the    \n|       | processor.                               \n| #UD   | If the LOCK prefix is used. If an attempt\n|       | is made to access CR1, CR5, CR6, or      \n|       | CR7.                                     \n\nReal-Address Mode Exceptions:\n| #GP| If an attempt is made to write a 1 to    \n|    | any reserved bit in CR4. If an attempt   \n|    | is made to write 1 to CR4.PCIDE. If      \n|    | an attempt is made to write invalid      \n|    | bit combinations in CR0 (such as setting \n|    | the PG flag to 1 when the PE flag is     \n|    | set to 0).                               \n| #UD| If the LOCK prefix is used. If an attempt\n|    | is made to access CR1, CR5, CR6, or      \n|    | CR7.                                     \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| These instructions cannot be executed\n|       | in virtual-8086 mode.                \n\nCompatibility Mode Exceptions:\n| #GP(0)| If the current privilege level is not    \n|       | 0. If an attempt is made to write invalid\n|       | bit combinations in CR0 (such as setting \n|       | the PG flag to 1 when the PE flag is     \n|       | set to 0, or setting the CD flag to      \n|       | 0 when the NW flag is set to 1). If      \n|       | an attempt is made to change CR4.PCIDE   \n|       | from 0 to 1 while CR3[11:0] != 000H.      \n|       | If an attempt is made to clear CR0.PG[bit\n|       | 31] while CR4.PCIDE = 1. If an attempt   \n|       | is made to write a 1 to any reserved     \n|       | bit in CR3. If an attempt is made to     \n|       | leave IA-32e mode by clearing CR4.PAE[bit\n|       | 5].                                      \n| #UD   | If the LOCK prefix is used. If an attempt\n|       | is made to access CR1, CR5, CR6, or      \n|       | CR7.                                     \n\n64-Bit Mode Exceptions:\n| #GP(0)| If the current privilege level is not    \n|       | 0. If an attempt is made to write invalid\n|       | bit combinations in CR0 (such as setting \n|       | the PG flag to 1 when the PE flag is     \n|       | set to 0, or setting the CD flag to      \n|       | 0 when the NW flag is set to 1). If      \n|       | an attempt is made to change CR4.PCIDE   \n|       | from 0 to 1 while CR3[11:0] != 000H.      \n|       | If an attempt is made to clear CR0.PG[bit\n|       | 31]. If an attempt is made to write      \n|       | a 1 to any reserved bit in CR4. If an    \n|       | attempt is made to write a 1 to any      \n|       | reserved bit in CR8. If an attempt is    \n|       | made to write a 1 to any reserved bit    \n|       | in CR3. If an attempt is made to leave   \n|       | IA-32e mode by clearing CR4.PAE[bit      \n|       | 5].                                      \n| #UD   | If the LOCK prefix is used. If an attempt\n|       | is made to access CR1, CR5, CR6, or      \n|       | CR7. If the REX.R prefix is used to      \n|       | specify a register other than CR8.       \n\nMOV - Move to/from Debug Registers:\n| Opcode/Instruction       | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                         \n| 0F 21/r MOV r32, DR0-DR7 | MR   | N.E.       | Valid          | Move debug register to r32.         \n| 0F 21/r MOV r64, DR0-DR7 | MR   | Valid      | N.E.           | Move extended debug register to r64.\n| 0F 23 /r MOV DR0-DR7, r32| RM   | N.E.       | Valid          | Move r32 to debug register.         \n| 0F 23 /r MOV DR0-DR7, r64| RM   | Valid      | N.E.           | Move r64 to extended debug register.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nMoves the contents of a debug register (DR0, DR1, DR2, DR3, DR4, DR5, DR6, or\nDR7) to a general-purpose register or vice versa. The operand size for these\ninstructions is always 32 bits in non-64-bit modes, regardless of the operand-size\nattribute. (See Section 17.2, \u201cDebug Registers\u201d, of the Intel\u00ae 64 and IA-32\nArchitectures Software Developer's Manual, Volume 3A, for a detailed description\nof the flags and fields in the debug registers.)\n\nThe instructions must be executed at privilege level 0 or in real-address mode.\n\nWhen the debug extension (DE) flag in register CR4 is clear, these instructions\noperate on debug registers in a manner that is compatible with Intel386 and\nIntel486 processors. In this mode, references to DR4 and DR5 refer to DR6 and\nDR7, respectively. When the DE flag in CR4 is set, attempts to reference DR4\nand DR5 result in an undefined opcode (#UD) exception. (The CR4 register was\nadded to the IA-32 Architecture beginning with the Pentium processor.)\n\nAt the opcode level, the reg field within the ModR/M byte specifies which of\nthe debug registers is loaded or read. The two bits in the mod field are ignored.\nThe r/m field specifies the general-purpose register loaded or read.\n\nIn 64-bit mode, the instruction's default operation size is 64 bits. Use of\nthe REX.B prefix permits access to additional registers (R8-R15). Use of the\nREX.W or 66H prefix is ignored. Use of the REX.R prefix causes an invalidopcode\nexception. See the summary chart at the beginning of this section for encoding\ndata and limits.\n\nOperation:\n\nIF ((DE = 1) and (SRC or DEST = DR4 or DR5))\n  THEN\n     #UD;\n  ELSE\n     DEST <- SRC;\nFI;\n\nFlags Affected:\nThe OF, SF, ZF, AF, PF, and CF flags are undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the current privilege level is not      \n|       | 0.                                         \n| #UD   | If CR4.DE[bit 3] = 1 (debug extensions)    \n|       | and a MOV instruction is executed involving\n|       | DR4 or DR5. If the LOCK prefix is used.    \n| #DB   | If any debug register is accessed while    \n|       | the DR7.GD[bit 13] = 1.                    \n\nReal-Address Mode Exceptions:\n| #UD| If CR4.DE[bit 3] = 1 (debug extensions)    \n|    | and a MOV instruction is executed involving\n|    | DR4 or DR5. If the LOCK prefix is used.    \n| #DB| If any debug register is accessed while    \n|    | the DR7.GD[bit 13] = 1.                    \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| The debug registers cannot be loaded\n|       | or read when in virtual-8086 mode.  \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)| If the current privilege level is not      \n|       | 0. If an attempt is made to write a        \n|       | 1 to any of bits 63:32 in DR6. If an       \n|       | attempt is made to write a 1 to any        \n|       | of bits 63:32 in DR7.                      \n| #UD   | If CR4.DE[bit 3] = 1 (debug extensions)    \n|       | and a MOV instruction is executed involving\n|       | DR4 or DR5. If the LOCK prefix is used.    \n|       | If the REX.R prefix is used.               \n| #DB   | If any debug register is accessed while    \n|       | the DR7.GD[bit 13] = 1.                    \n", 
      "mnem": "MOV"
    }, 
    {
      "description": "\nMOVAPD - Move Aligned Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| 66 0F 28 /r MOVAPD xmm1, xmm2/m128        | RM   | V/V           | SSE2              | Move packed double-precision floating-point\n|                                           |      |               |                   | values from xmm2/m128 to xmm1.             \n| 66 0F 29 /r MOVAPD xmm2/m128, xmm1        | MR   | V/V           | SSE2              | Move packed double-precision floating-point\n|                                           |      |               |                   | values from xmm1 to xmm2/m128.             \n| VEX.128.66.0F.WIG 28 /r VMOVAPD xmm1,     | RM   | V/V           | AVX               | Move aligned packed double-precision       \n| xmm2/m128                                 |      |               |                   | floatingpoint values from xmm2/mem to      \n|                                           |      |               |                   | xmm1.                                      \n| VEX.128.66.0F.WIG 29 /r VMOVAPD xmm2/m128,| MR   | V/V           | AVX               | Move aligned packed double-precision       \n| xmm1                                      |      |               |                   | floatingpoint values from xmm1 to xmm2/mem.\n| VEX.256.66.0F.WIG 28 /r VMOVAPD ymm1,     | RM   | V/V           | AVX               | Move aligned packed double-precision       \n| ymm2/m256                                 |      |               |                   | floatingpoint values from ymm2/mem to      \n|                                           |      |               |                   | ymm1.                                      \n| VEX.256.66.0F.WIG 29 /r VMOVAPD ymm2/m256,| MR   | V/V           | AVX               | Move aligned packed double-precision       \n| ymm1                                      |      |               |                   | floatingpoint values from ymm1 to ymm2/mem.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nMoves 2 or 4 double-precision floating-point values from the source operand\n(second operand) to the destination operand (first operand). This instruction\ncan be used to load an XMM or YMM register from an 128-bit or 256-bit memory\nlocation, to store the contents of an XMM or YMM register into a 128-bit or\n256-bit memory location, or to move data between two XMM or two YMM registers.\nWhen the source or destination operand is a memory operand, the operand must\nbe aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version)\nboundary or a general-protection exception (#GP) will be generated.\n\nTo move double-precision floating-point values to and from unaligned memory\nlocations, use the (V)MOVUPD instruction.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit versions: Moves 128 bits of packed double-precision\nfloating-point values from the source operand (second operand) to the destination\noperand (first operand). This instruction can be used to load an XMM register\nfrom a 128-bit memory location, to store the contents of an XMM register into\na 128-bit memory location, or to move data between two XMM registers. When the\nsource or destination operand is a memory operand, the operand must be aligned\non a 16-byte boundary or a general-protection exception (#GP) will be generated.\nTo move single-precision floating-point values to and from unaligned memory\nlocations, use the VMOVUPD instruction. 128-bit Legacy SSE version: Bits (VLMAX-1:128)\nof the corresponding YMM destination register remain unchanged. VEX.128 encoded\nversion: Bits (VLMAX-1:128) of the destination YMM register destination are\nzeroed. VEX.256 encoded version: Moves 256 bits of packed double-precision floating-point\nvalues from the source operand (second operand) to the destination operand (first\noperand). This instruction can be used to load a YMM register from a 256-bit\nmemory location, to store the contents of a YMM register into a 256-bit memory\nlocation, or to move data between two YMM registers. When the source or destination\noperand is a memory operand, the operand must be aligned on a 32-byte boundary\nor a general-protection exception (#GP) will be generated. To move single-precision\nfloating-point values to and from unaligned memory locations, use the VMOVUPD\ninstruction.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise\ninstructions will #UD.\n\nOperation:\n\nMOVAPD (128-bit load- and register-copy- form Legacy SSE version)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] (Unmodified)\n(V)MOVAPD (128-bit store-form version)\nDEST[127:0] <- SRC[127:0]\nVMOVAPD (VEX.128 encoded version)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] <- 0\nVMOVAPD (VEX.256 encoded version)\nDEST[255:0] <- SRC[255:0]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVAPD: | __m128d _mm_load_pd (double const * \n|         | p);                                 \n| MOVAPD: | _mm_store_pd(double * p, __m128d a);\n| VMOVAPD:| __m256d _mm256_load_pd (double const\n|         | * p);                               \n| VMOVAPD:| _mm256_store_pd(double * p, __m256d \n|         | a);                                 \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 1.SSE2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVAPD"
    }, 
    {
      "description": "\nMOVAPS - Move Aligned Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                          | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| 0F 28 /r MOVAPS xmm1, xmm2/m128             | RM   | V/V           | SSE               | Move packed single-precision floating-point\n|                                             |      |               |                   | values from xmm2/m128 to xmm1.             \n| 0F 29 /r MOVAPS xmm2/m128, xmm1             | MR   | V/V           | SSE               | Move packed single-precision floating-point\n|                                             |      |               |                   | values from xmm1 to xmm2/m128.             \n| VEX.128.0F.WIG 28 /r VMOVAPS xmm1, xmm2/m128| RM   | V/V           | AVX               | Move aligned packed single-precision       \n|                                             |      |               |                   | floatingpoint values from xmm2/mem to      \n|                                             |      |               |                   | xmm1.                                      \n| VEX.128.0F.WIG 29 /r VMOVAPS xmm2/m128,     | MR   | V/V           | AVX               | Move aligned packed single-precision       \n| xmm1                                        |      |               |                   | floatingpoint values from xmm1 to xmm2/mem.\n| VEX.256.0F.WIG 28 /r VMOVAPS ymm1, ymm2/m256| RM   | V/V           | AVX               | Move aligned packed single-precision       \n|                                             |      |               |                   | floatingpoint values from ymm2/mem to      \n|                                             |      |               |                   | ymm1.                                      \n| VEX.256.0F.WIG 29 /r VMOVAPS ymm2/m256,     | MR   | V/V           | AVX               | Move aligned packed single-precision       \n| ymm1                                        |      |               |                   | floatingpoint values from ymm1 to ymm2/mem.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nMoves 4 or8 single-precision floating-point values from the source operand (second\noperand) to the destination operand (first operand). This instruction can be\nused to load an XMM or YMM register from an 128-bit or 256-bit memory location,\nto store the contents of an XMM or YMM register into a 128-bit or 256-bit memory\nlocation, or to move data between two XMM or two YMM registers. When the source\nor destination operand is a memory operand, the operand must be aligned on a\n16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary or a\ngeneral-protection exception (#GP) will be generated.\n\nTo move single-precision floating-point values to and from unaligned memory\nlocations, use the (V)MOVUPS instruction.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). Note: In VEX-encoded versions, VEX.vvvv is reserved\nand must be 1111b otherwise instructions will #UD. 128-bit versions: Moves 128\nbits of packed single-precision floating-point values from the source operand\n(second operand) to the destination operand (first operand). This instruction\ncan be used to load an XMM register from a 128-bit memory location, to store\nthe contents of an XMM register into a 128-bit memory location, or to move data\nbetween two XMM registers. When the source or destination operand is a memory\noperand, the operand must be aligned on a 16-byte boundary or a general-protection\nexception (#GP) will be generated. To move single-precision floatingpoint values\nto and from unaligned memory locations, use the VMOVUPS instruction. 128-bit\nLegacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128) of the\ndestination YMM register are zeroed. VEX.256 encoded version: Moves 256 bits\nof packed single-precision floating-point values from the source operand (second\noperand) to the destination operand (first operand). This instruction can be\nused to load a YMM register from a 256-bit memory location, to store the contents\nof a YMM register into a 256-bit memory location, or to move data between two\nYMM registers.\n\nOperation:\n\nMOVAPS (128-bit load- and register-copy- form Legacy SSE version)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] (Unmodified)\n(V)MOVAPS (128-bit store form)\nDEST[127:0] <- SRC[127:0]\nVMOVAPS (VEX.128 encoded version)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] <- 0\nVMOVAPS (VEX.256 encoded version)\nDEST[255:0] <- SRC[255:0]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVAPS: | __m128 _mm_load_ps (float const * p);\n| MOVAPS: | _mm_store_ps(float * p, __m128 a);   \n| VMOVAPS:| __m256 _mm256_load_ps (float const * \n|         | p);                                  \n| VMOVAPS:| _mm256_store_ps(float * p, __m256 a);\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 1.SSE; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVAPS"
    }, 
    {
      "description": "\nMOVBE - Move Data After Swapping Bytes:\n| Opcode             | Instruction   | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F 38 F0 /r        | MOVBE r16, m16| RM   | Valid      | Valid          | Reverse byte order in m16 and move to\n|                    |               |      |            |                | r16.                                 \n| 0F 38 F0 /r        | MOVBE r32, m32| RM   | Valid      | Valid          | Reverse byte order in m32 and move to\n|                    |               |      |            |                | r32.                                 \n| REX.W + 0F 38 F0 /r| MOVBE r64, m64| RM   | Valid      | N.E.           | Reverse byte order in m64 and move to\n|                    |               |      |            |                | r64.                                 \n| 0F 38 F1 /r        | MOVBE m16, r16| MR   | Valid      | Valid          | Reverse byte order in r16 and move to\n|                    |               |      |            |                | m16.                                 \n| 0F 38 F1 /r        | MOVBE m32, r32| MR   | Valid      | Valid          | Reverse byte order in r32 and move to\n|                    |               |      |            |                | m32.                                 \n| REX.W + 0F 38 F1 /r| MOVBE m64, r64| MR   | Valid      | N.E.           | Reverse byte order in r64 and move to\n|                    |               |      |            |                | m64.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nPerforms a byte swap operation on the data copied from the second operand (source\noperand) and store the result in the first operand (destination operand). The\nsource operand can be a general-purpose register, or memory location; the destination\nregister can be a general-purpose register, or a memory location; however, both\noperands can not be registers, and only one operand can be a memory location.\nBoth operands must be the same size, which can be a word, a doubleword or quadword.\n\nThe MOVBE instruction is provided for swapping the bytes on a read from memory\nor on a write to memory; thus providing support for converting little-endian\nvalues to big-endian format and vice versa.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.R prefix permits access to additional registers (R8-R15). Use of the\nREX.W prefix promotes operation to 64 bits. See the summary chart at the beginning\nof this section for encoding data and limits.\n\nOperation:\n\nTEMP <- SRC\nIF ( OperandSize = 16)\n  THEN\n     DEST[7:0] <- TEMP[15:8];\n     DEST[15:8] <- TEMP[7:0];\n  ELES IF\n     DEST[7:0] <- TEMP[31:24];\n     DEST[15:8] <- TEMP[23:16];\n     DEST[23:16] <- TEMP[15:8];\n     DEST[31:23] <- TEMP[7:0];\n  ELSE IF ( OperandSize = 64)\n     DEST[7:0] <- TEMP[63:56];\n     DEST[15:8] <- TEMP[55:48];\n     DEST[23:16] <- TEMP[47:40];\n     DEST[31:24] <- TEMP[39:32];\n     DEST[39:32] <- TEMP[31:24];\n     DEST[47:40] <- TEMP[23:16];\n     DEST[55:48] <- TEMP[15:8];\n     DEST[63:56] <- TEMP[7:0];\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination operand is in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register contains a NULL segment     \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If CPUID.01H:ECX.MOVBE[bit 22] = 0.            \n|                | If the LOCK prefix is used. If REP (F3H)       \n|                | prefix is used.                                \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address   \n|    | is outside the CS, DS, ES, FS, or GS    \n|    | segment limit.                          \n| #SS| If a memory operand effective address   \n|    | is outside the SS segment limit.        \n| #UD| If CPUID.01H:ECX.MOVBE[bit 22] = 0.     \n|    | If the LOCK prefix is used. If REP (F3H)\n|    | prefix is used.                         \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address   \n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit.                          \n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made   \n|                | while the current privilege level is    \n|                | 3.                                      \n| #UD            | If CPUID.01H:ECX.MOVBE[bit 22] = 0.     \n|                | If the LOCK prefix is used. If REP (F3H)\n|                | prefix is used. If REPNE (F2H) prefix   \n|                | is used and CPUID.01H:ECX.SSE4_2[bit    \n|                | 20] = 0.                                \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #SS(0)         | If the stack address is in a non-canonical \n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If CPUID.01H:ECX.MOVBE[bit 22] = 0.        \n|                | If the LOCK prefix is used. If REP (F3H)   \n|                | prefix is used.                            \n", 
      "mnem": "MOVBE"
    }, 
    {
      "description": "\nMOVD/MOVQ - Move Doubleword/Move Quadword:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                              \n| 0F 6E /r MOVD mm, r/m32                   | RM   | V/V           | MMX               | Move doubleword from r/m32 to mm.        \n| REX.W + 0F 6E /r MOVQ mm, r/m64           | RM   | V/N.E.        | MMX               | Move quadword from r/m64 to mm.          \n| 0F 7E /r MOVD r/m32, mm                   | MR   | V/V           | MMX               | Move doubleword from mm to r/m32.        \n| REX.W + 0F 7E /r MOVQ r/m64, mm           | MR   | V/N.E.        | MMX               | Move quadword from mm to r/m64.          \n| VEX.128.66.0F.W0 6E /VMOVD xmm1, r32/m32  | RM   | V/V           | AVX               | Move doubleword from r/m32 to xmm1.      \n| VEX.128.66.0F.W1 6E /r VMOVQ xmm1, r64/m64| RM   | V/N.E.        | AVX               | Move quadword from r/m64 to xmm1.        \n| 66 0F 6E /r MOVD xmm, r/m32               | RM   | V/V           | SSE2              | Move doubleword from r/m32 to xmm.       \n| 66 REX.W 0F 6E /r MOVQ xmm, r/m64         | RM   | V/N.E.        | SSE2              | Move quadword from r/m64 to xmm.         \n| 66 0F 7E /r MOVD r/m32, xmm               | MR   | V/V           | SSE2              | Move doubleword from xmm register to     \n|                                           |      |               |                   | r/m32.                                   \n| 66 REX.W 0F 7E /r MOVQ r/m64, xmm         | MR   | V/N.E.        | SSE2              | Move quadword from xmm register to r/m64.\n| VEX.128.66.0F.W0 7E /r VMOVD r32/m32,     | MR   | V/V           | AVX               | Move doubleword from xmm1 register to    \n| xmm1                                      |      |               |                   | r/m32.                                   \n| VEX.128.66.0F.W1 7E /r VMOVQ r64/m64,     | MR   | V/N.E.        | AVX               | Move quadword from xmm1 register to      \n| xmm1                                      |      |               |                   | r/m64.                                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nCopies a doubleword from the source operand (second operand) to the destination\noperand (first operand). The source and destination operands can be general-purpose\nregisters, MMX technology registers, XMM registers, or 32-bit memory locations.\nThis instruction can be used to move a doubleword to and from the low doubleword\nof an MMX technology register and a general-purpose register or a 32-bit memory\nlocation, or to and from the low doubleword of an XMM register and a general-purpose\nregister or a 32-bit memory location. The instruction cannot be used to transfer\ndata between MMX technology registers, between XMM registers, between general-purpose\nregisters, or between memory locations.\n\nWhen the destination operand is an MMX technology register, the source operand\nis written to the low doubleword of the register, and the register is zero-extended\nto 64 bits. When the destination operand is an XMM register, the source operand\nis written to the low doubleword of the register, and the register is zero-extended\nto 128 bits.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.R prefix permits access to additional registers (R8-R15). Use of the\nREX.W prefix promotes operation to 64 bits. See the summary chart at the beginning\nof this section for encoding data and limits.\n\nOperation:\n\nMOVD (when destination operand is MMX technology register)\n  DEST[31:0] <- SRC;\n  DEST[63:32] <- 00000000H;\nMOVD (when destination operand is XMM register)\n  DEST[31:0] <- SRC;\n  DEST[127:32] <- 000000000000000000000000H;\n  DEST[VLMAX-1:128] (Unmodified)\nMOVD (when source operand is MMX technology or XMM register)\n  DEST <- SRC[31:0];\nVMOVD (VEX-encoded version when destination is an XMM register)\n  DEST[31:0] <- SRC[31:0]\n  DEST[VLMAX-1:32] <- 0\nMOVQ (when destination operand is XMM register)\n  DEST[63:0] <- SRC[63:0];\n  DEST[127:64] <- 0000000000000000H;\n  DEST[VLMAX-1:128] (Unmodified)\nMOVQ (when destination operand is r/m64)\n  DEST[63:0] <- SRC[63:0];\nMOVQ (when source operand is XMM register or r/m64)\n  DEST <- SRC[63:0];\nVMOVQ (VEX-encoded version when destination is an XMM register)\n  DEST[63:0] <- SRC[63:0]\n  DEST[VLMAX-1:64] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVD:| __m64 _mm_cvtsi32_si64 (int i )    \n| MOVD:| int _mm_cvtsi64_si32 ( __m64m )    \n| MOVD:| __m128i _mm_cvtsi32_si128 (int a)  \n| MOVD:| int _mm_cvtsi128_si32 ( __m128i a) \n| MOVQ:| __int64 _mm_cvtsi128_si64(__m128i);\n| MOVQ:| __m128i _mm_cvtsi64_si128(__int64);\n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n\nMOVQ - Move Quadword:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                           \n| 0F 6F /r MOVQ mm, mm/m64               | RM   | V/V           | MMX               | Move quadword from mm/m64 to mm.      \n| 0F 7F /r MOVQ mm/m64, mm               | MR   | V/V           | MMX               | Move quadword from mm to mm/m64.      \n| F3 0F 7E /r MOVQ xmm1, xmm2/m64        | RM   | V/V           | SSE2              | Move quadword from xmm2/mem64 to xmm1.\n| VEX.128.F3.0F.WIG 7E /r VMOVQ xmm1,    | RM   | V/V           | AVX               | Move quadword from xmm2 to xmm1.      \n| xmm2                                   |      |               |                   |                                       \n| VEX.128.F3.0F.WIG 7E /r VMOVQ xmm1,    | RM   | V/V           | AVX               | Load quadword from m64 to xmm1.       \n| m64                                    |      |               |                   |                                       \n| 66 0F D6 /r MOVQ xmm2/m64, xmm1        | MR   | V/V           | SSE2              | Move quadword from xmm1 to xmm2/mem64.\n| VEX.128.66.0F.WIG D6 /r VMOVQ xmm1/m64,| MR   | V/V           | AVX               | Move quadword from xmm2 register to   \n| xmm2                                   |      |               |                   | xmm1/m64.                             \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nCopies a quadword from the source operand (second operand) to the destination\noperand (first operand). The source and destination operands can be MMX technology\nregisters, XMM registers, or 64-bit memory locations. This instruction can be\nused to move a quadword between two MMX technology registers or between an MMX\ntechnology register and a 64-bit memory location, or to move data between two\nXMM registers or between an XMM register and a 64-bit memory location. The instruction\ncannot be used to transfer data between memory locations.\n\nWhen the source operand is an XMM register, the low quadword is moved; when\nthe destination operand is an XMM register, the quadword is stored to the low\nquadword of the register, and the high quadword is cleared to all 0s.\n\nIn 64-bit mode, use of the REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). Note: In VEX.128.66.0F D6 instruction\nversion, VEX.vvvv and VEX.L=1 are reserved and the former must be 1111b otherwise\ninstructions will #UD. Note: In VEX.128.F3.0F 7E version, VEX.vvvv and VEX.L=1\nare reserved and the former must be 1111b, otherwise instructions will #UD.\n\nOperation:\n\nMOVQ instruction when operating on MMX technology registers and memory locations:\n  DEST <- SRC;\nMOVQ instruction when source and destination operands are XMM registers:\n  DEST[63:0] <- SRC[63:0];\n  DEST[127:64] <- 0000000000000000H;\nMOVQ instruction when source operand is XMM register and destination\noperand is memory location:\n  DEST <- SRC[63:0];\nMOVQ instruction when source operand is memory location and destination\noperand is XMM register:\n  DEST[63:0] <- SRC;\n  DEST[127:64] <- 0000000000000000H;\nVMOVQ (VEX.NDS.128.F3.0F 7E) with XMM register source and destination:\nDEST[63:0] <- SRC[63:0]\nDEST[VLMAX-1:64] <- 0\nVMOVQ (VEX.128.66.0F D6) with XMM register source and destination:\nDEST[63:0] <- SRC[63:0]\nDEST[VLMAX-1:64] <- 0\nVMOVQ (7E) with memory source:\nDEST[63:0] <- SRC[63:0]\nDEST[VLMAX-1:64] <- 0\nVMOVQ (D6) with memory dest:\nDEST[63:0] <- SRC2[63:0]\n\nFlags Affected:\nNone.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVQ:| m128i _mm_mov_epi64(__m128i a)\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Table 22-8, \u201cException Conditions for Legacy SIMD/MMX Instructions without\nFP Exception,\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3B.\n", 
      "mnem": "MOVD"
    }, 
    {
      "description": "\nMOVDDUP - Move One Double-FP and Duplicate:\n| Opcode/Instruction                    | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                   \n| F2 0F 12 /r MOVDDUP xmm1, xmm2/m64    | RM   | V/V           | SSE3              | Move one double-precision floating-point      \n|                                       |      |               |                   | value from the lower 64-bit operand           \n|                                       |      |               |                   | in xmm2/m64 to xmm1 and duplicate.            \n| VEX.128.F2.0F.WIG 12 /r VMOVDDUP xmm1,| RM   | V/V           | AVX               | Move double-precision floating-point          \n| xmm2/m64                              |      |               |                   | values from xmm2/mem and duplicate into       \n|                                       |      |               |                   | xmm1.                                         \n| VEX.256.F2.0F.WIG 12 /r VMOVDDUP ymm1,| RM   | V/V           | AVX               | Move even index double-precision floatingpoint\n| ymm2/m256                             |      |               |                   | values from ymm2/mem and duplicate each       \n|                                       |      |               |                   | element into ymm1.                            \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nThe linear address corresponds to the address of the least-significant byte\nof the referenced memory data. When a memory address is indicated, the 8 bytes\nof data at memory location m64 are loaded. When the register-register form of\nthis operation is used, the lower half of the 128-bit source register is duplicated\nand copied into the 128-bit destination register. See Figure 3-24.\n\nMOVDDUP xmm1, xmm2/m64\n\n| [63:0]| xmm2/m64\nRESULT:\n\n| xmm1[127:64]| xmm2/m64[63:0][127:64]| xmm1[63:0]| xmm2/m64[63:0]xmm1 [63:0]\nOM15997\n\n| Figure 3-24.| MOVDDUP - Move One Double-FP and Duplicate\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nOperation:\n\nIF (Source = m64)\n  THEN\n     (* Load instruction *)\n     xmm1[63:0] = m64;\n     xmm1[127:64] = m64;\n  ELSE\n     (* Move instruction *)\n     xmm1[63:0] = xmm2[63:0];\n     xmm1[127:64] = xmm2[63:0];\nFI;\nMOVDDUP (128-bit Legacy SSE version)\nDEST[63:0] <- SRC[63:0]\nDEST[127:64] <- SRC[63:0]\nDEST[VLMAX-1:128] (Unmodified)\nVMOVDDUP (VEX.128 encoded version)\nDEST[63:0] <- SRC[63:0]\nDEST[127:64] <- SRC[63:0]\nDEST[VLMAX-1:128] <- 0\nVMOVDDUP (VEX.256 encoded version)\nDEST[63:0] <- SRC[63:0]\nDEST[127:64] <- SRC[63:0]\nDEST[191:128] <- SRC[191:128]\nDEST[255:192] <- SRC[191:128]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVDDUP:| __m128d _mm_movedup_pd(__m128d a)  \n| MOVDDUP:| __m128d _mm_loaddup_pd(double const\n|         | * dp)                              \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVDDUP"
    }, 
    {
      "description": "\nMOVDQ2Q - Move Quadword from XMM to MMX Technology Register:\n| Opcode     | Instruction    | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                \n| F2 0F D6 /r| MOVDQ2Q mm, xmm| RM   | Valid      | Valid          | Move low quadword from xmm to mmx register.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nMoves the low quadword from the source operand (second operand) to the destination\noperand (first operand). The source operand is an XMM register and the destination\noperand is an MMX technology register.\n\nThis instruction causes a transition from x87 FPU to MMX technology operation\n(that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word\nis set to all 0s [valid]). If this instruction is executed while an x87 FPU\nfloating-point exception is pending, the exception is handled before the MOVDQ2Q\ninstruction is executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nOperation:\n\nDEST <- SRC[63:0];\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVDQ2Q:| __m64 _mm_movepi64_pi64 ( __m128i a)\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #NM| If CR0.TS[bit 3] = 1.                   \n| #UD| If CR0.EM[bit 2] = 1. If CR4.OSFXSR[bit \n|    | 9] = 0. If CPUID.01H:EDX.SSE2[bit 26]   \n|    | = 0. If the LOCK prefix is used.        \n| #MF| If there is a pending x87 FPU exception.\n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "MOVDQ2Q"
    }, 
    {
      "description": "\nMOVDQA - Move Aligned Double Quadword:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| 66 0F 6F /r MOVDQA xmm1, xmm2/m128        | RM   | V/V           | SSE2              | Move aligned double quadword from xmm2/m128\n|                                           |      |               |                   | to xmm1.                                   \n| 66 0F 7F /r MOVDQA xmm2/m128, xmm1        | MR   | V/V           | SSE2              | Move aligned double quadword from xmm1     \n|                                           |      |               |                   | to xmm2/m128.                              \n| VEX.128.66.0F.WIG 6F /r VMOVDQA xmm1,     | RM   | V/V           | AVX               | Move aligned packed integer values from    \n| xmm2/m128                                 |      |               |                   | xmm2/mem to xmm1.                          \n| VEX.128.66.0F.WIG 7F /r VMOVDQA xmm2/m128,| MR   | V/V           | AVX               | Move aligned packed integer values from    \n| xmm1                                      |      |               |                   | xmm1 to xmm2/mem.                          \n| VEX.256.66.0F.WIG 6F /r VMOVDQA ymm1,     | RM   | V/V           | AVX               | Move aligned packed integer values from    \n| ymm2/m256                                 |      |               |                   | ymm2/mem to ymm1.                          \n| VEX.256.66.0F.WIG 7F /r VMOVDQA ymm2/m256,| MR   | V/V           | AVX               | Move aligned packed integer values from    \n| ymm1                                      |      |               |                   | ymm1 to ymm2/mem.                          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\n128-bit versions: Moves 128 bits of packed integer values from the source operand\n(second operand) to the destination operand (first operand). This instruction\ncan be used to load an XMM register from a 128-bit memory location, to store\nthe contents of an XMM register into a 128-bit memory location, or to move data\nbetween two XMM registers. When the source or destination operand is a memory\noperand, the operand must be aligned on a 16-byte boundary or a general-protection\nexception (#GP) will be generated. To move integer data to and from unaligned\nmemory locations, use the VMOVDQU instruction.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: Bits (VLMAX-1:128) of the\ncorresponding YMM destination register remain unchanged. VEX.128 encoded version:\nBits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.256 encoded\nversion: Moves 256 bits of packed integer values from the source operand (second\noperand) to the destination operand (first operand). This instruction can be\nused to load a YMM register from a 256-bit memory location, to store the contents\nof a YMM register into a 256-bit memory location, or to move data between two\nYMM registers. When the source or destination operand is a memory operand, the\noperand must be aligned on a 32-byte boundary or a general-protection exception\n(#GP) will be generated. To move integer data to and from unaligned memory locations,\nuse the VMOVDQU instruction. Note: In VEX-encoded versions, VEX.vvvv is reserved\nand must be 1111b otherwise instructions will #UD.\n\nOperation:\n\nMOVDQA (128-bit load- and register- form Legacy SSE version)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] (Unmodified)\n(* #GP if SRC or DEST unaligned memory operand *)\n(V)MOVDQA (128-bit store forms)\nDEST[127:0] <- SRC[127:0]\nVMOVDQA (VEX.128 encoded version)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] <- 0\nVMOVDQA (VEX.256 encoded version)\nDEST[255:0] <- SRC[255:0]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVDQA: | __m128i _mm_load_si128 ( __m128i *p)      \n| MOVDQA: | void _mm_store_si128 ( __m128i *p, __m128i\n|         | a)                                        \n| VMOVDQA:| __m256i _mm256_load_si256 (__m256i *      \n|         | p);                                       \n| VMOVDQA:| _mm256_store_si256(_m256i *p, __m256i     \n|         | a);                                       \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 1.SSE2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVDQA"
    }, 
    {
      "description": "\nMOVDQU - Move Unaligned Double Quadword:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                         \n| F3 0F 6F /r MOVDQU xmm1, xmm2/m128        | RM   | V/V           | SSE2              | Move unaligned double quadword from \n|                                           |      |               |                   | xmm2/m128 to xmm1.                  \n| F3 0F 7F /r MOVDQU xmm2/m128, xmm1        | MR   | V/V           | SSE2              | Move unaligned double quadword from \n|                                           |      |               |                   | xmm1 to xmm2/m128.                  \n| VEX.128.F3.0F.WIG 6F /r VMOVDQU xmm1,     | RM   | V/V           | AVX               | Move unaligned packed integer values\n| xmm2/m128                                 |      |               |                   | from xmm2/mem to xmm1.              \n| VEX.128.F3.0F.WIG 7F /r VMOVDQU xmm2/m128,| MR   | V/V           | AVX               | Move unaligned packed integer values\n| xmm1                                      |      |               |                   | from xmm1 to xmm2/mem.              \n| VEX.256.F3.0F.WIG 6F /r VMOVDQU ymm1,     | RM   | V/V           | AVX               | Move unaligned packed integer values\n| ymm2/m256                                 |      |               |                   | from ymm2/mem to ymm1.              \n| VEX.256.F3.0F.WIG 7F /r VMOVDQU ymm2/m256,| MR   | V/V           | AVX               | Move unaligned packed integer values\n| ymm1                                      |      |               |                   | from ymm1 to ymm2/mem.              \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\n128-bit versions:\n\nMoves 128 bits of packed integer values from the source operand (second operand)\nto the destination operand (first operand). This instruction can be used to\nload an XMM register from a 128-bit memory location, to store the contents of\nan XMM register into a 128-bit memory location, or to move data between two\nXMM registers. When the source or destination operand is a memory operand, the\noperand may be unaligned on a 16-byte boundary without causing a general-protection\nexception (#GP) to be generated.1\n\nTo move a double quadword to or from memory locations that are known to be aligned\non 16-byte boundaries, use the MOVDQA instruction.\n\nWhile executing in 16-bit addressing mode, a linear address for a 128-bit data\naccess that overlaps the end of a 16bit segment is not allowed and is defined\nas reserved behavior. A specific processor implementation may or may not generate\na general-protection exception (#GP) in this situation, and the address that\nspans the end of the segment may or may not wrap around to the beginning of\nthe segment.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: Bits (VLMAX-1:128) of the\ncorresponding YMM destination register remain unchanged. When the source or\ndestination operand is a memory operand, the operand may be unaligned to any\nalignment without causing a general-protection exception (#GP) to be generated\nVEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register\nare zeroed.\n\nVEX.256 encoded version: Moves 256 bits of packed integer values from the source\noperand (second operand) to the destination operand (first operand). This instruction\ncan be used to load a YMM register from a 256-bit memory\n\n| 1.| If alignment checking is enabled (CR0.AM  \n|   | = 1, RFLAGS.AC = 1, and CPL = 3), an      \n|   | alignment-check exception (#AC) may       \n|   | or may not be generated (depending on     \n|   | processor implementation) when the operand\n|   | is not aligned on an 8-byte boundary.     \nlocation, to store the contents of a YMM register into a 256-bit memory location,\nor to move data between two YMM registers. Note: In VEX-encoded versions, VEX.vvvv\nis reserved and must be 1111b otherwise instructions will #UD.\n\nOperation:\n\nMOVDQU load and register copy (128-bit Legacy SSE version)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] (Unmodified)\n(V)MOVDQU 128-bit store-form versions\nDEST[127:0] <- SRC[127:0]\nVMOVDQU (VEX.128 encoded version)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] <- 0\nVMOVDQU (VEX.256 encoded version)\nDEST[255:0] <- SRC[255:0]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVDQU: | void _mm_storeu_si128 ( __m128i *p,   \n|         | __m128i a)                            \n| MOVDQU: | __m128i _mm_loadu_si128 ( __m128i *p) \n| VMOVDQU:| __m256i _mm256_loadu_si256 (__m256i   \n|         | * p);                                 \n| VMOVDQU:| _mm256_storeu_si256(_m256i *p, __m256i\n|         | a);                                   \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVDQU"
    }, 
    {
      "description": "\nMOVHLPS -  Move Packed Single-Precision Floating-Point Values High to Low:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                    \n| 0F 12 /r MOVHLPS xmm1, xmm2            | RM   | V/V           | SSE               | Move two packed single-precision floatingpoint \n|                                        |      |               |                   | values from high quadword of xmm2 to           \n|                                        |      |               |                   | low quadword of xmm1.                          \n| VEX.NDS.128.0F.WIG 12 /r VMOVHLPS xmm1,| RVM  | V/V           | AVX               | Merge two packed single-precision floatingpoint\n| xmm2, xmm3                             |      |               |                   | values from high quadword of xmm3 and          \n|                                        |      |               |                   | low quadword of xmm2.                          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nThis instruction cannot be used for memory to register moves. 128-bit two-argument\nform: Moves two packed single-precision floating-point values from the high\nquadword of the second XMM argument (second operand) to the low quadword of\nthe first XMM register (first argument). The high quadword of the destination\noperand is left unchanged. Bits (VLMAX-1:64) of the corresponding YMM destination\nregister are unmodified. 128-bit three-argument form Moves two packed single-precision\nfloating-point values from the high quadword of the third XMM argument (third\noperand) to the low quadword of the destination (first operand). Copies the\nhigh quadword from the second XMM argument (second operand) to the high quadword\nof the destination (first operand). Bits (VLMAX-1:128) of the destination YMM\nregister are zeroed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). If VMOVHLPS is encoded with VEX.L= 1, an attempt to\nexecute the instruction encoded with VEX.L= 1 will cause an #UD exception.\n\nOperation:\n\nMOVHLPS (128-bit two-argument form)\nDEST[63:0] <- SRC[127:64]\nDEST[VLMAX-1:64] (Unmodified)\nVMOVHLPS (128-bit three-argument form)\nDEST[63:0] <- SRC2[127:64]\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVHLPS:| __m128 _mm_movehl_ps(__m128 a, __m128\n|         | b)                                   \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 7; additionally\n\n| #UD| If VEX.L= 1.\n", 
      "mnem": "MOVHLPS"
    }, 
    {
      "description": "\nMOVHPD - Move High Packed Double-Precision Floating-Point Value:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                            \n| 66 0F 16 /r MOVHPD xmm, m64            | RM   | V/V           | SSE2              | Move double-precision floating-point   \n|                                        |      |               |                   | value from m64 to high quadword of xmm.\n| 66 0F 17 /r MOVHPD m64, xmm            | MR   | V/V           | SSE2              | Move double-precision floating-point   \n|                                        |      |               |                   | value from high quadword of xmm to m64.\n| VEX.NDS.128.66.0F.WIG 16 /r VMOVHPD    | RVM  | V/V           | AVX               | Merge double-precision floating-point  \n| xmm2, xmm1, m64                        |      |               |                   | value from m64 and the low quadword    \n|                                        |      |               |                   | of xmm1.                               \n| VEX128.66.0F.WIG 17/r VMOVHPD m64, xmm1| MR   | V/V           | AVX               | Move double-precision floating-point   \n|                                        |      |               |                   | values from high quadword of xmm1 to   \n|                                        |      |               |                   | m64.                                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| MR   | ModRM:r/m (w)   | ModRM:reg (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nThis instruction cannot be used for register to register or memory to memory\nmoves. 128-bit Legacy SSE load: Moves a double-precision floating-point value\nfrom the source 64-bit memory operand and stores it in the high 64bits of the\ndestination XMM register. The lower 64bits of the XMM register are preserved.\nThe upper 128-bits of the corresponding YMM destination register are preserved.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). VEX.128 encoded load: Loads a double-precision floating-point\nvalue from the source 64-bit memory operand (third operand) and stores it in\nthe upper 64-bits of the destination XMM register (first operand). The low 64-bits\nfrom second XMM register (second operand) are stored in the lower 64-bits of\nthe destination. The upper 128-bits of the destination YMM register are zeroed.\n128-bit store: Stores a double-precision floating-point value from the high\n64-bits of the XMM register source (second operand) to the 64-bit memory location\n(first operand). Note: VMOVHPD (store) (VEX.128.66.0F 17 /r) is legal and has\nthe same behavior as the existing 66 0F 17 store. For VMOVHPD (store) (VEX.128.66.0F\n17 /r) instruction version, VEX.vvvv is reserved and must be 1111b otherwise\ninstruction will #UD. If VMOVHPD is encoded with VEX.L= 1, an attempt to execute\nthe instruction encoded with VEX.L= 1 will cause an #UD exception.\n\nOperation:\n\nMOVHPD (128-bit Legacy SSE load)\nDEST[63:0] (Unmodified)\nDEST[127:64] <- SRC[63:0]\nDEST[VLMAX-1:128] (Unmodified)\nVMOVHPD (VEX.128 encoded load)\nDEST[63:0] <- SRC1[63:0]\nDEST[127:64] <- SRC2[63:0]\nDEST[VLMAX-1:128] <- 0\nVMOVHPD (store)\nDEST[63:0] <- SRC[127:64]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVHPD:| __m128d _mm_loadh_pd ( __m128d a, double\n|        | *p)                                     \n| MOVHPD:| void _mm_storeh_pd (double *p, __m128d  \n|        | a)                                      \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L= 1.\n", 
      "mnem": "MOVHPD"
    }, 
    {
      "description": "\nMOVHPS - Move High Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                    | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                    \n| 0F 16 /r MOVHPS xmm, m64              | RM   | V/V           | SSE               | Move two packed single-precision floatingpoint \n|                                       |      |               |                   | values from m64 to high quadword of            \n|                                       |      |               |                   | xmm.                                           \n| 0F 17 /r MOVHPS m64, xmm              | MR   | V/V           | SSE               | Move two packed single-precision floatingpoint \n|                                       |      |               |                   | values from high quadword of xmm to            \n|                                       |      |               |                   | m64.                                           \n| VEX.NDS.128.0F.WIG 16 /r VMOVHPS xmm2,| RVM  | V/V           | AVX               | Merge two packed single-precision floatingpoint\n| xmm1, m64                             |      |               |                   | values from m64 and the low quadword           \n|                                       |      |               |                   | of xmm1.                                       \n| VEX.128.0F.WIG 17/r VMOVHPS m64, xmm1 | MR   | V/V           | AVX               | Move two packed single-precision floatingpoint \n|                                       |      |               |                   | values from high quadword of xmm1to            \n|                                       |      |               |                   | m64.                                           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| MR   | ModRM:r/m (w)   | ModRM:reg (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nThis instruction cannot be used for register to register or memory to memory\nmoves. 128-bit Legacy SSE load: Moves two packed single-precision floating-point\nvalues from the source 64-bit memory operand and stores them in the high 64-bits\nof the destination XMM register. The lower 64bits of the XMM register are preserved.\nThe upper 128-bits of the corresponding YMM destination register are preserved.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). VEX.128 encoded load: Loads two single-precision floating-point\nvalues from the source 64-bit memory operand (third operand) and stores it in\nthe upper 64-bits of the destination XMM register (first operand). The low 64-bits\nfrom second XMM register (second operand) are stored in the lower 64-bits of\nthe destination. The upper 128-bits of the destination YMM register are zeroed.\n128-bit store: Stores two packed single-precision floating-point values from\nthe high 64-bits of the XMM register source (second operand) to the 64-bit memory\nlocation (first operand). Note: VMOVHPS (store) (VEX.NDS.128.0F 17 /r) is legal\nand has the same behavior as the existing 0F 17 store. For VMOVHPS (store) (VEX.NDS.128.0F\n17 /r) instruction version, VEX.vvvv is reserved and must be 1111b otherwise\ninstruction will #UD. If VMOVHPS is encoded with VEX.L= 1, an attempt to execute\nthe instruction encoded with VEX.L= 1 will cause an #UD exception.\n\nOperation:\n\nMOVHPS (128-bit Legacy SSE load)\nDEST[63:0] (Unmodified)\nDEST[127:64] <- SRC[63:0]\nDEST[VLMAX-1:128] (Unmodified)\nVMOVHPS (VEX.128 encoded load)\nDEST[63:0] <- SRC1[63:0]\nDEST[127:64] <- SRC2[63:0]\nDEST[VLMAX-1:128] <- 0\nVMOVHPS (store)\nDEST[63:0] <- SRC[127:64]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVHPS:| __m128d _mm_loadh_pi ( __m128d a, __m64\n|        | *p)                                    \n| MOVHPS:| void _mm_storeh_pi (__m64 *p, __m128d  \n|        | a)                                     \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L= 1.\n", 
      "mnem": "MOVHPS"
    }, 
    {
      "description": "\nMOVLHPS - Move Packed Single-Precision Floating-Point Values Low to High:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                    \n| 0F 16 /r MOVLHPS xmm1, xmm2            | RM   | V/V           | SSE               | Move two packed single-precision floatingpoint \n|                                        |      |               |                   | values from low quadword of xmm2 to            \n|                                        |      |               |                   | high quadword of xmm1.                         \n| VEX.NDS.128.0F.WIG 16 /r VMOVLHPS xmm1,| RVM  | V/V           | AVX               | Merge two packed single-precision floatingpoint\n| xmm2, xmm3                             |      |               |                   | values from low quadword of xmm3 and           \n|                                        |      |               |                   | low quadword of xmm2.                          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nThis instruction cannot be used for memory to register moves. 128-bit two-argument\nform: Moves two packed single-precision floating-point values from the low quadword\nof the second XMM argument (second operand) to the high quadword of the first\nXMM register (first argument). The low quadword of the destination operand is\nleft unchanged. The upper 128 bits of the corresponding YMM destination register\nare unmodified. 128-bit three-argument form Moves two packed single-precision\nfloating-point values from the low quadword of the third XMM argument (third\noperand) to the high quadword of the destination (first operand). Copies the\nlow quadword from the second XMM argument (second operand) to the low quadword\nof the destination (first operand). The upper 128-bits of the destination YMM\nregister are zeroed. If VMOVLHPS is encoded with VEX.L= 1, an attempt to execute\nthe instruction encoded with VEX.L= 1 will cause an #UD exception.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nOperation:\n\nMOVLHPS (128-bit two-argument form)\nDEST[63:0] (Unmodified)\nDEST[127:64] <- SRC[63:0]\nDEST[VLMAX-1:128] (Unmodified)\nVMOVLHPS (128-bit three-argument form)\nDEST[63:0] <- SRC1[63:0]\nDEST[127:64] <- SRC2[63:0]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVHLPS:| __m128 _mm_movelh_ps(__m128 a, __m128\n|         | b)                                   \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 7; additionally\n\n| #UD| If VEX.L= 1.\n", 
      "mnem": "MOVLHPS"
    }, 
    {
      "description": "\nMOVLPD - Move Low Packed Double-Precision Floating-Point Value:\n| Opcode/Instruction                 | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                             \n| 66 0F 12 /r MOVLPD xmm, m64        | RM   | V/V           | SSE2              | Move double-precision floating-point    \n|                                    |      |               |                   | value from m64 to low quadword of xmm   \n|                                    |      |               |                   | register.                               \n| 66 0F 13 /r MOVLPD m64, xmm        | MR   | V/V           | SSE2              | Move double-precision floating-point    \n|                                    |      |               |                   | nvalue from low quadword of xmm register\n|                                    |      |               |                   | to m64.                                 \n| VEX.NDS.128.66.0F.WIG 12 /r VMOVLPD| RVM  | V/V           | AVX               | Merge double-precision floating-point   \n| xmm2, xmm1, m64                    |      |               |                   | value from m64 and the high quadword    \n|                                    |      |               |                   | of xmm1.                                \n| VEX.128.66.0F.WIG 13/r VMOVLPD m64,| MR   | V/V           | AVX               | Move double-precision floating-point    \n| xmm1                               |      |               |                   | values from low quadword of xmm1 to     \n|                                    |      |               |                   | m64.                                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| MR   | ModRM:r/m (w)   | ModRM:reg (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nThis instruction cannot be used for register to register or memory to memory\nmoves. 128-bit Legacy SSE load: Moves a double-precision floating-point value\nfrom the source 64-bit memory operand and stores it in the low 64bits of the\ndestination XMM register. The upper 64bits of the XMM register are preserved.\nThe upper 128-bits of the corresponding YMM destination register are preserved.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). VEX.128 encoded load: Loads a double-precision floating-point\nvalue from the source 64-bit memory operand (third operand), merges it with\nthe upper 64-bits of the first source XMM register (second operand), and stores\nit in the low 128-bits of the destination XMM register (first operand). The\nupper 128-bits of the destination YMM register are zeroed. 128-bit store: Stores\na double-precision floating-point value from the low 64-bits of the XMM register\nsource (second operand) to the 64-bit memory location (first operand). Note:\nVMOVLPD (store) (VEX.128.66.0F 13 /r) is legal and has the same behavior as\nthe existing 66 0F 13 store. For VMOVLPD (store) (VEX.128.66.0F 13 /r) instruction\nversion, VEX.vvvv is reserved and must be 1111b otherwise instruction will #UD.\nIf VMOVLPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded\nwith VEX.L= 1 will cause an #UD exception.\n\nOperation:\n\nMOVLPD (128-bit Legacy SSE load)\nDEST[63:0] <- SRC[63:0]\nDEST[VLMAX-1:64] (Unmodified)\nVMOVLPD (VEX.128 encoded load)\nDEST[63:0] <- SRC2[63:0]\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\nVMOVLPD (store)\nDEST[63:0] <- SRC[63:0]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVLPD:| __m128d _mm_loadl_pd ( __m128d a, double\n|        | *p)                                     \n| MOVLPD:| void _mm_storel_pd (double *p, __m128d  \n|        | a)                                      \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L= 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVLPD"
    }, 
    {
      "description": "\nMOVLPS - Move Low Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                    | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                    \n| 0F 12 /r MOVLPS xmm, m64              | RM   | V/V           | SSE               | Move two packed single-precision floatingpoint \n|                                       |      |               |                   | values from m64 to low quadword of xmm.        \n| 0F 13 /r MOVLPS m64, xmm              | MR   | V/V           | SSE               | Move two packed single-precision floatingpoint \n|                                       |      |               |                   | values from low quadword of xmm to m64.        \n| VEX.NDS.128.0F.WIG 12 /r VMOVLPS xmm2,| RVM  | V/V           | AVX               | Merge two packed single-precision floatingpoint\n| xmm1, m64                             |      |               |                   | values from m64 and the high quadword          \n|                                       |      |               |                   | of xmm1.                                       \n| VEX.128.0F.WIG 13/r VMOVLPS m64, xmm1 | MR   | V/V           | AVX               | Move two packed single-precision floatingpoint \n|                                       |      |               |                   | values from low quadword of xmm1 to            \n|                                       |      |               |                   | m64.                                           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| MR   | ModRM:r/m (w)   | ModRM:reg (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nThis instruction cannot be used for register to register or memory to memory\nmoves. 128-bit Legacy SSE load: Moves two packed single-precision floating-point\nvalues from the source 64-bit memory operand and stores them in the low 64-bits\nof the destination XMM register. The upper 64bits of the XMM register are preserved.\nThe upper 128-bits of the corresponding YMM destination register are preserved.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). VEX.128 encoded load: Loads two packed single-precision\nfloating-point values from the source 64-bit memory operand (third operand),\nmerges them with the upper 64-bits of the first source XMM register (second\noperand), and stores them in the low 128-bits of the destination XMM register\n(first operand). The upper 128-bits of the destination YMM register are zeroed.\n128-bit store: Loads two packed single-precision floating-point values from\nthe low 64-bits of the XMM register source (second operand) to the 64-bit memory\nlocation (first operand). Note: VMOVLPS (store) (VEX.128.0F 13 /r) is legal\nand has the same behavior as the existing 0F 13 store. For VMOVLPS (store) (VEX.128.0F\n13 /r) instruction version, VEX.vvvv is reserved and must be 1111b otherwise\ninstruction will #UD.\n\nIf VMOVLPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded\nwith VEX.L= 1 will cause an #UD exception.\n\nOperation:\n\nMOVLPS (128-bit Legacy SSE load)\nDEST[63:0] <- SRC[63:0]\nDEST[VLMAX-1:64] (Unmodified)\nVMOVLPS (VEX.128 encoded load)\nDEST[63:0] <- SRC2[63:0]\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\nVMOVLPS (store)\nDEST[63:0] <- SRC[63:0]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVLPS:| __m128 _mm_loadl_pi ( __m128 a, __m64\n|        | *p)                                  \n| MOVLPS:| void _mm_storel_pi (__m64 *p, __m128 \n|        | a)                                   \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L= 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVLPS"
    }, 
    {
      "description": "\nMOVMSKPD - Extract Packed Double-Precision Floating-Point Sign Mask:\n| Opcode/Instruction                    | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                          \n| 66 0F 50 /r MOVMSKPD reg, xmm         | RM   | V/V           | SSE2              | Extract 2-bit sign mask from xmm and \n|                                       |      |               |                   | store in reg. The upper bits of r32  \n|                                       |      |               |                   | or r64 are filled with zeros.        \n| VEX.128.66.0F.WIG 50 /r VMOVMSKPD reg,| RM   | V/V           | AVX               | Extract 2-bit sign mask from xmm2 and\n| xmm2                                  |      |               |                   | store in reg. The upper bits of r32  \n|                                       |      |               |                   | or r64 are zeroed.                   \n| VEX.256.66.0F.WIG 50 /r VMOVMSKPD reg,| RM   | V/V           | AVX               | Extract 4-bit sign mask from ymm2 and\n| ymm2                                  |      |               |                   | store in reg. The upper bits of r32  \n|                                       |      |               |                   | or r64 are zeroed.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nExtracts the sign bits from the packed double-precision floating-point values\nin the source operand (second operand), formats them into a 2-bit mask, and\nstores the mask in the destination operand (first operand). The source operand\nis an XMM register, and the destination operand is a general-purpose register.\nThe mask is stored in the 2 low-order bits of the destination operand. Zero-extend\nthe upper bits of the destination.\n\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15,\nR8-R15) when used with a REX.R prefix. The default operand size is 64-bit in\n64-bit mode. 128-bit versions: The source operand is a YMM register. The destination\noperand is a general purpose register. VEX.256 encoded version: The source operand\nis a YMM register. The destination operand is a general purpose register. Note:\nIn VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions\nwill #UD.\n\nOperation:\n\n(V)MOVMSKPD (128-bit versions)\nDEST[0] <- SRC[63]\nDEST[1] <- SRC[127]\nIF DEST = r32\n  THEN DEST[31:2] <- 0;\n  ELSE DEST[63:2] <- 0;\nFI\nVMOVMSKPD (VEX.256 encoded version)\nDEST[0] <- SRC[63]\nDEST[1] <- SRC[127]\nDEST[2] <- SRC[191]\nDEST[3] <- SRC[255]\nIF DEST = r32\n  THEN DEST[31:4] <- 0;\n  ELSE DEST[63:4] <- 0;\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVMSKPD:| int _mm_movemask_pd ( __m128d a)\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 7; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVMSKPD"
    }, 
    {
      "description": "\nMOVMSKPS - Extract Packed Single-Precision Floating-Point Sign Mask:\n| Opcode/Instruction                 | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                          \n| 0F 50 /r MOVMSKPS reg, xmm         | RM   | V/V           | SSE               | Extract 4-bit sign mask from xmm and \n|                                    |      |               |                   | store in reg. The upper bits of r32  \n|                                    |      |               |                   | or r64 are filled with zeros.        \n| VEX.128.0F.WIG 50 /r VMOVMSKPS reg,| RM   | V/V           | AVX               | Extract 4-bit sign mask from xmm2 and\n| xmm2                               |      |               |                   | store in reg. The upper bits of r32  \n|                                    |      |               |                   | or r64 are zeroed.                   \n| VEX.256.0F.WIG 50 /r VMOVMSKPS reg,| RM   | V/V           | AVX               | Extract 8-bit sign mask from ymm2 and\n| ymm2                               |      |               |                   | store in reg. The upper bits of r32  \n|                                    |      |               |                   | or r64 are zeroed.                   \n\nInstruction Operand Encoding1:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nExtracts the sign bits from the packed single-precision floating-point values\nin the source operand (second operand), formats them into a 4- or 8-bit mask,\nand stores the mask in the destination operand (first operand). The source operand\nis an XMM or YMM register, and the destination operand is a general-purpose\nregister. The mask is stored in the 4 or 8 low-order bits of the destination\noperand. The upper bits of the destination operand beyond the mask are filled\nwith zeros.\n\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15,\nR8-R15) when used with a REX.R prefix. The default operand size is 64-bit in\n64-bit mode.\n\n128-bit versions: The source operand is a YMM register. The destination operand\nis a general purpose register. VEX.256 encoded version: The source operand is\na YMM register. The destination operand is a general purpose register. Note:\nIn VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions\nwill #UD.\n\nOperation:\n\nDEST[0] <- SRC[31];\nDEST[1] <- SRC[63];\nDEST[2] <- SRC[95];\nDEST[3] <- SRC[127];\nIF DEST = r32\n  THEN DEST[31:4] <- ZeroExtend;\n  ELSE DEST[63:4] <- ZeroExtend;\nFI;\n1.\n(V)MOVMSKPS (128-bit version)\nDEST[0] <- SRC[31]\nDEST[1] <- SRC[63]\nDEST[2] <- SRC[95]\nDEST[3] <- SRC[127]\nIF DEST = r32\n  THEN DEST[31:4] <- 0;\n  ELSE DEST[63:4] <- 0;\nFI\nVMOVMSKPS (VEX.256 encoded version)\nDEST[0] <- SRC[31]\nDEST[1] <- SRC[63]\nDEST[2] <- SRC[95]\nDEST[3] <- SRC[127]\nDEST[4] <- SRC[159]\nDEST[5] <- SRC[191]\nDEST[6] <- SRC[223]\nDEST[7] <- SRC[255]\nIF DEST = r32\n  THEN DEST[31:8] <- 0;\n  ELSE DEST[63:8] <- 0;\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nint _mm_movemask_ps(__m128 a) int _mm256_movemask_ps(__m256 a)\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 7; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVMSKPS"
    }, 
    {
      "description": "\nMOVNTDQ - Store Double Quadword Using Non-Temporal Hint:\n| Opcode/Instruction                    | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                          \n| 66 0F E7 /r MOVNTDQ m128, xmm         | MR   | V/V           | SSE2              | Move double quadword from xmm to m128\n|                                       |      |               |                   | using non-temporal hint.             \n| VEX.128.66.0F.WIG E7 /r VMOVNTDQ m128,| MR   | V/V           | AVX               | Move packed integer values in xmm1 to\n| xmm1                                  |      |               |                   | m128 using non-temporal hint.        \n| VEX.256.66.0F.WIG E7 /r VMOVNTDQ m256,| MR   | V/V           | AVX               | Move packed integer values in ymm1 to\n| ymm1                                  |      |               |                   | m256 using non-temporal hint.        \n\nInstruction Operand Encoding1:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nMoves the packed integers in the source operand (second operand) to the destination\noperand (first operand) using a non-temporal hint to prevent caching of the\ndata during the write to memory. The source operand is an XMM register or YMM\nregister, which is assumed to contain integer data (packed bytes, words, doublewords,\nor quadwords). The destination operand is a 128-bit or 256-bit memory location.\nThe memory operand must be aligned on a 16-byte (128-bit version) or 32-byte\n(VEX.256 encoded version) boundary otherwise a general-protection exception\n(#GP) will be generated.\n\nThe non-temporal hint is implemented by using a write combining (WC) memory\ntype protocol when writing the data to memory. Using this protocol, the processor\ndoes not write the data into the cache hierarchy, nor does it fetch the corresponding\ncache line from memory into the cache hierarchy. The memory type of the region\nbeing written to can override the non-temporal hint, if the memory address specified\nfor the non-temporal store is in an uncacheable (UC) or write protected (WP)\nmemory region. For more information on non-temporal stores, see \u201cCaching of\nTemporal vs. Non-Temporal Data\u201d in Chapter 10 in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1.\n\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing\noperation implemented with the SFENCE or MFENCE instruction should be used in\nconjunction with MOVNTDQ instructions if multiple processors might use different\nmemory types to read/write the destination memory locations.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). Note: In VEX-128 encoded versions, VEX.vvvv is reserved\nand must be 1111b, VEX.L must be 0; otherwise instructions will #UD.\n\nOperation:\n\nDEST <- SRC;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVNTDQ: | void _mm_stream_si128( __m128i *p, __m128i\n|          | a);                                       \n| VMOVNTDQ:| void _mm256_stream_si256 (__m256i *       \n|          | p, __m256i a);                            \n\nSIMD Floating-Point Exceptions:\nNone.\n\n| 1.| ModRM.MOD = 011B is not permitted\n\nOther Exceptions:\nSee Exceptions Type 1.SSE2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVNTDQ"
    }, 
    {
      "description": "\nMOVNTDQA  -  Load Double Quadword Non-Temporal Aligned Hint:\n| Opcode/Instruction                 | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                             \n| 66 0F 38 2A /r MOVNTDQA xmm1, m128 | RM   | V/V           | SSE4_1            | Move double quadword from m128 to xmm   \n|                                    |      |               |                   | using non-temporal hint if WC memory    \n|                                    |      |               |                   | type.                                   \n| VEX.128.66.0F38.WIG 2A /r VMOVNTDQA| RM   | V/V           | AVX               | Move double quadword from m128 to xmm   \n| xmm1, m128                         |      |               |                   | using non-temporal hint if WC memory    \n|                                    |      |               |                   | type.                                   \n| VEX.256.66.0F38.WIG 2A /r VMOVNTDQA| RM   | V/V           | AVX2              | Move 256-bit data from m256 to ymm using\n| ymm1, m256                         |      |               |                   | non-temporal hint if WC memory type.    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\n(V)MOVNTDQA loads a double quadword from the source operand (second operand)\nto the destination operand (first operand) using a non-temporal hint. A processor\nimplementation may make use of the non-temporal hint associated with this instruction\nif the memory source is WC (write combining) memory type. An implementation\nmay also make use of the non-temporal hint associated with this instruction\nif the memory source is WB (write back) memory type. A processor's implementation\nof the non-temporal hint does not override the effective memory type semantics,\nbut the implementation of the hint is processor dependent. For example, a processor\nimplementation may choose to ignore the hint and process the instruction as\na normal MOVDQA for any memory type. Another implementation of the hint for\nWC memory type may optimize data transfer throughput of WC reads. A third implementation\nmay optimize cache reads generated by (V)MOVNTDQA on WB memory type to reduce\ncache evictions.\n\nWC Streaming Load Hint\n\nFor WC memory type in particular, the processor never appears to read the data\ninto the cache hierarchy. Instead, the non-temporal hint may be implemented\nby loading a temporary internal buffer with the equivalent of an aligned cache\nline without filling this data to the cache. Any memory-type aliased lines in\nthe cache will be snooped and flushed. Subsequent MOVNTDQA reads to unread portions\nof the WC cache line will receive data from the temporary internal buffer if\ndata is available. The temporary internal buffer may be flushed by the processor\nat any time for any reason, for example:\n\n - A load operation other than a (V)MOVNTDQA which references memory already resident\nin a temporary internal buffer.\n - A non-WC reference to memory already resident in a temporary internal buffer.\n - Interleaving of reads and writes to memory currently residing in a single temporary\ninternal buffer.\n - Repeated (V)MOVNTDQA loads of a particular 16-byte item in a streaming line.\n - Certain micro-architectural conditions including resource shortages, detection\nof a mis-speculation condition, and various fault conditions\n\nThe memory type of the region being read can override the non-temporal hint,\nif the memory address specified for the non-temporal read is not a WC memory\nregion. Information on non-temporal reads and writes can be found in Chapter\n11, \u201cMemory Cache Control\u201d of Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A. Because the WC protocol uses a weakly-ordered memory consistency\nmodel, an MFENCE or locked instruction should be used in conjunction with MOVNTDQA\ninstructions if multiple processors might reference the same WC memory locations\nor in order to synchronize reads of a processor with writes by other agents\nin the system. Because of the speculative nature of fetching due to MOVNTDQA,\nStreaming loads must not be used to reference memory addresses that are mapped\nto I/O devices having side effects or when reads to these devices are destruc-\n\ntive. For additional information on MOVNTDQA usages, see Section 12.10.3 in\nChapter 12, \u201cProgramming with SSE3, SSSE3 and SSE4\u201d of Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1. The 128-bit (V)MOVNTDQA addresses must\nbe 16-byte aligned or the instruction will cause a #GP. The 256-bit VMOVNTDQA\naddresses must be 32-byte aligned or the instruction will cause a #GP. Note:\nIn VEX-128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must\nbe 0; otherwise instructions will #UD.\n\nOperation:\n\nMOVNTDQA (128bit- Legacy SSE form)\nDEST <- SRC\nDEST[VLMAX-1:128] (Unmodified)\nVMOVNTDQA (VEX.128 encoded form)\nDEST <- SRC\nDEST[VLMAX-1:128] <- 0\nVMOVNTDQA (VEX.256 encoded form)\nDEST[255:0] <- SRC[255:0]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)MOVNTDQA:| __m128i _mm_stream_load_si128 (__m128i \n|             | *p);                                   \n| VMOVNTDQA:  | __m256i _mm256_stream_load_si256 (const\n|             | __m256i *p);                           \n\nFlags Affected:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 1.SSE4.1; additionally\n\n| #UD| If VEX.L= 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVNTDQA"
    }, 
    {
      "description": "\nMOVNTI - Store Doubleword Using Non-Temporal Hint:\n| Opcode          | Instruction    | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F C3 /r        | MOVNTI m32, r32| MR   | Valid      | Valid          | Move doubleword from r32 to m32 using\n|                 |                |      |            |                | nontemporal hint.                    \n| REX.W + 0F C3 /r| MOVNTI m64, r64| MR   | Valid      | N.E.           | Move quadword from r64 to m64 using  \n|                 |                |      |            |                | nontemporal hint.                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nMoves the doubleword integer in the source operand (second operand) to the destination\noperand (first operand) using a non-temporal hint to minimize cache pollution\nduring the write to memory. The source operand is a general-purpose register.\nThe destination operand is a 32-bit memory location.\n\nThe non-temporal hint is implemented by using a write combining (WC) memory\ntype protocol when writing the data to memory. Using this protocol, the processor\ndoes not write the data into the cache hierarchy, nor does it fetch the corresponding\ncache line from memory into the cache hierarchy. The memory type of the region\nbeing written to can override the non-temporal hint, if the memory address specified\nfor the non-temporal store is in an uncacheable (UC) or write protected (WP)\nmemory region. For more information on non-temporal stores, see \u201cCaching of\nTemporal vs. Non-Temporal Data\u201d in Chapter 10 in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1.\n\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing\noperation implemented with the SFENCE or MFENCE instruction should be used in\nconjunction with MOVNTI instructions if multiple processors might use different\nmemory types to read/write the destination memory locations.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.R prefix permits access to additional registers (R8-R15). Use of the\nREX.W prefix promotes operation to 64 bits. See the summary chart at the beginning\nof this section for encoding data and limits.\n\nOperation:\n\nDEST <- SRC;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVNTI:| void _mm_stream_si32 (int *p, int a)    \n| MOVNTI:| void _mm_stream_si64(__int64 *p, __int64\n|        | a)                                      \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | For an illegal memory operand effective  \n|                | address in the CS, DS, ES, FS or GS      \n|                | segments.                                \n| #SS(0)         | For an illegal address in the SS segment.\n| #PF(fault-code)| For a page fault.                        \n| #UD            | If CPUID.01H:EDX.SSE2[bit 26] = 0. If    \n|                | the LOCK prefix is used.                 \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand is not aligned on     \n|    | a 16-byte boundary, regardless of segment.\n|    | If any part of the operand lies outside   \n|    | the effective address space from 0 to     \n|    | FFFFH.                                    \n| #UD| If CPUID.01H:EDX.SSE2[bit 26] = 0. If     \n|    | the LOCK prefix is used.                  \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in real address mode.\n\n| #PF(fault-code)| For a page fault.\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| For a page fault.                          \n| #UD            | If CPUID.01H:EDX.SSE2[bit 26] = 0. If      \n|                | the LOCK prefix is used.                   \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n", 
      "mnem": "MOVNTI"
    }, 
    {
      "description": "\nMOVNTPD - Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint:\n| Opcode/Instruction                    | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| 66 0F 2B /r MOVNTPD m128, xmm         | MR   | V/V           | SSE2              | Move packed double-precision floating-point\n|                                       |      |               |                   | values from xmm to m128 using nontemporal  \n|                                       |      |               |                   | hint.                                      \n| VEX.128.66.0F.WIG 2B /r VMOVNTPD m128,| MR   | V/V           | AVX               | Move packed double-precision values        \n| xmm1                                  |      |               |                   | in xmm1 to m128 using non-temporal hint.   \n| VEX.256.66.0F.WIG 2B /r VMOVNTPD m256,| MR   | V/V           | AVX               | Move packed double-precision values        \n| ymm1                                  |      |               |                   | in ymm1 to m256 using non-temporal hint.   \n\nInstruction Operand Encoding1:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nMoves the packed double-precision floating-point values in the source operand\n(second operand) to the destination operand (first operand) using a non-temporal\nhint to prevent caching of the data during the write to memory. The source operand\nis an XMM register or YMM register, which is assumed to contain packed double-precision,\nfloatingpointing data. The destination operand is a 128-bit or 256-bit memory\nlocation. The memory operand must be aligned on a 16-byte (128-bit version)\nor 32-byte (VEX.256 encoded version) boundary otherwise a generalprotection\nexception (#GP) will be generated.\n\nThe non-temporal hint is implemented by using a write combining (WC) memory\ntype protocol when writing the data to memory. Using this protocol, the processor\ndoes not write the data into the cache hierarchy, nor does it fetch the corresponding\ncache line from memory into the cache hierarchy. The memory type of the region\nbeing written to can override the non-temporal hint, if the memory address specified\nfor the non-temporal store is in an uncacheable (UC) or write protected (WP)\nmemory region. For more information on non-temporal stores, see \u201cCaching of\nTemporal vs. Non-Temporal Data\u201d in Chapter 10 in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1.\n\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing\noperation implemented with the SFENCE or MFENCE instruction should be used in\nconjunction with MOVNTPD instructions if multiple processors might use different\nmemory types to read/write the destination memory locations.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). Note: In VEX-128 encoded versions, VEX.vvvv is reserved\nand must be 1111b, VEX.L must be 0; otherwise instructions will #UD.\n\nOperation:\n\nDEST <- SRC;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVNTPD: | void _mm_stream_pd(double *p, __m128d     \n|          | a)                                        \n| VMOVNTPD:| void _mm256_stream_pd (double * p, __m256d\n|          | a);                                       \n\nSIMD Floating-Point Exceptions:\nNone.\n\n| 1.| ModRM.MOD = 011B is not permitted\n\nOther Exceptions:\nSee Exceptions Type 1.SSE2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVNTPD"
    }, 
    {
      "description": "\nMOVNTPS - Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint:\n| Opcode/Instruction                 | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| 0F 2B /r MOVNTPS m128, xmm         | MR   | V/V           | SSE               | Move packed single-precision floating-point\n|                                    |      |               |                   | values from xmm to m128 using nontemporal  \n|                                    |      |               |                   | hint.                                      \n| VEX.128.0F.WIG 2B /r VMOVNTPS m128,| MR   | V/V           | AVX               | Move packed single-precision values        \n| xmm1                               |      |               |                   | xmm1 to mem using non-temporal hint.       \n| VEX.256.0F.WIG 2B /r VMOVNTPS m256,| MR   | V/V           | AVX               | Move packed single-precision values        \n| ymm1                               |      |               |                   | ymm1 to mem using non-temporal hint.       \n\nInstruction Operand Encoding1:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nMoves the packed single-precision floating-point values in the source operand\n(second operand) to the destination operand (first operand) using a non-temporal\nhint to prevent caching of the data during the write to memory. The source operand\nis an XMM register or YMM register, which is assumed to contain packed single-precision,\nfloatingpointing. The destination operand is a 128-bit or 256-bit memory location.\nThe memory operand must be aligned on a 16-byte (128-bit version) or 32-byte\n(VEX.256 encoded version) boundary otherwise a general-protection exception\n(#GP) will be generated.\n\nThe non-temporal hint is implemented by using a write combining (WC) memory\ntype protocol when writing the data to memory. Using this protocol, the processor\ndoes not write the data into the cache hierarchy, nor does it fetch the corresponding\ncache line from memory into the cache hierarchy. The memory type of the region\nbeing written to can override the non-temporal hint, if the memory address specified\nfor the non-temporal store is in an uncacheable (UC) or write protected (WP)\nmemory region. For more information on non-temporal stores, see \u201cCaching of\nTemporal vs. Non-Temporal Data\u201d in Chapter 10 in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1.\n\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing\noperation implemented with the SFENCE or MFENCE instruction should be used in\nconjunction with MOVNTPS instructions if multiple processors might use different\nmemory types to read/write the destination memory locations.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). Note: In VEX-encoded versions, VEX.vvvv is reserved\nand must be 1111b otherwise instructions will #UD.\n\nOperation:\n\nDEST <- SRC;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVNTDQ: | void _mm_stream_ps(float * p, __m128    \n|          | a)                                      \n| VMOVNTPS:| void _mm256_stream_ps (float * p, __m256\n|          | a);                                     \n\nSIMD Floating-Point Exceptions:\nNone.\n\n| 1.| ModRM.MOD = 011B is not permitted\n\nOther Exceptions:\nSee Exceptions Type 1.SSE; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVNTPS"
    }, 
    {
      "description": "\nMOVNTQ - Store of Quadword Using Non-Temporal Hint:\n| Opcode  | Instruction   | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                   \n| 0F E7 /r| MOVNTQ m64, mm| MR   | Valid      | Valid          | Move quadword from mm to m64 using nontemporal\n|         |               |      |            |                | hint.                                         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nMoves the quadword in the source operand (second operand) to the destination\noperand (first operand) using a non-temporal hint to minimize cache pollution\nduring the write to memory. The source operand is an MMX technology register,\nwhich is assumed to contain packed integer data (packed bytes, words, or doublewords).\nThe destination operand is a 64-bit memory location.\n\nThe non-temporal hint is implemented by using a write combining (WC) memory\ntype protocol when writing the data to memory. Using this protocol, the processor\ndoes not write the data into the cache hierarchy, nor does it fetch the corresponding\ncache line from memory into the cache hierarchy. The memory type of the region\nbeing written to can override the non-temporal hint, if the memory address specified\nfor the non-temporal store is in an uncacheable (UC) or write protected (WP)\nmemory region. For more information on non-temporal stores, see \u201cCaching of\nTemporal vs. Non-Temporal Data\u201d in Chapter 10 in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1.\n\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing\noperation implemented with the SFENCE or MFENCE instruction should be used in\nconjunction with MOVNTQ instructions if multiple processors might use different\nmemory types to read/write the destination memory locations.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nDEST <- SRC;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVNTQ:| void _mm_stream_pi(__m64 * p, __m64\n|        | a)                                 \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Table 22-8, \u201cException Conditions for Legacy SIMD/MMX Instructions without\nFP Exception,\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n", 
      "mnem": "MOVNTQ"
    }, 
    {
      "description": "-R:MOVD", 
      "mnem": "MOVQ"
    }, 
    {
      "description": "\nMOVQ2DQ - Move Quadword from MMX Technology to XMM Register:\n| Opcode     | Instruction    | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| F3 0F D6 /r| MOVQ2DQ xmm, mm| RM   | Valid      | Valid          | Move quadword from mmx to low quadword\n|            |                |      |            |                | of xmm.                               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nMoves the quadword from the source operand (second operand) to the low quadword\nof the destination operand (first operand). The source operand is an MMX technology\nregister and the destination operand is an XMM register.\n\nThis instruction causes a transition from x87 FPU to MMX technology operation\n(that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word\nis set to all 0s [valid]). If this instruction is executed while an x87 FPU\nfloating-point exception is pending, the exception is handled before the MOVQ2DQ\ninstruction is executed.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15).\n\nOperation:\n\nDEST[63:0] <- SRC[63:0];\nDEST[127:64] <- 00000000000000000H;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVQ2DQ:| __128i _mm_movpi64_pi64 ( __m64 a)\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #NM| If CR0.TS[bit 3] = 1.                   \n| #UD| If CR0.EM[bit 2] = 1. If CR4.OSFXSR[bit \n|    | 9] = 0. If CPUID.01H:EDX.SSE2[bit 26]   \n|    | = 0. If the LOCK prefix is used.        \n| #MF| If there is a pending x87 FPU exception.\n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "MOVQ2DQ"
    }, 
    {
      "description": "\nMOVS/MOVSB/MOVSW/MOVSD/MOVSQ - Move Data from String to String:\n\\\n\n| Opcode    | Instruction  | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                \n| A4        | MOVS m8, m8  | NP   | Valid      | Valid          | For legacy mode, Move byte from address    \n|           |              |      |            |                | DS:(E)SI to ES:(E)DI. For 64-bit mode      \n|           |              |      |            |                | move byte from address (R|E)SI to (R|E)DI. \n| A5        | MOVS m16, m16| NP   | Valid      | Valid          | For legacy mode, move word from address    \n|           |              |      |            |                | DS:(E)SI to ES:(E)DI. For 64-bit mode      \n|           |              |      |            |                | move word at address (R|E)SI to (R|E)DI.   \n| A5        | MOVS m32, m32| NP   | Valid      | Valid          | For legacy mode, move dword from address   \n|           |              |      |            |                | DS:(E)SI to ES:(E)DI. For 64-bit mode      \n|           |              |      |            |                | move dword from address (R|E)SI to (R|E)DI.\n| REX.W + A5| MOVS m64, m64| NP   | Valid      | N.E.           | Move qword from address (R|E)SI to (R|E)DI.\n| A4        | MOVSB        | NP   | Valid      | Valid          | For legacy mode, Move byte from address    \n|           |              |      |            |                | DS:(E)SI to ES:(E)DI. For 64-bit mode      \n|           |              |      |            |                | move byte from address (R|E)SI to (R|E)DI. \n| A5        | MOVSW        | NP   | Valid      | Valid          | For legacy mode, move word from address    \n|           |              |      |            |                | DS:(E)SI to ES:(E)DI. For 64-bit mode      \n|           |              |      |            |                | move word at address (R|E)SI to (R|E)DI.   \n| A5        | MOVSD        | NP   | Valid      | Valid          | For legacy mode, move dword from address   \n|           |              |      |            |                | DS:(E)SI to ES:(E)DI. For 64-bit mode      \n|           |              |      |            |                | move dword from address (R|E)SI to (R|E)DI.\n| REX.W + A5| MOVSQ        | NP   | Valid      | N.E.           | Move qword from address (R|E)SI to (R|E)DI.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nMoves the byte, word, or doubleword specified with the second operand (source\noperand) to the location specified with the first operand (destination operand).\nBoth the source and destination operands are located in memory. The address\nof the source operand is read from the DS:ESI or the DS:SI registers (depending\non the address-size attribute of the instruction, 32 or 16, respectively). The\naddress of the destination operand is read from the ES:EDI or the ES:DI registers\n(again depending on the address-size attribute of the instruction). The DS segment\nmay be overridden with a segment override prefix, but the ES segment cannot\nbe overridden.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \u201cexplicit-operands\u201d\nform and the \u201cnooperands\u201d form. The explicit-operands form (specified with the\nMOVS mnemonic) allows the source and destination operands to be specified explicitly.\nHere, the source and destination operands should be symbols that indicate the\nsize and location of the source value and the destination, respectively. This\nexplicit-operands form is provided to allow documentation; however, note that\nthe documentation provided by this form can be misleading. That is, the source\nand destination operand symbols must specify the correct type (size) of the\noperands (bytes, words, or doublewords), but they do not have to specify the\ncorrect location. The locations of the source and destination operands are always\nspecified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly\nbefore the move string instruction is executed.\n\nThe no-operands form provides \u201cshort forms\u201d of the byte, word, and doubleword\nversions of the MOVS instructions. Here also DS:(E)SI and ES:(E)DI are assumed\nto be the source and destination operands, respectively. The size of the source\nand destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW\n(word move), or MOVSD (doubleword move).\n\nAfter the move operation, the (E)SI and (E)DI registers are incremented or decremented\nautomatically according to the setting of the DF flag in the EFLAGS register.\n(If the DF flag is 0, the (E)SI and (E)DI register are incre-\n\nmented; if the DF flag is 1, the (E)SI and (E)DI registers are decremented.)\nThe registers are incremented or decremented by 1 for byte operations, by 2\nfor word operations, or by 4 for doubleword operations.\n\n\nNOTE:\nTo improve performance, more recent processors support modifications to the\nprocessor's operation during the string store operations initiated with MOVS\nand MOVSB. See Section 7.3.9.3 in the Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1 for additional information on fast-string operation.\n\nThe MOVS, MOVSB, MOVSW, and MOVSD instructions can be preceded by the REP prefix\n(see \u201cREP/REPE/REPZ /REPNE/REPNZ - Repeat String Operation Prefix\u201d in Chapter\n4 of the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n2B, for a description of the REP prefix) for block moves of ECX bytes, words,\nor doublewords.\n\nIn 64-bit mode, the instruction's default address size is 64 bits, 32-bit address\nsize is supported using the prefix 67H. The 64-bit addresses are specified by\nRSI and RDI; 32-bit address are specified by ESI and EDI. Use of the REX.W prefix\npromotes doubleword operation to 64 bits. See the summary chart at the beginning\nof this section for encoding data and limits.\n\nOperation:\n\nDEST <- SRC;\nNon-64-bit Mode:\nIF (Byte move)\n  THEN IF DF = 0\n     THEN\n       (E)SI <- (E)SI + 1;\n       (E)DI <- (E)DI + 1;\n     ELSE\n       (E)SI <- (E)SI - 1;\n       (E)DI <- (E)DI - 1;\n     FI;\n  ELSE IF (Word move)\n     THEN IF DF = 0\n       (E)SI <- (E)SI + 2;\n       (E)DI <- (E)DI + 2;\n       FI;\n     ELSE\n       (E)SI <- (E)SI - 2;\n       (E)DI <- (E)DI - 2;\n     FI;\n  ELSE IF (Doubleword move)\n     THEN IF DF = 0\n       (E)SI <- (E)SI + 4;\n       (E)DI <- (E)DI + 4;\n       FI;\n     ELSE\n       (E)SI <- (E)SI - 4;\n       (E)DI <- (E)DI - 4;\n     FI;\nFI;\n64-bit Mode:\nIF (Byte move)\n  THEN IF DF = 0\n     THEN\n       (R|E)SI <- (R|E)SI + 1;\n       (R|E)DI <- (R|E)DI + 1;\n     ELSE\n       (R|E)SI <- (R|E)SI - 1;\n       (R|E)DI <- (R|E)DI - 1;\n     FI;\n  ELSE IF (Word move)\n     THEN IF DF = 0\n       (R|E)SI <- (R|E)SI + 2;\n       (R|E)DI <- (R|E)DI + 2;\n       FI;\n     ELSE\n       (R|E)SI <- (R|E)SI - 2;\n       (R|E)DI <- (R|E)DI - 2;\n     FI;\n  ELSE IF (Doubleword move)\n     THEN IF DF = 0\n       (R|E)SI <- (R|E)SI + 4;\n       (R|E)DI <- (R|E)DI + 4;\n       FI;\n     ELSE\n       (R|E)SI <- (R|E)SI - 4;\n       (R|E)DI <- (R|E)DI - 4;\n     FI;\n  ELSE IF (Quadword move)\n     THEN IF DF = 0\n       (R|E)SI <- (R|E)SI + 8;\n       (R|E)DI <- (R|E)DI + 8;\n       FI;\n     ELSE\n       (R|E)SI <- (R|E)SI - 8;\n       (R|E)DI <- (R|E)DI - 8;\n     FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register contains a NULL segment     \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.              \n\nMOVSD - Move Scalar Double-Precision Floating-Point Value:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                 \n| F2 0F 10 /r MOVSD xmm1, xmm2/m64        | RM   | V/V           | SSE2              | Move scalar double-precision floating-point \n|                                         |      |               |                   | value from xmm2/m64 to xmm1 register.       \n| VEX.NDS.LIG.F2.0F.WIG 10 /r VMOVSD xmm1,| RVM  | V/V           | AVX               | Merge scalar double-precision floating-point\n| xmm2, xmm3                              |      |               |                   | value from xmm2 and xmm3 to xmm1 register.  \n| VEX.LIG.F2.0F.WIG 10 /r VMOVSD xmm1,    | XM   | V/V           | AVX               | Load scalar double-precision floating-point \n| m64                                     |      |               |                   | value from m64 to xmm1 register.            \n| F2 0F 11 /r MOVSD xmm2/m64, xmm1        | MR   | V/V           | SSE2              | Move scalar double-precision floating-point \n|                                         |      |               |                   | value from xmm1 register to xmm2/m64.       \n| VEX.NDS.LIG.F2.0F.WIG 11 /r VMOVSD xmm1,| MVR  | V/V           | AVX               | Merge scalar double-precision floating-point\n| xmm2, xmm3                              |      |               |                   | value from xmm2 and xmm3 registers to       \n|                                         |      |               |                   | xmm1.                                       \n| VEX.LIG.F2.0F.WIG 11 /r VMOVSD m64,     | MR   | V/V           | AVX               | Move scalar double-precision floating-point \n| xmm1                                    |      |               |                   | value from xmm1 register to m64.            \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA           | NA       \n| XM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| MVR  | ModRM:r/m (w)| VEX.vvvv (r) | ModRM:reg (r)| NA       \n\nDescription:\nMOVSD moves a scalar double-precision floating-point value from the source operand\n(second operand) to the destination operand (first operand). The source and\ndestination operands can be XMM registers or 64-bit memory locations. This instruction\ncan be used to move a double-precision floating-point value to and from the\nlow quadword of an XMM register and a 64-bit memory location, or to move a double-precision\nfloating-point value between the low quadwords of two XMM registers. The instruction\ncannot be used to transfer data between memory locations. For non-VEX encoded\ninstruction syntax and when the source and destination operands are XMM registers,\nthe high quadword of the destination operand remains unchanged. When the source\noperand is a memory location and destination operand is an XMM registers, the\nhigh quadword of the destination operand is cleared to all 0s.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). Note: For the \u201cVMOVSD m64, xmm1\u201d (memory store form)\ninstruction version, VEX.vvvv is reserved and must be 1111b, otherwise instruction\nwill #UD. Note: For the \u201cVMOVSD xmm1, m64\u201d (memory load form) instruction version,\nVEX.vvvv is reserved and must be 1111b otherwise instruction will #UD. VEX encoded\ninstruction syntax supports two source operands and a destination operand if\nModR/M.mod field is 11B. VEX.vvvv is used to encode the first source operand\n(the second operand). The low 128 bits of the destination operand stores the\nresult of merging the low quadword of the second source operand with the quad\nword in bits 127:64 of the first source operand. The upper bits of the destination\noperand are cleared.\n\nOperation:\n\nMOVSD (128-bit Legacy SSE version: MOVSD XMM1, XMM2)\nDEST[63:0] <- SRC[63:0]\nDEST[VLMAX-1:64] (Unmodified)\nMOVSD/VMOVSD (128-bit versions: MOVSD m64, xmm1 or VMOVSD m64, xmm1)\nDEST[63:0] <- SRC[63:0]\nMOVSD (128-bit Legacy SSE version: MOVSD XMM1, m64)\nDEST[63:0] <- SRC[63:0]\nDEST[127:64] <- 0\nDEST[VLMAX-1:128] (Unmodified)\nVMOVSD (VEX.NDS.128.F2.0F 11 /r: VMOVSD xmm1, xmm2, xmm3)\nDEST[63:0] <- SRC2[63:0]\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\nVMOVSD (VEX.NDS.128.F2.0F 10 /r: VMOVSD xmm1, xmm2, xmm3)\nDEST[63:0] <- SRC2[63:0]\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\nVMOVSD (VEX.NDS.128.F2.0F 10 /r: VMOVSD xmm1, m64)\nDEST[63:0] <- SRC[63:0]\nDEST[VLMAX-1:64] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVSD:| __m128d _mm_load_sd (double *p)         \n| MOVSD:| void _mm_store_sd (double *p, __m128d   \n|       | a)                                      \n| MOVSD:| __m128d _mm_store_sd (__m128d a, __m128d\n|       | b)                                      \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.vvvv != 1111B.  \n", 
      "mnem": "MOVS"
    }, 
    {
      "description": "-R:MOVS", 
      "mnem": "MOVSB"
    }, 
    {
      "description": "-R:MOVS", 
      "mnem": "MOVSD"
    }, 
    {
      "description": "\nMOVSHDUP - Move Packed Single-FP High and Duplicate:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                   \n| F3 0F 16 /r MOVSHDUP xmm1, xmm2/m128   | RM   | V/V           | SSE3              | Move two single-precision floating-point      \n|                                        |      |               |                   | values from the higher 32-bit operand         \n|                                        |      |               |                   | of each qword in xmm2/m128 to xmm1 and        \n|                                        |      |               |                   | duplicate each 32-bit operand to the          \n|                                        |      |               |                   | lower 32-bits of each qword.                  \n| VEX.128.F3.0F.WIG 16 /r VMOVSHDUP xmm1,| RM   | V/V           | AVX               | Move odd index single-precision floating-point\n| xmm2/m128                              |      |               |                   | values from xmm2/mem and duplicate each       \n|                                        |      |               |                   | element into xmm1.                            \n| VEX.256.F3.0F.WIG 16 /r VMOVSHDUP ymm1,| RM   | V/V           | AVX               | Move odd index single-precision floating-point\n| ymm2/m256                              |      |               |                   | values from ymm2/mem and duplicate each       \n|                                        |      |               |                   | element into ymm1.                            \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nThe linear address corresponds to the address of the least-significant byte\nof the referenced memory data. When a memory address is indicated, the 16 bytes\nof data at memory location m128 are loaded and the single-precision elements\nin positions 1 and 3 are duplicated. When the register-register form of this\noperation is used, the same operation is performed but with data coming from\nthe 128-bit source register. See Figure 3-25.\n\nMOVSHDUP xmm1, xmm2/m128\n\nxmm2/\n\n| [127:96]xmm2/| [95:64]xmm1[95:64]xmm2/m128[127:96]| [63:32]xmm1[63:32]xmm2/m128[63:32]| [31:0]m128 xmm1[31:0]RESULT: xmm2/xmm1\n|              |                                    |                                   | m128[63:32]                           \n| [127:96]     | [95:64]                            | [63:32]                           | [31:0]                                \nOM15998\n\n| Figure 3-25.| MOVSHDUP - Move Packed Single-FP High\n|             | and Duplicate                      \nIn 64-bit mode, use of the REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: Bits\n(VLMAX-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register\nare zeroed. Note: In VEX-encoded versions, VEX.vvvv is reserved and must be\n1111b otherwise instructions will #UD.\n\nOperation:\n\nMOVSHDUP (128-bit Legacy SSE version)\nDEST[31:0] <- SRC[63:32]\nDEST[63:32] <- SRC[63:32]\nDEST[95:64] <- SRC[127:96]\nDEST[127:96] <- SRC[127:96]\nDEST[VLMAX-1:128] (Unmodified)\nVMOVSHDUP (VEX.128 encoded version)\nDEST[31:0] <- SRC[63:32]\nDEST[63:32] <- SRC[63:32]\nDEST[95:64] <- SRC[127:96]\nDEST[127:96] <- SRC[127:96]\nDEST[VLMAX-1:128] <- 0\nVMOVSHDUP (VEX.256 encoded version)\nDEST[31:0] <- SRC[63:32]\nDEST[63:32] <- SRC[63:32]\nDEST[95:64] <- SRC[127:96]\nDEST[127:96] <- SRC[127:96]\nDEST[159:128] <- SRC[191:160]\nDEST[191:160] <- SRC[191:160]\nDEST[223:192] <- SRC[255:224]\nDEST[255:224] <- SRC[255:224]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)MOVSHDUP:| __m128 _mm_movehdup_ps(__m128 a)     \n| VMOVSHDUP:  | __m256 _mm256_movehdup_ps (__m256 a);\n\nExceptions:\nGeneral protection exception if not aligned on 16-byte boundary, regardless\nof segment.\n\n\nNumeric Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "MOVSHDUP"
    }, 
    {
      "description": "\nMOVSLDUP - Move Packed Single-FP Low and Duplicate:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                   \n| F3 0F 12 /r MOVSLDUP xmm1, xmm2/m128   | RM   | V/V           | SSE3              | Move two single-precision floating-point      \n|                                        |      |               |                   | values from the lower 32-bit operand          \n|                                        |      |               |                   | of each qword in xmm2/m128 to xmm1 and        \n|                                        |      |               |                   | duplicate each 32-bit operand to the          \n|                                        |      |               |                   | higher 32-bits of each qword.                 \n| VEX.128.F3.0F.WIG 12 /r VMOVSLDUP xmm1,| RM   | V/V           | AVX               | Move even index single-precision floatingpoint\n| xmm2/m128                              |      |               |                   | values from xmm2/mem and duplicate each       \n|                                        |      |               |                   | element into xmm1.                            \n| VEX.256.F3.0F.WIG 12 /r VMOVSLDUP ymm1,| RM   | V/V           | AVX               | Move even index single-precision floatingpoint\n| ymm2/m256                              |      |               |                   | values from ymm2/mem and duplicate each       \n|                                        |      |               |                   | element into ymm1.                            \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nThe linear address corresponds to the address of the least-significant byte\nof the referenced memory data. When a memory address is indicated, the 16 bytes\nof data at memory location m128 are loaded and the single-precision elements\nin positions 0 and 2 are duplicated. When the register-register form of this\noperation is used, the same operation is performed but with data coming from\nthe 128-bit source register.\n\nSee Figure 3-26.\n\nMOVSLDUP xmm1, xmm2/m128\n\nxmm2/\n\n| [127:96]xmm2/| [95:64]xmm1[95:64]xmm2/m128[95:64]| [63:32]xmm1[63:32]xmm2/m128[31:0]| [31:0]m128 xmm1[31:0]RESULT: xmm2/xmm1\n|              |                                   |                                  | m128[31:0]                            \n| [127:96]     | [95:64]                           | [63:32]                          | [31:0]                                \nOM15999\n\n| Figure 3-26.| MOVSLDUP - Move Packed Single-FP Low and\n|             | Duplicate                             \nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: Bits (VLMAX-1:128) of the\ncorresponding YMM destination register remain unchanged. VEX.128 encoded version:\nBits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise\ninstructions will #UD.\n\nOperation:\n\nMOVSLDUP (128-bit Legacy SSE version)\nDEST[31:0] <- SRC[31:0]\nDEST[63:32] <- SRC[31:0]\nDEST[95:64] <- SRC[95:64]\nDEST[127:96] <- SRC[95:64]\nDEST[VLMAX-1:128] (Unmodified)\nVMOVSLDUP (VEX.128 encoded version)\nDEST[31:0] <- SRC[31:0]\nDEST[63:32] <- SRC[31:0]\nDEST[95:64] <- SRC[95:64]\nDEST[127:96] <- SRC[95:64]\nDEST[VLMAX-1:128] <- 0\nVMOVSLDUP (VEX.256 encoded version)\nDEST[31:0] <- SRC[31:0]\nDEST[63:32] <- SRC[31:0]\nDEST[95:64] <- SRC[95:64]\nDEST[127:96] <- SRC[95:64]\nDEST[159:128] <- SRC[159:128]\nDEST[191:160] <- SRC[159:128]\nDEST[223:192] <- SRC[223:192]\nDEST[255:224] <- SRC[223:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)MOVSLDUP:| __m128 _mm_moveldup_ps(__m128 a)     \n| VMOVSLDUP:  | __m256 _mm256_moveldup_ps (__m256 a);\n\nExceptions:\nGeneral protection exception if not aligned on 16-byte boundary, regardless\nof segment.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVSLDUP"
    }, 
    {
      "description": "-R:MOVS", 
      "mnem": "MOVSQ"
    }, 
    {
      "description": "\nMOVSS - Move Scalar Single-Precision Floating-Point Values:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                 \n| F3 0F 10 /r MOVSS xmm1, xmm2/m32        | RM   | V/V           | SSE               | Move scalar single-precision floating-point \n|                                         |      |               |                   | value from xmm2/m32 to xmm1 register.       \n| VEX.NDS.LIG.F3.0F.WIG 10 /r VMOVSS xmm1,| RVM  | V/V           | AVX               | Merge scalar single-precision floating-point\n| xmm2, xmm3                              |      |               |                   | value from xmm2 and xmm3 to xmm1 register.  \n| VEX.LIG.F3.0F.WIG 10 /r VMOVSS xmm1,    | XM   | V/V           | AVX               | Load scalar single-precision floating-point \n| m32                                     |      |               |                   | value from m32 to xmm1 register.            \n| F3 0F 11 /r MOVSS xmm2/m32, xmm         | MR   | V/V           | SSE               | Move scalar single-precision floating-point \n|                                         |      |               |                   | value from xmm1 register to xmm2/m32.       \n| VEX.NDS.LIG.F3.0F.WIG 11 /r VMOVSS xmm1,| MVR  | V/V           | AVX               | Move scalar single-precision floating-point \n| xmm2, xmm3                              |      |               |                   | value from xmm2 and xmm3 to xmm1 register.  \n| VEX.LIG.F3.0F.WIG 11 /r VMOVSS m32,     | MR   | V/V           | AVX               | Move scalar single-precision floating-point \n| xmm1                                    |      |               |                   | value from xmm1 register to m32.            \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA           | NA       \n| XM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| MVR  | ModRM:r/m (w)| VEX.vvvv (r) | ModRM:reg (r)| NA       \n\nDescription:\nMoves a scalar single-precision floating-point value from the source operand\n(second operand) to the destination operand (first operand). The source and\ndestination operands can be XMM registers or 32-bit memory locations. This instruction\ncan be used to move a single-precision floating-point value to and from the\nlow doubleword of an XMM register and a 32-bit memory location, or to move a\nsingle-precision floating-point value between the low doublewords of two XMM\nregisters. The instruction cannot be used to transfer data between memory locations.\nFor non-VEX encoded syntax and when the source and destination operands are\nXMM registers, the high doublewords of the destination operand remains unchanged.\nWhen the source operand is a memory location and destination operand is an XMM\nregisters, the high doublewords of the destination operand is cleared to all\n0s.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). VEX encoded instruction syntax supports two source operands\nand a destination operand if ModR/M.mod field is 11B. VEX.vvvv is used to encode\nthe first source operand (the second operand). The low 128 bits of the destination\noperand stores the result of merging the low dword of the second source operand\nwith three dwords in bits 127:32 of the first source operand. The upper bits\nof the destination operand are cleared. Note: For the \u201cVMOVSS m32, xmm1\u201d (memory\nstore form) instruction version, VEX.vvvv is reserved and must be 1111b otherwise\ninstruction will #UD. Note: For the \u201cVMOVSS xmm1, m32\u201d (memory load form) instruction\nversion, VEX.vvvv is reserved and must be 1111b otherwise instruction will #UD.\n\nOperation:\n\nMOVSS (Legacy SSE version when the source and destination operands are both XMM registers)\nDEST[31:0] <- SRC[31:0]\nDEST[VLMAX-1:32] (Unmodified)\nMOVSS/VMOVSS (when the source operand is an XMM register and the destination is memory)\nDEST[31:0] <- SRC[31:0]\nMOVSS (Legacy SSE version when the source operand is memory and the destination is an XMM register)\nDEST[31:0] <- SRC[31:0]\nDEST[127:32] <- 0\nDEST[VLMAX-1:128] (Unmodified)\nVMOVSS (VEX.NDS.128.F3.0F 11 /r where the destination is an XMM register)\nDEST[31:0] <- SRC2[31:0]\nDEST[127:32] <- SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\nVMOVSS (VEX.NDS.128.F3.0F 10 /r where the source and destination are XMM registers)\nDEST[31:0] <- SRC2[31:0]\nDEST[127:32] <- SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\nVMOVSS (VEX.NDS.128.F3.0F 10 /r when the source operand is memory and the destination is an XMM register)\nDEST[31:0] <- SRC[31:0]\nDEST[VLMAX-1:32] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVSS:| __m128 _mm_load_ss(float * p)      \n| MOVSS:| void _mm_store_ss(float * p, __m128\n|       | a)                                 \n| MOVSS:| __m128 _mm_move_ss(__m128 a, __m128\n|       | b)                                 \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVSS"
    }, 
    {
      "description": "-R:MOVS", 
      "mnem": "MOVSW"
    }, 
    {
      "description": "\nMOVSX/MOVSXD - Move with Sign-Extension:\n| Opcode          | Instruction      | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                    \n| 0F BE /r        | MOVSX r16, r/m8  | RM   | Valid      | Valid          | Move byte to word with sign-extension.         \n| 0F BE /r        | MOVSX r32, r/m8  | RM   | Valid      | Valid          | Move byte to doubleword with signextension.    \n| REX + 0F BE /r  | MOVSX r64, r/m8* | RM   | Valid      | N.E.           | Move byte to quadword with sign-extension.     \n| 0F BF /r        | MOVSX r32, r/m16 | RM   | Valid      | Valid          | Move word to doubleword, with signextension.   \n| REX.W + 0F BF /r| MOVSX r64, r/m16 | RM   | Valid      | N.E.           | Move word to quadword with sign-extension.     \n| REX.W** + 63 /r | MOVSXD r64, r/m32| RM   | Valid      | N.E.           | Move doubleword to quadword with signextension.\nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH. ** The use of MOVSXD without\nREX.W in 64-bit mode is discouraged, Regular MOV should be used instead of using\nMOVSXD without REX.W.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nCopies the contents of the source operand (register or memory location) to the\ndestination operand (register) and sign extends the value to 16 or 32 bits (see\nFigure 7-6 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 1). The size of the converted value depends on the operand-size attribute.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.R prefix permits access to additional registers (R8-R15). Use of the\nREX.W prefix promotes operation to 64 bits. See the summary chart at the beginning\nof this section for encoding data and limits.\n\nOperation:\n\nDEST <- SignExtend(SRC);\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit.                       \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #UD            | If the LOCK prefix is used.          \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "MOVSX"
    }, 
    {
      "description": "-R:MOVSX", 
      "mnem": "MOVSXD"
    }, 
    {
      "description": "\nMOVUPD - Move Unaligned Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| 66 0F 10 /r MOVUPD xmm1, xmm2/m128        | RM   | V/V           | SSE2              | Move packed double-precision floating-point\n|                                           |      |               |                   | values from xmm2/m128 to xmm1.             \n| VEX.128.66.0F.WIG 10 /r VMOVUPD xmm1,     | RM   | V/V           | AVX               | Move unaligned packed double-precision     \n| xmm2/m128                                 |      |               |                   | floating-point from xmm2/mem to xmm1.      \n| VEX.256.66.0F.WIG 10 /r VMOVUPD ymm1,     | RM   | V/V           | AVX               | Move unaligned packed double-precision     \n| ymm2/m256                                 |      |               |                   | floating-point from ymm2/mem to ymm1.      \n| 66 0F 11 /r MOVUPD xmm2/m128, xmm         | MR   | V/V           | SSE2              | Move packed double-precision floating-point\n|                                           |      |               |                   | values from xmm1 to xmm2/m128.             \n| VEX.128.66.0F.WIG 11 /r VMOVUPD xmm2/m128,| MR   | V/V           | AVX               | Move unaligned packed double-precision     \n| xmm1                                      |      |               |                   | floating-point from xmm1 to xmm2/mem.      \n| VEX.256.66.0F.WIG 11 /r VMOVUPD ymm2/m256,| MR   | V/V           | AVX               | Move unaligned packed double-precision     \n| ymm1                                      |      |               |                   | floating-point from ymm1 to ymm2/mem.      \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\n128-bit versions:\n\nMoves a double quadword containing two packed double-precision floating-point\nvalues from the source operand (second operand) to the destination operand (first\noperand). This instruction can be used to load an XMM register from a 128-bit\nmemory location, store the contents of an XMM register into a 128-bit memory\nlocation, or move data between two XMM registers.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: Bits (VLMAX-1:128) of the\ncorresponding YMM destination register remain unchanged.\n\nWhen the source or destination operand is a memory operand, the operand may\nbe unaligned on a 16-byte boundary without causing a general-protection exception\n(#GP) to be generated.1\n\nTo move double-precision floating-point values to and from memory locations\nthat are known to be aligned on 16byte boundaries, use the MOVAPD instruction.\n\nWhile executing in 16-bit addressing mode, a linear address for a 128-bit data\naccess that overlaps the end of a 16bit segment is not allowed and is defined\nas reserved behavior. A specific processor implementation may or may not generate\na general-protection exception (#GP) in this situation, and the address that\nspans the end of the segment may or may not wrap around to the beginning of\nthe segment. VEX.128 encoded version: Bits (VLMAX-1:128) of the destination\nYMM register are zeroed. VEX.256 encoded version: Moves 256 bits of packed double-precision\nfloating-point values from the source operand (second operand) to the destination\noperand (first operand). This instruction can be used to load a YMM register\nfrom a 256-bit memory location, to store the contents of a YMM register into\na 256-bit memory location, or to move data between two YMM registers.\n\n| 1.| If alignment checking is enabled (CR0.AM  \n|   | = 1, RFLAGS.AC = 1, and CPL = 3), an      \n|   | alignment-check exception (#AC) may       \n|   | or may not be generated (depending on     \n|   | processor implementation) when the operand\n|   | is not aligned on an 8-byte boundary.     \nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise\ninstructions will #UD.\n\nOperation:\n\nMOVUPD (128-bit load and register-copy form Legacy SSE version)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] (Unmodified)\n(V)MOVUPD (128-bit store form)\nDEST[127:0] <- SRC[127:0]\nVMOVUPD (VEX.128 encoded version)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] <- 0\nVMOVUPD (VEX.256 encoded version)\nDEST[255:0] <- SRC[255:0]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVUPD: | __m128 _mm_loadu_pd(double * p)       \n| MOVUPD: | void _mm_storeu_pd(double *p, __m128  \n|         | a)                                    \n| VMOVUPD:| __m256d _mm256_loadu_pd (__m256d * p);\n| VMOVUPD:| _mm256_storeu_pd(_m256d *p, __m256d   \n|         | a);                                   \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4 Note treatment of #AC varies; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVUPD"
    }, 
    {
      "description": "\nMOVUPS - Move Unaligned Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                          | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| 0F 10 /r MOVUPS xmm1, xmm2/m128             | RM   | V/V           | SSE               | Move packed single-precision floating-point\n|                                             |      |               |                   | values from xmm2/m128 to xmm1.             \n| VEX.128.0F.WIG 10 /r VMOVUPS xmm1, xmm2/m128| RM   | V/V           | AVX               | Move unaligned packed single-precision     \n|                                             |      |               |                   | floating-point from xmm2/mem to xmm1.      \n| VEX.256.0F.WIG 10 /r VMOVUPS ymm1, ymm2/m256| RM   | V/V           | AVX               | Move unaligned packed single-precision     \n|                                             |      |               |                   | floating-point from ymm2/mem to ymm1.      \n| 0F 11 /r MOVUPS xmm2/m128, xmm1             | MR   | V/V           | SSE               | Move packed single-precision floating-point\n|                                             |      |               |                   | values from xmm1 to xmm2/m128.             \n| VEX.128.0F.WIG 11 /r VMOVUPS xmm2/m128,     | MR   | V/V           | AVX               | Move unaligned packed single-precision     \n| xmm1                                        |      |               |                   | floating-point from xmm1 to xmm2/mem.      \n| VEX.256.0F.WIG 11 /r VMOVUPS ymm2/m256,     | MR   | V/V           | AVX               | Move unaligned packed single-precision     \n| ymm1                                        |      |               |                   | floating-point from ymm1 to ymm2/mem.      \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\n128-bit versions: Moves a double quadword containing four packed single-precision\nfloating-point values from the source operand (second operand) to the destination\noperand (first operand). This instruction can be used to load an XMM register\nfrom a 128-bit memory location, store the contents of an XMM register into a\n128-bit memory location, or move data between two XMM registers.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: Bits (VLMAX-1:128) of the\ncorresponding YMM destination register remain unchanged.\n\nWhen the source or destination operand is a memory operand, the operand may\nbe unaligned on a 16-byte boundary without causing a general-protection exception\n(#GP) to be generated.1\n\nTo move packed single-precision floating-point values to and from memory locations\nthat are known to be aligned on 16-byte boundaries, use the MOVAPS instruction.\n\nWhile executing in 16-bit addressing mode, a linear address for a 128-bit data\naccess that overlaps the end of a 16bit segment is not allowed and is defined\nas reserved behavior. A specific processor implementation may or may not generate\na general-protection exception (#GP) in this situation, and the address that\nspans the end of the segment may or may not wrap around to the beginning of\nthe segment. VEX.128 encoded version: Bits (VLMAX-1:128) of the destination\nYMM register are zeroed.\n\nVEX.256 encoded version: Moves 256 bits of packed single-precision floating-point\nvalues from the source operand (second operand) to the destination operand (first\noperand). This instruction can be used to load a YMM register from a 256-bit\nmemory location, to store the contents of a YMM register into a 256-bit memory\nlocation, or to move data between two YMM registers. Note: In VEX-encoded versions,\nVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\n| 1.| If alignment checking is enabled (CR0.AM  \n|   | = 1, RFLAGS.AC = 1, and CPL = 3), an      \n|   | alignment-check exception (#AC) may       \n|   | or may not be generated (depending on     \n|   | processor implementation) when the operand\n|   | is not aligned on an 8-byte boundary.     \nOperation:\n\nMOVUPS (128-bit load and register-copy form Legacy SSE version)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] (Unmodified)\n(V)MOVUPS (128-bit store form)\nDEST[127:0] <- SRC[127:0]\nVMOVUPS (VEX.128 encoded load-form)\nDEST[127:0] <- SRC[127:0]\nDEST[VLMAX-1:128] <- 0\nVMOVUPS (VEX.256 encoded version)\nDEST[255:0] <- SRC[255:0]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MOVUPS: | __m128 _mm_loadu_ps(double * p)      \n| MOVUPS: | void _mm_storeu_ps(double *p, __m128 \n|         | a)                                   \n| VMOVUPS:| __m256 _mm256_loadu_ps (__m256 * p); \n| VMOVUPS:| _mm256_storeu_ps(_m256 *p, __m256 a);\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4 Note treatment of #AC varies; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "MOVUPS"
    }, 
    {
      "description": "\nMOVZX - Move with Zero-Extend:\n| Opcode          | Instruction     | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                             \n| 0F B6 /r        | MOVZX r16, r/m8 | RM   | Valid      | Valid          | Move byte to word with zero-extension.  \n| 0F B6 /r        | MOVZX r32, r/m8 | RM   | Valid      | Valid          | Move byte to doubleword, zero-extension.\n| REX.W + 0F B6 /r| MOVZX r64, r/m8*| RM   | Valid      | N.E.           | Move byte to quadword, zero-extension.  \n| 0F B7 /r        | MOVZX r32, r/m16| RM   | Valid      | Valid          | Move word to doubleword, zero-extension.\n| REX.W + 0F B7 /r| MOVZX r64, r/m16| RM   | Valid      | N.E.           | Move word to quadword, zero-extension.  \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if the REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nCopies the contents of the source operand (register or memory location) to the\ndestination operand (register) and zero extends the value. The size of the converted\nvalue depends on the operand-size attribute.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.R prefix permits access to additional registers (R8-R15). Use of the\nREX.W prefix promotes operation to 64 bit operands. See the summary chart at\nthe beginning of this section for encoding data and limits.\n\nOperation:\n\nDEST <- ZeroExtend(SRC);\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "MOVZX"
    }, 
    {
      "description": "\nMPSADBW  -  Compute Multiple Packed Sums of Absolute Difference:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                             \n| 66 0F 3A 42 /r ib MPSADBW xmm1, xmm2/m128,| RMI  | V/V           | SSE4_1            | Sums absolute 8-bit integer difference  \n| imm8                                      |      |               |                   | of adjacent groups of 4 byte integers   \n|                                           |      |               |                   | in xmm1 and xmm2/m128 and writes the    \n|                                           |      |               |                   | results in xmm1. Starting offsets within\n|                                           |      |               |                   | xmm1 and xmm2/m128 are determined by    \n|                                           |      |               |                   | imm8.                                   \n| VEX.NDS.128.66.0F3A.WIG 42 /r ib VMPSADBW | RVMI | V/V           | AVX               | Sums absolute 8-bit integer difference  \n| xmm1, xmm2, xmm3/m128, imm8               |      |               |                   | of adjacent groups of 4 byte integers   \n|                                           |      |               |                   | in xmm2 and xmm3/m128 and writes the    \n|                                           |      |               |                   | results in xmm1. Starting offsets within\n|                                           |      |               |                   | xmm2 and xmm3/m128 are determined by    \n|                                           |      |               |                   | imm8.                                   \n| VEX.NDS.256.66.0F3A.WIG 42 /r ib VMPSADBW | RVMI | V/V           | AVX2              | Sums absolute 8-bit integer difference  \n| ymm1, ymm2, ymm3/m256, imm8               |      |               |                   | of adjacent groups of 4 byte integers   \n|                                           |      |               |                   | in xmm2 and ymm3/m128 and writes the    \n|                                           |      |               |                   | results in ymm1. Starting offsets within\n|                                           |      |               |                   | ymm2 and xmm3/m128 are determined by    \n|                                           |      |               |                   | imm8.                                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\n(V)MPSADBW sums the absolute difference of 4 unsigned bytes (block_2) in the\nsecond source operand with sequential groups of 4 unsigned bytes (block_1) in\nthe first source operand. The immediate byte provides bit fields that specify\nthe initial offset of block_1 within the first source operand, and the offset\nof block_2 within the second source operand. The offset granularity in both\nsource operands are 32 bits. The sum-absolute-difference (SAD) operation is\nrepeated 8 times for (V)MPSADW between the same block_2 (fixed offset within\nthe second source operand) and a variable block_1 (offset is shifted by 8 bits\nfor each SAD operation) in the first source operand. Each 16-bit result of eight\nSAD operations is written to the respective word in the destination operand.\n128-bit Legacy SSE version: Imm8[1:0]*32 specifies the bit offset of block_2\nwithin the second source operand. Imm[2]*32 specifies the initial bit offset\nof the block_1 within the first source operand. The first source operand and\ndestination operand are the same. The first source and destination operands\nare XMM registers. The second source operand is either an XMM register or a\n128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination\nregister remain unchanged. Bits 7:3 of the immediate byte are ignored. VEX.128\nencoded version: Imm8[1:0]*32 specifies the bit offset of block_2 within the\nsecond source operand. Imm[2]*32 specifies the initial bit offset of the block_1\nwithin the first source operand. The first source and destination operands are\nXMM registers. The second source operand is either an XMM register or a 128-bit\nmemory location. Bits (127:128) of the corresponding YMM register are zeroed.\nBits 7:3 of the immediate byte are ignored. VEX.256 encoded version: The sum-absolute-difference\n(SAD) operation is repeated 8 times for MPSADW between the same block_2 (fixed\noffset within the second source operand) and a variable block_1 (offset is shifted\nby 8 bits for each SAD operation) in the first source operand. Each 16-bit result\nof eight SAD operations between block_2 and block_1 is written to the respective\nword in the lower 128 bits of the destination operand. Additionally, VMPSADBW\nperforms another eight SAD operations on block_4 of the second source operand\nand block_3 of the first source operand. (Imm8[4:3]*32 + 128) specifies the\nbit offset of block_4 within the second source operand. (Imm[5]*32+128) specifies\nthe initial bit offset of the block_3 within the first source operand. Each\n16-bit result of eight SAD operations between block_4 and block_3 is written\nto the respective word in the upper 128 bits of the destination operand.\n\nThe first source operand is a YMM register. The second source register can be\na YMM register or a 256-bit memory location. The destination operand is a YMM\nregister. Bits 7:6 of the immediate byte are ignored. Note: If VMPSADBW is encoded\nwith VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will\ncause an #UD exception.\n\nImm[4:3]*32+128\n\n| 255| 224| 192| 128\nSrc2 Abs. Diff. Imm[5]*32+128\n\nSrc1 Sum\n\n| 255| 144| 128\nDestination\n\nImm[1:0]*32\n\n| 127| 96| 64| 0\nSrc2 Abs. Diff. Imm[2]*32\n\nSrc1 Sum\n\n| 127| 16| 0\nDestination\n\n| Figure 3-27.| VMPSADBW Operation\nOperation:\n\nVMPSADBW (VEX.256 encoded version)\nSRC2_OFFSET <- imm8[1:0]*32\nSRC1_OFFSET <- imm8[2]*32\nSRC1_BYTE0 <- SRC1[SRC1_OFFSET+7:SRC1_OFFSET]\nSRC1_BYTE1 <- SRC1[SRC1_OFFSET+15:SRC1_OFFSET+8]\nSRC1_BYTE2 <- SRC1[SRC1_OFFSET+23:SRC1_OFFSET+16]\nSRC1_BYTE3 <- SRC1[SRC1_OFFSET+31:SRC1_OFFSET+24]\nSRC1_BYTE4 <-SRC1[SRC1_OFFSET+39:SRC1_OFFSET+32]\nSRC1_BYTE5 <- SRC1[SRC1_OFFSET+47:SRC1_OFFSET+40]\nSRC1_BYTE6 <- SRC1[SRC1_OFFSET+55:SRC1_OFFSET+48]\nSRC1_BYTE7 <- SRC1[SRC1_OFFSET+63:SRC1_OFFSET+56]\nSRC1_BYTE8 <- SRC1[SRC1_OFFSET+71:SRC1_OFFSET+64]\nSRC1_BYTE9 <- SRC1[SRC1_OFFSET+79:SRC1_OFFSET+72]\nSRC1_BYTE10 <- SRC1[SRC1_OFFSET+87:SRC1_OFFSET+80]\nSRC2_BYTE0 <-SRC2[SRC2_OFFSET+7:SRC2_OFFSET]\nSRC2_BYTE1 <- SRC2[SRC2_OFFSET+15:SRC2_OFFSET+8]\nSRC2_BYTE2 <- SRC2[SRC2_OFFSET+23:SRC2_OFFSET+16]\nSRC2_BYTE3 <- SRC2[SRC2_OFFSET+31:SRC2_OFFSET+24]\nTEMP0 <- ABS(SRC1_BYTE0 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE1 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE2 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE3 - SRC2_BYTE3)\nDEST[15:0] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE1 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE2 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE3 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE4 - SRC2_BYTE3)\nDEST[31:16] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE2 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE3 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE4 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE5 - SRC2_BYTE3)\nDEST[47:32] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE3 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE4 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE5 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE6 - SRC2_BYTE3)\nDEST[63:48] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE4 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE5 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE6 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE7 - SRC2_BYTE3)\nDEST[79:64] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE5 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE6 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE7 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE8 - SRC2_BYTE3)\nDEST[95:80] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE6 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE7 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE8 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE9 - SRC2_BYTE3)\nDEST[111:96] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE7 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE8 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE9 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE10 - SRC2_BYTE3)\nDEST[127:112] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nSRC2_OFFSET <- imm8[4:3]*32 + 128\nSRC1_OFFSET <- imm8[5]*32 + 128\nSRC1_BYTE0 <- SRC1[SRC1_OFFSET+7:SRC1_OFFSET]\nSRC1_BYTE1 <- SRC1[SRC1_OFFSET+15:SRC1_OFFSET+8]\nSRC1_BYTE2 <- SRC1[SRC1_OFFSET+23:SRC1_OFFSET+16]\nSRC1_BYTE3 <- SRC1[SRC1_OFFSET+31:SRC1_OFFSET+24]\nSRC1_BYTE4 <- SRC1[SRC1_OFFSET+39:SRC1_OFFSET+32]\nSRC1_BYTE5 <- SRC1[SRC1_OFFSET+47:SRC1_OFFSET+40]\nSRC1_BYTE6 <- SRC1[SRC1_OFFSET+55:SRC1_OFFSET+48]\nSRC1_BYTE7 <- SRC1[SRC1_OFFSET+63:SRC1_OFFSET+56]\nSRC1_BYTE8 <- SRC1[SRC1_OFFSET+71:SRC1_OFFSET+64]\nSRC1_BYTE9 <- SRC1[SRC1_OFFSET+79:SRC1_OFFSET+72]\nSRC1_BYTE10 <- SRC1[SRC1_OFFSET+87:SRC1_OFFSET+80]\nSRC2_BYTE0 <-SRC2[SRC2_OFFSET+7:SRC2_OFFSET]\nSRC2_BYTE1 <- SRC2[SRC2_OFFSET+15:SRC2_OFFSET+8]\nSRC2_BYTE2 <- SRC2[SRC2_OFFSET+23:SRC2_OFFSET+16]\nSRC2_BYTE3 <- SRC2[SRC2_OFFSET+31:SRC2_OFFSET+24]\nTEMP0 <- ABS(SRC1_BYTE0 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE1 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE2 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE3 - SRC2_BYTE3)\nDEST[143:128] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <-ABS(SRC1_BYTE1 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE2 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE3 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE4 - SRC2_BYTE3)\nDEST[159:144] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE2 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE3 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE4 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE5 - SRC2_BYTE3)\nDEST[175:160] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <-ABS(SRC1_BYTE3 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE4 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE5 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE6 - SRC2_BYTE3)\nDEST[191:176] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE4 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE5 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE6 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE7 - SRC2_BYTE3)\nDEST[207:192] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE5 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE6 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE7 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE8 - SRC2_BYTE3)\nDEST[223:208] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE6 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE7 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE8 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE9 - SRC2_BYTE3)\nDEST[239:224] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE7 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE8 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE9 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE10 - SRC2_BYTE3)\nDEST[255:240] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nVMPSADBW (VEX.128 encoded version)\nSRC2_OFFSET <- imm8[1:0]*32\nSRC1_OFFSET <- imm8[2]*32\nSRC1_BYTE0 <- SRC1[SRC1_OFFSET+7:SRC1_OFFSET]\nSRC1_BYTE1 <- SRC1[SRC1_OFFSET+15:SRC1_OFFSET+8]\nSRC1_BYTE2 <- SRC1[SRC1_OFFSET+23:SRC1_OFFSET+16]\nSRC1_BYTE3 <- SRC1[SRC1_OFFSET+31:SRC1_OFFSET+24]\nSRC1_BYTE4 <- SRC1[SRC1_OFFSET+39:SRC1_OFFSET+32]\nSRC1_BYTE5 <- SRC1[SRC1_OFFSET+47:SRC1_OFFSET+40]\nSRC1_BYTE6 <- SRC1[SRC1_OFFSET+55:SRC1_OFFSET+48]\nSRC1_BYTE7 <- SRC1[SRC1_OFFSET+63:SRC1_OFFSET+56]\nSRC1_BYTE8 <- SRC1[SRC1_OFFSET+71:SRC1_OFFSET+64]\nSRC1_BYTE9 <- SRC1[SRC1_OFFSET+79:SRC1_OFFSET+72]\nSRC1_BYTE10 <- SRC1[SRC1_OFFSET+87:SRC1_OFFSET+80]\nSRC2_BYTE0 <-SRC2[SRC2_OFFSET+7:SRC2_OFFSET]\nSRC2_BYTE1 <- SRC2[SRC2_OFFSET+15:SRC2_OFFSET+8]\nSRC2_BYTE2 <- SRC2[SRC2_OFFSET+23:SRC2_OFFSET+16]\nSRC2_BYTE3 <- SRC2[SRC2_OFFSET+31:SRC2_OFFSET+24]\nTEMP0 <- ABS(SRC1_BYTE0 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE1 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE2 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE3 - SRC2_BYTE3)\nDEST[15:0] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE1 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE2 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE3 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE4 - SRC2_BYTE3)\nDEST[31:16] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE2 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE3 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE4 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE5 - SRC2_BYTE3)\nDEST[47:32] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE3 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE4 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE5 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE6 - SRC2_BYTE3)\nDEST[63:48] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE4 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE5 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE6 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE7 - SRC2_BYTE3)\nDEST[79:64] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE5 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE6 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE7 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE8 - SRC2_BYTE3)\nDEST[95:80] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE6 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE7 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE8 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE9 - SRC2_BYTE3)\nDEST[111:96] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS(SRC1_BYTE7 - SRC2_BYTE0)\nTEMP1 <- ABS(SRC1_BYTE8 - SRC2_BYTE1)\nTEMP2 <- ABS(SRC1_BYTE9 - SRC2_BYTE2)\nTEMP3 <- ABS(SRC1_BYTE10 - SRC2_BYTE3)\nDEST[127:112] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nDEST[VLMAX-1:128] <- 0\nMPSADBW (128-bit Legacy SSE version)\nSRC_OFFSET <- imm8[1:0]*32\nDEST_OFFSET <- imm8[2]*32\nDEST_BYTE0 <- DEST[DEST_OFFSET+7:DEST_OFFSET]\nDEST_BYTE1 <- DEST[DEST_OFFSET+15:DEST_OFFSET+8]\nDEST_BYTE2 <- DEST[DEST_OFFSET+23:DEST_OFFSET+16]\nDEST_BYTE3 <- DEST[DEST_OFFSET+31:DEST_OFFSET+24]\nDEST_BYTE4 <- DEST[DEST_OFFSET+39:DEST_OFFSET+32]\nDEST_BYTE5 <- DEST[DEST_OFFSET+47:DEST_OFFSET+40]\nDEST_BYTE6 <- DEST[DEST_OFFSET+55:DEST_OFFSET+48]\nDEST_BYTE7 <- DEST[DEST_OFFSET+63:DEST_OFFSET+56]\nDEST_BYTE8 <- DEST[DEST_OFFSET+71:DEST_OFFSET+64]\nDEST_BYTE9 <- DEST[DEST_OFFSET+79:DEST_OFFSET+72]\nDEST_BYTE10 <- DEST[DEST_OFFSET+87:DEST_OFFSET+80]\nSRC_BYTE0 <- SRC[SRC_OFFSET+7:SRC_OFFSET]\nSRC_BYTE1 <- SRC[SRC_OFFSET+15:SRC_OFFSET+8]\nSRC_BYTE2 <- SRC[SRC_OFFSET+23:SRC_OFFSET+16]\nSRC_BYTE3 <- SRC[SRC_OFFSET+31:SRC_OFFSET+24]\nTEMP0 <- ABS( DEST_BYTE0 - SRC_BYTE0)\nTEMP1 <- ABS( DEST_BYTE1 - SRC_BYTE1)\nTEMP2 <- ABS( DEST_BYTE2 - SRC_BYTE2)\nTEMP3 <- ABS( DEST_BYTE3 - SRC_BYTE3)\nDEST[15:0] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS( DEST_BYTE1 - SRC_BYTE0)\nTEMP1 <- ABS( DEST_BYTE2 - SRC_BYTE1)\nTEMP2 <- ABS( DEST_BYTE3 - SRC_BYTE2)\nTEMP3 <- ABS( DEST_BYTE4 - SRC_BYTE3)\nDEST[31:16] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS( DEST_BYTE2 - SRC_BYTE0)\nTEMP1 <- ABS( DEST_BYTE3 - SRC_BYTE1)\nTEMP2 <- ABS( DEST_BYTE4 - SRC_BYTE2)\nTEMP3 <- ABS( DEST_BYTE5 - SRC_BYTE3)\nDEST[47:32] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS( DEST_BYTE3 - SRC_BYTE0)\nTEMP1 <- ABS( DEST_BYTE4 - SRC_BYTE1)\nTEMP2 <- ABS( DEST_BYTE5 - SRC_BYTE2)\nTEMP3 <- ABS( DEST_BYTE6 - SRC_BYTE3)\nDEST[63:48] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS( DEST_BYTE4 - SRC_BYTE0)\nTEMP1 <- ABS( DEST_BYTE5 - SRC_BYTE1)\nTEMP2 <- ABS( DEST_BYTE6 - SRC_BYTE2)\nTEMP3 <- ABS( DEST_BYTE7 - SRC_BYTE3)\nDEST[79:64] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS( DEST_BYTE5 - SRC_BYTE0)\nTEMP1 <- ABS( DEST_BYTE6 - SRC_BYTE1)\nTEMP2 <- ABS( DEST_BYTE7 - SRC_BYTE2)\nTEMP3 <- ABS( DEST_BYTE8 - SRC_BYTE3)\nDEST[95:80] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS( DEST_BYTE6 - SRC_BYTE0)\nTEMP1 <- ABS( DEST_BYTE7 - SRC_BYTE1)\nTEMP2 <- ABS( DEST_BYTE8 - SRC_BYTE2)\nTEMP3 <- ABS( DEST_BYTE9 - SRC_BYTE3)\nDEST[111:96] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 <- ABS( DEST_BYTE7 - SRC_BYTE0)\nTEMP1 <- ABS( DEST_BYTE8 - SRC_BYTE1)\nTEMP2 <- ABS( DEST_BYTE9 - SRC_BYTE2)\nTEMP3 <- ABS( DEST_BYTE10 - SRC_BYTE3)\nDEST[127:112] <- TEMP0 + TEMP1 + TEMP2 + TEMP3\nDEST[VLMAX-1:128] (Unmodified)\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)MPSADBW:| __m128i _mm_mpsadbw_epu8 (__m128i s1,\n|            | __m128i s2, const int mask);         \n| VMPSADBW:  | __m256i _mm256_mpsadbw_epu8 (__m256i \n|            | s1, __m256i s2, const int mask);     \n\nFlags Affected:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "MPSADBW"
    }, 
    {
      "description": "\nMUL - Unsigned Multiply:\n| Opcode       | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                               \n| F6 /4        | MUL r/m8   | M    | Valid      | Valid          | Unsigned multiply (AX \u2190 AL * r/m8).       \n| REX + F6 /4  | MUL r/m8*  | M    | Valid      | N.E.           | Unsigned multiply (AX \u2190 AL * r/m8).       \n| F7 /4        | MUL r/m16  | M    | Valid      | Valid          | Unsigned multiply (DX:AX \u2190 AX * r/m16).   \n| F7 /4        | MUL r/m32  | M    | Valid      | Valid          | Unsigned multiply (EDX:EAX \u2190 EAX * r/m32).\n| REX.W + F7 /4| MUL r/m64  | M    | Valid      | N.E.           | Unsigned multiply (RDX:RAX \u2190 RAX * r/m64).\nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nPerforms an unsigned multiplication of the first operand (destination operand)\nand the second operand (source operand) and stores the result in the destination\noperand. The destination operand is an implied operand located in register AL,\nAX or EAX (depending on the size of the operand); the source operand is located\nin a generalpurpose register or a memory location. The action of this instruction\nand the location of the result depends on the opcode and the operand size as\nshown in Table 3-66.\n\nThe result is stored in register AX, register pair DX:AX, or register pair EDX:EAX\n(depending on the operand size), with the high-order bits of the product contained\nin register AH, DX, or EDX, respectively. If the high-order bits of the product\nare 0, the CF and OF flags are cleared; otherwise, the flags are set.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of\nthe REX.R prefix permits access to additional registers (R8-R15). Use of the\nREX.W prefix promotes operation to 64 bits.\n\nSee the summary chart at the beginning of this section for encoding data and\nlimits.\n\n\nTable 3-66. MUL Results:\n| Operand Size| Source 1 AL AX EAX RAX| Source 2 r/m8 r/m16 r/m32 r/m64| Destination AX DX:AX EDX:EAX RDX:RAX\nOperation:\n\nIF (Byte operation)\n  THEN\n     AX <- AL * SRC;\n  ELSE (* Word or doubleword operation *)\n     IF OperandSize = 16\n       THEN\n          DX:AX <- AX * SRC;\n       ELSE IF OperandSize = 32\n          THEN EDX:EAX <- EAX * SRC; FI;\n       ELSE (* OperandSize = 64 *)\n          RDX:RAX <- RAX * SRC;\n     FI;\nFI;\n\nFlags Affected:\nThe OF and CF flags are set to 0 if the upper half of the result is 0; otherwise,\nthey are set to 1. The SF, ZF, AF, and PF flags are undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n", 
      "mnem": "MUL"
    }, 
    {
      "description": "\nMULPD - Multiply Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                    \n| 66 0F 59 /r MULPD xmm1, xmm2/m128            | RM   | V/V           | SSE2              | Multiply packed double-precision floating-point\n|                                              |      |               |                   | values in xmm2/m128 by xmm1.                   \n| VEX.NDS.128.66.0F.WIG 59 /r VMULPD xmm1,xmm2,| RVM  | V/V           | AVX               | Multiply packed double-precision floating-point\n| xmm3/m128                                    |      |               |                   | values from xmm3/mem to xmm2 and stores        \n|                                              |      |               |                   | result in xmm1.                                \n| VEX.NDS.256.66.0F.WIG 59 /r VMULPD ymm1,     | RVM  | V/V           | AVX               | Multiply packed double-precision floating-point\n| ymm2, ymm3/m256                              |      |               |                   | values from ymm3/mem to ymm2 and stores        \n|                                              |      |               |                   | result in ymm1.                                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD multiply of the two or four packed double-precision floating-point\nvalues from the source operand (second operand) and the destination operand\n(first operand), and stores the packed double-precision floatingpoint results\nin the destination operand. The source operand can be an XMM register or a 128-bit\nmemory location. The destination operand is an XMM register. See Figure 11-3\nin the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1, for an illustration of a SIMD double-precision floating-point operation.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The second source can be\nan XMM register or an 128-bit memory location. The destination is not distinct\nfrom the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are unmodified. VEX.128 encoded version: the first\nsource operand is an XMM register or 128-bit memory location. The destination\noperand is an XMM register. The upper bits (VLMAX-1:128) of the destination\nYMM register destination are zeroed. VEX.256 encoded version: The first source\noperand is a YMM register. The second source operand can be a YMM register or\na 256-bit memory location. The destination operand is a YMM register.\n\nOperation:\n\nMULPD (128-bit Legacy SSE version)\nDEST[63:0] <- DEST[63:0] * SRC[63:0]\nDEST[127:64] <- DEST[127:64] * SRC[127:64]\nDEST[VLMAX-1:128] (Unmodified)\nVMULPD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0] * SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] * SRC2[127:64]\nDEST[VLMAX-1:128] <- 0\nVMULPD (VEX.256 encoded version)\nDEST[63:0] <- SRC1[63:0] * SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] * SRC2[127:64]\nDEST[191:128] <- SRC1[191:128] * SRC2[191:128]\nDEST[255:192] <- SRC1[255:192] * SRC2[255:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MULPD: | __m128d _mm_mul_pd (m128d a, m128d b)    \n| VMULPD:| __m256d _mm256_mul_pd (__m256d a, __m256d\n|        | b);                                      \n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "MULPD"
    }, 
    {
      "description": "\nMULPS - Multiply Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                        | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                    \n| 0F 59 /r MULPS xmm1, xmm2/m128            | RM   | V/V           | SSE               | Multiply packed single-precision floating-point\n|                                           |      |               |                   | values in xmm2/mem by xmm1.                    \n| VEX.NDS.128.0F.WIG 59 /r VMULPS xmm1,xmm2,| RVM  | V/V           | AVX               | Multiply packed single-precision floating-point\n| xmm3/m128                                 |      |               |                   | values from xmm3/mem to xmm2 and stores        \n|                                           |      |               |                   | result in xmm1.                                \n| VEX.NDS.256.0F.WIG 59 /r VMULPS ymm1,     | RVM  | V/V           | AVX               | Multiply packed single-precision floating-point\n| ymm2, ymm3/m256                           |      |               |                   | values from ymm3/mem to ymm2 and stores        \n|                                           |      |               |                   | result in ymm1.                                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD multiply of the four packed single-precision floating-point\nvalues from the source operand (second operand) and the destination operand\n(first operand), and stores the packed single-precision floatingpoint results\nin the destination operand. See Figure 10-5 in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1, for an illustration of a SIMD single-precision\nfloating-point operation.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The second source can be\nan XMM register or an 128-bit memory location. The destination is not distinct\nfrom the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are unmodified. VEX.128 encoded version: the first\nsource operand is an XMM register or 128-bit memory location. The destination\noperand is an XMM register. The upper bits (VLMAX-1:128) of the destination\nYMM register destination are zeroed. VEX.256 encoded version: The first source\noperand is a YMM register. The second source operand can be a YMM register or\na 256-bit memory location. The destination operand is a YMM register.\n\nOperation:\n\nMULPS (128-bit Legacy SSE version)\nDEST[31:0] <- SRC1[31:0] * SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] * SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] * SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] * SRC2[127:96]\nDEST[VLMAX-1:128] (Unmodified)\nVMULPS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0] * SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] * SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] * SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] * SRC2[127:96]\nDEST[VLMAX-1:128] <- 0\nVMULPS (VEX.256 encoded version)\nDEST[31:0] <- SRC1[31:0] * SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] * SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] * SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] * SRC2[127:96]\nDEST[159:128] <- SRC1[159:128] * SRC2[159:128]\nDEST[191:160]<- SRC1[191:160] * SRC2[191:160]\nDEST[223:192] <- SRC1[223:192] * SRC2[223:192]\nDEST[255:224] <- SRC1[255:224] * SRC2[255:224].\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MULPS: | __m128 _mm_mul_ps(__m128 a, __m128 b) \n| VMULPS:| __m256 _mm256_mul_ps (__m256 a, __m256\n|        | b);                                   \n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "MULPS"
    }, 
    {
      "description": "\nMULSD - Multiply Scalar Double-Precision Floating-Point Values:\n| Opcode/Instruction                          | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                    \n| F2 0F 59 /r MULSD xmm1, xmm2/m64            | RM   | V/V           | SSE2              | Multiply the low double-precision floatingpoint\n|                                             |      |               |                   | value in xmm2/mem64 by low doubleprecision     \n|                                             |      |               |                   | floating-point value in xmm1.                  \n| VEX.NDS.LIG.F2.0F.WIG 59/r VMULSD xmm1,xmm2,| RVM  | V/V           | AVX               | Multiply the low double-precision floatingpoint\n| xmm3/m64                                    |      |               |                   | value in xmm3/mem64 by low double precision    \n|                                             |      |               |                   | floating-point value in xmm2.                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nMultiplies the low double-precision floating-point value in the source operand\n(second operand) by the low doubleprecision floating-point value in the destination\noperand (first operand), and stores the double-precision floatingpoint result\nin the destination operand. The source operand can be an XMM register or a 64-bit\nmemory location. The destination operand is an XMM register. The high quadword\nof the destination operand remains unchanged. See Figure 11-4 in the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration\nof a scalar double-precision floating-point operation.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The first source operand\nand the destination operand are the same. Bits (VLMAX1:64) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128)\nof the destination YMM register are zeroed.\n\nOperation:\n\nMULSD (128-bit Legacy SSE version)\nDEST[63:0] <- DEST[63:0] * SRC[63:0]\nDEST[VLMAX-1:64] (Unmodified)\nVMULSD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0] * SRC2[63:0]\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MULSD:| __m128d _mm_mul_sd (m128d a, m128d b)\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3\n\n", 
      "mnem": "MULSD"
    }, 
    {
      "description": "\nMULSS - Multiply Scalar Single-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                     \n| F3 0F 59 /r MULSS xmm1, xmm2/m32             | RM   | V/V           | SSE               | Multiply the low single-precision floating-point\n|                                              |      |               |                   | value in xmm2/mem by the low singleprecision    \n|                                              |      |               |                   | floating-point value in xmm1.                   \n| VEX.NDS.LIG.F3.0F.WIG 59 /r VMULSS xmm1,xmm2,| RVM  | V/V           | AVX               | Multiply the low single-precision floating-point\n| xmm3/m32                                     |      |               |                   | value in xmm3/mem by the low singleprecision    \n|                                              |      |               |                   | floating-point value in xmm2.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nMultiplies the low single-precision floating-point value from the source operand\n(second operand) by the low single-precision floating-point value in the destination\noperand (first operand), and stores the single-precision floating-point result\nin the destination operand. The source operand can be an XMM register or a 32-bit\nmemory location. The destination operand is an XMM register. The three high-order\ndoublewords of the destination operand remain unchanged. See Figure 10-6 in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 1,\nfor an illustration of a scalar single-precision floating-point operation.\n\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The first source operand\nand the destination operand are the same. Bits (VLMAX1:32) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128)\nof the destination YMM register are zeroed.\n\nOperation:\n\nMULSS (128-bit Legacy SSE version)\nDEST[31:0] <- DEST[31:0] * SRC[31:0]\nDEST[VLMAX-1:32] (Unmodified)\nVMULSS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0] * SRC2[31:0]\nDEST[127:32] <- SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MULSS:| __m128 _mm_mul_ss(__m128 a, __m128 b)\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3\n\n", 
      "mnem": "MULSS"
    }, 
    {
      "description": "\nMULX  -  Unsigned Multiply Without Affecting Flags:\n| Opcode/Instruction                    | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                        \n| VEX.NDD.LZ.F2.0F38.W0 F6 /r MULX r32a,| RVM  | V/V            | BMI2              | Unsigned multiply of r/m32 with EDX\n| r32b, r/m32                           |      |                |                   | without affecting arithmetic flags.\n| VEX.NDD.LZ.F2.0F38.W1 F6 /r MULX r64a,| RVM  | V/N.E.         | BMI2              | Unsigned multiply of r/m64 with RDX\n| r64b, r/m64                           |      |                |                   | without affecting arithmetic flags.\n\nInstruction Operand Encoding:\n| Op/En RVM| Operand 1 ModRM:reg (w)| Operand 2 VEX.vvvv (w)| Operand 3 ModRM:r/m (r)| Operand 4 RDX/EDX is implied 64/32 bits\n|          |                        |                       |                        | source                                 \n\nDescription:\nPerforms an unsigned multiplication of the implicit source operand (EDX/RDX)\nand the specified source operand (the third operand) and stores the low half\nof the result in the second destination (second operand), the high half of the\nresult in the first destination operand (first operand), without reading or\nwriting the arithmetic flags. This enables efficient programming where the software\ncan interleave add with carry operations and multiplications. If the first and\nsecond operand are identical, it will contain the high half of the multiplication\nresult. This instruction is not supported in real mode and virtual-8086 mode.\nThe operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand\nsize 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to\nexecute this instruction with VEX.L not equal to 0 will cause #UD.\n\nOperation:\n\n// DEST1: ModRM:reg\n// DEST2: VEX.vvvv\nIF (OperandSize = 32)\n  SRC1 <- EDX;\n  DEST2 <- (SRC1*SRC2)[31:0];\n  DEST1 <- (SRC1*SRC2)[63:32];\nELSE IF (OperandSize = 64)\n  SRC1 <- RDX;\n     DEST2 <- (SRC1*SRC2)[63:0];\n     DEST1 <- (SRC1*SRC2)[127:64];\nFI\n\nFlags Affected:\nNone\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nAuto-generated from high-level language when possible.\n\nunsigned int mulx_u32(unsigned int a, unsigned int b, unsigned int * hi);\n\nunsigned __int64 mulx_u64(unsigned __int64 a, unsigned __int64 b, unsigned __int64\n* hi);\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Section 2.5.1, \u201cException Conditions for VEX-Encoded GPR Instructions\u201d,\nTable 2-29; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "MULX"
    }, 
    {
      "description": "\nMWAIT - Monitor Wait:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                                \n| 0F 01 C9| MWAIT      | NP   | Valid      | Valid          | A hint that allow the processor to stop                    \n|         |            |      |            |                | instruction execution and enter an implementation-dependent\n|         |            |      |            |                | optimized state until occurrence of                        \n|         |            |      |            |                | a class of events.                                         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nMWAIT instruction provides hints to allow the processor to enter an implementation-dependent\noptimized state. There are two principal targeted usages: address-range monitor\nand advanced power management. Both usages of MWAIT require the use of the MONITOR\ninstruction.\n\nCPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT\nin the processor. When set, MWAIT may be executed only at privilege level 0\n(use at any other privilege level results in an invalid-opcode exception). The\noperating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE\nMSR; disabling MWAIT clears the CPUID feature flag and causes execution to generate\nan invalid-opcode exception.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nECX specifies optional extensions for the MWAIT instruction. EAX may contain\nhints such as the preferred optimized state the processor should enter. The\nfirst processors to implement MWAIT supported only the zero value for EAX and\nECX. Later processors allowed setting ECX[0] to enable masked interrupts as\nbreak events for MWAIT (see below). Software can use the CPUID instruction to\ndetermine the extensions and hints supported by the processor.\n\n\nMWAIT for Address Range Monitoring:\nFor address-range monitoring, the MWAIT instruction operates with the MONITOR\ninstruction. The two instructions allow the definition of an address at which\nto wait (MONITOR) and a implementation-dependent-optimized operation to commence\nat the wait address (MWAIT). The execution of MWAIT is a hint to the processor\nthat it can enter an implementation-dependent-optimized state while waiting\nfor an event or a store operation to the address range armed by MONITOR.\n\nThe following cause the processor to exit the implementation-dependent-optimized\nstate: a store to the address range armed by the MONITOR instruction, an NMI\nor SMI, a debug exception, a machine check exception, the BINIT# signal, the\nINIT# signal, and the RESET# signal. Other implementation-dependent events may\nalso cause the processor to exit the implementation-dependent-optimized state.\n\nIn addition, an external interrupt causes the processor to exit the implementation-dependent-optimized\nstate either (1) if the interrupt would be delivered to software (e.g., as it\nwould be if HLT had been executed instead of MWAIT); or (2) if ECX[0] = 1. Software\ncan execute MWAIT with ECX[0] = 1 only if CPUID.05H:ECX[bit 1] = 1. (Implementation-specific\nconditions may result in an interrupt causing the processor to exit the implementationdependent-optimized\nstate even if interrupts are masked and ECX[0] = 0.)\n\nFollowing exit from the implementation-dependent-optimized state, control passes\nto the instruction following the MWAIT instruction. A pending interrupt that\nis not masked (including an NMI or an SMI) may be delivered before execution\nof that instruction. Unlike the HLT instruction, the MWAIT instruction does\nnot support a restart at the MWAIT instruction following the handling of an\nSMI.\n\nIf the preceding MONITOR instruction did not successfully arm an address range\nor if the MONITOR instruction has not been executed prior to executing MWAIT,\nthen the processor will not enter the implementation-dependent-optimized state.\nExecution will resume at the instruction following the MWAIT.\n\n\nMWAIT for Power Management:\nMWAIT accepts a hint and optional extension to the processor that it can enter\na specified target C state while waiting for an event or a store operation to\nthe address range armed by MONITOR. Support for MWAIT extensions for power management\nis indicated by CPUID.05H:ECX[bit 0] reporting 1.\n\nEAX and ECX are used to communicate the additional information to the MWAIT\ninstruction, such as the kind of optimized state the processor should enter.\nECX specifies optional extensions for the MWAIT instruction. EAX may contain\nhints such as the preferred optimized state the processor should enter. Implementation-specific\nconditions may cause a processor to ignore the hint and enter a different optimized\nstate. Future processor implementations may implement several optimized \u201cwaiting\u201d\nstates and will select among those states based on the hint argument.\n\nTable 3-67 describes the meaning of ECX and EAX registers for MWAIT extensions.\n\n\nTable 3-67. MWAIT Extension Register (ECX):\n| Bits                                   | Description                     \n| Treat interrupts as break events even  | 0                               \n| if masked (e.g., even if EFLAGS.IF=0). |                                 \n| May be set only if CPUID.05H:ECX[bit   |                                 \n| 1] = 1.                                |                                 \n| Reserved                               | 31: 1 MWAIT Hints Register (EAX)\n| Bits                                   | Description                     \n| Sub C-state within a C-state, indicated| 3 : 0                           \n| by bits [7:4]                          |                                 \n| Target C-state*Value of 0 means C1;    | 7 : 4                           \n| 1 means C2 and so on Value of 01111B   |                                 \n| means C0                               |                                 \nNote: Target C states for MWAIT extensions are processor-specific C-states,\nnot ACPI C-states\n\n| 31: 8| Reserved\nNote that if MWAIT is used to enter any of the C-states that are numerically\nhigher than C1, a store to the address range armed by the MONITOR instruction\nwill cause the processor to exit MWAIT only if the store was originated by other\nprocessor agents. A store from non-processor agent might not cause the processor\nto exit MWAIT in such cases.\n\nFor additional details of MWAIT extensions, see Chapter 14, \u201cPower and Thermal\nManagement,\u201d of Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 3A.\n\nOperation:\n\n(* MWAIT takes the argument in EAX as a hint extension and is architected to take the argument in ECX as an instruction extension\nMWAIT EAX, ECX *)\n{\nWHILE ( (\u201cMonitor Hardware is in armed state\u201d)) {\n  implementation_dependent_optimized_state(EAX, ECX); }\nSet the state of Monitor Hardware as triggered;\n}\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| MWAIT:| void _mm_mwait(unsigned extensions,\n|       | unsigned hints)                    \n\nExample:\nMONITOR/MWAIT instruction pair must be coded in the same loop because execution\nof the MWAIT instruction will trigger the monitor hardware. It is not a proper\nusage to execute MONITOR once and then execute MWAIT in a loop. Setting up MONITOR\nwithout executing MWAIT has no adverse effects.\n\nTypically the MONITOR/MWAIT pair is used in a sequence, such as:\n\nEAX = Logical Address(Trigger) ECX = 0 (*Hints *) EDX = 0 (* Hints *)\n\nIF ( !trigger_store_happened) {MONITOR EAX, ECX, EDX IF ( !trigger_store_happened\n) {MWAIT EAX, ECX }}\n\nThe above code sequence makes sure that a triggering store does not happen between\nthe first check of the trigger and the execution of the monitor instruction.\nWithout the second check that triggering store would go un-noticed. Typical\nusage of MONITOR and MWAIT would have the above code sequence within a loop.\n\n\nNumeric Exceptions:\nNone\n\n\nProtected Mode Exceptions:\n| #GP(0)| If ECX[31:1] != 0. If ECX[0] = 1 and \n|       | CPUID.05H:ECX[bit 1] = 0.           \n| #UD   | If CPUID.01H:ECX.MONITOR[bit 3] = 0.\n|       | If current privilege level is not 0.\n\nReal Address Mode Exceptions:\n| #GP| If ECX[31:1] != 0. If ECX[0] = 1 and \n|    | CPUID.05H:ECX[bit 1] = 0.           \n| #UD| If CPUID.01H:ECX.MONITOR[bit 3] = 0.\n\nVirtual 8086 Mode Exceptions:\n| #UD| The MWAIT instruction is not recognized                \n|    | in virtual-8086 mode (even if CPUID.01H:ECX.MONITOR[bit\n|    | 3] = 1).                                               \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)| If RCX[63:1] != 0. If RCX[0] = 1 and  \n|       | CPUID.05H:ECX[bit 1] = 0.            \n| #UD   | If the current privilege level is not\n|       | 0. If CPUID.01H:ECX.MONITOR[bit 3] = \n|       | 0.                                   \n", 
      "mnem": "MWAIT"
    }, 
    {
      "description": "\nNEG - Two's Complement Negation:\n| Opcode       | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                   \n| F6 /3        | NEG r/m8   | M    | Valid      | Valid          | Two's complement negate r/m8. \n| REX + F6 /3  | NEG r/m8*  | M    | Valid      | N.E.           | Two's complement negate r/m8. \n| F7 /3        | NEG r/m16  | M    | Valid      | Valid          | Two's complement negate r/m16.\n| F7 /3        | NEG r/m32  | M    | Valid      | Valid          | Two's complement negate r/m32.\n| REX.W + F7 /3| NEG r/m64  | M    | Valid      | N.E.           | Two's complement negate r/m64.\nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r, w)| NA       | NA       | NA       \n\nDescription:\nReplaces the value of operand (the destination operand) with its two's complement.\n(This operation is equivalent to subtracting the operand from 0.) The destination\noperand is located in a general-purpose register or a memory location.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nOperation:\n\nIF DEST = 0\n  THEN CF <- 0;\n  ELSE CF <- 1;\nFI;\nDEST <- [- (DEST)]\n\nFlags Affected:\nThe CF flag set to 0 if the source operand is 0; otherwise it is set to 1. The\nOF, SF, ZF, AF, and PF flags are set according to the result.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register contains a NULL segment     \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used but the destination \n|                | is not a memory operand.                       \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame as for protected mode exceptions.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| For a page fault.                             \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "NEG"
    }, 
    {
      "description": "\nNOP - No Operation:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                         \n| 90      | NOP        | NP   | Valid      | Valid          | One byte no-operation instruction.  \n| 0F 1F /0| NOP r/m16  | M    | Valid      | Valid          | Multi-byte no-operation instruction.\n| 0F 1F /0| NOP r/m32  | M    | Valid      | Valid          | Multi-byte no-operation instruction.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| NP   | NA           | NA       | NA       | NA       \n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nThis instruction performs no operation. It is a one-byte or multi-byte NOP that\ntakes up space in the instruction stream but does not impact machine context,\nexcept for the EIP register.\n\nThe multi-byte form of NOP is available on processors with model encoding:\n\n - CPUID.01H.EAX[Bytes 11:8] = 0110B or 1111B\n\nThe multi-byte NOP instruction does not alter the content of a register and\nwill not issue a memory operation. The instruction's operation is the same in\nnon-64-bit modes and 64-bit mode.\n\nOperation:\n\nThe one-byte NOP instruction is an alias mnemonic for the XCHG (E)AX, (E)AX instruction.\nThe multi-byte NOP instruction performs no operation on supported processors and generates undefined opcode\nexception on processors that do not support the multi-byte NOP instruction.\nThe memory operand form of the instruction allows software to create a byte sequence of \u201cno operation\u201d as one\ninstruction. For situations where multiple-byte NOPs are needed, the recommended operations (32-bit mode and\n64-bit mode) are:\n\nTable 4-9. Recommended Multi-Byte Sequence of NOP Instruction:\n| Length | Assembly                                  | Byte Sequence              \n| 2 bytes| 66 NOP                                    | 66 90H                     \n| 3 bytes| NOP DWORD ptr [EAX]                       | 0F 1F 00H                  \n| 4 bytes| NOP DWORD ptr [EAX + 00H]                 | 0F 1F 40 00H               \n| 5 bytes| NOP DWORD ptr [EAX + EAX*1 + 00H]         | 0F 1F 44 00 00H            \n| 6 bytes| 66 NOP DWORD ptr [EAX + EAX*1 + 00H]      | 66 0F 1F 44 00 00H         \n| 7 bytes| NOP DWORD ptr [EAX + 00000000H]           | 0F 1F 80 00 00 00 00H      \n| 8 bytes| NOP DWORD ptr [EAX + EAX*1 + 00000000H]   | 0F 1F 84 00 00 00 00 00H   \n| 9 bytes| 66 NOP DWORD ptr [EAX + EAX*1 + 00000000H]| 66 0F 1F 84 00 00 00 00 00H\n\nFlags Affected:\nNone.\n\n\nExceptions (All Operating Modes):\n| #UD| If the LOCK prefix is used.\n", 
      "mnem": "NOP"
    }, 
    {
      "description": "\nNOT - One's Complement Negation:\n| Opcode       | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description               \n| F6 /2        | NOT r/m8   | M    | Valid      | Valid          | Reverse each bit of r/m8. \n| REX + F6 /2  | NOT r/m8*  | M    | Valid      | N.E.           | Reverse each bit of r/m8. \n| F7 /2        | NOT r/m16  | M    | Valid      | Valid          | Reverse each bit of r/m16.\n| F7 /2        | NOT r/m32  | M    | Valid      | Valid          | Reverse each bit of r/m32.\n| REX.W + F7 /2| NOT r/m64  | M    | Valid      | N.E.           | Reverse each bit of r/m64.\nNotes: \n\n| *| In 64-bit mode, r/m8 can not be encoded\n|  | to access the following byte registers \n|  | if a REX prefix is used: AH, BH, CH,   \n|  | DH.                                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r, w)| NA       | NA       | NA       \n\nDescription:\nPerforms a bitwise NOT operation (each 1 is set to 0, and each 0 is set to 1)\non the destination operand and stores the result in the destination operand\nlocation. The destination operand can be a register or a memory location.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nOperation:\n\nDEST <- NOT DEST;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination operand points to          \n|                | a non-writable segment. If a memory           \n|                | operand effective address is outside          \n|                | the CS, DS, ES, FS, or GS segment limit.      \n|                | If the DS, ES, FS, or GS register contains    \n|                | a NULL segment selector.                      \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame as for protected mode exceptions.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "NOT"
    }, 
    {
      "description": "\nOR - Logical Inclusive OR:\n| Opcode          | Instruction    | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                    \n| 0C ib           | OR AL, imm8    | I    | Valid      | Valid          | AL OR imm8.                    \n| 0D iw           | OR AX, imm16   | I    | Valid      | Valid          | AX OR imm16.                   \n| 0D id           | OR EAX, imm32  | I    | Valid      | Valid          | EAX OR imm32.                  \n| REX.W + 0D id   | OR RAX, imm32  | I    | Valid      | N.E.           | RAX OR imm32 (sign-extended).  \n| 80 /1 ib        | OR r/m8, imm8  | MI   | Valid      | Valid          | r/m8 OR imm8.                  \n| REX + 80 /1 ib  | OR r/m8*, imm8 | MI   | Valid      | N.E.           | r/m8 OR imm8.                  \n| 81 /1 iw        | OR r/m16, imm16| MI   | Valid      | Valid          | r/m16 OR imm16.                \n| 81 /1 id        | OR r/m32, imm32| MI   | Valid      | Valid          | r/m32 OR imm32.                \n| REX.W + 81 /1 id| OR r/m64, imm32| MI   | Valid      | N.E.           | r/m64 OR imm32 (sign-extended).\n| 83 /1 ib        | OR r/m16, imm8 | MI   | Valid      | Valid          | r/m16 OR imm8 (sign-extended). \n| 83 /1 ib        | OR r/m32, imm8 | MI   | Valid      | Valid          | r/m32 OR imm8 (sign-extended). \n| REX.W + 83 /1 ib| OR r/m64, imm8 | MI   | Valid      | N.E.           | r/m64 OR imm8 (sign-extended). \n| 08 /r           | OR r/m8, r8    | MR   | Valid      | Valid          | r/m8 OR r8.                    \n| REX + 08 /r     | OR r/m8*, r8*  | MR   | Valid      | N.E.           | r/m8 OR r8.                    \n| 09 /r           | OR r/m16, r16  | MR   | Valid      | Valid          | r/m16 OR r16.                  \n| 09 /r           | OR r/m32, r32  | MR   | Valid      | Valid          | r/m32 OR r32.                  \n| REX.W + 09 /r   | OR r/m64, r64  | MR   | Valid      | N.E.           | r/m64 OR r64.                  \n| 0A /r           | OR r8, r/m8    | RM   | Valid      | Valid          | r8 OR r/m8.                    \n| REX + 0A /r     | OR r8*, r/m8*  | RM   | Valid      | N.E.           | r8 OR r/m8.                    \n| 0B /r           | OR r16, r/m16  | RM   | Valid      | Valid          | r16 OR r/m16.                  \n| 0B /r           | OR r32, r/m32  | RM   | Valid      | Valid          | r32 OR r/m32.                  \n| REX.W + 0B /r   | OR r64, r/m64  | RM   | Valid      | N.E.           | r64 OR r/m64.                  \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| I    | AL/AX/EAX/RAX   | imm8/16/32   | NA       | NA       \n| MI   | ModRM:r/m (r, w)| imm8/16/32   | NA       | NA       \n| MR   | ModRM:r/m (r, w)| ModRM:reg (r)| NA       | NA       \n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nPerforms a bitwise inclusive OR operation between the destination (first) and\nsource (second) operands and stores the result in the destination operand location.\nThe source operand can be an immediate, a register, or a memory location; the\ndestination operand can be a register or a memory location. (However, two memory\noperands cannot be used in one instruction.) Each bit of the result of the OR\ninstruction is set to 0 if both corresponding bits of the first and second operands\nare 0; otherwise, each bit is set to 1.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nOperation:\n\nDEST <- DEST OR SRC;\n\nFlags Affected:\nThe OF and CF flags are cleared; the SF, ZF, and PF flags are set according\nto the result. The state of the AF flag is undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination operand points to          \n|                | a non-writable segment. If a memory           \n|                | operand effective address is outside          \n|                | the CS, DS, ES, FS, or GS segment limit.      \n|                | If the DS, ES, FS, or GS register contains    \n|                | a NULL segment selector.                      \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame as for protected mode exceptions.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "OR"
    }, 
    {
      "description": "\nORPD - Bitwise Logical OR of Double-Precision Floating-Point Values:\n| Opcode/Instruction                          | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 66 0F 56 /r ORPD xmm1, xmm2/m128            | RM   | V/V                   | SSE2              | Bitwise OR of xmm2/m128 and xmm1.      \n| VEX.NDS.128.66.0F.WIG 56 /r VORPD xmm1,xmm2,| RVM  | V/V                   | AVX               | Return the bitwise logical OR of packed\n| xmm3/m128                                   |      |                       |                   | double-precision floating-point values \n|                                             |      |                       |                   | in xmm2 and xmm3/mem.                  \n| VEX.NDS.256.66.0F.WIG 56 /r VORPD ymm1,     | RVM  | V/V                   | AVX               | Return the bitwise logical OR of packed\n| ymm2, ymm3/m256                             |      |                       |                   | double-precision floating-point values \n|                                             |      |                       |                   | in ymm2 and ymm3/mem.                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a bitwise logical OR of the two or four packed double-precision floating-point\nvalues from the first source operand and the second source operand, and stores\nthe result in the destination operand\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe destination YMM register destination are zeroed. VEX.256 encoded version:\nThe first source operand is a YMM register. The second source operand can be\na YMM register or a 256-bit memory location. The destination operand is a YMM\nregister. Note: If VORPD is encoded with VEX.L= 1, an attempt to execute the\ninstruction encoded with VEX.L= 1 will cause an #UD exception.\n\nOperation:\n\nORPD (128-bit Legacy SSE version)\nDEST[63:0] <- DEST[63:0] BITWISE OR SRC[63:0]\nDEST[127:64] <- DEST[127:64] BITWISE OR SRC[127:64]\nDEST[VLMAX-1:128] (Unmodified)\nVORPD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0] BITWISE OR SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] BITWISE OR SRC2[127:64]\nDEST[VLMAX-1:128] <- 0\nVORPD (VEX.256 encoded version)\nDEST[63:0] <- SRC1[63:0] BITWISE OR SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] BITWISE OR SRC2[127:64]\nDEST[191:128] <- SRC1[191:128] BITWISE OR SRC2[191:128]\nDEST[255:192] <- SRC1[255:192] BITWISE OR SRC2[255:192]\n\nIntel\u00ae C/C++ Compiler Intrinsic Equivalent:\n| ORPD: | __m128d _mm_or_pd(__m128d a, __m128d    \n|       | b);                                     \n| VORPD:| __m256d _mm256_or_pd (__m256d a, __m256d\n|       | b);                                     \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "ORPD"
    }, 
    {
      "description": "\nORPS - Bitwise Logical OR of Single-Precision Floating-Point Values:\n| Opcode/Instruction                  | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 0F 56 /r ORPS xmm1, xmm2/m128       | RM   | V/V                   | SSE               | Bitwise OR of xmm1 and xmm2/m128.      \n| VEX.NDS.128.0F.WIG 56 /r VORPS xmm1,| RVM  | V/V                   | AVX               | Return the bitwise logical OR of packed\n| xmm2, xmm3/m128                     |      |                       |                   | singleprecision floating-point values  \n|                                     |      |                       |                   | in xmm2 and xmm3/mem.                  \n| VEX.NDS.256.0F.WIG 56 /r VORPS ymm1,| RVM  | V/V                   | AVX               | Return the bitwise logical OR of packed\n| ymm2, ymm3/m256                     |      |                       |                   | singleprecision floating-point values  \n|                                     |      |                       |                   | in ymm2 and ymm3/mem.                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a bitwise logical OR of the four or eight packed single-precision floating-point\nvalues from the first source operand and the second source operand, and stores\nthe result in the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe destination YMM register destination are zeroed. VEX.256 Encoded version:\nThe first source operand is a YMM register. The second source operand can be\na YMM register or a 256-bit memory location. The destination operand is a YMM\nregister. Note: If VORPS is encoded with VEX.L= 1, an attempt to execute the\ninstruction encoded with VEX.L= 1 will cause an #UD exception.\n\nOperation:\n\nORPS (128-bit Legacy SSE version)\nDEST[31:0] <- SRC1[31:0] BITWISE OR SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] BITWISE OR SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] BITWISE OR SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] BITWISE OR SRC2[127:96]\nDEST[VLMAX-1:128] (Unmodified)\nVORPS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0] BITWISE OR SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] BITWISE OR SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] BITWISE OR SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] BITWISE OR SRC2[127:96]\nDEST[VLMAX-1:128] <- 0\nVORPS (VEX.256 encoded version)\nDEST[31:0] <- SRC1[31:0] BITWISE OR SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] BITWISE OR SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] BITWISE OR SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] BITWISE OR SRC2[127:96]\nDEST[159:128] <- SRC1[159:128] BITWISE OR SRC2[159:128]\nDEST[191:160]<- SRC1[191:160] BITWISE OR SRC2[191:160]\nDEST[223:192] <- SRC1[223:192] BITWISE OR SRC2[223:192]\nDEST[255:224] <- SRC1[255:224] BITWISE OR SRC2[255:224].\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ORPS: | __m128 _mm_or_ps (__m128 a, __m128 b);\n| VORPS:| __m256 _mm256_or_ps (__m256 a, __m256 \n|       | b);                                   \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "ORPS"
    }, 
    {
      "description": "\nOUT - Output to Port:\n| Opcode*| Instruction  | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| E6 ib  | OUT imm8, AL | I    | Valid      | Valid          | Output byte in AL to I/O port address\n|        |              |      |            |                | imm8.                                \n| E7 ib  | OUT imm8, AX | I    | Valid      | Valid          | Output word in AX to I/O port address\n|        |              |      |            |                | imm8.                                \n| E7 ib  | OUT imm8, EAX| I    | Valid      | Valid          | Output doubleword in EAX to I/O port \n|        |              |      |            |                | address imm8.                        \n| EE     | OUT DX, AL   | NP   | Valid      | Valid          | Output byte in AL to I/O port address\n|        |              |      |            |                | in DX.                               \n| EF     | OUT DX, AX   | NP   | Valid      | Valid          | Output word in AX to I/O port address\n|        |              |      |            |                | in DX.                               \n| EF     | OUT DX, EAX  | NP   | Valid      | Valid          | Output doubleword in EAX to I/O port \n|        |              |      |            |                | address in DX.                       \nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| I    | imm8     | NA       | NA       | NA       \n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nCopies the value from the second operand (source operand) to the I/O port specified\nwith the destination operand (first operand). The source operand can be register\nAL, AX, or EAX, depending on the size of the port being accessed (8, 16, or\n32 bits, respectively); the destination operand can be a byte-immediate or the\nDX register. Using a byte immediate allows I/O port addresses 0 to 255 to be\naccessed; using the DX register as a source operand allows I/O ports from 0\nto 65,535 to be accessed.\n\nThe size of the I/O port being accessed is determined by the opcode for an 8-bit\nI/O port or by the operand-size attribute of the instruction for a 16- or 32-bit\nI/O port.\n\nAt the machine code level, I/O instructions are shorter when accessing 8-bit\nI/O ports. Here, the upper eight bits of the port address will be 0.\n\nThis instruction is only useful for accessing I/O ports located in the processor's\nI/O address space. See Chapter 16, \u201cInput/Output,\u201d in the Intel\u00ae 64 and IA-32\nArchitectures Software Developer's Manual, Volume 1, for more information on\naccessing I/O ports in the I/O address space.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nIA-32 Architecture Compatibility:\nAfter executing an OUT instruction, the Pentium\u00ae processor ensures that the\nEWBE# pin has been sampled active before it begins to execute the next instruction.\n(Note that the instruction can be prefetched if EWBE# is not active, but it\nwill not be executed until the EWBE# pin is sampled active.) Only the Pentium\nprocessor family has the EWBE# pin.\n\nOperation:\n\nIF ((PE = 1) and ((CPL > IOPL) or (VM = 1)))\n  THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)\n     IF (Any I/O Permission Bit for I/O port being accessed = 1)\n       THEN (* I/O operation is not allowed *)\n          #GP(0);\n       ELSE ( * I/O operation is allowed *)\n          DEST <- SRC; (* Writes to selected I/O port *)\n     FI;\n  ELSE (Real Mode or Protected Mode with CPL \u2264 IOPL *)\n     DEST <- SRC; (* Writes to selected I/O port *)\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the CPL is greater than (has less       \n|       | privilege) the I/O privilege level (IOPL)  \n|       | and any of the corresponding I/O permission\n|       | bits in TSS for the I/O port being accessed\n|       | is 1.                                      \n| #UD   | If the LOCK prefix is used.                \n\nReal-Address Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If any of the I/O permission bits in   \n|                | the TSS for the I/O port being accessed\n|                | is 1.                                  \n| #PF(fault-code)| If a page fault occurs.                \n| #UD            | If the LOCK prefix is used.            \n\nCompatibility Mode Exceptions:\nSame as protected mode exceptions.\n\n\n64-Bit Mode Exceptions:\nSame as protected mode exceptions.\n\n", 
      "mnem": "OUT"
    }, 
    {
      "description": "\nOUTS/OUTSB/OUTSW/OUTSD - Output String to Port:\n| Opcode*| Instruction | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                               \n| 6E     | OUTS DX, m8 | NP   | Valid      | Valid          | Output byte from memory location specified\n|        |             |      |            |                | in DS:(E)SI or RSI to I/O port specified  \n|        |             |      |            |                | in DX**.                                  \n| 6F     | OUTS DX, m16| NP   | Valid      | Valid          | Output word from memory location specified\n|        |             |      |            |                | in DS:(E)SI or RSI to I/O port specified  \n|        |             |      |            |                | in DX**.                                  \n| 6F     | OUTS DX, m32| NP   | Valid      | Valid          | Output doubleword from memory location    \n|        |             |      |            |                | specified in DS:(E)SI or RSI to I/O       \n|        |             |      |            |                | port specified in DX**.                   \n| 6E     | OUTSB       | NP   | Valid      | Valid          | Output byte from memory location specified\n|        |             |      |            |                | in DS:(E)SI or RSI to I/O port specified  \n|        |             |      |            |                | in DX**.                                  \n| 6F     | OUTSW       | NP   | Valid      | Valid          | Output word from memory location specified\n|        |             |      |            |                | in DS:(E)SI or RSI to I/O port specified  \n|        |             |      |            |                | in DX**.                                  \n| 6F     | OUTSD       | NP   | Valid      | Valid          | Output doubleword from memory location    \n|        |             |      |            |                | specified in DS:(E)SI or RSI to I/O       \n|        |             |      |            |                | port specified in DX**.                   \nNotes: * See IA-32 Architecture Compatibility section below. ** In 64-bit mode,\nonly 64-bit (RSI) and 32-bit (ESI) address sizes are supported. In non-64-bit\nmode, only 32-bit (ESI) and 16-bit (SI) address sizes are supported.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nCopies data from the source operand (second operand) to the I/O port specified\nwith the destination operand (first operand). The source operand is a memory\nlocation, the address of which is read from either the DS:SI, DS:ESI or the\nRSI registers (depending on the address-size attribute of the instruction, 16,\n32 or 64, respectively). (The DS segment may be overridden with a segment override\nprefix.) The destination operand is an I/O port address (from 0 to 65,535) that\nis read from the DX register. The size of the I/O port being accessed (that\nis, the size of the source and destination operands) is determined by the opcode\nfor an 8-bit I/O port or by the operand-size attribute of the instruction for\na 16- or 32-bit I/O port.\n\nAt the assembly-code level, two forms of this instruction are allowed: the \u201cexplicit-operands\u201d\nform and the \u201cnooperands\u201d form. The explicit-operands form (specified with the\nOUTS mnemonic) allows the source and destination operands to be specified explicitly.\nHere, the source operand should be a symbol that indicates the size of the I/O\nport and the source address, and the destination operand must be DX. This explicit-operands\nform is provided to allow documentation; however, note that the documentation\nprovided by this form can be misleading. That is, the source operand symbol\nmust specify the correct type (size) of the operand (byte, word, or doubleword),\nbut it does not have to specify the correct location. The location is always\nspecified by the DS:(E)SI or RSI registers, which must be loaded correctly before\nthe OUTS instruction is executed.\n\nThe no-operands form provides \u201cshort forms\u201d of the byte, word, and doubleword\nversions of the OUTS instructions. Here also DS:(E)SI is assumed to be the source\noperand and DX is assumed to be the destination operand. The size of the I/O\nport is specified with the choice of mnemonic: OUTSB (byte), OUTSW (word), or\nOUTSD (doubleword).\n\nAfter the byte, word, or doubleword is transferred from the memory location\nto the I/O port, the SI/ESI/RSI register is incremented or decremented automatically\naccording to the setting of the DF flag in the EFLAGS register. (If the DF flag\nis 0, the (E)SI register is incremented; if the DF flag is 1, the SI/ESI/RSI\nregister is decremented.) The SI/ESI/RSI register is incremented or decremented\nby 1 for byte operations, by 2 for word operations, and by 4 for doubleword\noperations.\n\nThe OUTS, OUTSB, OUTSW, and OUTSD instructions can be preceded by the REP prefix\nfor block input of ECX bytes, words, or doublewords. See \u201cREP/REPE/REPZ /REPNE/REPNZ - Repeat\nString Operation Prefix\u201d in this chapter for a description of the REP prefix.\nThis instruction is only useful for accessing I/O ports located in the processor's\nI/O address space. See Chapter 16, \u201cInput/Output,\u201d in the Intel\u00ae 64 and IA-32\nArchitectures Software Developer's Manual, Volume 1, for more information on\naccessing I/O ports in the I/O address space.\n\nIn 64-bit mode, the default operand size is 32 bits; operand size is not promoted\nby the use of REX.W. In 64-bit mode, the default address size is 64 bits, and\n64-bit address is specified using RSI by default. 32-bit address using ESI is\nsupport using the prefix 67H, but 16-bit address is not supported in 64-bit\nmode.\n\n\nIA-32 Architecture Compatibility:\nAfter executing an OUTS, OUTSB, OUTSW, or OUTSD instruction, the Pentium processor\nensures that the EWBE#pin has been sampled active before it begins to execute\nthe next instruction. (Note that the instruction can be prefetched if EWBE#\nis not active, but it will not be executed until the EWBE# pin is sampled active.)\nOnly the Pentium processor family has the EWBE# pin. For the Pentium 4, Intel\u00ae\nXeon\u00ae, and P6 processor family, upon execution of an OUTS, OUTSB, OUTSW, or\nOUTSD instruction, the processor will not execute the next instruction until\nthe data phase of the transaction is complete.\n\nOperation:\n\nIF ((PE = 1) and ((CPL > IOPL) or (VM = 1)))\n  THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)\n     IF (Any I/O Permission Bit for I/O port being accessed = 1)\n       THEN (* I/O operation is not allowed *)\n          #GP(0);\n       ELSE (* I/O operation is allowed *)\n          DEST <- SRC; (* Writes to I/O port *)\n     FI;\n  ELSE (Real Mode or Protected Mode or 64-Bit Mode with CPL \u2264 IOPL *)\n     DEST <- SRC; (* Writes to I/O port *)\nFI;\nByte transfer:\n  IF 64-bit mode\n     Then\n       IF 64-Bit Address Size\n          THEN\n             IF DF = 0\n               THEN RSI <- RSI RSI + 1;\n               ELSE RSI <- RSI or - 1;\n             FI;\n          ELSE (* 32-Bit Address Size *)\n             IF DF = 0\n               THEN\n               ELSE\n             FI;\n       FI;\n     ELSE\n       IF DF = 0\n          THEN\n          ELSE (E)SI <- (E)SI - 1;\n       FI;\n  FI;\nWord transfer:\n  IF 64-bit mode\n     Then\n       IF 64-Bit Address Size\n          THEN\n             IF DF = 0\n               THEN RSI <- RSI RSI + 2;\n               ELSE RSI <- RSI or - 2;\n             FI;\n          ELSE (* 32-Bit Address Size *)\n             IF DF = 0\n               THEN\n               ELSE\n             FI;\n       FI;\n     ELSE\n       IF DF = 0\n          THEN\n          ELSE (E)SI <- (E)SI - 2;\n       FI;\n  FI;\nDoubleword transfer:\n  IF 64-bit mode\n     Then\n       IF 64-Bit Address Size\n          THEN\n             IF DF = 0\n               THEN RSI <- RSI RSI + 4;\n               ELSE RSI <- RSI or - 4;\n             FI;\n          ELSE (* 32-Bit Address Size *)\n             IF DF = 0\n               THEN\n               ELSE\n             FI;\n       FI;\n     ELSE\n       IF DF = 0\n          THEN\n          ELSE (E)SI <- (E)SI - 4;\n       FI;\n  FI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the CPL is greater than (has less       \n|                | privilege) the I/O privilege level (IOPL)  \n|                | and any of the corresponding I/O permission\n|                | bits in TSS for the I/O port being accessed\n|                | is 1. If a memory operand effective        \n|                | address is outside the limit of the        \n|                | CS, DS, ES, FS, or GS segment. If the      \n|                | segment register contains a NULL segment   \n|                | selector.                                  \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If any of the I/O permission bits in   \n|                | the TSS for the I/O port being accessed\n|                | is 1.                                  \n| #PF(fault-code)| If a page fault occurs.                \n| #AC(0)         | If alignment checking is enabled and   \n|                | an unaligned memory reference is made. \n| #UD            | If the LOCK prefix is used.            \n\nCompatibility Mode Exceptions:\nSame as for protected mode exceptions.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the CPL is greater than (has less       \n|                | privilege) the I/O privilege level (IOPL)  \n|                | and any of the corresponding I/O permission\n|                | bits in TSS for the I/O port being accessed\n|                | is 1. If the memory address is in a        \n|                | non-canonical form.                        \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "OUTS"
    }, 
    {
      "description": "-R:OUTS", 
      "mnem": "OUTSB"
    }, 
    {
      "description": "-R:OUTS", 
      "mnem": "OUTSD"
    }, 
    {
      "description": "-R:OUTS", 
      "mnem": "OUTSW"
    }, 
    {
      "description": "\nPABSB/PABSW/PABSD  -  Packed Absolute Value:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| 0F 38 1C /r1 PABSB mm1, mm2/m64       | RM   | V/V                   | SSSE3             | Compute the absolute value of bytes     \n|                                       |      |                       |                   | in mm2/m64 and store UNSIGNED result    \n|                                       |      |                       |                   | in mm1.                                 \n| 66 0F 38 1C /r PABSB xmm1, xmm2/m128  | RM   | V/V                   | SSSE3             | Compute the absolute value of bytes     \n|                                       |      |                       |                   | in xmm2/m128 and store UNSIGNED result  \n|                                       |      |                       |                   | in xmm1.                                \n| 0F 38 1D /r1 PABSW mm1, mm2/m64       | RM   | V/V                   | SSSE3             | Compute the absolute value of 16-bit    \n|                                       |      |                       |                   | integers in mm2/m64 and store UNSIGNED  \n|                                       |      |                       |                   | result in mm1.                          \n| 66 0F 38 1D /r PABSW xmm1, xmm2/m128  | RM   | V/V                   | SSSE3             | Compute the absolute value of 16-bit    \n|                                       |      |                       |                   | integers in xmm2/m128 and store UNSIGNED\n|                                       |      |                       |                   | result in xmm1.                         \n| 0F 38 1E /r1 PABSD mm1, mm2/m64       | RM   | V/V                   | SSSE3             | Compute the absolute value of 32-bit    \n|                                       |      |                       |                   | integers in mm2/m64 and store UNSIGNED  \n|                                       |      |                       |                   | result in mm1.                          \n| 66 0F 38 1E /r PABSD xmm1, xmm2/m128  | RM   | V/V                   | SSSE3             | Compute the absolute value of 32-bit    \n|                                       |      |                       |                   | integers in xmm2/m128 and store UNSIGNED\n|                                       |      |                       |                   | result in xmm1.                         \n| VEX.128.66.0F38.WIG 1C /r VPABSB xmm1,| RM   | V/V                   | AVX               | Compute the absolute value of bytes     \n| xmm2/m128                             |      |                       |                   | in xmm2/m128 and store UNSIGNED result  \n|                                       |      |                       |                   | in xmm1.                                \n| VEX.128.66.0F38.WIG 1D /r VPABSW xmm1,| RM   | V/V                   | AVX               | Compute the absolute value of 16- bit   \n| xmm2/m128                             |      |                       |                   | integers in xmm2/m128 and store UNSIGNED\n|                                       |      |                       |                   | result in xmm1.                         \n| VEX.128.66.0F38.WIG 1E /r VPABSD xmm1,| RM   | V/V                   | AVX               | Compute the absolute value of 32- bit   \n| xmm2/m128                             |      |                       |                   | integers in xmm2/m128 and store UNSIGNED\n|                                       |      |                       |                   | result in xmm1.                         \n| VEX.256.66.0F38.WIG 1C /r VPABSB ymm1,| RM   | V/V                   | AVX2              | Compute the absolute value of bytes     \n| ymm2/m256                             |      |                       |                   | in ymm2/m256 and store UNSIGNED result  \n|                                       |      |                       |                   | in ymm1.                                \n| VEX.256.66.0F38.WIG 1D /r VPABSW ymm1,| RM   | V/V                   | AVX2              | Compute the absolute value of 16-bit    \n| ymm2/m256                             |      |                       |                   | integers in ymm2/m256 and store UNSIGNED\n|                                       |      |                       |                   | result in ymm1.                         \n| VEX.256.66.0F38.WIG 1E /r VPABSD ymm1,| RM   | V/V                   | AVX2              | Compute the absolute value of 32-bit    \n| ymm2/m256                             |      |                       |                   | integers in ymm2/m256 and store UNSIGNED\n|                                       |      |                       |                   | result in ymm1.                         \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\n(V)PABSB/W/D computes the absolute value of each data element of the source\noperand (the second operand) and stores the UNSIGNED results in the destination\noperand (the first operand). (V)PABSB operates on signed bytes, (V)PABSW operates\non 16-bit words, and (V)PABSD operates on signed 32-bit integers. The source\noperand can be an MMX register or a 64-bit memory location, or it can be an\nXMM register, a YMM register, a 128-bit memory location, or a 256-bit memory\nlocation. The destination operand can be an MMX, an XMM or a YMM register. Both\noperands can be MMX registers or XMM registers. When the source operand is a\n128-bit memory operand, the operand must be aligned on a 16byte boundary or\na general-protection exception (#GP) will be generated.\n\nIn 64-bit mode, use the REX prefix to access additional registers. 128-bit Legacy\nSSE version: The source operand can be an XMM register or a 128-bit memory location.\nThe destination is not distinct from the first source XMM register and the upper\nbits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: The source operand is an XMM register or 128-bit memory\nlocation. The destination operand is an XMM register. The upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are zeroed. VEX.256 encoded version:\nThe first source operand is a YMM register or a 256-bit memory location. The\ndestination operand is a YMM register.\n\nNote: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0; otherwise instructions\nwill #UD.\n\nOperation:\n\nPABSB (with 64 bit operands)\n  Unsigned DEST[7:0] <- ABS(SRC[7:0])\n  Repeat operation for 2nd through 7th bytes\n  Unsigned DEST[63:56] <- ABS(SRC[63:56])\nPABSB (with 128 bit operands)\n  Unsigned DEST[7:0] <- ABS(SRC[7:.0])\n  Repeat operation for 2nd through 15th bytes\n  Unsigned DEST[127:120] <- ABS(SRC[127:120])\nPABSW (with 64 bit operands)\n  Unsigned DEST[15:0] <- ABS(SRC[15:0])\n  Repeat operation for 2nd through 3rd 16-bit words\n  Unsigned DEST[63:48] <- ABS(SRC[63:48])\nPABSW (with 128 bit operands)\n  Unsigned DEST[15:0] <- ABS(SRC[15:0])\n  Repeat operation for 2nd through 7th 16-bit words\n  Unsigned DEST[127:112] <- ABS(SRC[127:112])\nPABSD (with 64 bit operands)\n  Unsigned DEST[31:0] <- ABS(SRC[31:0])\n  Unsigned DEST[63:32] <- ABS(SRC[63:32])\nPABSD (with 128 bit operands)\n  Unsigned DEST[31:0] <- ABS(SRC[31:0])\n  Repeat operation for 2nd through 3rd 32-bit double words\n  Unsigned DEST[127:96] <- ABS(SRC[127:96])\nPABSB (128-bit Legacy SSE version)\n  DEST[127:0] <- BYTE_ABS(SRC)\n  DEST[VLMAX-1:128] (Unmodified)\nVPABSB (VEX.128 encoded version)\n  DEST[127:0] <- BYTE_ABS(SRC)\n  DEST[VLMAX-1:128] <- 0\nVPABSB (VEX.256 encoded version)\n  Unsigned DEST[7:0]<- ABS(SRC[7:.0])\n  Repeat operation for 2nd through 31st bytes\n  Unsigned DEST[255:248] <- ABS(SRC[255:248])\nPABSW (128-bit Legacy SSE version)\n  DEST[127:0] <- WORD_ABS(SRC)\n  DEST[VLMAX-1:128] (Unmodified)\nVPABSW (VEX.128 encoded version)\n  DEST[127:0] <- WORD_ABS(SRC)\n  DEST[VLMAX-1:128] <- 0\nVPABSW (VEX.256 encoded version)\n  Unsigned DEST[15:0]<- ABS(SRC[15:0])\n  Repeat operation for 2nd through 15th 16-bit words\n  Unsigned DEST[255:240] <- ABS(SRC[255:240])\nPABSD (128-bit Legacy SSE version)\n  DEST[127:0] <- DWORD_ABS(SRC)\n  DEST[VLMAX-1:128] (Unmodified)\nVPABSD (VEX.128 encoded version)\n  DEST[127:0] <- DWORD_ABS(SRC)\n  DEST[VLMAX-1:128] <- 0\nVPABSD (VEX.256 encoded version)\n  Unsigned DEST[31:0] <- ABS(SRC[31:0])\n  Repeat operation for 2nd through 7th 32-bit double words\n  Unsigned DEST[255:224] <- ABS(SRC[255:224])\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PABSB:   | __m64 _mm_abs_pi8 (__m64 a)         \n| (V)PABSB:| __m128i _mm_abs_epi8 (__m128i a)    \n| VPABSB:  | __m256i _mm256_abs_epi8 (__m256i a) \n| PABSW:   | __m64 _mm_abs_pi16 (__m64 a)        \n| (V)PABSW:| __m128i _mm_abs_epi16 (__m128i a)   \n| VPABSW:  | __m256i _mm256_abs_epi16 (__m256i a)\n| PABSD:   | __m64 _mm_abs_pi32 (__m64 a)        \n| (V)PABSD:| __m128i _mm_abs_epi32 (__m128i a)   \n| VPABSD:  | __m256i _mm256_abs_epi32 (__m256i a)\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PABSB"
    }, 
    {
      "description": "-R:PABSB", 
      "mnem": "PABSD"
    }, 
    {
      "description": "-R:PABSB", 
      "mnem": "PABSW"
    }, 
    {
      "description": "-R:PACKSSWB", 
      "mnem": "PACKSSDW"
    }, 
    {
      "description": "\nPACKSSWB/PACKSSDW - Pack with Signed Saturation:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| 0F 63 /r1 PACKSSWB mm1, mm2/m64      | RM   | V/V                   | MMX               | Converts 4 packed signed word integers  \n|                                      |      |                       |                   | from mm1 and from mm2/m64 into 8 packed \n|                                      |      |                       |                   | signed byte integers in mm1 using signed\n|                                      |      |                       |                   | saturation.                             \n| 66 0F 63 /r PACKSSWB xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Converts 8 packed signed word integers  \n|                                      |      |                       |                   | from xmm1 and from xxm2/m128 into 16    \n|                                      |      |                       |                   | packed signed byte integers in xxm1     \n|                                      |      |                       |                   | using signed saturation.                \n| 0F 6B /r1 PACKSSDW mm1, mm2/m64      | RM   | V/V                   | MMX               | Converts 2 packed signed doubleword     \n|                                      |      |                       |                   | integers from mm1 and from mm2/m64 into \n|                                      |      |                       |                   | 4 packed signed word integers in mm1    \n|                                      |      |                       |                   | using signed saturation.                \n| 66 0F 6B /r PACKSSDW xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Converts 4 packed signed doubleword     \n|                                      |      |                       |                   | integers from xmm1 and from xxm2/m128   \n|                                      |      |                       |                   | into 8 packed signed word integers in   \n|                                      |      |                       |                   | xxm1 using signed saturation.           \n| VEX.NDS.128.66.0F.WIG 63 /r VPACKSSWB| RVM  | V/V                   | AVX               | Converts 8 packed signed word integers  \n| xmm1,xmm2, xmm3/m128                 |      |                       |                   | from xmm2 and from xmm3/m128 into 16    \n|                                      |      |                       |                   | packed signed byte integers in xmm1     \n|                                      |      |                       |                   | using signed saturation.                \n| VEX.NDS.128.66.0F.WIG 6B /r VPACKSSDW| RVM  | V/V                   | AVX               | Converts 4 packed signed doubleword     \n| xmm1,xmm2, xmm3/m128                 |      |                       |                   | integers from xmm2 and from xmm3/m128   \n|                                      |      |                       |                   | into 8 packed signed word integers in   \n|                                      |      |                       |                   | xmm1 using signed saturation.           \n| VEX.NDS.256.66.0F.WIG 63 /r VPACKSSWB| RVM  | V/V                   | AVX2              | Converts 16 packed signed word integers \n| ymm1, ymm2, ymm3/m256                |      |                       |                   | from ymm2 and from ymm3/m256 into 32    \n|                                      |      |                       |                   | packed signed byte integers in ymm1     \n|                                      |      |                       |                   | using signed saturation.                \n| VEX.NDS.256.66.0F.WIG 6B /r VPACKSSDW| RVM  | V/V                   | AVX2              | Converts 8 packed signed doubleword     \n| ymm1, ymm2, ymm3/m256                |      |                       |                   | integers from ymm2 and from ymm3/m256   \n|                                      |      |                       |                   | into 16 packed signed word integers     \n|                                      |      |                       |                   | in ymm1using signed saturation.         \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nConverts packed signed word integers into packed signed byte integers (PACKSSWB)\nor converts packed signed doubleword integers into packed signed word integers\n(PACKSSDW), using saturation to handle overflow conditions. See Figure 4-2 for\nan example of the packing operation.\n\n| 64-Bit SRC                           | 64-Bit DEST\n| C                                    | A          \n| D'64-Bit DEST                        | A'         \n| Operation of the PACKSSDW Instruction| Figure 4-2.\n| Using 64-bit Operands                |            \nThe (V)PACKSSWB instruction converts 4, 8 or 16 signed word integers from the\ndestination operand (first operand) and 4, 8 or 16 signed word integers from\nthe source operand (second operand) into 8, 16 or 32 signed byte integers and\nstores the result in the destination operand. If a signed word integer value\nis beyond the range of a signed byte integer (that is, greater than 7FH for\na positive integer or greater than 80H for a negative integer), the saturated\nsigned byte integer value of 7FH or 80H, respectively, is stored in the destination.\n\nThe (V)PACKSSDW instruction packs 2, 4 or 8 signed doublewords from the destination\noperand (first operand) and 2, 4 or 8 signed doublewords from the source operand\n(second operand) into 4, 8 or 16 signed words in the destination operand (see\nFigure 4-2). If a signed doubleword integer value is beyond the range of a signed\nword (that is, greater than 7FFFH for a positive integer or greater than 8000H\nfor a negative integer), the saturated signed word integer value of 7FFFH or\n8000H, respectively, is stored into the destination.\n\nThe (V)PACKSSWB and (V)PACKSSDW instructions operate on either 64-bit, 128-bit\noperands or 256-bit operands. When operating on 64-bit operands, the destination\noperand must be an MMX technology register and the source operand can be either\nan MMX technology register or a 64-bit memory location. In 64-bit mode, using\na REX prefix in the form of REX.R permits this instruction to access additional\nregisters (XMM8-XMM15). 128-bit Legacy SSE version: The first source operand\nis an XMM register. The second operand can be an XMM register or a 128-bit memory\nlocation. The destination is not distinct from the first source XMM register\nand the upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. VEX.128 encoded version: The first source operand is an XMM\nregister. The second source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second\nsource operand is a YMM register or a 256-bit memory location. The destination\noperand is a YMM register.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPACKSSWB (with 64-bit operands)\n  DEST[7:0] <- SaturateSignedWordToSignedByte DEST[15:0];\n  DEST[15:8] <- SaturateSignedWordToSignedByte DEST[31:16];\n  DEST[23:16] <- SaturateSignedWordToSignedByte DEST[47:32];\n  DEST[31:24] <- SaturateSignedWordToSignedByte DEST[63:48];\n  DEST[39:32] <- SaturateSignedWordToSignedByte SRC[15:0];\n  DEST[47:40] <- SaturateSignedWordToSignedByte SRC[31:16];\n  DEST[55:48] <- SaturateSignedWordToSignedByte SRC[47:32];\n  DEST[63:56] <- SaturateSignedWordToSignedByte SRC[63:48];\nPACKSSDW (with 64-bit operands)\n  DEST[15:0] <- SaturateSignedDoublewordToSignedWord DEST[31:0];\n  DEST[31:16] <- SaturateSignedDoublewordToSignedWord DEST[63:32];\n  DEST[47:32] <- SaturateSignedDoublewordToSignedWord SRC[31:0];\n  DEST[63:48] <- SaturateSignedDoublewordToSignedWord SRC[63:32];\nPACKSSWB instruction (128-bit Legacy SSE version)\n  DEST[7:0]<- SaturateSignedWordToSignedByte (DEST[15:0]);\n  DEST[15:8] <- SaturateSignedWordToSignedByte (DEST[31:16]);\n  DEST[23:16] <- SaturateSignedWordToSignedByte (DEST[47:32]);\n  DEST[31:24] <- SaturateSignedWordToSignedByte (DEST[63:48]);\n  DEST[39:32] <- SaturateSignedWordToSignedByte (DEST[79:64]);\n  DEST[47:40] <-SaturateSignedWordToSignedByte (DEST[95:80]);\n  DEST[55:48] <- SaturateSignedWordToSignedByte (DEST[111:96]);\n  DEST[63:56] <- SaturateSignedWordToSignedByte (DEST[127:112]);\n  DEST[71:64] <- SaturateSignedWordToSignedByte (SRC[15:0]);\n  DEST[79:72] <- SaturateSignedWordToSignedByte (SRC[31:16]);\n  DEST[87:80] <- SaturateSignedWordToSignedByte (SRC[47:32]);\n  DEST[95:88] <- SaturateSignedWordToSignedByte (SRC[63:48]);\n  DEST[103:96] <- SaturateSignedWordToSignedByte (SRC[79:64]);\n  DEST[111:104] <- SaturateSignedWordToSignedByte (SRC[95:80]);\n  DEST[119:112] <- SaturateSignedWordToSignedByte (SRC[111:96]);\n  DEST[127:120] <- SaturateSignedWordToSignedByte (SRC[127:112]);\nPACKSSDW instruction (128-bit Legacy SSE version)\n  DEST[15:0] <- SaturateSignedDwordToSignedWord (DEST[31:0]);\n  DEST[31:16] <- SaturateSignedDwordToSignedWord (DEST[63:32]);\n  DEST[47:32] <- SaturateSignedDwordToSignedWord (DEST[95:64]);\n  DEST[63:48] <- SaturateSignedDwordToSignedWord (DEST[127:96]);\n  DEST[79:64] <- SaturateSignedDwordToSignedWord (SRC[31:0]);\n  DEST[95:80] <- SaturateSignedDwordToSignedWord (SRC[63:32]);\n  DEST[111:96] <- SaturateSignedDwordToSignedWord (SRC[95:64]);\n  DEST[127:112] <- SaturateSignedDwordToSignedWord (SRC[127:96]);\nVPACKSSWB instruction (VEX.128 encoded version)\n  DEST[7:0]<- SaturateSignedWordToSignedByte (SRC1[15:0]);\n  DEST[15:8] <- SaturateSignedWordToSignedByte (SRC1[31:16]);\n  DEST[23:16] <- SaturateSignedWordToSignedByte (SRC1[47:32]);\n  DEST[31:24] <- SaturateSignedWordToSignedByte (SRC1[63:48]);\n  DEST[39:32] <- SaturateSignedWordToSignedByte (SRC1[79:64]);\n  DEST[47:40] <- SaturateSignedWordToSignedByte (SRC1[95:80]);\n  DEST[55:48] <- SaturateSignedWordToSignedByte (SRC1[111:96]);\n  DEST[63:56] <- SaturateSignedWordToSignedByte (SRC1[127:112]);\n  DEST[71:64] <- SaturateSignedWordToSignedByte (SRC2[15:0]);\n  DEST[79:72] <- SaturateSignedWordToSignedByte (SRC2[31:16]);\n  DEST[87:80] <- SaturateSignedWordToSignedByte (SRC2[47:32]);\n  DEST[95:88] <- SaturateSignedWordToSignedByte (SRC2[63:48]);\n  DEST[103:96] <- SaturateSignedWordToSignedByte (SRC2[79:64]);\n  DEST[111:104] <- SaturateSignedWordToSignedByte (SRC2[95:80]);\n  DEST[119:112] <- SaturateSignedWordToSignedByte (SRC2[111:96]);\n  DEST[127:120] <- SaturateSignedWordToSignedByte (SRC2[127:112]);\n  DEST[VLMAX-1:128]<- 0;\nVPACKSSDW instruction (VEX.128 encoded version)\n  DEST[15:0] <- SaturateSignedDwordToSignedWord (SRC1[31:0]);\n  DEST[31:16] <- SaturateSignedDwordToSignedWord (SRC1[63:32]);\n  DEST[47:32] <- SaturateSignedDwordToSignedWord (SRC1[95:64]);\n  DEST[63:48] <- SaturateSignedDwordToSignedWord (SRC1[127:96]);\n  DEST[79:64] <- SaturateSignedDwordToSignedWord (SRC2[31:0]);\n  DEST[95:80] <- SaturateSignedDwordToSignedWord (SRC2[63:32]);\n  DEST[111:96] <- SaturateSignedDwordToSignedWord (SRC2[95:64]);\n  DEST[127:112] <- SaturateSignedDwordToSignedWord (SRC2[127:96]);\n  DEST[VLMAX-1:128]<- 0;\nVPACKSSWB instruction (VEX.256 encoded version)\n  DEST[7:0]<- SaturateSignedWordToSignedByte (SRC1[15:0]);\n  DEST[15:8] <- SaturateSignedWordToSignedByte (SRC1[31:16]);\n  DEST[23:16] <- SaturateSignedWordToSignedByte (SRC1[47:32]);\n  DEST[31:24] <- SaturateSignedWordToSignedByte (SRC1[63:48]);\n  DEST[39:32] <- SaturateSignedWordToSignedByte (SRC1[79:64]);\n  DEST[47:40] <- SaturateSignedWordToSignedByte (SRC1[95:80]);\n  DEST[55:48] <- SaturateSignedWordToSignedByte (SRC1[111:96]);\n  DEST[63:56] <- SaturateSignedWordToSignedByte (SRC1[127:112]);\n  DEST[71:64] <- SaturateSignedWordToSignedByte (SRC2[15:0]);\n  DEST[79:72] <- SaturateSignedWordToSignedByte (SRC2[31:16]);\n  DEST[87:80] <- SaturateSignedWordToSignedByte (SRC2[47:32]);\n  DEST[95:88] <- SaturateSignedWordToSignedByte (SRC2[63:48]);\n  DEST[103:96] <- SaturateSignedWordToSignedByte (SRC2[79:64]);\n  DEST[111:104] <- SaturateSignedWordToSignedByte (SRC2[95:80]);\n  DEST[119:112] <- SaturateSignedWordToSignedByte (SRC2[111:96]);\n  DEST[127:120] <- SaturateSignedWordToSignedByte (SRC2[127:112]);\n  DEST[135:128]<- SaturateSignedWordToSignedByte (SRC1[143:128]);\n  DEST[143:136] <- SaturateSignedWordToSignedByte (SRC1[159:144]);\n  DEST[151:144] <- SaturateSignedWordToSignedByte (SRC1[175:160]);\n  DEST[159:152] <- SaturateSignedWordToSignedByte (SRC1[191:176]);\n  DEST[167:160] <- SaturateSignedWordToSignedByte (SRC1[207:192]);\n  DEST[175:168] <- SaturateSignedWordToSignedByte (SRC1[223:208]);\n  DEST[183:176] <- SaturateSignedWordToSignedByte (SRC1[239:224]);\n  DEST[191:184] <- SaturateSignedWordToSignedByte (SRC1[255:240]);\n  DEST[199:192] <- SaturateSignedWordToSignedByte (SRC2[143:128]);\n  DEST[207:200] <- SaturateSignedWordToSignedByte (SRC2[159:144]);\n  DEST[215:208] <- SaturateSignedWordToSignedByte (SRC2[175:160]);\n  DEST[223:216] <- SaturateSignedWordToSignedByte (SRC2[191:176]);\n  DEST[231:224] <- SaturateSignedWordToSignedByte (SRC2[207:192]);\n  DEST[239:232] <- SaturateSignedWordToSignedByte (SRC2[223:208]);\n  DEST[247:240] <- SaturateSignedWordToSignedByte (SRC2[239:224]);\n  DEST[255:248] <- SaturateSignedWordToSignedByte (SRC2[255:240]);\nVPACKSSDW instruction (VEX.256 encoded version)\n  DEST[15:0] <- SaturateSignedDwordToSignedWord (SRC1[31:0]);\n  DEST[31:16] <- SaturateSignedDwordToSignedWord (SRC1[63:32]);\n  DEST[47:32] <- SaturateSignedDwordToSignedWord (SRC1[95:64]);\n  DEST[63:48] <- SaturateSignedDwordToSignedWord (SRC1[127:96]);\n  DEST[79:64] <- SaturateSignedDwordToSignedWord (SRC2[31:0]);\n  DEST[95:80] <- SaturateSignedDwordToSignedWord (SRC2[63:32]);\n  DEST[111:96] <- SaturateSignedDwordToSignedWord (SRC2[95:64]);\n  DEST[127:112] <- SaturateSignedDwordToSignedWord (SRC2[127:96]);\n  DEST[143:128] <- SaturateSignedDwordToSignedWord (SRC1[159:128]);\n  DEST[159:144] <- SaturateSignedDwordToSignedWord (SRC1[191:160]);\n  DEST[175:160] <- SaturateSignedDwordToSignedWord (SRC1[223:192]);\n  DEST[191:176] <- SaturateSignedDwordToSignedWord (SRC1[255:224]);\n  DEST[207:192] <- SaturateSignedDwordToSignedWord (SRC2[159:128]);\n  DEST[223:208] <- SaturateSignedDwordToSignedWord (SRC2[191:160]);\n  DEST[239:224] <- SaturateSignedDwordToSignedWord (SRC2[223:192]);\n  DEST[255:240] <- SaturateSignedDwordToSignedWord (SRC2[255:224]);\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PACKSSWB:   | __m64 _mm_packs_pi16(__m64 m1, __m64  \n|             | m2)                                   \n| (V)PACKSSWB:| __m128i _mm_packs_epi16(__m128i m1,   \n|             | __m128i m2)                           \n| VPACKSSWB:  | __m256i _mm256_packs_epi16(__m256i m1,\n|             | __m256i m2)                           \n| PACKSSDW:   | __m64 _mm_packs_pi32 (__m64 m1, __m64 \n|             | m2)                                   \n| (V)PACKSSDW:| __m128i _mm_packs_epi32(__m128i m1,   \n|             | __m128i m2)                           \n| VPACKSSDW:  | __m256i _mm256_packs_epi32(__m256i m1,\n|             | __m256i m2)                           \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PACKSSWB"
    }, 
    {
      "description": "\nPACKUSDW  -  Pack with Unsigned Saturation:\n| Opcode/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| 66 0F 38 2B /r PACKUSDW xmm1, xmm2/m128| RM   | V/V                   | SSE4_1            | Convert 4 packed signed doubleword integers\n|                                        |      |                       |                   | from xmm1 and 4 packed signed doubleword   \n|                                        |      |                       |                   | integers from xmm2/m128 into 8 packed      \n|                                        |      |                       |                   | unsigned word integers in xmm1 using       \n|                                        |      |                       |                   | unsigned saturation.                       \n| VEX.NDS.128.66.0F38.WIG 2B /r VPACKUSDW| RVM  | V/V                   | AVX               | Convert 4 packed signed doubleword integers\n| xmm1, xmm2, xmm3/m128                  |      |                       |                   | from xmm2 and 4 packed signed doubleword   \n|                                        |      |                       |                   | integers from xmm3/m128 into 8 packed      \n|                                        |      |                       |                   | unsigned word integers in xmm1 using       \n|                                        |      |                       |                   | unsigned saturation.                       \n| VEX.NDS.256.66.0F38.WIG 2B /r VPACKUSDW| RVM  | V/V                   | AVX2              | Convert 8 packed signed doubleword integers\n| ymm1, ymm2, ymm3/m256                  |      |                       |                   | from ymm2 and 8 packed signed doubleword   \n|                                        |      |                       |                   | integers from ymm3/m128 into 16 packed     \n|                                        |      |                       |                   | unsigned word integers in ymm1 using       \n|                                        |      |                       |                   | unsigned saturation.                       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nConverts packed signed doubleword integers into packed unsigned word integers\nusing unsigned saturation to\n\n| handle overflow conditions. greater          | If the signed doubleword value is beyond\n| than FFFFH or less than 0000H), the          | the range of an unsigned word (that     \n| saturated unsigned word integer value        | is,                                     \n| of FFFFH or 0000H, respectively, is          |                                         \n| stored in the destination. 128-bit Legacy    |                                         \n| SSE version: The first source operand        |                                         \n| is an XMM register. The second operand       |                                         \n| can be an XMM register or a 128-bit          |                                         \n| memory location. The destination is          |                                         \n| not distinct from the first source XMM       |                                         \n| register and the upper bits (VLMAX-1:128)    |                                         \n| of the corresponding YMM register destination|                                         \n| are unmodified. VEX.128 encoded version:     |                                         \n| The first source operand is an XMM register. |                                         \n| The second source operand is an XMM          |                                         \n| register or 128-bit memory location.         |                                         \n| The destination operand is an XMM register.  |                                         \n| The upper bits (VLMAX-1:128) of the          |                                         \n| corresponding YMM register destination       |                                         \n| are zeroed. VEX.256 encoded version:         |                                         \n| The first source operand is a YMM register.  |                                         \n| The second source operand is a YMM register  |                                         \n| or a 256-bit memory location. The destination|                                         \n| operand is a YMM register. Note: VEX.L       |                                         \n| must be 0, otherwise the instruction         |                                         \n| will #UD.                                    |                                         \nOperation:\n\nPACKUSDW (Legacy SSE instruction)\nTMP[15:0] <- (DEST[31:0] < 0) ? 0 : DEST[15:0];\nDEST[15:0] <- (DEST[31:0] > FFFFH) ? FFFFH : TMP[15:0] ;\nTMP[31:16] <- (DEST[63:32] < 0) ? 0 : DEST[47:32];\nDEST[31:16] <- (DEST[63:32] > FFFFH) ? FFFFH : TMP[31:16] ;\nTMP[47:32] <- (DEST[95:64] < 0) ? 0 : DEST[79:64];\nDEST[47:32] <- (DEST[95:64] > FFFFH) ? FFFFH : TMP[47:32] ;\nTMP[63:48] <- (DEST[127:96] < 0) ? 0 : DEST[111:96];\nDEST[63:48] <- (DEST[127:96] > FFFFH) ? FFFFH : TMP[63:48] ;\nTMP[79:64] <- (SRC[31:0] < 0) ? 0 : SRC[15:0];\nDEST[63:48] <- (SRC[31:0] > FFFFH) ? FFFFH : TMP[79:64] ;\nTMP[95:80] <- (SRC[63:32] < 0) ? 0 : SRC[47:32];\nDEST[95:80] <- (SRC[63:32] > FFFFH) ? FFFFH : TMP[95:80] ;\nTMP[111:96] <- (SRC[95:64] < 0) ? 0 : SRC[79:64];\nDEST[111:96] <- (SRC[95:64] > FFFFH) ? FFFFH : TMP[111:96] ;\nTMP[127:112] <- (SRC[127:96] < 0) ? 0 : SRC[111:96];\nDEST[127:112] <- (SRC[127:96] > FFFFH) ? FFFFH : TMP[127:112] ;\nPACKUSDW (VEX.128 encoded version)\nTMP[15:0] <- (SRC1[31:0] < 0) ? 0 : SRC1[15:0];\nDEST[15:0] <- (SRC1[31:0] > FFFFH) ? FFFFH : TMP[15:0] ;\nTMP[31:16] <- (SRC1[63:32] < 0) ? 0 : SRC1[47:32];\nDEST[31:16] <- (SRC1[63:32] > FFFFH) ? FFFFH : TMP[31:16] ;\nTMP[47:32] <- (SRC1[95:64] < 0) ? 0 : SRC1[79:64];\nDEST[47:32] <- (SRC1[95:64] > FFFFH) ? FFFFH : TMP[47:32] ;\nTMP[63:48] <- (SRC1[127:96] < 0) ? 0 : SRC1[111:96];\nDEST[63:48] <- (SRC1[127:96] > FFFFH) ? FFFFH : TMP[63:48] ;\nTMP[79:64] <- (SRC2[31:0] < 0) ? 0 : SRC2[15:0];\nDEST[63:48] <- (SRC2[31:0] > FFFFH) ? FFFFH : TMP[79:64] ;\nTMP[95:80] <- (SRC2[63:32] < 0) ? 0 : SRC2[47:32];\nDEST[95:80] <- (SRC2[63:32] > FFFFH) ? FFFFH : TMP[95:80] ;\nTMP[111:96] <- (SRC2[95:64] < 0) ? 0 : SRC2[79:64];\nDEST[111:96] <- (SRC2[95:64] > FFFFH) ? FFFFH : TMP[111:96] ;\nTMP[127:112] <- (SRC2[127:96] < 0) ? 0 : SRC2[111:96];\nDEST[127:112] <- (SRC2[127:96] > FFFFH) ? FFFFH : TMP[127:112];\nDEST[VLMAX-1:128] <- 0;\nVPACKUSDW (VEX.256 encoded version)\nTMP[15:0] <- (SRC1[31:0] < 0) ? 0 : SRC1[15:0];\nDEST[15:0] <- (SRC1[31:0] > FFFFH) ? FFFFH : TMP[15:0] ;\nTMP[31:16] <- (SRC1[63:32] < 0) ? 0 : SRC1[47:32];\nDEST[31:16] <- (SRC1[63:32] > FFFFH) ? FFFFH : TMP[31:16] ;\nTMP[47:32] <- (SRC1[95:64] < 0) ? 0 : SRC1[79:64];\nDEST[47:32] <- (SRC1[95:64] > FFFFH) ? FFFFH : TMP[47:32] ;\nTMP[63:48] <- (SRC1[127:96] < 0) ? 0 : SRC1[111:96];\nDEST[63:48] <- (SRC1[127:96] > FFFFH) ? FFFFH : TMP[63:48] ;\nTMP[79:64] <- (SRC2[31:0] < 0) ? 0 : SRC2[15:0];\nDEST[63:48] <- (SRC2[31:0] > FFFFH) ? FFFFH : TMP[79:64] ;\nTMP[95:80] <- (SRC2[63:32] < 0) ? 0 : SRC2[47:32];\nDEST[95:80] <- (SRC2[63:32] > FFFFH) ? FFFFH : TMP[95:80] ;\nTMP[111:96] <- (SRC2[95:64] < 0) ? 0 : SRC2[79:64];\nDEST[111:96] <- (SRC2[95:64] > FFFFH) ? FFFFH : TMP[111:96] ;\nTMP[127:112] <- (SRC2[127:96] < 0) ? 0 : SRC2[111:96];\nDEST[128:112] <- (SRC2[127:96] > FFFFH) ? FFFFH : TMP[127:112] ;\nTMP[143:128] <- (SRC1[159:128] < 0) ? 0 : SRC1[143:128];\nDEST[143:128] <- (SRC1[159:128] > FFFFH) ? FFFFH : TMP[143:128] ;\nTMP[159:144] <- (SRC1[191:160] < 0) ? 0 : SRC1[175:160];\nDEST[159:144] <- (SRC1[191:160] > FFFFH) ? FFFFH : TMP[159:144] ;\nTMP[175:160] <- (SRC1[223:192] < 0) ? 0 : SRC1[207:192];\nDEST[175:160] <- (SRC1[223:192] > FFFFH) ? FFFFH : TMP[175:160] ;\nTMP[191:176] <- (SRC1[255:224] < 0) ? 0 : SRC1[239:224];\nDEST[191:176] <- (SRC1[255:224] > FFFFH) ? FFFFH : TMP[191:176] ;\nTMP[207:192] <- (SRC2[159:128] < 0) ? 0 : SRC2[143:128];\nDEST[207:192] <- (SRC2[159:128] > FFFFH) ? FFFFH : TMP[207:192] ;\nTMP[223:208] <- (SRC2[191:160] < 0) ? 0 : SRC2[175:160];\nDEST[223:208] <- (SRC2[191:160] > FFFFH) ? FFFFH : TMP[223:208] ;\nTMP[239:224] <- (SRC2[223:192] < 0) ? 0 : SRC2[207:192];\nDEST[239:224] <- (SRC2[223:192] > FFFFH) ? FFFFH : TMP[239:224] ;\nTMP[255:240] <- (SRC2[255:224] < 0) ? 0 : SRC2[239:224];\nDEST[255:240] <- (SRC2[255:224] > FFFFH) ? FFFFH : TMP[255:240] ;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n(V)PACKUSDW: __m128i _mm_packus_epi32(__m128i m1, __m128i m2);\n\n| VPACKUSDW:| __m256i _mm256_packus_epi32(__m256i\n|           | m1, __m256i m2);                   \n\nFlags Affected:\nNone.\n\n\nSIMD Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PACKUSDW"
    }, 
    {
      "description": "\nPACKUSWB - Pack with Unsigned Saturation:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| 0F 67 /r1 PACKUSWB mm, mm/m64        | RM   | V/V                   | MMX               | Converts 4 signed word integers from     \n|                                      |      |                       |                   | mm and 4 signed word integers from mm/m64\n|                                      |      |                       |                   | into 8 unsigned byte integers in mm      \n|                                      |      |                       |                   | using unsigned saturation.               \n| 66 0F 67 /r PACKUSWB xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Converts 8 signed word integers from     \n|                                      |      |                       |                   | xmm1 and 8 signed word integers from     \n|                                      |      |                       |                   | xmm2/m128 into 16 unsigned byte integers \n|                                      |      |                       |                   | in xmm1 using unsigned saturation.       \n| VEX.NDS.128.66.0F.WIG 67 /r VPACKUSWB| RVM  | V/V                   | AVX               | Converts 8 signed word integers from     \n| xmm1, xmm2, xmm3/m128                |      |                       |                   | xmm2 and 8 signed word integers from     \n|                                      |      |                       |                   | xmm3/m128 into 16 unsigned byte integers \n|                                      |      |                       |                   | in xmm1 using unsigned saturation.       \n| VEX.NDS.256.66.0F.WIG 67 /r VPACKUSWB| RVM  | V/V                   | AVX2              | Converts 16 signed word integers from    \n| ymm1, ymm2, ymm3/m256                |      |                       |                   | ymm2 and 16signed word integers from     \n|                                      |      |                       |                   | ymm3/m256 into 32 unsigned byte integers \n|                                      |      |                       |                   | in ymm1 using unsigned saturation.       \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nConverts 4, 8 or 16 signed word integers from the destination operand (first\noperand) and 4, 8 or 16 signed word integers from the source operand (second\noperand) into 8, 16 or 32 unsigned byte integers and stores the result in the\ndestination operand. (See Figure 4-2 for an example of the packing operation.)\nIf a signed word integer value is beyond the range of an unsigned byte integer\n(that is, greater than FFH or less than 00H), the saturated unsigned byte integer\nvalue of FFH or 00H, respectively, is stored in the destination.\n\nThe PACKUSWB instruction operates on either 64-bit, 128-bit or 256-bit operands.\nWhen operating on 64-bit operands, the destination operand must be an MMX technology\nregister and the source operand can be either an MMX technology register or\na 64-bit memory location. In 64-bit mode, using a REX prefix in the form of\nREX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The first source operand is an XMM register. The\nsecond operand can be an XMM register or a 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: The first source operand is an XMM register. The second source operand\nis an XMM register or 128-bit memory location. The destination operand is an\nXMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register\ndestination are zeroed. VEX.256 encoded version: The first source operand is\na YMM register. The second source operand is a YMM register or a 256-bit memory\nlocation. The destination operand is a YMM register.\n\nOperation:\n\nPACKUSWB (with 64-bit operands)\n  DEST[7:0] <- SaturateSignedWordToUnsignedByte DEST[15:0];\n  DEST[15:8] <- SaturateSignedWordToUnsignedByte DEST[31:16];\n  DEST[23:16] <- SaturateSignedWordToUnsignedByte DEST[47:32];\n  DEST[31:24] <- SaturateSignedWordToUnsignedByte DEST[63:48];\n  DEST[39:32] <- SaturateSignedWordToUnsignedByte SRC[15:0];\n  DEST[47:40] <- SaturateSignedWordToUnsignedByte SRC[31:16];\n  DEST[55:48] <- SaturateSignedWordToUnsignedByte SRC[47:32];\n  DEST[63:56] <- SaturateSignedWordToUnsignedByte SRC[63:48];\nPACKUSWB (Legacy SSE instruction)\n  DEST[7:0]<-SaturateSignedWordToUnsignedByte (DEST[15:0]);\n  DEST[15:8] <-SaturateSignedWordToUnsignedByte (DEST[31:16]);\n  DEST[23:16] <-SaturateSignedWordToUnsignedByte (DEST[47:32]);\n  DEST[31:24] <- SaturateSignedWordToUnsignedByte (DEST[63:48]);\n  DEST[39:32] <- SaturateSignedWordToUnsignedByte (DEST[79:64]);\n  DEST[47:40] <- SaturateSignedWordToUnsignedByte (DEST[95:80]);\n  DEST[55:48] <- SaturateSignedWordToUnsignedByte (DEST[111:96]);\n  DEST[63:56] <- SaturateSignedWordToUnsignedByte (DEST[127:112]);\n  DEST[71:64] <- SaturateSignedWordToUnsignedByte (SRC[15:0]);\n  DEST[79:72] <- SaturateSignedWordToUnsignedByte (SRC[31:16]);\n  DEST[87:80] <- SaturateSignedWordToUnsignedByte (SRC[47:32]);\n  DEST[95:88] <- SaturateSignedWordToUnsignedByte (SRC[63:48]);\n  DEST[103:96] <- SaturateSignedWordToUnsignedByte (SRC[79:64]);\n  DEST[111:104] <- SaturateSignedWordToUnsignedByte (SRC[95:80]);\n  DEST[119:112] <- SaturateSignedWordToUnsignedByte (SRC[111:96]);\n  DEST[127:120] <- SaturateSignedWordToUnsignedByte (SRC[127:112]);\nPACKUSWB (VEX.128 encoded version)\n  DEST[7:0]<- SaturateSignedWordToUnsignedByte (SRC1[15:0]);\n  DEST[15:8] <-SaturateSignedWordToUnsignedByte (SRC1[31:16]);\n  DEST[23:16] <-SaturateSignedWordToUnsignedByte (SRC1[47:32]);\n  DEST[31:24] <- SaturateSignedWordToUnsignedByte (SRC1[63:48]);\n  DEST[39:32] <- SaturateSignedWordToUnsignedByte (SRC1[79:64]);\n  DEST[47:40] <- SaturateSignedWordToUnsignedByte (SRC1[95:80]);\n  DEST[55:48] <- SaturateSignedWordToUnsignedByte (SRC1[111:96]);\n  DEST[63:56] <- SaturateSignedWordToUnsignedByte (SRC1[127:112]);\n  DEST[71:64] <- SaturateSignedWordToUnsignedByte (SRC2[15:0]);\n  DEST[79:72] <- SaturateSignedWordToUnsignedByte (SRC2[31:16]);\n  DEST[87:80] <- SaturateSignedWordToUnsignedByte (SRC2[47:32]);\n  DEST[95:88] <- SaturateSignedWordToUnsignedByte (SRC2[63:48]);\n  DEST[103:96] <- SaturateSignedWordToUnsignedByte (SRC2[79:64]);\n  DEST[111:104] <- SaturateSignedWordToUnsignedByte (SRC2[95:80]);\n  DEST[119:112] <- SaturateSignedWordToUnsignedByte (SRC2[111:96]);\n  DEST[127:120] <- SaturateSignedWordToUnsignedByte (SRC2[127:112]);\n  DEST[VLMAX-1:128] <- 0;\nVPACKUSWB (VEX.256 encoded version)\n  DEST[7:0]<- SaturateSignedWordToUnsignedByte (SRC1[15:0]);\n  DEST[15:8] <-SaturateSignedWordToUnsignedByte (SRC1[31:16]);\n  DEST[23:16] <-SaturateSignedWordToUnsignedByte (SRC1[47:32]);\n  DEST[31:24] <- SaturateSignedWordToUnsignedByte (SRC1[63:48]);\n  DEST[39:32] <-SaturateSignedWordToUnsignedByte (SRC1[79:64]);\n  DEST[47:40] <- SaturateSignedWordToUnsignedByte (SRC1[95:80]);\n  DEST[55:48] <- SaturateSignedWordToUnsignedByte (SRC1[111:96]);\n  DEST[63:56] <- SaturateSignedWordToUnsignedByte (SRC1[127:112]);\n  DEST[71:64] <-SaturateSignedWordToUnsignedByte (SRC2[15:0]);\n  DEST[79:72] <- SaturateSignedWordToUnsignedByte (SRC2[31:16]);\n  DEST[87:80] <- SaturateSignedWordToUnsignedByte (SRC2[47:32]);\n  DEST[95:88] <- SaturateSignedWordToUnsignedByte (SRC2[63:48]);\n  DEST[103:96] <- SaturateSignedWordToUnsignedByte (SRC2[79:64]);\n  DEST[111:104] <- SaturateSignedWordToUnsignedByte (SRC2[95:80]);\n  DEST[119:112] <- SaturateSignedWordToUnsignedByte (SRC2[111:96]);\n  DEST[127:120] <- SaturateSignedWordToUnsignedByte (SRC2[127:112]);\n  DEST[135:128]<- SaturateSignedWordToUnsignedByte (SRC1[143:128]);\n  DEST[143:136] <-SaturateSignedWordToUnsignedByte (SRC1[159:144]);\n  DEST[151:144] <-SaturateSignedWordToUnsignedByte (SRC1[175:160]);\n  DEST[159:152] <-SaturateSignedWordToUnsignedByte (SRC1[191:176]);\n  DEST[167:160] <- SaturateSignedWordToUnsignedByte (SRC1[207:192]);\n  DEST[175:168] <- SaturateSignedWordToUnsignedByte (SRC1[223:208]);\n  DEST[183:176] <- SaturateSignedWordToUnsignedByte (SRC1[239:224]);\n  DEST[191:184] <- SaturateSignedWordToUnsignedByte (SRC1[255:240]);\n  DEST[199:192] <- SaturateSignedWordToUnsignedByte (SRC2[143:128]);\n  DEST[207:200] <- SaturateSignedWordToUnsignedByte (SRC2[159:144]);\n  DEST[215:208] <- SaturateSignedWordToUnsignedByte (SRC2[175:160]);\n  DEST[223:216] <- SaturateSignedWordToUnsignedByte (SRC2[191:176]);\n  DEST[231:224] <- SaturateSignedWordToUnsignedByte (SRC2[207:192]);\n  DEST[239:232] <- SaturateSignedWordToUnsignedByte (SRC2[223:208]);\n  DEST[247:240] <- SaturateSignedWordToUnsignedByte (SRC2[239:224]);\n  DEST[255:248] <- SaturateSignedWordToUnsignedByte (SRC2[255:240]);\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PACKUSWB:   | __m64 _mm_packs_pu16(__m64 m1, __m64\n|             | m2)                                 \n| (V)PACKUSWB:| __m128i _mm_packus_epi16(__m128i m1,\n|             | __m128i m2)                         \n| VPACKUSWB:  | __m256i _mm256_packus_epi16(__m256i \n|             | m1, __m256i m2);                    \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PACKUSWB"
    }, 
    {
      "description": "\nPADDB/PADDW/PADDD - Add Packed Integers:\n| Opcode/Instruction                      | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 0F FC /r1 PADDB mm, mm/m64              | RM   | V/V                   | MMX               | Add packed byte integers from mm/m64   \n|                                         |      |                       |                   | and mm.                                \n| 66 0F FC /r PADDB xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Add packed byte integers from xmm2/m128\n|                                         |      |                       |                   | and xmm1.                              \n| 0F FD /r1 PADDW mm, mm/m64              | RM   | V/V                   | MMX               | Add packed word integers from mm/m64   \n|                                         |      |                       |                   | and mm.                                \n| 66 0F FD /r PADDW xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Add packed word integers from xmm2/m128\n|                                         |      |                       |                   | and xmm1.                              \n| 0F FE /r1 PADDD mm, mm/m64              | RM   | V/V                   | MMX               | Add packed doubleword integers from    \n|                                         |      |                       |                   | mm/m64 and mm.                         \n| 66 0F FE /r PADDD xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Add packed doubleword integers from    \n|                                         |      |                       |                   | xmm2/m128 and xmm1.                    \n| VEX.NDS.128.66.0F.WIG FC /r VPADDB xmm1,| RVM  | V/V                   | AVX               | Add packed byte integers from xmm3/m128\n| xmm2, xmm3/m128                         |      |                       |                   | and xmm2.                              \n| VEX.NDS.128.66.0F.WIG FD /r VPADDW xmm1,| RVM  | V/V                   | AVX               | Add packed word integers from xmm3/m128\n| xmm2, xmm3/m128                         |      |                       |                   | and xmm2.                              \n| VEX.NDS.128.66.0F.WIG FE /r VPADDD xmm1,| RVM  | V/V                   | AVX               | Add packed doubleword integers from    \n| xmm2, xmm3/m128                         |      |                       |                   | xmm3/m128 and xmm2.                    \n| VEX.NDS.256.66.0F.WIG FC /r VPADDB ymm1,| RVM  | V/V                   | AVX2              | Add packed byte integers from ymm2,    \n| ymm2, ymm3/m256                         |      |                       |                   | and ymm3/m256 and store in ymm1.       \n| VEX.NDS.256.66.0F.WIG FD /r VPADDW ymm1,| RVM  | V/V                   | AVX2              | Add packed word integers from ymm2,    \n| ymm2, ymm3/m256                         |      |                       |                   | ymm3/m256 and store in ymm1.           \n| VEX.NDS.256.66.0F.WIG FE /r VPADDD ymm1,| RVM  | V/V                   | AVX2              | Add packed doubleword integers from    \n| ymm2, ymm3/m256                         |      |                       |                   | ymm2, ymm3/m256 and store in ymm1.     \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD add of the packed integers from the source operand (second operand)\nand the destination operand (first operand), and stores the packed integer results\nin the destination operand. See Figure 9-4 in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1, for an illustration of a SIMD operation.\nOverflow is handled with wraparound, as described in the following paragraphs.\nAdds the packed byte, word, doubleword, or quadword integers in the first source\noperand to the second source operand and stores the result in the destination\noperand. When a result is too large to be represented in the\n\n8/16/32 integer (overflow), the result is wrapped around and the low bits are\nwritten to the destination element (that is, the carry is ignored).\n\nNote that these instructions can operate on either unsigned or signed (two's\ncomplement notation) integers; however, it does not set bits in the EFLAGS register\nto indicate overflow and/or a carry. To prevent undetected overflow conditions,\nsoftware must control the ranges of the values operated on.\n\nThese instructions can operate on either 64-bit, 128-bit or 256-bit operands.\nWhen operating on 64-bit operands, the destination operand must be an MMX technology\nregister and the source operand can be either an MMX technology register or\na 64-bit memory location. In 64-bit mode, using a REX prefix in the form of\nREX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The first source operand is an XMM register. The\nsecond operand can be an XMM register or a 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: The first source operand is an XMM register. The second source operand\nis an XMM register or 128-bit memory location. The destination operand is an\nXMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register\ndestination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second\nsource operand is a YMM register or a 256-bit memory location. The destination\noperand is a YMM register.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPADDB (with 64-bit operands)\n  DEST[7:0] <- DEST[7:0] + SRC[7:0];\n  (* Repeat add operation for 2nd through 7th byte *)\n  DEST[63:56] <- DEST[63:56] + SRC[63:56];\nPADDB (with 128-bit operands)\n  DEST[7:0] <- DEST[7:0] + SRC[7:0];\n  (* Repeat add operation for 2nd through 14th byte *)\n  DEST[127:120] <- DEST[111:120] + SRC[127:120];\nVPADDB (VEX.128 encoded version)\n  DEST[7:0] <- SRC1[7:0]+SRC2[7:0]\n  DEST[15:8] <- SRC1[15:8]+SRC2[15:8]\n  DEST[23:16] <- SRC1[23:16]+SRC2[23:16]\n  DEST[31:24] <- SRC1[31:24]+SRC2[31:24]\n  DEST[39:32] <- SRC1[39:32]+SRC2[39:32]\n  DEST[47:40] <- SRC1[47:40]+SRC2[47:40]\n  DEST[55:48] <- SRC1[55:48]+SRC2[55:48]\n  DEST[63:56] <- SRC1[63:56]+SRC2[63:56]\n  DEST[71:64] <- SRC1[71:64]+SRC2[71:64]\n  DEST[79:72] <- SRC1[79:72]+SRC2[79:72]\n  DEST[87:80] <- SRC1[87:80]+SRC2[87:80]\n  DEST[95:88] <- SRC1[95:88]+SRC2[95:88]\n  DEST[103:96] <- SRC1[103:96]+SRC2[103:96]\n  DEST[111:104] <- SRC1[111:104]+SRC2[111:104]\n  DEST[119:112] <- SRC1[119:112]+SRC2[119:112]\n  DEST[127:120] <- SRC1[127:120]+SRC2[127:120]\n  DEST[VLMAX-1:128] <- 0\nVPADDB (VEX.256 encoded instruction)\n  DEST[7:0]<- SRC1[7:0] + SRC2[7:0];\n  (* Repeat add operation for 2nd through 31th byte *)\n  DEST[255:248]<- SRC1[255:248] + SRC2[255:248];\nPADDW (with 64-bit operands)\n  DEST[15:0] <- DEST[15:0] + SRC[15:0];\n  (* Repeat add operation for 2nd and 3th word *)\n  DEST[63:48] <- DEST[63:48] + SRC[63:48];\nPADDW (with 128-bit operands)\n  DEST[15:0]\n  (* Repeat add operation for 2nd through 7th word *)\n  DEST[127:112] <- DEST[127:112] + SRC[127:112];\nVPADDW (VEX.128 encoded version)\n  DEST[15:0] <- SRC1[15:0]+SRC2[15:0]\n  DEST[31:16] <- SRC1[31:16]+SRC2[31:16]\n  DEST[47:32] <- SRC1[47:32]+SRC2[47:32]\n  DEST[63:48] <- SRC1[63:48]+SRC2[63:48]\n  DEST[79:64] <- SRC1[79:64]+SRC2[79:64]\n  DEST[95:80] <- SRC1[95:80]+SRC2[95:80]\n  DEST[111:96] <- SRC1[111:96]+SRC2[111:96]\n  DEST[127:112] <- SRC1[127:112]+SRC2[127:112]\n  DEST[VLMAX-1:128] <- 0\nVPADDW (VEX.256 encoded instruction)\n  DEST[15:0] <- SRC1[15:0] + SRC2[15:0];\n  (* Repeat add operation for 2nd through 15th word *)\n  DEST[255:240]<- SRC1[255:240] + SRC2[255:240];\nPADDD (with 64-bit operands)\n  DEST[31:0] <- DEST[31:0] + SRC[31:0];\n  DEST[63:32] <- DEST[63:32] + SRC[63:32];\nPADDD (with 128-bit operands)\n  DEST[31:0] <- DEST[31:0]\n  (* Repeat add operation for 2nd and 3th doubleword *)\n  DEST[127:96] <- DEST[127:96] + SRC[127:96];\nVPADDD (VEX.128 encoded version)\n  DEST[31:0] <- SRC1[31:0]+SRC2[31:0]\n  DEST[63:32] <- SRC1[63:32]+SRC2[63:32]\n  DEST[95:64] <- SRC1[95:64]+SRC2[95:64]\n  DEST[127:96] <- SRC1[127:96]+SRC2[127:96]\n  DEST[VLMAX-1:128] <- 0\nVPADDD (VEX.256 encoded instruction)\n  DEST[31:0]<- SRC1[31:0]\n  (* Repeat add operation for 2nd and 7th doubleword *)\n  DEST[255:224] <- SRC1[255:224] + SRC2[255:224];\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PADDB:   | __m64 _mm_add_pi8(__m64 m1, __m64 m2)     \n| (V)PADDB:| __m128i _mm_add_epi8 (__m128ia,__m128ib   \n|          | )                                         \n| VPADDB:  | __m256i _mm256_add_epi8 (__m256ia,__m256i \n|          | b )                                       \n| PADDW:   | __m64 _mm_add_pi16(__m64 m1, __m64 m2)    \n| (V)PADDW:| __m128i _mm_add_epi16 ( __m128i a, __m128i\n|          | b)                                        \n| VPADDW:  | __m256i _mm256_add_epi16 ( __m256i a,     \n|          | __m256i b)                                \n| PADDD:   | __m64 _mm_add_pi32(__m64 m1, __m64 m2)    \n| (V)PADDD:| __m128i _mm_add_epi32 ( __m128i a, __m128i\n|          | b)                                        \n| VPADDD:  | __m256i _mm256_add_epi32 ( __m256i a,     \n|          | __m256i b)                                \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PADDB"
    }, 
    {
      "description": "-R:PADDB", 
      "mnem": "PADDD"
    }, 
    {
      "description": "\nPADDQ - Add Packed Quadword Integers:\n| Opcode/Instruction                      | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 0F D4 /r1 PADDQ mm1, mm2/m64            | RM   | V/V                   | SSE2              | Add quadword integer mm2/m64 to mm1.   \n| 66 0F D4 /r PADDQ xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Add packed quadword integers xmm2/m128 \n|                                         |      |                       |                   | to xmm1.                               \n| VEX.NDS.128.66.0F.WIG D4 /r VPADDQ xmm1,| RVM  | V/V                   | AVX               | Add packed quadword integers xmm3/m128 \n| xmm2, xmm3/m128                         |      |                       |                   | and xmm2.                              \n| VEX.NDS.256.66.0F.WIG D4 /r VPADDQ ymm1,| RVM  | V/V                   | AVX2              | Add packed quadword integers from ymm2,\n| ymm2, ymm3/m256                         |      |                       |                   | ymm3/m256 and store in ymm1.           \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nAdds the first operand (destination operand) to the second operand (source operand)\nand stores the result in the destination operand. The source operand can be\na quadword integer stored in an MMX technology register or a 64bit memory location,\nor it can be two packed quadword integers stored in an XMM register or an 128-bit\nmemory location. The destination operand can be a quadword integer stored in\nan MMX technology register or two packed quadword integers stored in an XMM\nregister. When packed quadword operands are used, a SIMD add is performed. When\na quadword result is too large to be represented in 64 bits (overflow), the\nresult is wrapped around and the low 64 bits are written to the destination\nelement (that is, the carry is ignored).\n\nNote that the (V)PADDQ instruction can operate on either unsigned or signed\n(two's complement notation) integers; however, it does not set bits in the EFLAGS\nregister to indicate overflow and/or a carry. To prevent undetected overflow\nconditions, software must control the ranges of the values operated on.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nfirst source operand is an XMM register. The second operand can be an XMM register\nor a 128-bit memory location. The destination is not distinct from the first\nsource XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM\nregister destination are unmodified. VEX.128 encoded version: The first source\noperand is an XMM register. The second source operand is an XMM register or\n128-bit memory location. The destination operand is an XMM register. The upper\nbits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second\nsource operand is a YMM register or a 256-bit memory location. The destination\noperand is a YMM register.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPADDQ (with 64-Bit operands)\n  DEST[63:0] <- DEST[63:0] + SRC[63:0];\nPADDQ (with 128-Bit operands)\n  DEST[63:0] <- DEST[63:0] + SRC[63:0];\n  DEST[127:64] <- DEST[127:64] + SRC[127:64];\nVPADDQ (VEX.128 encoded instruction)\n  DEST[63:0]<- SRC1[63:0]\n  DEST[127:64] <- SRC1[127:64] + SRC2[127:64];\n  DEST[VLMAX-1:128] <- 0;\nVPADDQ (VEX.256 encoded instruction)\n  DEST[63:0]<- SRC1[63:0]\n  DEST[127:64] <- SRC1[127:64] + SRC2[127:64];\n  DEST[191:128]<- SRC1[191:128]\n  DEST[255:192] <- SRC1[255:192] + SRC2[255:192];\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PADDQ:   | __m64 _mm_add_si64 (__m64 a, __m64 b)     \n| (V)PADDQ:| __m128i _mm_add_epi64 ( __m128i a, __m128i\n|          | b)                                        \n| VPADDQ:  | __m256i _mm256_add_epi64 ( __m256i a,     \n|          | __m256i b)                                \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PADDQ"
    }, 
    {
      "description": "\nPADDSB/PADDSW - Add Packed Signed Integers with Signed Saturation:\n| Opcode/Instruction                 | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| 0F EC /r1 PADDSB mm, mm/m64        | RM   | V/V                   | MMX               | Add packed signed byte integers from       \n|                                    |      |                       |                   | mm/m64 and mm and saturate the results.    \n| 66 0F EC /r PADDSB xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Add packed signed byte integers from       \n|                                    |      |                       |                   | xmm2/m128 and xmm1 saturate the results.   \n| 0F ED /r1 PADDSW mm, mm/m64        | RM   | V/V                   | MMX               | Add packed signed word integers from       \n|                                    |      |                       |                   | mm/m64 and mm and saturate the results.    \n| 66 0F ED /r PADDSW xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Add packed signed word integers from       \n|                                    |      |                       |                   | xmm2/m128 and xmm1 and saturate the        \n|                                    |      |                       |                   | results.                                   \n| VEX.NDS.128.66.0F.WIG EC /r VPADDSB| RVM  | V/V                   | AVX               | Add packed signed byte integers from       \n| xmm1, xmm2, xmm3/m128              |      |                       |                   | xmm3/m128 and xmm2 saturate the results.   \n| VEX.NDS.128.66.0F.WIG ED /r VPADDSW| RVM  | V/V                   | AVX               | Add packed signed word integers from       \n| xmm1, xmm2, xmm3/m128              |      |                       |                   | xmm3/m128 and xmm2 and saturate the        \n|                                    |      |                       |                   | results.                                   \n| VEX.NDS.256.66.0F.WIG EC /r VPADDSB| RVM  | V/V                   | AVX2              | Add packed signed byte integers from       \n| ymm1, ymm2, ymm3/m256              |      |                       |                   | ymm2, and ymm3/m256 and store the saturated\n|                                    |      |                       |                   | results in ymm1.                           \n| VEX.NDS.256.66.0F.WIG ED /r VPADDSW| RVM  | V/V                   | AVX2              | Add packed signed word integers from       \n| ymm1, ymm2, ymm3/m256              |      |                       |                   | ymm2, and ymm3/m256 and store the saturated\n|                                    |      |                       |                   | results in ymm1.                           \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD add of the packed signed integers from the source operand (second\noperand) and the destination operand (first operand), and stores the packed\ninteger results in the destination operand. See Figure 9-4 in the Intel\u00ae 64\nand IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration\nof a SIMD operation. Overflow is handled with signed saturation, as described\nin the following paragraphs.\n\nThe PADDSB instruction adds packed signed byte integers. When an individual\nbyte result is beyond the range of a signed byte integer (that is, greater than\n7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written\nto the destination operand.\n\nThe PADDSW instruction adds packed signed word integers. When an individual\nword result is beyond the range of a signed word integer (that is, greater than\n7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively,\nis written to the destination operand.\n\nThese instructions can operate on either 64-bit, 128-bit or 256-bit operands.\nWhen operating on 64-bit operands, the destination operand must be an MMX technology\nregister and the source operand can be either an MMX technology register or\na 64-bit memory location. In 64-bit mode, using a REX prefix in the form of\nREX.R permits this instruction to access additional registers (XMM8-XMM15).\n\n128-bit Legacy SSE version: The first source operand is an XMM register. The\nsecond operand can be an XMM register or a 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: The first source operand is an XMM register. The second source operand\nis an XMM register or 128-bit memory location. The destination operand is an\nXMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register\ndestination are zeroed. VEX.256 encoded version: The first source operand is\na YMM register. The second source operand is a YMM register or a 256-bit memory\nlocation. The destination operand is a YMM register.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPADDSB (with 64-bit operands)\n  DEST[7:0] <- SaturateToSignedByte(DEST[7:0] + SRC (7:0]);\n  (* Repeat add operation for 2nd through 7th bytes *)\n  DEST[63:56] <- SaturateToSignedByte(DEST[63:56] + SRC[63:56] );\nPADDSB (with 128-bit operands)\n  DEST[7:0] <-SaturateToSignedByte (DEST[7:0] + SRC[7:0]);\n  (* Repeat add operation for 2nd through 14th bytes *)\n  DEST[127:120] <- SaturateToSignedByte (DEST[111:120] + SRC[127:120]);\nVPADDSB (VEX.128 encoded version)\n  DEST[7:0] <- SaturateToSignedByte (SRC1[7:0] + SRC2[7:0]);\n  (* Repeat subtract operation for 2nd through 14th bytes *)\n  DEST[127:120] <- SaturateToSignedByte (SRC1[111:120] + SRC2[127:120]);\n  DEST[VLMAX-1:128] <- 0\nVPADDSB (VEX.256 encoded version)\n  DEST[7:0] <- SaturateToSignedByte (SRC1[7:0] + SRC2[7:0]);\n  (* Repeat add operation for 2nd through 31st bytes *)\n  DEST[255:248]<- SaturateToSignedByte (SRC1[255:248] + SRC2[255:248]);\nPADDSW (with 64-bit operands)\n  DEST[15:0] <- SaturateToSignedWord(DEST[15:0] + SRC[15:0] );\n  (* Repeat add operation for 2nd and 7th words *)\n  DEST[63:48] <- SaturateToSignedWord(DEST[63:48] + SRC[63:48] );\nPADDSW (with 128-bit operands)\n  DEST[15:0]\n  (* Repeat add operation for 2nd through 7th words *)\n  DEST[127:112] <- SaturateToSignedWord (DEST[127:112] + SRC[127:112]);\nVPADDSW (VEX.128 encoded version)\n  DEST[15:0] <- SaturateToSignedWord (SRC1[15:0] + SRC2[15:0]);\n  (* Repeat subtract operation for 2nd through 7th words *)\n  DEST[127:112] <- SaturateToSignedWord (SRC1[127:112] + SRC2[127:112]);\n  DEST[VLMAX-1:128] <- 0\nVPADDSW (VEX.256 encoded version)\n  DEST[15:0] <- SaturateToSignedWord (SRC1[15:0] + SRC2[15:0]);\n  (* Repeat add operation for 2nd through 15th words *)\n  DEST[255:240] <- SaturateToSignedWord (SRC1[255:240] + SRC2[255:240])\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PADDSB:   | __m64 _mm_adds_pi8(__m64 m1, __m64 m2)    \n| (V)PADDSB:| __m128i _mm_adds_epi8 ( __m128i a, __m128i\n|           | b)                                        \n| VPADDSB:  | __m256i _mm256_adds_epi8 ( __m256i a,     \n|           | __m256i b)                                \n| PADDSW:   | __m64 _mm_adds_pi16(__m64 m1, __m64       \n|           | m2)                                       \n| (V)PADDSW:| __m128i _mm_adds_epi16 ( __m128i a,       \n|           | __m128i b)                                \n| VPADDSW:  | __m256i _mm256_adds_epi16 ( __m256i       \n|           | a, __m256i b)                             \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PADDSB"
    }, 
    {
      "description": "-R:PADDSB", 
      "mnem": "PADDSW"
    }, 
    {
      "description": "\nPADDUSB/PADDUSW - Add Packed Unsigned Integers with Unsigned Saturation:\n| Opcode/Instruction                  | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| 0F DC /r1 PADDUSB mm, mm/m64        | RM   | V/V                   | MMX               | Add packed unsigned byte integers from     \n|                                     |      |                       |                   | mm/m64 and mm and saturate the results.    \n| 66 0F DC /r PADDUSB xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Add packed unsigned byte integers from     \n|                                     |      |                       |                   | xmm2/m128 and xmm1 saturate the results.   \n| 0F DD /r1 PADDUSW mm, mm/m64        | RM   | V/V                   | MMX               | Add packed unsigned word integers from     \n|                                     |      |                       |                   | mm/m64 and mm and saturate the results.    \n| 66 0F DD /r PADDUSW xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Add packed unsigned word integers from     \n|                                     |      |                       |                   | xmm2/m128 to xmm1 and saturate the results.\n| VEX.NDS.128.660F.WIG DC /r VPADDUSB | RVM  | V/V                   | AVX               | Add packed unsigned byte integers from     \n| xmm1, xmm2, xmm3/m128               |      |                       |                   | xmm3/m128 to xmm2 and saturate the results.\n| VEX.NDS.128.66.0F.WIG DD /r VPADDUSW| RVM  | V/V                   | AVX               | Add packed unsigned word integers from     \n| xmm1, xmm2, xmm3/m128               |      |                       |                   | xmm3/m128 to xmm2 and saturate the results.\n| VEX.NDS.256.66.0F.WIG DC /r VPADDUSB| RVM  | V/V                   | AVX2              | Add packed unsigned byte integers from     \n| ymm1, ymm2, ymm3/m256               |      |                       |                   | ymm2, and ymm3/m256 and store the saturated\n|                                     |      |                       |                   | results in ymm1.                           \n| VEX.NDS.256.66.0F.WIG DD /r VPADDUSW| RVM  | V/V                   | AVX2              | Add packed unsigned word integers from     \n| ymm1, ymm2, ymm3/m256               |      |                       |                   | ymm2, and ymm3/m256 and store the saturated\n|                                     |      |                       |                   | results in ymm1.                           \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD add of the packed unsigned integers from the source operand\n(second operand) and the destination operand (first operand), and stores the\npacked integer results in the destination operand. See Figure 9-4 in the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration\nof a SIMD operation. Overflow is handled with unsigned saturation, as described\nin the following paragraphs.\n\nThe (V)PADDUSB instruction adds packed unsigned byte integers. When an individual\nbyte result is beyond the range of an unsigned byte integer (that is, greater\nthan FFH), the saturated value of FFH is written to the destination operand.\n\nThe (V)PADDUSW instruction adds packed unsigned word integers. When an individual\nword result is beyond the range of an unsigned word integer (that is, greater\nthan FFFFH), the saturated value of FFFFH is written to the destination operand.\n\nThese instructions can operate on either 64-bit, 128-bit or 256-bit operands.\nWhen operating on 64-bit operands, the destination operand must be an MMX technology\nregister and the source operand can be either an MMX tech-\n\nnology register or a 64-bit memory location. In 64-bit mode, using a REX prefix\nin the form of REX.R permits this instruction to access additional registers\n(XMM8-XMM15). 128-bit Legacy SSE version: The first source operand is an XMM\nregister. The second operand can be an XMM register or a 128-bit memory location.\nThe destination is not distinct from the first source XMM register and the upper\nbits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second\nsource operand is an XMM register or 128-bit memory location. The destination\noperand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are zeroed. VEX.256 encoded version: The first source\noperand is a YMM register. The second source operand is a YMM register or a\n256-bit memory location. The destination operand is a YMM register. Note: VEX.L\nmust be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPADDUSB (with 64-bit operands)\n  DEST[7:0] <- SaturateToUnsignedByte(DEST[7:0] + SRC (7:0] );\n  (* Repeat add operation for 2nd through 7th bytes *)\n  DEST[63:56] <- SaturateToUnsignedByte(DEST[63:56] + SRC[63:56]\nPADDUSB (with 128-bit operands)\n  DEST[7:0] <- SaturateToUnsignedByte (DEST[7:0] + SRC[7:0]);\n  (* Repeat add operation for 2nd through 14th bytes *)\n  DEST[127:120] <- SaturateToUnSignedByte (DEST[127:120] + SRC[127:120]);\nVPADDUSB (VEX.128 encoded version)\n  DEST[7:0] <- SaturateToUnsignedByte (SRC1[7:0] + SRC2[7:0]);\n  (* Repeat subtract operation for 2nd through 14th bytes *)\n  DEST[127:120] <- SaturateToUnsignedByte (SRC1[111:120] + SRC2[127:120]);\n  DEST[VLMAX-1:128] <- 0\nVPADDUSB (VEX.256 encoded version)\n  DEST[7:0] <- SaturateToUnsignedByte (SRC1[7:0] + SRC2[7:0]);\n  (* Repeat add operation for 2nd through 31st bytes *)\n  DEST[255:248]<- SaturateToUnsignedByte (SRC1[255:248] + SRC2[255:248]);\nPADDUSW (with 64-bit operands)\n  DEST[15:0] <- SaturateToUnsignedWord(DEST[15:0] + SRC[15:0] );\n  (* Repeat add operation for 2nd and 3rd words *)\n  DEST[63:48] <- SaturateToUnsignedWord(DEST[63:48] + SRC[63:48] );\nPADDUSW (with 128-bit operands)\n  DEST[15:0] <- SaturateToUnsignedWord (DEST[15:0] + SRC[15:0]);\n  (* Repeat add operation for 2nd through 7th words *)\n  DEST[127:112] <- SaturateToUnSignedWord (DEST[127:112] + SRC[127:112]);\nVPADDUSW (VEX.128 encoded version)\n  DEST[15:0] <- SaturateToUnsignedWord (SRC1[15:0] + SRC2[15:0]);\n  (* Repeat subtract operation for 2nd through 7th words *)\n  DEST[127:112] <- SaturateToUnsignedWord (SRC1[127:112] + SRC2[127:112]);\n  DEST[VLMAX-1:128] <- 0\nVPADDUSW (VEX.256 encoded version)\n  DEST[15:0] <- SaturateToUnsignedWord (SRC1[15:0] + SRC2[15:0]);\n  (* Repeat add operation for 2nd through 15th words *)\n  DEST[255:240] <- SaturateToUnsignedWord (SRC1[255:240] + SRC2[255:240])\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PADDUSB:   | __m64 _mm_adds_pu8(__m64 m1, __m64 m2)    \n| PADDUSW:   | __m64 _mm_adds_pu16(__m64 m1, __m64       \n|            | m2)                                       \n| (V)PADDUSB:| __m128i _mm_adds_epu8 ( __m128i a, __m128i\n|            | b)                                        \n| (V)PADDUSW:| __m128i _mm_adds_epu16 ( __m128i a,       \n|            | __m128i b)                                \n| VPADDUSB:  | __m256i _mm256_adds_epu8 ( __m256i a,     \n|            | __m256i b)                                \n| VPADDUSW:  | __m256i _mm256_adds_epu16 ( __m256i       \n|            | a, __m256i b)                             \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PADDUSB"
    }, 
    {
      "description": "-R:PADDUSB", 
      "mnem": "PADDUSW"
    }, 
    {
      "description": "-R:PADDB", 
      "mnem": "PADDW"
    }, 
    {
      "description": "\nPALIGNR  -  Packed Align Right:\n| Opcode/Instruction                        | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                 \n| 0F 3A 0F /r ib1 PALIGNR mm1, mm2/m64,     | RMI  | V/V                   | SSSE3             | Concatenate destination and source operands,\n| imm8                                      |      |                       |                   | extract byte-aligned result shifted         \n|                                           |      |                       |                   | to the right by constant value in imm8      \n|                                           |      |                       |                   | into mm1.                                   \n| 66 0F 3A 0F /r ib PALIGNR xmm1, xmm2/m128,| RMI  | V/V                   | SSSE3             | Concatenate destination and source operands,\n| imm8                                      |      |                       |                   | extract byte-aligned result shifted         \n|                                           |      |                       |                   | to the right by constant value in imm8      \n|                                           |      |                       |                   | into xmm1.                                  \n| VEX.NDS.128.66.0F3A.WIG 0F /r ib VPALIGNR | RVMI | V/V                   | AVX               | Concatenate xmm2 and xmm3/m128, extract     \n| xmm1, xmm2, xmm3/m128, imm8               |      |                       |                   | byte aligned result shifted to the right    \n|                                           |      |                       |                   | by constant value in imm8 and result        \n|                                           |      |                       |                   | is stored in xmm1.                          \n| VEX.NDS.256.66.0F3A.WIG 0F /r ib VPALIGNR | RVMI | V/V                   | AVX2              | Concatenate pairs of 16 bytes in ymm2       \n| ymm1, ymm2, ymm3/m256, imm8               |      |                       |                   | and ymm3/m256 into 32-byte intermediate     \n|                                           |      |                       |                   | result, extract byte-aligned, 16-byte       \n|                                           |      |                       |                   | result shifted to the right by constant     \n|                                           |      |                       |                   | values in imm8 from each intermediate       \n|                                           |      |                       |                   | result, and two 16-byte results are         \n|                                           |      |                       |                   | stored in ymm1.                             \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\n(V)PALIGNR concatenates the destination operand (the first operand) and the\nsource operand (the second operand) into an intermediate composite, shifts the\ncomposite at byte granularity to the right by a constant immediate, and extracts\nthe right-aligned result into the destination. The first and the second operands\ncan be an MMX, XMM or a YMM register. The immediate value is considered unsigned.\nImmediate shift counts larger than the 2L (i.e. 32 for 128-bit operands, or\n16 for 64-bit operands) produce a zero result. Both operands can be MMX registers,\nXMM registers or YMM registers. When the source operand is a 128-bit memory\noperand, the operand must be aligned on a 16-byte boundary or a general-protection\nexception (#GP) will be generated.\n\nIn 64-bit mode, use the REX prefix to access additional registers. 128-bit Legacy\nSSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register\nremain unchanged. VEX.128 encoded version: The first source operand is an XMM\nregister. The second source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed. VEX.256 encoded version:\nThe first source operand is a YMM register and contains two 16-byte blocks.\nThe second source operand is a YMM register or a 256-bit memory location containing\ntwo 16-byte block. The destination operand is a YMM register and contain two\n16-byte results. The imm8[7:0] is the common shift count used for the two lower\n16-byte block sources and the two upper 16-byte block sources. The low 16-byte\nblock of the two source\n\noperands produce the low 16-byte result of the destination operand, the high\n16-byte block of the two source operands produce the high 16-byte result of\nthe destination operand. Concatenation is done with 128-bit data in the first\nand second source operand for both 128-bit and 256-bit instructions. The high\n128-bits of the intermediate composite 256-bit result came from the 128-bit\ndata from the first source operand; the low 128-bits of the intermediate result\ncame from the 128-bit data of the second source operand. Note: VEX.L must be\n0, otherwise the instruction will #UD.\n\n| 127| 0| 127| 0 SRC2\nImm8[7:0]*8\n\n| 255| 128| 255| 128 SRC2\nImm8[7:0]*8\n\n| 255 Figure 4-3.| 128 256-bit VPALIGN Instruction Operation| 127| 0 DEST\nOperation:\n\nPALIGNR (with 64-bit operands)\n  temp1[127:0] = CONCATENATE(DEST,SRC)>>(imm8*8)\n  DEST[63:0] = temp1[63:0]\nPALIGNR (with 128-bit operands)\ntemp1[255:0] <- ((DEST[127:0] << 128) OR SRC[127:0])>>(imm8*8);\nDEST[127:0] <- temp1[127:0]\nDEST[VLMAX-1:128] (Unmodified)\nVPALIGNR (VEX.128 encoded version)\ntemp1[255:0] <- ((SRC1[127:0] << 128) OR SRC2[127:0])>>(imm8*8);\nDEST[127:0] <- temp1[127:0]\nDEST[VLMAX-1:128] <- 0\nVPALIGNR (VEX.256 encoded version)\ntemp1[255:0] <- ((SRC1[127:0] << 128) OR SRC2[127:0])>>(imm8[7:0]*8);\nDEST[127:0] <- temp1[127:0]\ntemp1[255:0] <- ((SRC1[255:128] << 128) OR SRC2[255:128])>>(imm8[7:0]*8);\nDEST[255:128] <- temp1[127:0]\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PALIGNR:   | __m64 _mm_alignr_pi8 (__m64 a, __m64\n|            | b, int n)                           \n| (V)PALIGNR:| __m128i _mm_alignr_epi8 (__m128i a, \n|            | __m128i b, int n)                   \n| VPALIGNR:  | __m256i _mm256_alignr_epi8 (__m256i \n|            | a, __m256i b, const int n)          \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PALIGNR"
    }, 
    {
      "description": "\nPAND - Logical AND:\n| Opcode/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                           \n| 0F DB /r1 PAND mm, mm/m64              | RM   | V/V                   | MMX               | Bitwise AND mm/m64 and mm.            \n| 66 0F DB /r PAND xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Bitwise AND of xmm2/m128 and xmm1.    \n| VEX.NDS.128.66.0F.WIG DB /r VPAND xmm1,| RVM  | V/V                   | AVX               | Bitwise AND of xmm3/m128 and xmm.     \n| xmm2, xmm3/m128                        |      |                       |                   |                                       \n| VEX.NDS.256.66.0F.WIG DB /r VPAND ymm1,| RVM  | V/V                   | AVX2              | Bitwise AND of ymm2, and ymm3/m256 and\n| ymm2, ymm3/.m256                       |      |                       |                   | store result in ymm1.                 \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a bitwise logical AND operation on the first source operand and second\nsource operand and stores the result in the destination operand. Each bit of\nthe result is set to 1 if the corresponding bits of the first and second operands\nare 1, otherwise it is set to 0.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions: The source operand can be an MMX technology register\nor a 64-bit memory location. The destination operand can be an MMX technology\nregister.\n\n128-bit Legacy SSE version: The first source operand is an XMM register. The\nsecond operand can be an XMM register or a 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: The first source operand is an XMM register. The second source operand\nis an XMM register or 128-bit memory location. The destination operand is an\nXMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register\ndestination are zeroed. VEX.256 encoded version: The first source operand is\na YMM register. The second source operand is a YMM register or a 256-bit memory\nlocation. The destination operand is a YMM register.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPAND (128-bit Legacy SSE version)\nDEST <- DEST AND SRC\nDEST[VLMAX-1:128] (Unmodified)\nVPAND (VEX.128 encoded version)\nDEST <- SRC1 AND SRC2\nDEST[VLMAX-1:128] <- 0\nVPAND (VEX.256 encoded instruction)\nDEST[255:0] <- (SRC1[255:0] AND SRC2[255:0])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PAND:   | __m64 _mm_and_si64 (__m64 m1, __m64       \n|         | m2)                                       \n| (V)PAND:| __m128i _mm_and_si128 ( __m128i a, __m128i\n|         | b)                                        \n| VPAND:  | __m256i _mm256_and_si256 ( __m256i a,     \n|         | __m256i b)                                \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PAND"
    }, 
    {
      "description": "\nPANDN - Logical AND NOT:\n| Opcode/Instruction                      | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                           \n| 0F DF /r1 PANDN mm, mm/m64              | RM   | V/V                   | MMX               | Bitwise AND NOT of mm/m64 and mm.     \n| 66 0F DF /r PANDN xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Bitwise AND NOT of xmm2/m128 and xmm1.\n| VEX.NDS.128.66.0F.WIG DF /r VPANDN xmm1,| RVM  | V/V                   | AVX               | Bitwise AND NOT of xmm3/m128 and xmm2.\n| xmm2, xmm3/m128                         |      |                       |                   |                                       \n| VEX.NDS.256.66.0F.WIG DF /r VPANDN ymm1,| RVM  | V/V                   | AVX2              | Bitwise AND NOT of ymm2, and ymm3/m256\n| ymm2, ymm3/m256                         |      |                       |                   | and store result in ymm1.             \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a bitwise logical NOT operation on the first source operand, then performs\nbitwise AND with second source operand and stores the result in the destination\noperand. Each bit of the result is set to 1 if the corresponding bit in the\nfirst operand is 0 and the corresponding bit in the second operand is 1, otherwise\nit is set to 0.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions: The source operand can be an MMX technology register\nor a 64-bit memory location. The destination operand can be an MMX technology\nregister. 128-bit Legacy SSE version: The first source operand is an XMM register.\nThe second operand can be an XMM register or a 128-bit memory location. The\ndestination is not distinct from the first source XMM register and the upper\nbits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: The first source operand is an XMM register. The second\nsource operand is an XMM register or 128-bit memory location. The destination\noperand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are zeroed. VEX.256 encoded version: The first source\noperand is a YMM register. The second source operand is a YMM register or a\n256-bit memory location. The destination operand is a YMM register.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPANDN(128-bit Legacy SSE version)\nDEST <- NOT(DEST) AND SRC\nDEST[VLMAX-1:128] (Unmodified)\nVPANDN (VEX.128 encoded version)\nDEST <- NOT(SRC1) AND SRC2\nDEST[VLMAX-1:128] <- 0\nVPANDN (VEX.256 encoded instruction)\nDEST[255:0] <- ((NOT SRC1[255:0]) AND SRC2[255:0])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PANDN:   | __m64 _mm_andnot_si64 (__m64 m1, __m64\n|          | m2)                                   \n| (V)PANDN:| __m128i _mm_andnot_si128 ( __m128i a, \n|          | __m128i b)                            \n| VPANDN:  | __m256i _mm256_andnot_si256 ( __m256i \n|          | a, __m256i b)                         \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PANDN"
    }, 
    {
      "description": "\nPAUSE - Spin Loop Hint:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| F3 90 | PAUSE      | NP   | Valid      | Valid          | Gives hint to processor that improves\n|       |            |      |            |                | performance of spin-wait loops.      \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nImproves the performance of spin-wait loops. When executing a \u201cspin-wait loop,\u201d\nprocessors will suffer a severe performance penalty when exiting the loop because\nit detects a possible memory order violation. The PAUSE instruction provides\na hint to the processor that the code sequence is a spin-wait loop. The processor\nuses this hint to avoid the memory order violation in most situations, which\ngreatly improves processor performance. For this reason, it is recommended that\na PAUSE instruction be placed in all spin-wait loops.\n\nAn additional function of the PAUSE instruction is to reduce the power consumed\nby a processor while executing a spin loop. A processor can execute a spin-wait\nloop extremely quickly, causing the processor to consume a lot of power while\nit waits for the resource it is spinning on to become available. Inserting a\npause instruction in a spinwait loop greatly reduces the processor's power consumption.\n\nThis instruction was introduced in the Pentium 4 processors, but is backward\ncompatible with all IA-32 processors. In earlier IA-32 processors, the PAUSE\ninstruction operates like a NOP instruction. The Pentium 4 and Intel Xeon processors\nimplement the PAUSE instruction as a delay. The delay is finite and can be zero\nfor some processors. This instruction does not change the architectural state\nof the processor (that is, it performs essentially a delaying no-op operation).\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nExecute_Next_Instruction(DELAY);\n\nNumeric Exceptions:\nNone.\n\n\nExceptions (All Operating Modes):\n| #UD| If the LOCK prefix is used.\n", 
      "mnem": "PAUSE"
    }, 
    {
      "description": "\nPAVGB/PAVGW - Average Packed Integers:\n| Opcode/Instruction                      | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                           \n| 0F E0 /r1 PAVGB mm1, mm2/m64            | RM   | V/V                   | SSE               | Average packed unsigned byte integers \n|                                         |      |                       |                   | from mm2/m64 and mm1 with rounding.   \n| 66 0F E0, /r PAVGB xmm1, xmm2/m128      | RM   | V/V                   | SSE2              | Average packed unsigned byte integers \n|                                         |      |                       |                   | from xmm2/m128 and xmm1 with rounding.\n| 0F E3 /r1 PAVGW mm1, mm2/m64            | RM   | V/V                   | SSE               | Average packed unsigned word integers \n|                                         |      |                       |                   | from mm2/m64 and mm1 with rounding.   \n| 66 0F E3 /r PAVGW xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Average packed unsigned word integers \n|                                         |      |                       |                   | from xmm2/m128 and xmm1 with rounding.\n| VEX.NDS.128.66.0F.WIG E0 /r VPAVGB xmm1,| RVM  | V/V                   | AVX               | Average packed unsigned byte integers \n| xmm2, xmm3/m128                         |      |                       |                   | from xmm3/m128 and xmm2 with rounding.\n| VEX.NDS.128.66.0F.WIG E3 /r VPAVGW xmm1,| RVM  | V/V                   | AVX               | Average packed unsigned word integers \n| xmm2, xmm3/m128                         |      |                       |                   | from xmm3/m128 and xmm2 with rounding.\n| VEX.NDS.256.66.0F.WIG E0 /r VPAVGB ymm1,| RVM  | V/V                   | AVX2              | Average packed unsigned byte integers \n| ymm2, ymm3/m256                         |      |                       |                   | from ymm2, and ymm3/m256 with rounding\n|                                         |      |                       |                   | and store to ymm1.                    \n| VEX.NDS.256.66.0F.WIG E3 /r VPAVGW ymm1,| RVM  | V/V                   | AVX2              | Average packed unsigned word integers \n| ymm2, ymm3/m256                         |      |                       |                   | from ymm2, ymm3/m256 with rounding to \n|                                         |      |                       |                   | ymm1.                                 \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD average of the packed unsigned integers from the source operand\n(second operand) and the destination operand (first operand), and stores the\nresults in the destination operand. For each corresponding pair of data elements\nin the first and second operands, the elements are added together, a 1 is added\nto the temporary sum, and that result is shifted right one bit position.\n\nThe (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW\ninstruction operates on packed unsigned words.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions: The source operand can be an MMX technology register\nor a 64-bit memory location. The destination operand can be an MMX technology\nregister. 128-bit Legacy SSE version: The first source operand is an XMM register.\nThe second operand can be an XMM register or a 128-bit memory location. The\ndestination is not distinct from the first source XMM register and the upper\nbits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.\n\nVEX.128 encoded version: The first source operand is an XMM register. The second\nsource operand is an XMM register or 128-bit memory location. The destination\noperand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding\nYMM register destination are zeroed. VEX.256 encoded version: The first source\noperand is a YMM register. The second source operand is a YMM register or a\n256-bit memory location. The destination operand is a YMM register.\n\nOperation:\n\nPAVGB (with 64-bit operands)\n  DEST[7:0] <- (SRC[7:0] + DEST[7:0] + 1) >> 1; (* Temp sum before shifting is 9 bits *)\n  (* Repeat operation performed for bytes 2 through 6 *)\n  DEST[63:56] <- (SRC[63:56] + DEST[63:56] + 1) >> 1;\nPAVGW (with 64-bit operands)\n  DEST[15:0] <- (SRC[15:0] + DEST[15:0] + 1) >> 1; (* Temp sum before shifting is 17 bits *)\n  (* Repeat operation performed for words 2 and 3 *)\n  DEST[63:48] <- (SRC[63:48] + DEST[63:48] + 1) >> 1;\nPAVGB (with 128-bit operands)\n  DEST[7:0] <- (SRC[7:0] + DEST[7:0] + 1) >> 1; (* Temp sum before shifting is 9 bits *)\n  (* Repeat operation performed for bytes 2 through 14 *)\n  DEST[127:120] <- (SRC[127:120] + DEST[127:120] + 1) >> 1;\nPAVGW (with 128-bit operands)\n  DEST[15:0] <- (SRC[15:0] + DEST[15:0] + 1) >> 1; (* Temp sum before shifting is 17 bits *)\n  (* Repeat operation performed for words 2 through 6 *)\n  DEST[127:112] <- (SRC[127:112] + DEST[127:112] + 1) >> 1;\nVPAVGB (VEX.128 encoded version)\n  DEST[7:0] <- (SRC1[7:0] + SRC2[7:0] + 1) >> 1;\n  (* Repeat operation performed for bytes 2 through 15 *)\n  DEST[127:120] <- (SRC1[127:120] + SRC2[127:120] + 1) >> 1\n  DEST[VLMAX-1:128] <- 0\nVPAVGW (VEX.128 encoded version)\n  DEST[15:0] <- (SRC1[15:0] + SRC2[15:0] + 1) >> 1;\n  (* Repeat operation performed for 16-bit words 2 through 7 *)\n  DEST[127:112] <- (SRC1[127:112] + SRC2[127:112] + 1) >> 1\n  DEST[VLMAX-1:128] <- 0\nVPAVGB (VEX.256 encoded instruction)\n  DEST[7:0] <- (SRC1[7:0] + SRC2[7:0] + 1) >> 1; (* Temp sum before shifting is 9 bits *)\n  (* Repeat operation performed for bytes 2 through 31)\n  DEST[255:248] <- (SRC1[255:248] + SRC2[255:248] + 1) >> 1;\nVPAVGW (VEX.256 encoded instruction)\n  DEST[15:0] <- (SRC1[15:0] + SRC2[15:0] + 1) >> 1; (* Temp sum before shifting is 17 bits *)\n  (* Repeat operation performed for words 2 through 15)\n  DEST[255:14]) <- (SRC1[255:240] + SRC2[255:240] + 1) >> 1;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PAVGB:   | __m64 _mm_avg_pu8 (__m64 a, __m64 b)      \n| PAVGW:   | __m64 _mm_avg_pu16 (__m64 a, __m64 b)     \n| (V)PAVGB:| __m128i _mm_avg_epu8 ( __m128i a, __m128i \n|          | b)                                        \n| (V)PAVGW:| __m128i _mm_avg_epu16 ( __m128i a, __m128i\n|          | b)                                        \n| VPAVGB:  | __m256i _mm256_avg_epu8 ( __m256i a,      \n|          | __m256i b)                                \n| VPAVGW:  | __m256i _mm256_avg_epu16 ( __m256i a,     \n|          | __m256i b)                                \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PAVGB"
    }, 
    {
      "description": "-R:PAVGB", 
      "mnem": "PAVGW"
    }, 
    {
      "description": "\nPBLENDVB  -  Variable Blend Packed Bytes:\n| Opcode/Instruction                         | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                               \n| 66 0F 38 10 /r PBLENDVB xmm1, xmm2/m128,   | RM   | V/V                   | SSE4_1            | Select byte values from xmm1 and xmm2/m128\n| <XMM0>                                     |      |                       |                   | from mask specified in the high bit       \n|                                            |      |                       |                   | of each byte in XMM0 and store the values \n|                                            |      |                       |                   | into xmm1.                                \n| VEX.NDS.128.66.0F3A.W0 4C /r /is4 VPBLENDVB| RVMR | V/V                   | AVX               | Select byte values from xmm2 and xmm3/m128\n| xmm1, xmm2, xmm3/m128, xmm4                |      |                       |                   | using mask bits in the specified mask     \n|                                            |      |                       |                   | register, xmm4, and store the values      \n|                                            |      |                       |                   | into xmm1.                                \n| VEX.NDS.256.66.0F3A.W0 4C /r /is4 VPBLENDVB| RVMR | V/V                   | AVX2              | Select byte values from ymm2 and ymm3/m256\n| ymm1, ymm2, ymm3/m256, ymm4                |      |                       |                   | from mask specified in the high bit       \n|                                            |      |                       |                   | of each byte in ymm4 and store the values \n|                                            |      |                       |                   | into ymm1.                                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| <XMM0>       | NA       \n| RVMR | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8[7:4]\n\nDescription:\nConditionally copies byte elements from the source operand (second operand)\nto the destination operand (first operand) depending on mask bits defined in\nthe implicit third register argument, XMM0. The mask bits are the most significant\nbit in each byte element of the XMM0 register. If a mask bit is \u201c1\", then the\ncorresponding byte element in the source operand is copied to the destination,\nelse the byte element in the destination operand is left unchanged. The register\nassignment of the implicit third operand is defined to be the architectural\nregister XMM0. 128-bit Legacy SSE version: The first source operand and the\ndestination operand is the same. Bits (VLMAX-1:128) of the corresponding YMM\ndestination register remain unchanged. The mask register operand is implicitly\ndefined to be the architectural register XMM0. An attempt to execute PBLENDVB\nwith a VEX prefix will cause #UD. VEX.128 encoded version: The first source\noperand and the destination operand are XMM registers. The second source operand\nis an XMM register or 128-bit memory location. The mask operand is the third\nsource register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0]\nof imm8 are ignored. In 32-bit mode, imm8[7] is ignored. The upper bits (VLMAX-1:128)\nof the corresponding YMM register (destination register) are zeroed. VEX.L must\nbe 0, otherwise the instruction will #UD. VEX.W must be 0, otherwise, the instruction\nwill #UD. VEX.256 encoded version: The first source operand and the destination\noperand are YMM registers. The second source operand is an YMM register or 256-bit\nmemory location. The third source register is an YMM register and encoded in\nbits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In\n32-bit mode, imm8[7] is ignored. VPBLENDVB permits the mask to be any XMM or\nYMM register. In contrast, PBLENDVB treats XMM0 implicitly as the mask and do\nnot support non-destructive destination operation. An attempt to execute PBLENDVB\nencoded with a VEX prefix will cause a #UD exception.\n\nOperation:\n\nPBLENDVB (128-bit Legacy SSE version)\nMASK <- XMM0\nIF (MASK[7] = 1) THEN DEST[7:0] <- SRC[7:0];\nELSE DEST[7:0] <- DEST[7:0];\nIF (MASK[15] = 1) THEN DEST[15:8] <- SRC[15:8];\nELSE DEST[15:8] <- DEST[15:8];\nIF (MASK[23] = 1) THEN DEST[23:16] <- SRC[23:16]\nELSE DEST[23:16] <- DEST[23:16];\nIF (MASK[31] = 1) THEN DEST[31:24] <- SRC[31:24]\nELSE DEST[31:24] <- DEST[31:24];\nIF (MASK[39] = 1) THEN DEST[39:32] <- SRC[39:32]\nELSE DEST[39:32] <- DEST[39:32];\nIF (MASK[47] = 1) THEN DEST[47:40] <- SRC[47:40]\nELSE DEST[47:40] <- DEST[47:40];\nIF (MASK[55] = 1) THEN DEST[55:48] <- SRC[55:48]\nELSE DEST[55:48] <- DEST[55:48];\nIF (MASK[63] = 1) THEN DEST[63:56] <- SRC[63:56]\nELSE DEST[63:56] <- DEST[63:56];\nIF (MASK[71] = 1) THEN DEST[71:64] <- SRC[71:64]\nELSE DEST[71:64] <- DEST[71:64];\nIF (MASK[79] = 1) THEN DEST[79:72] <- SRC[79:72]\nELSE DEST[79:72] <- DEST[79:72];\nIF (MASK[87] = 1) THEN DEST[87:80] <- SRC[87:80]\nELSE DEST[87:80] <- DEST[87:80];\nIF (MASK[95] = 1) THEN DEST[95:88] <- SRC[95:88]\nELSE DEST[95:88] <-\uf020DEST[95:88];\nIF (MASK[103] = 1) THEN DEST[103:96] <- SRC[103:96]\nELSE DEST[103:96] <-\uf020DEST[103:96];\nIF (MASK[111] = 1) THEN DEST[111:104] <- SRC[111:104]\nELSE DEST[111:104] <- DEST[111:104];\nIF (MASK[119] = 1) THEN DEST[119:112] <- SRC[119:112]\nELSE DEST[119:112] <- DEST[119:112];\nIF (MASK[127] = 1) THEN DEST[127:120] <- SRC[127:120]\nELSE DEST[127:120] <- DEST[127:120])\nDEST[VLMAX-1:128] (Unmodified)\nVPBLENDVB (VEX.128 encoded version)\nMASK <- SRC3\nIF (MASK[7] = 1) THEN DEST[7:0] <- SRC2[7:0];\nELSE DEST[7:0] <- SRC1[7:0];\nIF (MASK[15] = 1) THEN DEST[15:8] <- SRC2[15:8];\nELSE DEST[15:8] <- SRC1[15:8];\nIF (MASK[23] = 1) THEN DEST[23:16] <- SRC2[23:16]\nELSE DEST[23:16] <- SRC1[23:16];\nIF (MASK[31] = 1) THEN DEST[31:24] <- SRC2[31:24]\nELSE DEST[31:24] <- SRC1[31:24];\nIF (MASK[39] = 1) THEN DEST[39:32] <- SRC2[39:32]\nELSE DEST[39:32] <- SRC1[39:32];\nIF (MASK[47] = 1) THEN DEST[47:40] <- SRC2[47:40]\nELSE DEST[47:40] <- SRC1[47:40];\nIF (MASK[55] = 1) THEN DEST[55:48] <- SRC2[55:48]\nELSE DEST[55:48] <- SRC1[55:48];\nIF (MASK[63] = 1) THEN DEST[63:56] <- SRC2[63:56]\nELSE DEST[63:56] <- SRC1[63:56];\nIF (MASK[71] = 1) THEN DEST[71:64] <- SRC2[71:64]\nELSE DEST[71:64] <- SRC1[71:64];\nIF (MASK[79] = 1) THEN DEST[79:72] <- SRC2[79:72]\nELSE DEST[79:72] <- SRC1[79:72];\nIF (MASK[87] = 1) THEN DEST[87:80] <- SRC2[87:80]\nELSE DEST[87:80] <- SRC1[87:80];\nIF (MASK[95] = 1) THEN DEST[95:88] <- SRC2[95:88]\nELSE DEST[95:88] <-\uf020SRC1[95:88];\nIF (MASK[103] = 1) THEN DEST[103:96] <- SRC2[103:96]\nELSE DEST[103:96] <-\uf020SRC1[103:96];\nIF (MASK[111] = 1) THEN DEST[111:104] <- SRC2[111:104]\nELSE DEST[111:104] <- SRC1[111:104];\nIF (MASK[119] = 1) THEN DEST[119:112] <- SRC2[119:112]\nELSE DEST[119:112] <- SRC1[119:112];\nIF (MASK[127] = 1) THEN DEST[127:120] <- SRC2[127:120]\nELSE DEST[127:120] <- SRC1[127:120])\nDEST[VLMAX-1:128] <- 0\nVPBLENDVB (VEX.256 encoded version)\nMASK <- SRC3\nIF (MASK[7] == 1) THEN DEST[7:0] <- SRC2[7:0];\nELSE DEST[7:0] <- SRC1[7:0];\nIF (MASK[15] == 1) THEN DEST[15:8] <-SRC2[15:8];\nELSE DEST[15:8] <- SRC1[15:8];\nIF (MASK[23] == 1) THEN DEST[23:16] <-SRC2[23:16]\nELSE DEST[23:16] <- SRC1[23:16];\nIF (MASK[31] == 1) THEN DEST[31:24] <- SRC2[31:24]\nELSE DEST[31:24] <- SRC1[31:24];\nIF (MASK[39] == 1) THEN DEST[39:32] <- SRC2[39:32]\nELSE DEST[39:32] <- SRC1[39:32];\nIF (MASK[47] == 1) THEN DEST[47:40] <- SRC2[47:40]\nELSE DEST[47:40] <- SRC1[47:40];\nIF (MASK[55] == 1) THEN DEST[55:48] <- SRC2[55:48]\nELSE DEST[55:48] <- SRC1[55:48];\nIF (MASK[63] == 1) THEN DEST[63:56] <-SRC2[63:56]\nELSE DEST[63:56] <- SRC1[63:56];\nIF (MASK[71] == 1) THEN DEST[71:64] <-SRC2[71:64]\nELSE DEST[71:64] <- SRC1[71:64];\nIF (MASK[79] == 1) THEN DEST[79:72] <- SRC2[79:72]\nELSE DEST[79:72] <- SRC1[79:72];\nIF (MASK[87] == 1) THEN DEST[87:80] <- SRC2[87:80]\nELSE DEST[87:80] <- SRC1[87:80];\nIF (MASK[95] == 1) THEN DEST[95:88] <- SRC2[95:88]\nELSE DEST[95:88] <- SRC1[95:88];\nIF (MASK[103] == 1) THEN DEST[103:96] <- SRC2[103:96]\nELSE DEST[103:96] <- SRC1[103:96];\nIF (MASK[111] == 1) THEN DEST[111:104] <- SRC2[111:104]\nELSE DEST[111:104] <- SRC1[111:104];\nIF (MASK[119] == 1) THEN DEST[119:112] <- SRC2[119:112]\nELSE DEST[119:112] <- SRC1[119:112];\nIF (MASK[127] == 1) THEN DEST[127:120] <- SRC2[127:120]\nELSE DEST[127:120] <- SRC1[127:120])\nIF (MASK[135] == 1) THEN DEST[135:128] <- SRC2[135:128];\nELSE DEST[135:128] <- SRC1[135:128];\nIF (MASK[143] == 1) THEN DEST[143:136] <- SRC2[143:136];\nELSE DEST[[143:136] <- SRC1[143:136];\nIF (MASK[151] == 1) THEN DEST[151:144] <- SRC2[151:144]\nELSE DEST[151:144] <- SRC1[151:144];\nIF (MASK[159] == 1) THEN DEST[159:152] <- SRC2[159:152]\nELSE DEST[159:152] <- SRC1[159:152];\nIF (MASK[167] == 1) THEN DEST[167:160] <- SRC2[167:160]\nELSE DEST[167:160] <- SRC1[167:160];\nIF (MASK[175] == 1) THEN DEST[175:168] <- SRC2[175:168]\nELSE DEST[175:168] <- SRC1[175:168];\nIF (MASK[183] == 1) THEN DEST[183:176] <- SRC2[183:176]\nELSE DEST[183:176] <- SRC1[183:176];\nIF (MASK[191] == 1) THEN DEST[191:184] <- SRC2[191:184]\nELSE DEST[191:184] <- SRC1[191:184];\nIF (MASK[199] == 1) THEN DEST[199:192] <- SRC2[199:192]\nELSE DEST[199:192] <- SRC1[199:192];\nIF (MASK[207] == 1) THEN DEST[207:200] <- SRC2[207:200]\nELSE DEST[207:200] <- SRC1[207:200]\nIF (MASK[215] == 1) THEN DEST[215:208] <- SRC2[215:208]\nELSE DEST[215:208] <- SRC1[215:208];\nIF (MASK[223] == 1) THEN DEST[223:216] <- SRC2[223:216]\nELSE DEST[223:216] <- SRC1[223:216];\nIF (MASK[231] == 1) THEN DEST[231:224] <- SRC2[231:224]\nELSE DEST[231:224] <- SRC1[231:224];\nIF (MASK[239] == 1) THEN DEST[239:232] <- SRC2[239:232]\nELSE DEST[239:232] <- SRC1[239:232];\nIF (MASK[247] == 1) THEN DEST[247:240] <- SRC2[247:240]\nELSE DEST[247:240] <- SRC1[247:240];\nIF (MASK[255] == 1) THEN DEST[255:248] <- SRC2[255:248]\nELSE DEST[255:248] <- SRC1[255:248]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PBLENDVB:| __m128i _mm_blendv_epi8 (__m128i v1,\n|             | __m128i v2, __m128i mask);          \n| VPBLENDVB:  | __m256i _mm256_blendv_epi8 (__m256i \n|             | v1, __m256i v2, __m256i mask);      \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1. If VEX.W = 1.\n", 
      "mnem": "PBLENDVB"
    }, 
    {
      "description": "\nPBLENDW  -  Blend Packed Words:\n| Opcode/Instruction                        | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                          \n| 66 0F 3A 0E /r ib PBLENDW xmm1, xmm2/m128,| RMI  | V/V                   | SSE4_1            | Select words from xmm1 and xmm2/m128 \n| imm8                                      |      |                       |                   | from mask specified in imm8 and store\n|                                           |      |                       |                   | the values into xmm1.                \n| VEX.NDS.128.66.0F3A.WIG 0E /r ib VPBLENDW | RVMI | V/V                   | AVX               | Select words from xmm2 and xmm3/m128 \n| xmm1, xmm2, xmm3/m128, imm8               |      |                       |                   | from mask specified in imm8 and store\n|                                           |      |                       |                   | the values into xmm1.                \n| VEX.NDS.256.66.0F3A.WIG 0E /r ib VPBLENDW | RVMI | V/V                   | AVX2              | Select words from ymm2 and ymm3/m256 \n| ymm1, ymm2, ymm3/m256, imm8               |      |                       |                   | from mask specified in imm8 and store\n|                                           |      |                       |                   | the values into ymm1.                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nWords from the source operand (second operand) are conditionally written to\nthe destination operand (first operand) depending on bits in the immediate operand\n(third operand). The immediate bits (bits 7:0) form a mask that determines whether\nthe corresponding word in the destination is copied from the source. If a bit\nin the mask, corresponding to a word, is \u201c1\", then the word is copied, else\nthe word element in the destination operand is unchanged. 128-bit Legacy SSE\nversion: The second source operand can be an XMM register or a 128-bit memory\nlocation. The first source and destination operands are XMM registers. Bits\n(VLMAX-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand can be an XMM register or\na 128-bit memory location. The first source and destination operands are XMM\nregisters. Bits (VLMAX-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second\nsource operand is a YMM register or a 256-bit memory location. The destination\noperand is a YMM register.\n\nOperation:\n\nPBLENDW (128-bit Legacy SSE version)\nIF (imm8[0] = 1) THEN DEST[15:0] <- SRC[15:0]\nELSE DEST[15:0] <- DEST[15:0]\nIF (imm8[1] = 1) THEN DEST[31:16] <- SRC[31:16]\nELSE DEST[31:16] <- DEST[31:16]\nIF (imm8[2] = 1) THEN DEST[47:32] <- SRC[47:32]\nELSE DEST[47:32] <- DEST[47:32]\nIF (imm8[3] = 1) THEN DEST[63:48] <- SRC[63:48]\nELSE DEST[63:48] <- DEST[63:48]\nIF (imm8[4] = 1) THEN DEST[79:64] <- SRC[79:64]\nELSE DEST[79:64] <- DEST[79:64]\nIF (imm8[5] = 1) THEN DEST[95:80] <- SRC[95:80]\nELSE DEST[95:80] <- DEST[95:80]\nIF (imm8[6] = 1) THEN DEST[111:96] <- SRC[111:96]\nELSE DEST[111:96] <- DEST[111:96]\nIF (imm8[7] = 1) THEN DEST[127:112] <- SRC[127:112]\nELSE DEST[127:112] <- DEST[127:112]\nVPBLENDW (VEX.128 encoded version)\nIF (imm8[0] = 1) THEN DEST[15:0] <- SRC2[15:0]\nELSE DEST[15:0] <- SRC1[15:0]\nIF (imm8[1] = 1) THEN DEST[31:16] <- SRC2[31:16]\nELSE DEST[31:16] <- SRC1[31:16]\nIF (imm8[2] = 1) THEN DEST[47:32] <- SRC2[47:32]\nELSE DEST[47:32] <- SRC1[47:32]\nIF (imm8[3] = 1) THEN DEST[63:48] <- SRC2[63:48]\nELSE DEST[63:48] <- SRC1[63:48]\nIF (imm8[4] = 1) THEN DEST[79:64] <- SRC2[79:64]\nELSE DEST[79:64] <- SRC1[79:64]\nIF (imm8[5] = 1) THEN DEST[95:80] <- SRC2[95:80]\nELSE DEST[95:80] <- SRC1[95:80]\nIF (imm8[6] = 1) THEN DEST[111:96] <- SRC2[111:96]\nELSE DEST[111:96] <- SRC1[111:96]\nIF (imm8[7] = 1) THEN DEST[127:112] <- SRC2[127:112]\nELSE DEST[127:112] <- SRC1[127:112]\nDEST[VLMAX-1:128] <- 0\nVPBLENDW (VEX.256 encoded version)\nIF (imm8[0] == 1) THEN DEST[15:0] <- SRC2[15:0]\nELSE DEST[15:0] <- SRC1[15:0]\nIF (imm8[1] == 1) THEN DEST[31:16] <- SRC2[31:16]\nELSE DEST[31:16] <- SRC1[31:16]\nIF (imm8[2] == 1) THEN DEST[47:32] <- SRC2[47:32]\nELSE DEST[47:32] <- SRC1[47:32]\nIF (imm8[3] == 1) THEN DEST[63:48] <- SRC2[63:48]\nELSE DEST[63:48] <- SRC1[63:48]\nIF (imm8[4] == 1) THEN DEST[79:64] <- SRC2[79:64]\nELSE DEST[79:64] <- SRC1[79:64]\nIF (imm8[5] == 1) THEN DEST[95:80] <- SRC2[95:80]\nELSE DEST[95:80] <- SRC1[95:80]\nIF (imm8[6] == 1) THEN DEST[111:96] <- SRC2[111:96]\nELSE DEST[111:96] <- SRC1[111:96]\nIF (imm8[7] == 1) THEN DEST[127:112] <- SRC2[127:112]\nELSE DEST[127:112] <- SRC1[127:112]\nIF (imm8[0] == 1) THEN DEST[143:128] <- SRC2[143:128]\nELSE DEST[143:128] <- SRC1[143:128]\nIF (imm8[1] == 1) THEN DEST[159:144] <- SRC2[159:144]\nELSE DEST[159:144] <- SRC1[159:144]\nIF (imm8[2] == 1) THEN DEST[175:160] <- SRC2[175:160]\nELSE DEST[175:160] <- SRC1[175:160]\nIF (imm8[3] == 1) THEN DEST[191:176] <- SRC2[191:176]\nELSE DEST[191:176] <- SRC1[191:176]\nIF (imm8[4] == 1) THEN DEST[207:192] <- SRC2[207:192]\nELSE DEST[207:192] <- SRC1[207:192]\nIF (imm8[5] == 1) THEN DEST[223:208] <- SRC2[223:208]\nELSE DEST[223:208] <- SRC1[223:208]\nIF (imm8[6] == 1) THEN DEST[239:224] <- SRC2[239:224]\nELSE DEST[239:224] <- SRC1[239:224]\nIF (imm8[7] == 1) THEN DEST[255:240] <- SRC2[255:240]\nELSE DEST[255:240] <- SRC1[255:240]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PBLENDW:| __m128i _mm_blend_epi16 (__m128i v1,\n|            | __m128i v2, const int mask);        \n| VPBLENDW:  | __m256i _mm256_blend_epi16 (__m256i \n|            | v1, __m256i v2, const int mask)     \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PBLENDW"
    }, 
    {
      "description": "\nPCLMULQDQ - Carry-Less Multiplication Quadword:\n| Opcode/Instruction                          | Op/En| 64/32 bit Mode Support| CPUID Feature Flag      | Description                              \n| 66 0F 3A 44 /r ib PCLMULQDQ xmm1, xmm2/m128,| RMI  | V/V                   | CLMUL                   | Carry-less multiplication of one quadword\n| imm8                                        |      |                       |                         | of xmm1 by one quadword of xmm2/m128,    \n|                                             |      |                       |                         | stores the 128-bit result in xmm1. The   \n|                                             |      |                       |                         | immediate is used to determine which     \n|                                             |      |                       |                         | quadwords of xmm1 and xmm2/m128 should   \n|                                             |      |                       |                         | be used.                                 \n| VEX.NDS.128.66.0F3A.WIG 44 /r ib VPCLMULQDQ | RVMI | V/V                   | Both CLMUL and AVX flags| Carry-less multiplication of one quadword\n| xmm1, xmm2, xmm3/m128, imm8                 |      |                       |                         | of xmm2 by one quadword of xmm3/m128,    \n|                                             |      |                       |                         | stores the 128-bit result in xmm1. The   \n|                                             |      |                       |                         | immediate is used to determine which     \n|                                             |      |                       |                         | quadwords of xmm2 and xmm3/m128 should   \n|                                             |      |                       |                         | be used.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand2     | Operand3     | Operand4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA      \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8    \n\nDescription:\nPerforms a carry-less multiplication of two quadwords, selected from the first\nsource and second source operand according to the value of the immediate byte.\nBits 4 and 0 are used to select which 64-bit half of each operand to use according\nto Table 4-10, other bits of the immediate byte are ignored.\n\n\nTable 4-10. PCLMULQDQ Quadword Selection of Immediate Byte:\n| Imm[4]| Imm[0]CL_MUL( SRC21[63:0], SRC1[63:0]     | PCLMULQDQ Operation 0 0 1 1\n|       | ) CL_MUL( SRC2[63:0], SRC1[127:64] )      |                            \n|       | CL_MUL( SRC2[127:64], SRC1[63:0] ) CL_MUL(|                            \n|       | SRC2[127:64], SRC1[127:64] )              |                            \nNotes: 1. SRC2 denotes the second source operand, which can be a register or\nmemory; SRC1 denotes the first source and destination operand.\n\nThe first source operand and the destination operand are the same and must be\nan XMM register. The second source operand can be an XMM register or a 128-bit\nmemory location. Bits (VLMAX-1:128) of the corresponding YMM destination register\nremain unchanged.\n\nCompilers and assemblers may implement the following pseudo-op syntax to simply\nprogramming and emit the required encoding for Imm8.\n\n\nTable 4-11. Pseudo-Op and PCLMULQDQ Implementation:\n| Pseudo-Op              | Imm8 Encoding\n| PCLMULLQLQDQ xmm1, xmm2| 0000_0000B   \n| PCLMULHQLQDQ xmm1, xmm2| 0000_0001B   \n| PCLMULLQHDQ xmm1, xmm2 | 0001_0000B   \n| PCLMULHQHDQ xmm1, xmm2 | 0001_0001B   \nOperation:\n\nPCLMULQDQ\nIF (Imm8[0] = 0 )\n  THEN\n     TEMP1 <- SRC1 [63:0];\n  ELSE\n     TEMP1 <- SRC1 [127:64];\nFI\nIF (Imm8[4] = 0 )\n  THEN\n     TEMP2 <- SRC2 [63:0];\n  ELSE\n     TEMP2 <- SRC2 [127:64];\nFI\nFor i = 0 to 63 {\n  TmpB [ i ] <- (TEMP1[ 0 ] and TEMP2[ i ]);\n  For j = 1 to i {\n     TmpB [ i ] <- TmpB [ i ] xor (TEMP1[ j ] and TEMP2[ i - j ])\n  }\n  DEST[ i ] <- TmpB[ i ];\n}\nFor i = 64 to 126 {\n  TmpB [ i ] <- 0;\n  For j = i - 63 to 63 {\n     TmpB [ i ] <- TmpB [ i ] xor (TEMP1[ j ] and TEMP2[ i - j ])\n  }\n  DEST[ i ] <- TmpB[ i ];\n}\nDEST[127] <- 0;\nDEST[VLMAX-1:128] (Unmodified)\nVPCLMULQDQ\nIF (Imm8[0] = 0 )\n  THEN\n     TEMP1 <- SRC1 [63:0];\n  ELSE\n     TEMP1 <- SRC1 [127:64];\nFI\nIF (Imm8[4] = 0 )\n  THEN\n     TEMP2 <- SRC2 [63:0];\n  ELSE\n     TEMP2 <- SRC2 [127:64];\nFI\nFor i = 0 to 63 {\n  TmpB [ i ] <- (TEMP1[ 0 ] and TEMP2[ i ]);\n  For j = 1 to i {\n     TmpB [i] <- TmpB [i] xor (TEMP1[ j ] and TEMP2[ i - j ])\n  }\n  DEST[i] <- TmpB[i];\n}\nFor i = 64 to 126 {\n  TmpB [ i ] <- 0;\n  For j = i - 63 to 63 {\n     TmpB [i] <- TmpB [i] xor (TEMP1[ j ] and TEMP2[ i - j ])\n  }\n  DEST[i] <- TmpB[i];\n}\nDEST[VLMAX-1:127] <- 0;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PCLMULQDQ:| __m128i| _mm_clmulepi64_si128 (__m128i, __m128i,\n|              |        | const int)                             \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "PCLMULQDQ"
    }, 
    {
      "description": "\nPCMPEQB/PCMPEQW/PCMPEQD -  Compare Packed Data for Equal:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 0F 74 /r1 PCMPEQB mm, mm/m64          | RM   | V/V                   | MMX               | Compare packed bytes in mm/m64 and mm  \n|                                       |      |                       |                   | for equality.                          \n| 66 0F 74 /r PCMPEQB xmm1, xmm2/m128   | RM   | V/V                   | SSE2              | Compare packed bytes in xmm2/m128 and  \n|                                       |      |                       |                   | xmm1 for equality.                     \n| 0F 75 /r1 PCMPEQW mm, mm/m64          | RM   | V/V                   | MMX               | Compare packed words in mm/m64 and mm  \n|                                       |      |                       |                   | for equality.                          \n| 66 0F 75 /r PCMPEQW xmm1, xmm2/m128   | RM   | V/V                   | SSE2              | Compare packed words in xmm2/m128 and  \n|                                       |      |                       |                   | xmm1 for equality.                     \n| 0F 76 /r1 PCMPEQD mm, mm/m64          | RM   | V/V                   | MMX               | Compare packed doublewords in mm/m64   \n|                                       |      |                       |                   | and mm for equality.                   \n| 66 0F 76 /r PCMPEQD xmm1, xmm2/m128   | RM   | V/V                   | SSE2              | Compare packed doublewords in xmm2/m128\n|                                       |      |                       |                   | and xmm1 for equality.                 \n| VEX.NDS.128.66.0F.WIG 74 /r VPCMPEQB  | RVM  | V/V                   | AVX               | Compare packed bytes in xmm3/m128 and  \n| xmm1, xmm2, xmm3/m128                 |      |                       |                   | xmm2 for equality.                     \n| VEX.NDS.128.66.0F.WIG 75 /r VPCMPEQW  | RVM  | V/V                   | AVX               | Compare packed words in xmm3/m128 and  \n| xmm1, xmm2, xmm3/m128                 |      |                       |                   | xmm2 for equality.                     \n| VEX.NDS.128.66.0F.WIG 76 /r VPCMPEQD  | RVM  | V/V                   | AVX               | Compare packed doublewords in xmm3/m128\n| xmm1, xmm2, xmm3/m128                 |      |                       |                   | and xmm2 for equality.                 \n| VEX.NDS.256.66.0F.WIG 75 /r VPCMPEQW  | RVM  | V/V                   | AVX2              | Compare packed words in ymm3/m256 and  \n| ymm1, ymm2, ymm3 /m256                |      |                       |                   | ymm2 for equality.                     \n| VEX.NDS.256.66.0F.WIG 76 /r VPCMPEQD  | RVM  | V/V                   | AVX2              | Compare packed doublewords in ymm3/m256\n| ymm1, ymm2, ymm3 /m256                |      |                       |                   | and ymm2 for equality.                 \n| VEX.NDS.256.66.0F38.WIG 29 /r VPCMPEQQ| RVM  | V/V                   | AVX2              | Compare packed quadwords in ymm3/m256  \n| ymm1, ymm2, ymm3 /m256                |      |                       |                   | and ymm2 for equality.                 \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD compare for equality of the packed bytes, words, or doublewords\nin the destination operand (first operand) and the source operand (second operand).\nIf a pair of data elements is equal, the corresponding data element in the destination\noperand is set to all 1s; otherwise, it is set to all 0s.\n\nThe (V)PCMPEQB instruction compares the corresponding bytes in the destination\nand source operands; the (V)PCMPEQW instruction compares the corresponding words\nin the destination and source operands; and the (V)PCMPEQD instruction compares\nthe corresponding doublewords in the destination and source operands.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions: The source operand can be an MMX technology register\nor a 64-bit memory location. The destination operand can be an MMX technology\nregister. 128-bit Legacy SSE version: The second source operand can be an XMM\nregister or a 128-bit memory location. The first source and destination operands\nare XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register\nremain unchanged. VEX.128 encoded version: The second source operand can be\nan XMM register or a 128-bit memory location. The first source and destination\noperands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register\nare zeroed. VEX.256 encoded version: The first source operand is a YMM register.\nThe second source operand is a YMM register or a 256-bit memory location. The\ndestination operand is a YMM register. Note: VEX.L must be 0, otherwise the\ninstruction will #UD.\n\nOperation:\n\nPCMPEQB (with 64-bit operands)\n  IF DEST[7:0] = SRC[7:0]\n     THEN DEST[7:0) <- FFH;\n     ELSE DEST[7:0] <- 0; FI;\n  (* Continue comparison of 2nd through 7th bytes in DEST and SRC *)\n  IF DEST[63:56] = SRC[63:56]\n     THEN DEST[63:56] <- FFH;\n     ELSE DEST[63:56] <- 0; FI;\nPCMPEQB (with 128-bit operands)\n  IF DEST[7:0] = SRC[7:0]\n     THEN DEST[7:0) <- FFH;\n     ELSE DEST[7:0] <- 0; FI;\n  (* Continue comparison of 2nd through 15th bytes in DEST and SRC *)\n  IF DEST[127:120] = SRC[127:120]\n     THEN DEST[127:120] <- FFH;\n     ELSE DEST[127:120] <- 0; FI;\nVPCMPEQB (VEX.128 encoded version)\nDEST[127:0] <-COMPARE_BYTES_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[VLMAX-1:128] <- 0\nVPCMPEQB (VEX.256 encoded version)\nDEST[127:0] <-COMPARE_BYTES_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[255:128] <-COMPARE_BYTES_EQUAL(SRC1[255:128],SRC2[255:128])\nPCMPEQW (with 64-bit operands)\n  IF DEST[15:0] = SRC[15:0]\n     THEN DEST[15:0] <- FFFFH;\n     ELSE DEST[15:0] <- 0; FI;\n  (* Continue comparison of 2nd and 3rd words in DEST and SRC *)\n  IF DEST[63:48] = SRC[63:48]\n     THEN DEST[63:48] <- FFFFH;\n     ELSE DEST[63:48] <- 0; FI;\nPCMPEQW (with 128-bit operands)\n  IF DEST[15:0] = SRC[15:0]\n     THEN DEST[15:0] <- FFFFH;\n     ELSE DEST[15:0] <- 0; FI;\n  (* Continue comparison of 2nd through 7th words in DEST and SRC *)\n  IF DEST[127:112] = SRC[127:112]\n     THEN DEST[127:112] <- FFFFH;\n     ELSE DEST[127:112] <- 0; FI;\nVPCMPEQW (VEX.128 encoded version)\nDEST[127:0] <-COMPARE_WORDS_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[VLMAX-1:128] <- 0\nVPCMPEQW (VEX.256 encoded version)\nDEST[127:0] <-COMPARE_WORDS_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[255:128] <-COMPARE_WORDS_EQUAL(SRC1[255:128],SRC2[255:128])\nPCMPEQD (with 64-bit operands)\n  IF DEST[31:0] = SRC[31:0]\n     THEN DEST[31:0] <- FFFFFFFFH;\n     ELSE DEST[31:0] <- 0; FI;\n  IF DEST[63:32] = SRC[63:32]\n     THEN DEST[63:32] <- FFFFFFFFH;\n     ELSE DEST[63:32] <- 0; FI;\nPCMPEQD (with 128-bit operands)\n  IF DEST[31:0] = SRC[31:0]\n     THEN DEST[31:0] <- FFFFFFFFH;\n     ELSE DEST[31:0] <- 0; FI;\n  (* Continue comparison of 2nd and 3rd doublewords in DEST and SRC *)\n  IF DEST[127:96] = SRC[127:96]\n     THEN DEST[127:96] <- FFFFFFFFH;\n     ELSE DEST[127:96] <- 0; FI;\nVPCMPEQD (VEX.128 encoded version)\nDEST[127:0] <-COMPARE_DWORDS_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[VLMAX-1:128] <- 0\nVPCMPEQD (VEX.256 encoded version)\nDEST[127:0] <-COMPARE_DWORDS_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[255:128] <-COMPARE_DWORDS_EQUAL(SRC1[255:128],SRC2[255:128])\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PCMPEQB:   | __m64 _mm_cmpeq_pi8 (__m64 m1, __m64 \n|            | m2)                                  \n| PCMPEQW:   | __m64 _mm_cmpeq_pi16 (__m64 m1, __m64\n|            | m2)                                  \n| PCMPEQD:   | __m64 _mm_cmpeq_pi32 (__m64 m1, __m64\n|            | m2)                                  \n| (V)PCMPEQB:| __m128i _mm_cmpeq_epi8 ( __m128i a,  \n|            | __m128i b)                           \n| (V)PCMPEQW:| __m128i _mm_cmpeq_epi16 ( __m128i a, \n|            | __m128i b)                           \n| (V)PCMPEQD:| __m128i _mm_cmpeq_epi32 ( __m128i a, \n|            | __m128i b)                           \n| VPCMPEQB:  | __m256i _mm256_cmpeq_epi8 ( __m256i  \n|            | a, __m256i b)                        \n| VPCMPEQW:  | __m256i _mm256_cmpeq_epi16 ( __m256i \n|            | a, __m256i b)                        \n| VPCMPEQD:  | __m256i _mm256_cmpeq_epi32 ( __m256i \n|            | a, __m256i b)                        \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PCMPEQB"
    }, 
    {
      "description": "-R:PCMPEQB", 
      "mnem": "PCMPEQD"
    }, 
    {
      "description": "\nPCMPEQQ  -  Compare Packed Qword Data for Equal:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                           \n| 66 0F 38 29 /r PCMPEQQ xmm1, xmm2/m128| RM   | V/V                   | SSE4_1            | Compare packed qwords in xmm2/m128 and\n|                                       |      |                       |                   | xmm1 for equality.                    \n| VEX.NDS.128.66.0F38.WIG 29 /r VPCMPEQQ| RVM  | V/V                   | AVX               | Compare packed quadwords in xmm3/m128 \n| xmm1, xmm2, xmm3/m128                 |      |                       |                   | and xmm2 for equality.                \n| VEX.NDS.256.66.0F38.WIG 29 /r VPCMPEQQ| RVM  | V/V                   | AVX2              | Compare packed quadwords in ymm3/m256 \n| ymm1, ymm2, ymm3 /m256                |      |                       |                   | and ymm2 for equality.                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an SIMD compare for equality of the packed quadwords in the destination\noperand (first operand) and the\n\n| source operand (second operand). nation       | If a pair of data elements is equal, \n| is set to all 1s; otherwise, it is set        | the corresponding data element in the\n| to 0s. 128-bit Legacy SSE version: The        | desti-                               \n| second source operand can be an XMM           |                                      \n| register or a 128-bit memory location.        |                                      \n| The first source and destination operands     |                                      \n| are XMM registers. Bits (VLMAX-1:128)         |                                      \n| of the corresponding YMM destination          |                                      \n| register remain unchanged. VEX.128 encoded    |                                      \n| version: The second source operand can        |                                      \n| be an XMM register or a 128-bit memory        |                                      \n| location. The first source and destination    |                                      \n| operands are XMM registers. Bits (VLMAX-1:128)|                                      \n| of the corresponding YMM register are         |                                      \n| zeroed. VEX.256 encoded version: The          |                                      \n| first source operand is a YMM register.       |                                      \n| The second source operand is a YMM register   |                                      \n| or a 256-bit memory location. The destination |                                      \n| operand is a YMM register. Note: VEX.L        |                                      \n| must be 0, otherwise the instruction          |                                      \n| will #UD.                                     |                                      \nOperation:\n\nIF (DEST[63:0] = SRC[63:0])\n  THEN DEST[63:0] <- FFFFFFFFFFFFFFFFH;\n  ELSE DEST[63:0] <- 0; FI;\nIF (DEST[127:64] = SRC[127:64])\n  THEN DEST[127:64] <- FFFFFFFFFFFFFFFFH;\n  ELSE DEST[127:64] <- 0; FI;\nVPCMPEQQ (VEX.128 encoded version)\nDEST[127:0] <-COMPARE_QWORDS_EQUAL(SRC1,SRC2)\nDEST[VLMAX-1:128] <- 0\nVPCMPEQQ (VEX.256 encoded version)\nDEST[127:0] <-COMPARE_QWORDS_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[255:128] <-COMPARE_QWORDS_EQUAL(SRC1[255:128],SRC2[255:128])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PCMPEQQ:| __m128i _mm_cmpeq_epi64(__m128i a, __m128i\n|            | b);                                       \n| VPCMPEQQ:  | __m256i _mm256_cmpeq_epi64( __m256i       \n|            | a, __m256i b);                            \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PCMPEQQ"
    }, 
    {
      "description": "-R:PCMPEQB", 
      "mnem": "PCMPEQW"
    }, 
    {
      "description": "\nPCMPESTRI  -  Packed Compare Explicit Length Strings, Return Index:\n| Opcode/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                           \n| 66 0F 3A 61 /r imm8 PCMPESTRI xmm1,    | RMI  | V/V                   | SSE4_2            | Perform a packed comparison of string \n| xmm2/m128, imm8                        |      |                       |                   | data with explicit lengths, generating\n|                                        |      |                       |                   | an index, and storing the result in   \n|                                        |      |                       |                   | ECX.                                  \n| VEX.128.66.0F3A.WIG 61 /r ib VPCMPESTRI| RMI  | V/V                   | AVX               | Perform a packed comparison of string \n| xmm1, xmm2/m128, imm8                  |      |                       |                   | data with explicit lengths, generating\n|                                        |      |                       |                   | an index, and storing the result in   \n|                                        |      |                       |                   | ECX.                                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RMI  | ModRM:reg (r)| ModRM:r/m (r)| imm8     | NA       \n\nDescription:\nThe instruction compares and processes data from two string fragments based\non the encoded value in the Imm8 Control Byte (see Section 4.1, \u201cImm8 Control\nByte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM\u201d), and generates\nan index stored to the count register (ECX/RCX).\n\nEach string fragment is represented by two values. The first value is an xmm\n(or possibly m128 for the second\n\n| operand) which contains the data elements| The second value is stored in an input\n| of the string (byte or word data). length|                                       \n| register. The input length register      |                                       \n| is EAX/RAX (for xmm1) or EDX/RDX (for    |                                       \n| xmm2/m128). The length represents the    |                                       \n| number of bytes/words which are valid    |                                       \n| for the respective xmm/m128 data. The    |                                       \n| length of each input is interpreted      |                                       \n| as being the absolute-value of the value |                                       \n| in the length register. The absolutevalue|                                       \n| computation saturates to 16 (for bytes)  |                                       \n| and 8 (for words), based on the value    |                                       \n| of imm8[bit3] when the value in the      |                                       \n| length register is greater than 16 (8)   |                                       \n| or less than -16 (-8). The comparison    |                                       \n| and aggregation operations are performed |                                       \n| according to the encoded value of Imm8   |                                       \n| bit fields (see Section 4.1). The index  |                                       \n| of the first (or last, according to      |                                       \n| imm8[6]) set bit of IntRes2 (see Section |                                       \n| 4.1.4) is returned in ECX. If no bits    |                                       \n| are set in IntRes2, ECX is set to 16     |                                       \n| (8). Note that the Arithmetic Flags      |                                       \n| are written in a non-standard manner     |                                       \n| in order to supply the most relevant     |                                       \n| information:                             |                                       \nCFlag - Reset if IntRes2 is equal to zero, set otherwise ZFlag - Set if absolute-value\nof EDX is < 16 (8), reset otherwise SFlag - Set if absolute-value of EAX is\n< 16 (8), reset otherwise OFlag - IntRes2[0]AFlag - Reset PFlag - Reset\n\n\nEffective Operand Size:\n| Operating mode/size| Operand 1| Operand 2| Length 1| Length 2| Result\n| 16 bit             | xmm      | xmm/m128 | EAX     | EDX     | ECX   \n| 32 bit             | xmm      | xmm/m128 | EAX     | EDX     | ECX   \n| 64 bit             | xmm      | xmm/m128 | EAX     | EDX     | ECX   \n| 64 bit + REX.W     | xmm      | xmm/m128 | RAX     | RDX     | RCX   \n\nIntel C/C++ Compiler Intrinsic Equivalent For Returning Index:\n| int| _mm_cmpestri (__m128i a, int la, __m128i\n|    | b, int lb, const int mode);             \n\nIntel C/C++ Compiler Intrinsics For Reading EFlag Results:\n| int| _mm_cmpestra (__m128i a, int la, __m128i\n|    | b, int lb, const int mode);             \n| int| _mm_cmpestrc (__m128i a, int la, __m128i\n|    | b, int lb, const int mode);             \n| int| _mm_cmpestro (__m128i a, int la, __m128i\n|    | b, int lb, const int mode);             \n| int| _mm_cmpestrs (__m128i a, int la, __m128i\n|    | b, int lb, const int mode);             \n| int| _mm_cmpestrz (__m128i a, int la, __m128i\n|    | b, int lb, const int mode);             \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally, this instruction does not cause #GP if\nthe memory operand is not aligned to 16 Byte boundary, and\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PCMPESTRI"
    }, 
    {
      "description": "\nPCMPESTRM  -  Packed Compare Explicit Length Strings, Return Mask:\n| Opcode/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 66 0F 3A 60 /r imm8 PCMPESTRM xmm1,    | RMI  | V/V                   | SSE4_2            | Perform a packed comparison of string  \n| xmm2/m128, imm8                        |      |                       |                   | data with explicit lengths, generating \n|                                        |      |                       |                   | a mask, and storing the result in XMM0 \n| VEX.128.66.0F3A.WIG 60 /r ib VPCMPESTRM| RMI  | V/V                   | AVX               | Perform a packed comparison of string  \n| xmm1, xmm2/m128, imm8                  |      |                       |                   | data with explicit lengths, generating \n|                                        |      |                       |                   | a mask, and storing the result in XMM0.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RMI  | ModRM:reg (r)| ModRM:r/m (r)| imm8     | NA       \n\nDescription:\nThe instruction compares data from two string fragments based on the encoded\nvalue in the imm8 contol byte (see Section 4.1, \u201cImm8 Control Byte Operation\nfor PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM\u201d), and generates a mask stored\nto XMM0.\n\nEach string fragment is represented by two values. The first value is an xmm\n(or possibly m128 for the second operand) which contains the data elements of\nthe string (byte or word data). The second value is stored in an input length\nregister. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128).\nThe length represents the number of bytes/words which are valid for the respective\nxmm/m128 data.\n\nThe length of each input is interpreted as being the absolute-value of the value\nin the length register. The absolutevalue computation saturates to 16 (for bytes)\nand 8 (for words), based on the value of imm8[bit3] when the value in the length\nregister is greater than 16 (8) or less than -16 (-8).\n\nThe comparison and aggregation operations are performed according to the encoded\nvalue of Imm8 bit fields (see Section 4.1). As defined by imm8[6], IntRes2 is\nthen either stored to the least significant bits of XMM0 (zero extended to 128\nbits) or expanded into a byte/word-mask and then stored to XMM0.\n\nNote that the Arithmetic Flags are written in a non-standard manner in order\nto supply the most relevant information:\n\nCFlag - Reset if IntRes2 is equal to zero, set otherwise ZFlag - Set if absolute-value\nof EDX is < 16 (8), reset otherwise SFlag - Set if absolute-value of EAX is\n< 16 (8), reset otherwise OFlag -IntRes2[0]AFlag - Reset PFlag - Reset\n\nNote: In VEX.128 encoded versions, bits (VLMAX-1:128) of XMM0 are zeroed. VEX.vvvv\nis reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will\n#UD.\n\n\nEffective Operand Size:\n| Operating mode/size| Operand1| Operand 2| Length1| Length2| Result\n| 16 bit             | xmm     | xmm/m128 | EAX    | EDX    | XMM0  \n| 32 bit             | xmm     | xmm/m128 | EAX    | EDX    | XMM0  \n| 64 bit             | xmm     | xmm/m128 | EAX    | EDX    | XMM0  \n| 64 bit + REX.W     | xmm     | xmm/m128 | RAX    | RDX    | XMM0  \n\nIntel C/C++ Compiler Intrinsic Equivalent For Returning Mask:\n__m128i _mm_cmpestrm (__m128i a, int la, __m128i b, int lb, const int mode);\n\n\nIntel C/C++ Compiler Intrinsics For Reading EFlag Results:\n| int| _mm_cmpestra (__m128i a, int la, __m128i\n|    | b, int lb, const int mode);             \n| int| _mm_cmpestrc (__m128i a, int la, __m128i\n|    | b, int lb, const int mode);             \n| int| _mm_cmpestro (__m128i a, int la, __m128i\n|    | b, int lb, const int mode);             \n| int| _mm_cmpestrs (__m128i a, int la, __m128i\n|    | b, int lb, const int mode);             \n| int| _mm_cmpestrz (__m128i a, int la, __m128i\n|    | b, int lb, const int mode);             \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally, this instruction does not cause #GP if\nthe memory operand is not aligned to 16 Byte boundary, and\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PCMPESTRM"
    }, 
    {
      "description": "\nPCMPGTB/PCMPGTW/PCMPGTD - Compare Packed Signed Integers for Greater Than:\n| Opcode/Instruction                  | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| 0F 64 /r1 PCMPGTB mm, mm/m64        | RM   | V/V                   | MMX               | Compare packed signed byte integers      \n|                                     |      |                       |                   | in mm and mm/m64 for greater than.       \n| 66 0F 64 /r PCMPGTB xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Compare packed signed byte integers      \n|                                     |      |                       |                   | in xmm1 and xmm2/m128 for greater than.  \n| 0F 65 /r1 PCMPGTW mm, mm/m64        | RM   | V/V                   | MMX               | Compare packed signed word integers      \n|                                     |      |                       |                   | in mm and mm/m64 for greater than.       \n| 66 0F 65 /r PCMPGTW xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Compare packed signed word integers      \n|                                     |      |                       |                   | in xmm1 and xmm2/m128 for greater than.  \n| 0F 66 /r1 PCMPGTD mm, mm/m64        | RM   | V/V                   | MMX               | Compare packed signed doubleword integers\n|                                     |      |                       |                   | in mm and mm/m64 for greater than.       \n| 66 0F 66 /r PCMPGTD xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Compare packed signed doubleword integers\n|                                     |      |                       |                   | in xmm1 and xmm2/m128 for greater than.  \n| VEX.NDS.128.66.0F.WIG 64 /r VPCMPGTB| RVM  | V/V                   | AVX               | Compare packed signed byte integers      \n| xmm1, xmm2, xmm3/m128               |      |                       |                   | in xmm2 and xmm3/m128 for greater than.  \n| VEX.NDS.128.66.0F.WIG 65 /r VPCMPGTW| RVM  | V/V                   | AVX               | Compare packed signed word integers      \n| xmm1, xmm2, xmm3/m128               |      |                       |                   | in xmm2 and xmm3/m128 for greater than.  \n| VEX.NDS.128.66.0F.WIG 66 /r VPCMPGTD| RVM  | V/V                   | AVX               | Compare packed signed doubleword integers\n| xmm1, xmm2, xmm3/m128               |      |                       |                   | in xmm2 and xmm3/m128 for greater than.  \n| VEX.NDS.256.66.0F.WIG 64 /r VPCMPGTB| RVM  | V/V                   | AVX2              | Compare packed signed byte integers      \n| ymm1, ymm2, ymm3/m256               |      |                       |                   | in ymm2 and ymm3/m256 for greater than.  \n| VEX.NDS.256.66.0F.WIG 65 /r VPCMPGTW| RVM  | V/V                   | AVX2              | Compare packed signed word integers      \n| ymm1, ymm2, ymm3/m256               |      |                       |                   | in ymm2 and ymm3/m256 for greater than.  \n| VEX.NDS.256.66.0F.WIG 66 /r VPCMPGTD| RVM  | V/V                   | AVX2              | Compare packed signed doubleword integers\n| ymm1, ymm2, ymm3/m256               |      |                       |                   | in ymm2 and ymm3/m256 for greater than.  \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an SIMD signed compare for the greater value of the packed byte, word,\nor doubleword integers in the destination operand (first operand) and the source\noperand (second operand). If a data element in the destination operand is greater\nthan the corresponding date element in the source operand, the corresponding\ndata element in the destination operand is set to all 1s; otherwise, it is set\nto all 0s.\n\nThe PCMPGTB instruction compares the corresponding signed byte integers in the\ndestination and source operands; the PCMPGTW instruction compares the corresponding\nsigned word integers in the destination and source\n\noperands; and the PCMPGTD instruction compares the corresponding signed doubleword\nintegers in the destination and source operands. In 64-bit mode, using a REX\nprefix in the form of REX.R permits this instruction to access additional registers\n(XMM8-XMM15).\n\nLegacy SSE instructions: The source operand can be an MMX technology register\nor a 64-bit memory location. The destination operand can be an MMX technology\nregister. 128-bit Legacy SSE version: The second source operand can be an XMM\nregister or a 128-bit memory location. The first source operand and destination\noperand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: The second source operand\ncan be an XMM register or a 128-bit memory location. The first source operand\nand destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding\nYMM register are zeroed. VEX.256 encoded version: The first source operand is\na YMM register. The second source operand is a YMM register or a 256-bit memory\nlocation. The destination operand is a YMM register.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPCMPGTB (with 64-bit operands)\n  IF DEST[7:0] > SRC[7:0]\n     THEN DEST[7:0) <- FFH;\n     ELSE DEST[7:0] <- 0; FI;\n  (* Continue comparison of 2nd through 7th bytes in DEST and SRC *)\n  IF DEST[63:56] > SRC[63:56]\n     THEN DEST[63:56] <- FFH;\n     ELSE DEST[63:56] <- 0; FI;\nPCMPGTB (with 128-bit operands)\n  IF DEST[7:0] > SRC[7:0]\n     THEN DEST[7:0) <- FFH;\n     ELSE DEST[7:0] <- 0; FI;\n  (* Continue comparison of 2nd through 15th bytes in DEST and SRC *)\n  IF DEST[127:120] > SRC[127:120]\n     THEN DEST[127:120] <- FFH;\n     ELSE DEST[127:120] <- 0; FI;\nVPCMPGTB (VEX.128 encoded version)\nDEST[127:0] <-COMPARE_BYTES_GREATER(SRC1,SRC2)\nDEST[VLMAX-1:128] <- 0\nVPCMPGTB (VEX.256 encoded version)\nDEST[127:0] <-COMPARE_BYTES_GREATER(SRC1[127:0],SRC2[127:0])\nDEST[255:128] <-COMPARE_BYTES_GREATER(SRC1[255:128],SRC2[255:128])\nPCMPGTW (with 64-bit operands)\n  IF DEST[15:0] > SRC[15:0]\n     THEN DEST[15:0] <- FFFFH;\n     ELSE DEST[15:0] <- 0; FI;\n  (* Continue comparison of 2nd and 3rd words in DEST and SRC *)\n  IF DEST[63:48] > SRC[63:48]\n     THEN DEST[63:48] <- FFFFH;\n     ELSE DEST[63:48] <- 0; FI;\nPCMPGTW (with 128-bit operands)\n  IF DEST[15:0] > SRC[15:0]\n     THEN DEST[15:0] <- FFFFH;\n     ELSE DEST[15:0] <- 0; FI;\n  (* Continue comparison of 2nd through 7th words in DEST and SRC *)\n  IF DEST[63:48] > SRC[127:112]\n     THEN DEST[127:112] <- FFFFH;\n     ELSE DEST[127:112] <- 0; FI;\nVPCMPGTW (VEX.128 encoded version)\nDEST[127:0] <-COMPARE_WORDS_GREATER(SRC1,SRC2)\nDEST[VLMAX-1:128] <- 0\nVPCMPGTW (VEX.256 encoded version)\nDEST[127:0] <-COMPARE_WORDS_GREATER(SRC1[127:0],SRC2[127:0])\nDEST[255:128] <-COMPARE_WORDS_GREATER(SRC1[255:128],SRC2[255:128])\nPCMPGTD (with 64-bit operands)\n  IF DEST[31:0] > SRC[31:0]\n     THEN DEST[31:0] <- FFFFFFFFH;\n     ELSE DEST[31:0] <- 0; FI;\n  IF DEST[63:32] > SRC[63:32]\n     THEN DEST[63:32] <- FFFFFFFFH;\n     ELSE DEST[63:32] <- 0; FI;\nPCMPGTD (with 128-bit operands)\n  IF DEST[31:0] > SRC[31:0]\n     THEN DEST[31:0] <- FFFFFFFFH;\n     ELSE DEST[31:0] <- 0; FI;\n  (* Continue comparison of 2nd and 3rd doublewords in DEST and SRC *)\n  IF DEST[127:96] > SRC[127:96]\n     THEN DEST[127:96] <- FFFFFFFFH;\n     ELSE DEST[127:96] <- 0; FI;\nVPCMPGTD (VEX.128 encoded version)\nDEST[127:0] <-COMPARE_DWORDS_GREATER(SRC1,SRC2)\nDEST[VLMAX-1:128] <- 0\nVPCMPGTD (VEX.256 encoded version)\nDEST[127:0] <-COMPARE_DWORDS_GREATER(SRC1[127:0],SRC2[127:0])\nDEST[255:128] <-COMPARE_DWORDS_GREATER(SRC1[255:128],SRC2[255:128])\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PCMPGTB:   | __m64 _mm_cmpgt_pi8 (__m64 m1, __m64  \n|            | m2)                                   \n| PCMPGTW:   | __m64 _mm_pcmpgt_pi16 (__m64 m1, __m64\n|            | m2)                                   \n| DCMPGTD:   | __m64 _mm_pcmpgt_pi32 (__m64 m1, __m64\n|            | m2)                                   \n| (V)PCMPGTB:| __m128i _mm_cmpgt_epi8 ( __m128i a,   \n|            | __m128i b)                            \n| (V)PCMPGTW:| __m128i _mm_cmpgt_epi16 ( __m128i a,  \n|            | __m128i b)                            \n| (V)DCMPGTD:| __m128i _mm_cmpgt_epi32 ( __m128i a,  \n|            | __m128i b)                            \n| VPCMPGTB:  | __m256i _mm256_cmpgt_epi8 ( __m256i   \n|            | a, __m256i b)                         \n| VPCMPGTW:  | __m256i _mm256_cmpgt_epi16 ( __m256i  \n|            | a, __m256i b)                         \n| VPCMPGTD:  | __m256i _mm256_cmpgt_epi32 ( __m256i  \n|            | a, __m256i b)                         \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PCMPGTB"
    }, 
    {
      "description": "-R:PCMPGTB", 
      "mnem": "PCMPGTD"
    }, 
    {
      "description": "\nPCMPGTQ  -  Compare Packed Data for Greater Than:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| 66 0F 38 37 /r PCMPGTQ xmm1,xmm2/m128 | RM   | V/V                   | SSE4_2            | Compare packed signed qwords in xmm2/m128\n|                                       |      |                       |                   | and xmm1 for greater than.               \n| VEX.NDS.128.66.0F38.WIG 37 /r VPCMPGTQ| RVM  | V/V                   | AVX               | Compare packed signed qwords in xmm2     \n| xmm1, xmm2, xmm3/m128                 |      |                       |                   | and xmm3/m128 for greater than.          \n| VEX.NDS.256.66.0F38.WIG 37 /r VPCMPGTQ| RVM  | V/V                   | AVX2              | Compare packed signed qwords in ymm2     \n| ymm1, ymm2, ymm3/m256                 |      |                       |                   | and ymm3/m256 for greater than.          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an SIMD signed compare for the packed quadwords in the destination\noperand (first operand) and the source operand (second operand). If the data\nelement in the first (destination) operand is greater than the corresponding\nelement in the second (source) operand, the corresponding data element in the\ndestination is set to all 1s; otherwise, it is set to 0s.\n\n128-bit Legacy SSE version: The second source operand can be an XMM register\nor a 128-bit memory location. The first source operand and destination operand\nare XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register\nremain unchanged. VEX.128 encoded version: The second source operand can be\nan XMM register or a 128-bit memory location. The first source operand and destination\noperand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register\nare zeroed. VEX.256 encoded version: The first source operand is a YMM register.\nThe second source operand is a YMM register or a 256-bit memory location. The\ndestination operand is a YMM register.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nIF (DEST[63-0] > SRC[63-0])\n  THEN DEST[63-0] <- FFFFFFFFFFFFFFFFH;\n  ELSE DEST[63-0] <- 0; FI\nIF (DEST[127-64] > SRC[127-64])\n  THEN DEST[127-64] <- FFFFFFFFFFFFFFFFH;\n  ELSE DEST[127-64] <- 0; FI\nVPCMPGTQ (VEX.128 encoded version)\nDEST[127:0] <-COMPARE_QWORDS_GREATER(SRC1,SRC2)\nDEST[VLMAX-1:128] <- 0\nVPCMPGTQ (VEX.256 encoded version)\nDEST[127:0] <-COMPARE_QWORDS_GREATER(SRC1[127:0],SRC2[127:0])\nDEST[255:128] <-COMPARE_QWORDS_GREATER(SRC1[255:128],SRC2[255:128])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PCMPGTQ:| __m128i _mm_cmpgt_epi64(__m128i a, __m128i\n|            | b)                                        \n| VPCMPGTQ:  | __m256i _mm256_cmpgt_epi64( __m256i       \n|            | a, __m256i b);                            \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PCMPGTQ"
    }, 
    {
      "description": "-R:PCMPGTB", 
      "mnem": "PCMPGTW"
    }, 
    {
      "description": "\nPCMPISTRI  -  Packed Compare Implicit Length Strings, Return Index:\n| Opcode/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                           \n| 66 0F 3A 63 /r imm8 PCMPISTRI xmm1,    | RM   | V/V                   | SSE4_2            | Perform a packed comparison of string \n| xmm2/m128, imm8                        |      |                       |                   | data with implicit lengths, generating\n|                                        |      |                       |                   | an index, and storing the result in   \n|                                        |      |                       |                   | ECX.                                  \n| VEX.128.66.0F3A.WIG 63 /r ib VPCMPISTRI| RM   | V/V                   | AVX               | Perform a packed comparison of string \n| xmm1, xmm2/m128, imm8                  |      |                       |                   | data with implicit lengths, generating\n|                                        |      |                       |                   | an index, and storing the result in   \n|                                        |      |                       |                   | ECX.                                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r)| ModRM:r/m (r)| imm8     | NA       \n\nDescription:\nThe instruction compares data from two strings based on the encoded value in\nthe Imm8 Control Byte (see Section 4.1, \u201cImm8 Control Byte Operation for PCMPESTRI\n/ PCMPESTRM / PCMPISTRI / PCMPISTRM\u201d), and generates an index stored to ECX.\n\n| Each string is represented by a single        | The value is an xmm (or possibly m128     \n| value. contains the data elements of          | for the second operand) which Each input  \n| the string (byte or word data). valid/invalid | byte/word is augmented with a A byte/word \n| tag. byte/word. The comparison and aggregation| is considered valid only if it has a      \n| operations are performed according to         | lower index than the least significant    \n| the encoded value of Imm8 bit fields          | null (The least significant null byte/word\n| (see Section 4.1). The index of the           | is also considered invalid.)              \n| first (or last, according to imm8[6])         |                                           \n| set bit of IntRes2 is returned in ECX.        |                                           \n| If no bits are set in IntRes2, ECX is         |                                           \n| set to 16 (8). Note that the Arithmetic       |                                           \n| Flags are written in a non-standard           |                                           \n| manner in order to supply the most relevant   |                                           \n| information:                                  |                                           \nCFlag - Reset if IntRes2 is equal to zero, set otherwise ZFlag - Set if any\nbyte/word of xmm2/mem128 is null, reset otherwise SFlag - Set if any byte/word\nof xmm1 is null, reset otherwise OFlag -IntRes2[0]AFlag - Reset PFlag - Reset\nNote: In VEX.128 encoded version, VEX.vvvv is reserved and must be 1111b, VEX.L\nmust be 0, otherwise the instruction will #UD.\n\n\nEffective Operand Size:\n| Operating mode/size| Operand1| Operand 2| Result\n| 16 bit             | xmm     | xmm/m128 | ECX   \n| 32 bit             | xmm     | xmm/m128 | ECX   \n| 64 bit             | xmm     | xmm/m128 | ECX   \n| 64 bit + REX.W     | xmm     | xmm/m128 | RCX   \n\nIntel C/C++ Compiler Intrinsic Equivalent For Returning Index:\n| int| _mm_cmpistri (__m128i a, __m128i b,\n|    | const int mode);                   \n\nIntel C/C++ Compiler Intrinsics For Reading EFlag Results:\n| int| _mm_cmpistra (__m128i a, __m128i b,\n|    | const int mode);                   \n| int| _mm_cmpistrc (__m128i a, __m128i b,\n|    | const int mode);                   \n| int| _mm_cmpistro (__m128i a, __m128i b,\n|    | const int mode);                   \n| int| _mm_cmpistrs (__m128i a, __m128i b,\n|    | const int mode);                   \n| int| _mm_cmpistrz (__m128i a, __m128i b,\n|    | const int mode);                   \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally, this instruction does not cause #GP if\nthe memory operand is not aligned to 16 Byte boundary, and\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PCMPISTRI"
    }, 
    {
      "description": "\nPCMPISTRM  -  Packed Compare Implicit Length Strings, Return Mask:\n| Opcode/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 66 0F 3A 62 /r imm8 PCMPISTRM xmm1,    | RM   | V/V                   | SSE4_2            | Perform a packed comparison of string  \n| xmm2/m128, imm8                        |      |                       |                   | data with implicit lengths, generating \n|                                        |      |                       |                   | a mask, and storing the result in XMM0.\n| VEX.128.66.0F3A.WIG 62 /r ib VPCMPISTRM| RM   | V/V                   | AVX               | Perform a packed comparison of string  \n| xmm1, xmm2/m128, imm8                  |      |                       |                   | data with implicit lengths, generating \n|                                        |      |                       |                   | a Mask, and storing the result in XMM0.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r)| ModRM:r/m (r)| imm8     | NA       \n\nDescription:\nThe instruction compares data from two strings based on the encoded value in\nthe imm8 byte (see Section 4.1, \u201cImm8 Control Byte Operation for PCMPESTRI /\nPCMPESTRM / PCMPISTRI / PCMPISTRM\u201d) generating a mask stored to XMM0.\n\nEach string is represented by a single value. The value is an xmm (or possibly\nm128 for the second operand) which\n\n| contains the data elements of the string | Each input byte/word is augmented with     \n| (byte or word data). valid/invalid tag.  | a A byte/word is considered valid only     \n| byte/word. The comparison and aggregation| if it has a lower index than the least     \n| operation are performed according to     | significant null (The least significant    \n| the encoded value of Imm8 bit fields     | null byte/word is also considered invalid.)\n| (see Section 4.1). As defined by imm8[6],|                                            \n| IntRes2 is then either stored to the     |                                            \n| least significant bits of XMM0 (zero     |                                            \n| extended to 128 bits) or expanded into   |                                            \n| a byte/word-mask and then stored to      |                                            \n| XMM0. Note that the Arithmetic Flags     |                                            \n| are written in a non-standard manner     |                                            \n| in order to supply the most relevant     |                                            \n| information:                             |                                            \nCFlag - Reset if IntRes2 is equal to zero, set otherwise ZFlag - Set if any\nbyte/word of xmm2/mem128 is null, reset otherwise SFlag - Set if any byte/word\nof xmm1 is null, reset otherwise OFlag - IntRes2[0]AFlag - Reset PFlag - Reset\nNote: In VEX.128 encoded versions, bits (VLMAX-1:128) of XMM0 are zeroed. VEX.vvvv\nis reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will\n#UD.\n\n\nEffective Operand Size:\n| Operating mode/size| Operand1| Operand 2| Result\n| 16 bit             | xmm     | xmm/m128 | XMM0  \n| 32 bit             | xmm     | xmm/m128 | XMM0  \n| 64 bit             | xmm     | xmm/m128 | XMM0  \n| 64 bit + REX.W     | xmm     | xmm/m128 | XMM0  \n\nIntel C/C++ Compiler Intrinsic Equivalent For Returning Mask:\n__m128i _mm_cmpistrm (__m128i a, __m128i b, const int mode);\n\n\nIntel C/C++ Compiler Intrinsics For Reading EFlag Results:\n| int| _mm_cmpistra (__m128i a, __m128i b,\n|    | const int mode);                   \n| int| _mm_cmpistrc (__m128i a, __m128i b,\n|    | const int mode);                   \n| int| _mm_cmpistro (__m128i a, __m128i b,\n|    | const int mode);                   \n| int| _mm_cmpistrs (__m128i a, __m128i b,\n|    | const int mode);                   \n| int| _mm_cmpistrz (__m128i a, __m128i b,\n|    | const int mode);                   \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally, this instruction does not cause #GP if\nthe memory operand is not aligned to 16 Byte boundary, and\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PCMPISTRM"
    }, 
    {
      "description": "\nPDEP  -  Parallel Bits Deposit:\n| Opcode/Instruction                    | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                             \n| VEX.NDS.LZ.F2.0F38.W0 F5 /r PDEP r32a,| RVM  | V/V            | BMI2              | Parallel deposit of bits from r32b using\n| r32b, r/m32                           |      |                |                   | mask in r/m32, result is written to     \n|                                       |      |                |                   | r32a.                                   \n| VEX.NDS.LZ.F2.0F38.W1 F5 /r PDEP r64a,| RVM  | V/N.E.         | BMI2              | Parallel deposit of bits from r64b using\n| r64b, r/m64                           |      |                |                   | mask in r/m64, result is written to     \n|                                       |      |                |                   | r64a.                                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2   | Operand 3    | Operand 4\n| RVM  | ModRM:reg (w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nPDEP uses a mask in the second source operand (the third operand) to transfer/scatter\ncontiguous low order bits in the first source operand (the second operand) into\nthe destination (the first operand). PDEP takes the low bits from the first\nsource operand and deposit them in the destination operand at the corresponding\nbit locations that are set in the second source operand (mask). All other bits\n(bits not set in mask) in destination are set to zero.\n\n| SRC1| S<sub>31</sub>| S<sub>30</sub>| S<sub>29</sub> S<sub>28</sub>| S<sub>27</sub>| S<sub>7</sub>| S<sub>6</sub>| S<sub>5</sub>| S<sub>4</sub>| S<sub>3</sub>| S<sub>2</sub>| S<sub>1</sub>| S 0\nSRC2\n\n| 0| 0| 0| 1            | 0            | 1                         | 0| 1            | 0| 0| 1            | 0| 0 (mask)\n| 0| 0| 0| S<sub>3</sub>| 0 Figure 4-4.| S<sub>2</sub> PDEP Example| 0| S<sub>1</sub>| 0| 0| S<sub>0</sub>| 0| 0 bit 0 \nThis instruction is not supported in real mode and virtual-8086 mode. The operand\nsize is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64\nrequires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute\nthis instruction with VEX.L not equal to 0 will cause #UD.\n\nOperation:\n\nTEMP <- SRC1;\nMASK <- SRC2;\nDEST <- 0 ;\nm<- 0, k<- 0;\nDO WHILE m< OperandSize\n     IF MASK[ m] = 1 THEN\n       DEST[ m] <- TEMP[ k];\n       k <- k+ 1;\n     FI\n     m <- m+ 1;\nOD\n\nFlags Affected:\nNone.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PDEP:| unsigned __int32 _pdep_u32(unsigned \n|      | __int32 src, unsigned __int32 mask);\n| PDEP:| unsigned __int64 _pdep_u64(unsigned \n|      | __int64 src, unsigned __int32 mask);\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Section 2.5.1, \u201cException Conditions for VEX-Encoded GPR Instructions\u201d,\nTable 2-29; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "PDEP"
    }, 
    {
      "description": "\nPEXT  -  Parallel Bits Extract:\n| Opcode/Instruction                    | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                             \n| VEX.NDS.LZ.F3.0F38.W0 F5 /r PEXT r32a,| RVM  | V/V            | BMI2              | Parallel extract of bits from r32b using\n| r32b, r/m32                           |      |                |                   | mask in r/m32, result is written to     \n|                                       |      |                |                   | r32a.                                   \n| VEX.NDS.LZ.F3.0F38.W1 F5 /r PEXT r64a,| RVM  | V/N.E.         | BMI2              | Parallel extract of bits from r64b using\n| r64b, r/m64                           |      |                |                   | mask in r/m64, result is written to     \n|                                       |      |                |                   | r64a.                                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2   | Operand 3    | Operand 4\n| RVM  | ModRM:reg (w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nPEXT uses a mask in the second source operand (the third operand) to transfer\neither contiguous or non-contiguous bits in the first source operand (the second\noperand) to contiguous low order bit positions in the destination (the first\noperand). For each bit set in the MASK, PEXT extracts the corresponding bits\nfrom the first source operand and writes them into contiguous lower bits of\ndestination operand. The remaining upper bits of destination are zeroed.\n\nSRC1\n\n| S<sub>31</sub>| S<sub>30</sub>| S<sub>29</sub> S<sub>28</sub>| S<sub>27</sub>| S<sub>7</sub>| S<sub>6</sub>| S<sub>5</sub>| S<sub>4</sub>| S<sub>3</sub>| S<sub>2</sub>| S<sub>1</sub>| S<sub>0</sub>\nSRC2\n\n| 0| 0| 0| 1| 0            | 1             | 0| 1| 0| 0             | 1            | 0            | 0 (mask)           \n| 0| 0| 0| 0| 0 Figure 4-5.| 0 PEXT Example| 0| 0| 0| S<sub>28</sub>| S<sub>7</sub>| S<sub>5</sub>| S<sub>2</sub> bit 0\nThis instruction is not supported in real mode and virtual-8086 mode. The operand\nsize is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64\nrequires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute\nthis instruction with VEX.L not equal to 0 will cause #UD.\n\nOperation:\n\nTEMP <- SRC1;\nMASK <- SRC2;\nDEST <- 0 ;\nm<- 0, k<- 0;\nDO WHILE m< OperandSize\n     IF MASK[ m] = 1 THEN\n       DEST[ k] <- TEMP[ m];\n       k <- k+ 1;\n     FI\n     m <- m+ 1;\nOD\n\nFlags Affected:\nNone.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PEXT:| unsigned __int32 _pext_u32(unsigned \n|      | __int32 src, unsigned __int32 mask);\n| PEXT:| unsigned __int64 _pext_u64(unsigned \n|      | __int64 src, unsigned __int32 mask);\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Section 2.5.1, \u201cException Conditions for VEX-Encoded GPR Instructions\u201d,\nTable 2-29; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "PEXT"
    }, 
    {
      "description": "\nPEXTRB/PEXTRD/PEXTRQ  -  Extract Byte/Dword/Qword:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 66 0F 3A 14 /r ib PEXTRB reg/m8, xmm2,| MRI  | V/V                   | SSE4_1            | Extract a byte integer value from xmm2 \n| imm8                                  |      |                       |                   | at the source byte offset specified    \n|                                       |      |                       |                   | by imm8 into reg or m8. The upper bits \n|                                       |      |                       |                   | of r32 or r64 are zeroed.              \n| 66 0F 3A 16 /r ib PEXTRD r/m32, xmm2, | MRI  | V/V                   | SSE4_1            | Extract a dword integer value from xmm2\n| imm8                                  |      |                       |                   | at the source dword offset specified   \n|                                       |      |                       |                   | by imm8 into r/m32.                    \n| 66 REX.W 0F 3A 16 /r ib PEXTRQ r/m64, | MRI  | V/N.E.                | SSE4_1            | Extract a qword integer value from xmm2\n| xmm2, imm8                            |      |                       |                   | at the source qword offset specified   \n|                                       |      |                       |                   | by imm8 into r/m64.                    \n| VEX.128.66.0F3A.W0 14 /r ib VPEXTRB   | MRI  | V1/V                  | AVX               | Extract a byte integer value from xmm2 \n| reg/m8, xmm2, imm8                    |      |                       |                   | at the source byte offset specified    \n|                                       |      |                       |                   | by imm8 into reg or m8. The upper bits \n|                                       |      |                       |                   | of r64/r32 is filled with zeros.       \n| VEX.128.66.0F3A.W0 16 /r ib VPEXTRD   | MRI  | V/V                   | AVX               | Extract a dword integer value from xmm2\n| r32/m32, xmm2, imm8                   |      |                       |                   | at the source dword offset specified   \n|                                       |      |                       |                   | by imm8 into r32/m32.                  \n| VEX.128.66.0F3A.W1 16 /r ib VPEXTRQ   | MRI  | V/i                   | AVX               | Extract a qword integer value from xmm2\n| r64/m64, xmm2, imm8                   |      |                       |                   | at the source dword offset specified   \n|                                       |      |                       |                   | by imm8 into r64/m64.                  \nNotes: 1. In 64-bit mode, VEX.W1 is ignored for VPEXTRB (similar to legacy REX.W=1\nprefix in PEXTRB).\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MRI  | ModRM:r/m (w)| ModRM:reg (r)| imm8     | NA       \n\nDescription:\nExtract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword\noffset determined from imm8[3:0]. The destination can be a register or byte/dword/qword\nmemory location. If the destination is a register, the upper bits of the register\nare zero extended. In legacy non-VEX encoded version and if the destination\noperand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD\nis 64 bits, the bits above the least significant byte/dword data are filled\nwith zeros. PEXTRQ is not encodable in non-64-bit modes and requires REX.W in\n64-bit mode. Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must\nbe 1111b, VEX.L must be 0, otherwise the instruction will #UD. If the destination\noperand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD\nis 64 bits, the bits above the least significant byte/word/dword data are filled\nwith zeros. Attempt to execute VPEXTRQ in non-64-bit mode will cause #UD.\n\nOperation:\n\nCASE of\n  PEXTRB: SEL <- COUNT[3:0];\n       TEMP <- (Src >> SEL*8) AND FFH;\n       IF (DEST = Mem8)\n          THEN\n          Mem8 <- TEMP[7:0];\n       ELSE IF (64-Bit Mode and 64-bit register selected)\n          THEN\n             R64[7:0] <- TEMP[7:0];\n             r64[63:8] <- ZERO_FILL; };\n       ELSE\n             R32[7:0] <- TEMP[7:0];\n             r32[31:8] <- ZERO_FILL; };\n       FI;\n  PEXTRD:SEL <- COUNT[1:0];\n       TEMP <- (Src >> SEL*32) AND FFFF_FFFFH;\n       DEST <- TEMP;\n  PEXTRQ: SEL <- COUNT[0];\n       TEMP <- (Src >> SEL*64);\n       DEST <- TEMP;\nEASC:\n(V)PEXTRTD/(V)PEXTRQ\nIF (64-Bit Mode and 64-bit dest operand)\nTHEN\n  Src_Offset <- Imm8[0]\n  r64/m64 <-(Src >> Src_Offset * 64)\nELSE\n  Src_Offset <- Imm8[1:0]\n  r32/m32 <- ((Src >> Src_Offset *32) AND 0FFFFFFFFh);\nFI\n(V)PEXTRB ( dest=m8)\nSRC_Offset <- Imm8[3:0]\nMem8 <- (Src >> Src_Offset*8)\n(V)PEXTRB ( dest=reg)\nIF (64-Bit Mode )\nTHEN\n  SRC_Offset <- Imm8[3:0]\n  DEST[7:0] <- ((Src >> Src_Offset*8) AND 0FFh)\n  DEST[63:8] <-\uf020ZERO_FILL;\nELSE\n  SRC_Offset <-. Imm8[3:0];\n  DEST[7:0] <- ((Src >> Src_Offset*8) AND 0FFh);\n  DEST[31:8] <-\uf020ZERO_FILL;\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PEXTRB:| int _mm_extract_epi8 (__m128i src, const\n|        | int ndx);                               \n| PEXTRD:| int _mm_extract_epi32 (__m128i src,     \n|        | const int ndx);                         \n| PEXTRQ:| __int64 _mm_extract_epi64 (__m128i src, \n|        | const int ndx);                         \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.    \n|    | If VPEXTRQ in non-64-bit mode, VEX.W=1.\n", 
      "mnem": "PEXTRB"
    }, 
    {
      "description": "-R:PEXTRB", 
      "mnem": "PEXTRD"
    }, 
    {
      "description": "-R:PEXTRB", 
      "mnem": "PEXTRQ"
    }, 
    {
      "description": "\nPEXTRW - Extract Word:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 0F C5 /r ib1 PEXTRW reg, mm, imm8     | RMI  | V/V                   | SSE               | Extract the word specified by imm8 from\n|                                       |      |                       |                   | mm and move it to reg, bits 15-0. The  \n|                                       |      |                       |                   | upper bits of r32 or r64 is zeroed.    \n| 66 0F C5 /r ib PEXTRW reg, xmm, imm8  | RMI  | V/V                   | SSE2              | Extract the word specified by imm8 from\n|                                       |      |                       |                   | xmm and move it to reg, bits 15-0. The \n|                                       |      |                       |                   | upper bits of r32 or r64 is zeroed.    \n| 66 0F 3A 15 /r ib PEXTRW reg/m16, xmm,| MRI  | V/V                   | SSE4_1            | Extract the word specified by imm8 from\n| imm8                                  |      |                       |                   | xmm and copy it to lowest 16 bits of   \n|                                       |      |                       |                   | reg or m16. Zero-extend the result in  \n|                                       |      |                       |                   | the destination, r32 or r64.           \n| VEX.128.66.0F.W0 C5 /r ib VPEXTRW reg,| RMI  | V2/V                  | AVX               | Extract the word specified by imm8 from\n| xmm1, imm8                            |      |                       |                   | xmm1 and move it to reg, bits 15:0.    \n|                                       |      |                       |                   | Zeroextend the result. The upper bits  \n|                                       |      |                       |                   | of r64/r32 is filled with zeros.       \n| VEX.128.66.0F3A.W0 15 /r ib VPEXTRW   | MRI  | V/V                   | AVX               | Extract a word integer value from xmm2 \n| reg/m16, xmm2, imm8                   |      |                       |                   | at the source word offset specified    \n|                                       |      |                       |                   | by imm8 into reg or m16. The upper bits\n|                                       |      |                       |                   | of r64/r32 is filled with zeros.       \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A. 2. In 64-bit mode, VEX.W1 is ignored for VPEXTRW (similar\nto legacy REX.W=1 prefix in PEXTRW).\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8     | NA       \n| MRI  | ModRM:r/m (w)| ModRM:reg (r)| imm8     | NA       \n\nDescription:\nCopies the word in the source operand (second operand) specified by the count\noperand (third operand) to the destination operand (first operand). The source\noperand can be an MMX technology register or an XMM register. The destination\noperand can be the low word of a general-purpose register or a 16-bit memory\naddress. The count operand is an 8-bit immediate. When specifying a word location\nin an MMX technology register, the 2 least-significant bits of the count operand\nspecify the location; for an XMM register, the 3 least-significant bits specify\nthe location. The content of the destination register above bit 16 is cleared\n(set to all 0s).\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15, R8-15). If the destination operand\nis a general-purpose register, the default operand size is 64-bits in 64-bit\nmode. Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b,\nVEX.L must be 0, otherwise the instruction will #UD. If the destination operand\nis a register, the default operand size in 64-bit mode for VPEXTRW is 64 bits,\nthe bits above the least significant byte/word/dword data are filled with zeros.\n\nOperation:\n\nIF (DEST = Mem16)\nTHEN\n  SEL <- COUNT[2:0];\n  TEMP <- (Src >> SEL*16) AND FFFFH;\n  Mem16 <- TEMP[15:0];\nELSE IF (64-Bit Mode and destination is a general-purpose register)\n  THEN\n     FOR (PEXTRW instruction with 64-bit source operand)\n      { SEL <- COUNT[1:0];\n       TEMP <- (SRC >> (SEL * 16)) AND FFFFH;\n       r64[15:0] <- TEMP[15:0];\n       r64[63:16] <- ZERO_FILL; };\n     FOR (PEXTRW instruction with 128-bit source operand)\n      { SEL <- COUNT[2:0];\n       TEMP <- (SRC >> (SEL * 16)) AND FFFFH;\n       r64[15:0] <- TEMP[15:0];\n       r64[63:16] <- ZERO_FILL; }\n  ELSE\n     FOR (PEXTRW instruction with 64-bit source operand)\n      {\n       TEMP <- (SRC >> (SEL * 16)) AND FFFFH;\n       r32[15:0] <- TEMP[15:0];\n       r32[31:16] <- ZERO_FILL; };\n     FOR (PEXTRW instruction with 128-bit source operand)\n      {\n       TEMP <- (SRC >> (SEL * 16)) AND FFFFH;\n       r32[15:0] <- TEMP[15:0];\n       r32[31:16] <- ZERO_FILL; };\n  FI;\nFI;\n(V)PEXTRW ( dest=m16)\nSRC_Offset <- Imm8[2:0]\nMem16 <- (Src >> Src_Offset*16)\n(V)PEXTRW ( dest=reg)\nIF (64-Bit Mode )\nTHEN\n  SRC_Offset <- Imm8[2:0]\n  DEST[15:0] <- ((Src >> Src_Offset*16) AND 0FFFFh)\n  DEST[63:16] <-\uf020ZERO_FILL;\nELSE\n  SRC_Offset <- Imm8[2:0]\n  DEST[15:0] <- ((Src >> Src_Offset*16) AND 0FFFFh)\n  DEST[31:16] <-\uf020ZERO_FILL;\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PEXTRW:| int _mm_extract_pi16 (__m64 a, int n) \n| PEXTRW:| int _mm_extract_epi16 ( __m128i a, int\n|        | imm)                                  \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PEXTRW"
    }, 
    {
      "description": "-R:PHADDW", 
      "mnem": "PHADDD"
    }, 
    {
      "description": "\nPHADDSW  -  Packed Horizontal Add and Saturate:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| 0F 38 03 /r1 PHADDSW mm1, mm2/m64     | RM   | V/V                   | SSSE3             | Add 16-bit signed integers horizontally,\n|                                       |      |                       |                   | pack saturated integers to mm1.         \n| 66 0F 38 03 /r PHADDSW xmm1, xmm2/m128| RM   | V/V                   | SSSE3             | Add 16-bit signed integers horizontally,\n|                                       |      |                       |                   | pack saturated integers to xmm1.        \n| VEX.NDS.128.66.0F38.WIG 03 /r VPHADDSW| RVM  | V/V                   | AVX               | Add 16-bit signed integers horizontally,\n| xmm1, xmm2, xmm3/m128                 |      |                       |                   | pack saturated integers to xmm1.        \n| VEX.NDS.256.66.0F38.WIG 03 /r VPHADDSW| RVM  | V/V                   | AVX2              | Add 16-bit signed integers horizontally,\n| ymm1, ymm2, ymm3/m256                 |      |                       |                   | pack saturated integers to ymm1.        \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\n(V)PHADDSW adds two adjacent signed 16-bit integers horizontally from the source\nand destination operands and saturates the signed results; packs the signed,\nsaturated 16-bit results to the destination operand (first operand) When the\nsource operand is a 128-bit memory operand, the operand must be aligned on a\n16-byte boundary or a general-protection exception (#GP) will be generated.\nLegacy SSE version: Both operands can be MMX registers. The second source operand\ncan be an MMX register or a 64-bit memory location.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM\nregisters. The second source operand is an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the corresponding YMM destination register remain\nunchanged.\n\nIn 64-bit mode, use the REX prefix to access additional registers. VEX.128 encoded\nversion: The first source and destination operands are XMM registers. The second\nsource operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)\nof the destination YMM register are zeroed. VEX.256 encoded version: The first\nsource and destination operands are YMM registers. The second source operand\ncan be an YMM register or a 256-bit memory location.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPHADDSW (with 64-bit operands)\n  mm1[15-0]\n  mm1[31-16] = SaturateToSignedWord(mm1[63-48] + mm1[47-32]);\n  mm1[47-32] = SaturateToSignedWord(mm2/m64[31-16] + mm2/m64[15-0]);\n  mm1[63-48] = SaturateToSignedWord(mm2/m64[63-48] + mm2/m64[47-32]);\nPHADDSW (with 128-bit operands)\n  xmm1[15-0]= SaturateToSignedWord(xmm1[31-16] + xmm1[15-0]);\n  xmm1[31-16] = SaturateToSignedWord(xmm1[63-48] + xmm1[47-32]);\n  xmm1[47-32] = SaturateToSignedWord(xmm1[95-80] + xmm1[79-64]);\n  xmm1[63-48] = SaturateToSignedWord(xmm1[127-112] + xmm1[111-96]);\n  xmm1[79-64] = SaturateToSignedWord(xmm2/m128[31-16] + xmm2/m128[15-0]);\n  xmm1[95-80] = SaturateToSignedWord(xmm2/m128[63-48] + xmm2/m128[47-32]);\n  xmm1[111-96] = SaturateToSignedWord(xmm2/m128[95-80] + xmm2/m128[79-64]);\n  xmm1[127-112] = SaturateToSignedWord(xmm2/m128[127-112] + xmm2/m128[111-96]);\nVPHADDSW (VEX.128 encoded version)\nDEST[15:0]= SaturateToSignedWord(SRC1[31:16] + SRC1[15:0])\nDEST[31:16] = SaturateToSignedWord(SRC1[63:48] + SRC1[47:32])\nDEST[47:32] = SaturateToSignedWord(SRC1[95:80] + SRC1[79:64])\nDEST[63:48] = SaturateToSignedWord(SRC1[127:112] + SRC1[111:96])\nDEST[79:64] = SaturateToSignedWord(SRC2[31:16] + SRC2[15:0])\nDEST[95:80] = SaturateToSignedWord(SRC2[63:48] + SRC2[47:32])\nDEST[111:96] = SaturateToSignedWord(SRC2[95:80] + SRC2[79:64])\nDEST[127:112] = SaturateToSignedWord(SRC2[127:112] + SRC2[111:96])\nDEST[VLMAX-1:128] <- 0\nVPHADDSW (VEX.256 encoded version)\nDEST[15:0]= SaturateToSignedWord(SRC1[31:16] + SRC1[15:0])\nDEST[31:16] = SaturateToSignedWord(SRC1[63:48] + SRC1[47:32])\nDEST[47:32] = SaturateToSignedWord(SRC1[95:80] + SRC1[79:64])\nDEST[63:48] = SaturateToSignedWord(SRC1[127:112] + SRC1[111:96])\nDEST[79:64] = SaturateToSignedWord(SRC2[31:16] + SRC2[15:0])\nDEST[95:80] = SaturateToSignedWord(SRC2[63:48] + SRC2[47:32])\nDEST[111:96] = SaturateToSignedWord(SRC2[95:80] + SRC2[79:64])\nDEST[127:112] = SaturateToSignedWord(SRC2[127:112] + SRC2[111:96])\nDEST[143:128]= SaturateToSignedWord(SRC1[159:144] + SRC1[143:128])\nDEST[159:144] = SaturateToSignedWord(SRC1[191:176] + SRC1[175:160])\nDEST[175:160] = SaturateToSignedWord( SRC1[223:208] + SRC1[207:192])\nDEST[191:176] = SaturateToSignedWord(SRC1[255:240] + SRC1[239:224])\nDEST[207:192] = SaturateToSignedWord(SRC2[127:112] + SRC2[143:128])\nDEST[223:208] = SaturateToSignedWord(SRC2[159:144] + SRC2[175:160])\nDEST[239:224] = SaturateToSignedWord(SRC2[191-160] + SRC2[159-128])\nDEST[255:240] = SaturateToSignedWord(SRC2[255:240] + SRC2[239:224])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PHADDSW:   | __m64 _mm_hadds_pi16 (__m64 a, __m64\n|            | b)                                  \n| (V)PHADDSW:| __m128i _mm_hadds_epi16 (__m128i a, \n|            | __m128i b)                          \n| VPHADDSW:  | __m256i _mm256_hadds_epi16 (__m256i \n|            | a, __m256i b)                       \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PHADDSW"
    }, 
    {
      "description": "\nPHADDW/PHADDD  -  Packed Horizontal Add:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| 0F 38 01 /r1 PHADDW mm1, mm2/m64     | RM   | V/V                   | SSSE3             | Add 16-bit integers horizontally, pack  \n|                                      |      |                       |                   | to mm1.                                 \n| 66 0F 38 01 /r PHADDW xmm1, xmm2/m128| RM   | V/V                   | SSSE3             | Add 16-bit integers horizontally, pack  \n|                                      |      |                       |                   | to xmm1.                                \n| 0F 38 02 /r PHADDD mm1, mm2/m64      | RM   | V/V                   | SSSE3             | Add 32-bit integers horizontally, pack  \n|                                      |      |                       |                   | to mm1.                                 \n| 66 0F 38 02 /r PHADDD xmm1, xmm2/m128| RM   | V/V                   | SSSE3             | Add 32-bit integers horizontally, pack  \n|                                      |      |                       |                   | to xmm1.                                \n| VEX.NDS.128.66.0F38.WIG 01 /r VPHADDW| RVM  | V/V                   | AVX               | Add 16-bit integers horizontally, pack  \n| xmm1, xmm2, xmm3/m128                |      |                       |                   | to xmm1.                                \n| VEX.NDS.128.66.0F38.WIG 02 /r VPHADDD| RVM  | V/V                   | AVX               | Add 32-bit integers horizontally, pack  \n| xmm1, xmm2, xmm3/m128                |      |                       |                   | to xmm1.                                \n| VEX.NDS.256.66.0F38.WIG 01 /r VPHADDW| RVM  | V/V                   | AVX2              | Add 16-bit signed integers horizontally,\n| ymm1, ymm2, ymm3/m256                |      |                       |                   | pack to ymm1.                           \n| VEX.NDS.256.66.0F38.WIG 02 /r VPHADDD| RVM  | V/V                   | AVX2              | Add 32-bit signed integers horizontally,\n| ymm1, ymm2, ymm3/m256                |      |                       |                   | pack to ymm1.                           \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\n(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source\nand destination operands and packs the 16-bit signed results to the destination\noperand (first operand). (V)PHADDD adds two adjacent 32-bit signed integers\nhorizontally from the source and destination operands and packs the 32-bit signed\nresults to the destination operand (first operand). When the source operand\nis a 128-bit memory operand, the operand must be aligned on a 16-byte boundary\nor a general-protection exception (#GP) will be generated.\n\nNote that these instructions can operate on either unsigned or signed (two's\ncomplement notation) integers; however, it does not set bits in the EFLAGS register\nto indicate overflow and/or a carry. To prevent undetected overflow conditions,\nsoftware must control the ranges of the values operated on.\n\nLegacy SSE instructions: Both operands can be MMX registers. The second source\noperand can be an MMX register or a 64-bit memory location. 128-bit Legacy SSE\nversion: The first source and destination operands are XMM registers. The second\nsource operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)\nof the corresponding YMM destination register remain unchanged.\n\nIn 64-bit mode, use the REX prefix to access additional registers.\n\nVEX.128 encoded version: The first source and destination operands are XMM registers.\nThe second source operand can be an XMM register or a 128-bit memory location.\nBits (VLMAX-1:128) of the corresponding YMM register are zeroed. VEX.256 encoded\nversion: Horizontal addition of two adjacent data elements of the low 16-bytes\nof the first and second source operands are packed into the low 16-bytes of\nthe destination operand. Horizontal addition of two adjacent data elements of\nthe high 16-bytes of the first and second source operands are packed into the\nhigh 16bytes of the destination operand. The first source and destination operands\nare YMM registers. The second source operand can be an YMM register or a 256-bit\nmemory location.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\n| SRC2| Y7| Y6 S7| Y5 Figure 4-6.| Y4 S3| Y3 Dest| Y2 S3 255 256-bit VPHADDD Instruction| Y1| Y0 S4| X7 S3| X6| X5| X4 S2| X3 S1| X2 0| X1| X0 S0| SRC1\n|     |   |      |               |      |        | Operation                            |   |      |      |   |   |      |      |     |   |      |     \nOperation:\n\nPHADDW (with 64-bit operands)\n  mm1[15-0]\n  mm1[31-16] = mm1[63-48] + mm1[47-32];\n  mm1[47-32] = mm2/m64[31-16] + mm2/m64[15-0];\n  mm1[63-48] = mm2/m64[63-48] + mm2/m64[47-32];\nPHADDW (with 128-bit operands)\n  xmm1[15-0] = xmm1[31-16] + xmm1[15-0];\n  xmm1[31-16] = xmm1[63-48] + xmm1[47-32];\n  xmm1[47-32] = xmm1[95-80] + xmm1[79-64];\n  xmm1[63-48] = xmm1[127-112] + xmm1[111-96];\n  xmm1[79-64] = xmm2/m128[31-16] + xmm2/m128[15-0];\n  xmm1[95-80] = xmm2/m128[63-48] + xmm2/m128[47-32];\n  xmm1[111-96] = xmm2/m128[95-80] + xmm2/m128[79-64];\n  xmm1[127-112] = xmm2/m128[127-112] + xmm2/m128[111-96];\nVPHADDW (VEX.128 encoded version)\nDEST[15:0] <- SRC1[31:16] + SRC1[15:0]\nDEST[31:16] <- SRC1[63:48] + SRC1[47:32]\nDEST[47:32] <- SRC1[95:80] + SRC1[79:64]\nDEST[63:48] <- SRC1[127:112] + SRC1[111:96]\nDEST[79:64] <- SRC2[31:16] + SRC2[15:0]\nDEST[95:80] <- SRC2[63:48] + SRC2[47:32]\nDEST[111:96] <- SRC2[95:80] + SRC2[79:64]\nDEST[127:112] <- SRC2[127:112] + SRC2[111:96]\nDEST[VLMAX-1:128] <- 0\nVPHADDW (VEX.256 encoded version)\nDEST[15:0] <- SRC1[31:16] + SRC1[15:0]\nDEST[31:16] <- SRC1[63:48] + SRC1[47:32]\nDEST[47:32] <- SRC1[95:80] + SRC1[79:64]\nDEST[63:48] <- SRC1[127:112] + SRC1[111:96]\nDEST[79:64] <- SRC2[31:16] + SRC2[15:0]\nDEST[95:80] <- SRC2[63:48] + SRC2[47:32]\nDEST[111:96] <- SRC2[95:80] + SRC2[79:64]\nDEST[127:112] <- SRC2[127:112] + SRC2[111:96]\nDEST[143:128] <- SRC1[159:144] + SRC1[143:128]\nDEST[159:144] <- SRC1[191:176] + SRC1[175:160]\nDEST[175:160] <- SRC1[223:208] + SRC1[207:192]\nDEST[191:176] <- SRC1[255:240] + SRC1[239:224]\nDEST[207:192] <- SRC2[127:112] + SRC2[143:128]\nDEST[223:208] <- SRC2[159:144] + SRC2[175:160]\nDEST[239:224] <- SRC2[191:176] + SRC2[207:192]\nDEST[255:240] <- SRC2[223:208] + SRC2[239:224]\nPHADDD (with 64-bit operands)\n  mm1[31-0]\n  mm1[63-32] = mm2/m64[63-32] + mm2/m64[31-0];\nPHADDD (with 128-bit operands)\n  xmm1[31-0] = xmm1[63-32] + xmm1[31-0];\n  xmm1[63-32] = xmm1[127-96] + xmm1[95-64];\n  xmm1[95-64] = xmm2/m128[63-32] + xmm2/m128[31-0];\n  xmm1[127-96] = xmm2/m128[127-96] + xmm2/m128[95-64];\nVPHADDD (VEX.128 encoded version)\nDEST[31-0] <- SRC1[63-32] + SRC1[31-0]\nDEST[63-32] <- SRC1[127-96] + SRC1[95-64]\nDEST[95-64] <- SRC2[63-32] + SRC2[31-0]\nDEST[127-96] <- SRC2[127-96] + SRC2[95-64]\nDEST[VLMAX-1:128] <- 0\nVPHADDD (VEX.256 encoded version)\nDEST[31-0] <- SRC1[63-32] + SRC1[31-0]\nDEST[63-32] <- SRC1[127-96] + SRC1[95-64]\nDEST[95-64] <- SRC2[63-32] + SRC2[31-0]\nDEST[127-96] <- SRC2[127-96] + SRC2[95-64]\nDEST[159-128] <- SRC1[191-160] + SRC1[159-128]\nDEST[191-160] <- SRC1[255-224] + SRC1[223-192]\nDEST[223-192] <- SRC2[191-160] + SRC2[159-128]\nDEST[255-224] <- SRC2[255-224] + SRC2[223-192]\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PHADDW:   | __m64 _mm_hadd_pi16 (__m64 a, __m64       \n|           | b)                                        \n| PHADDD:   | __m64 _mm_hadd_pi32 (__m64 a, __m64       \n|           | b)                                        \n| (V)PHADDW:| __m128i _mm_hadd_epi16 (__m128i a, __m128i\n|           | b)                                        \n| (V)PHADDD:| __m128i _mm_hadd_epi32 (__m128i a, __m128i\n|           | b)                                        \n| VPHADDW:  | __m256i _mm256_hadd_epi16 (__m256i a,     \n|           | __m256i b)                                \n| VPHADDD:  | __m256i _mm256_hadd_epi32 (__m256i a,     \n|           | __m256i b)                                \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PHADDW"
    }, 
    {
      "description": "\nPHMINPOSUW  -  Packed Horizontal Word Minimum:\n| Opcode/Instruction                       | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| 66 0F 38 41 /r PHMINPOSUW xmm1, xmm2/m128| RM   | V/V                   | SSE4_1            | Find the minimum unsigned word in xmm2/m128\n|                                          |      |                       |                   | and place its value in the low word        \n|                                          |      |                       |                   | of xmm1 and its index in the secondlowest  \n|                                          |      |                       |                   | word of xmm1.                              \n| VEX.128.66.0F38.WIG 41 /r VPHMINPOSUW    | RM   | V/V                   | AVX               | Find the minimum unsigned word in xmm2/m128\n| xmm1, xmm2/m128                          |      |                       |                   | and place its value in the low word        \n|                                          |      |                       |                   | of xmm1 and its index in the secondlowest  \n|                                          |      |                       |                   | word of xmm1.                              \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nDetermine the minimum unsigned word value in the source operand (second operand)\nand place the unsigned\n\n| word in the low word (bits 0-15) of        | The word index of the minimum value        \n| the destination operand (first operand).   | The remaining upper bits of the destination\n| is stored in bits 16-18 of the destination | are set to zero.                           \n| operand. 128-bit Legacy SSE version:       |                                            \n| Bits (VLMAX-1:128) of the corresponding    |                                            \n| YMM destination register remain unchanged. |                                            \n| VEX.128 encoded version: Bits (VLMAX-1:128)|                                            \n| of the destination YMM register are        |                                            \n| zeroed. VEX.vvvv is reserved and must      |                                            \n| be 1111b, VEX.L must be 0, otherwise       |                                            \n| the instruction will #UD.                  |                                            \nOperation:\n\nPHMINPOSUW (128-bit Legacy SSE version)\nINDEX <- 0;\nMIN <- SRC[15:0]\nIF (SRC[31:16] < MIN)\n  THEN INDEX <- 1;\nIF (SRC[47:32] < MIN)\n  THEN INDEX <- 2;\n* Repeat operation for words 3 through 6\nIF (SRC[127:112] < MIN)\n  THEN INDEX <- 7;\nDEST[15:0] <- MIN;\nDEST[18:16] <- INDEX;\nDEST[127:19] <- 0000000000000000000000000000H;\nVPHMINPOSUW (VEX.128 encoded version)\nINDEX <- 0\nMIN <- SRC[15:0]\nIF (SRC[31:16] < MIN) THEN INDEX <- 1; MIN <- SRC[31:16]\nIF (SRC[47:32] < MIN) THEN INDEX <- 2; MIN <- SRC[47:32]\n* Repeat operation for words 3 through 6\nIF (SRC[127:112] < MIN) THEN INDEX <- 7; MIN <- SRC[127:112]\nDEST[15:0] <- MIN\nDEST[18:16] <- INDEX\nDEST[127:19] <- 0000000000000000000000000000H\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PHMINPOSUW:| __m128i _mm_minpos_epu16( __m128i packed_words);\n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PHMINPOSUW"
    }, 
    {
      "description": "-R:PHSUBW", 
      "mnem": "PHSUBD"
    }, 
    {
      "description": "\nPHSUBSW  -  Packed Horizontal Subtract and Saturate:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                 \n| 0F 38 07 /r1 PHSUBSW mm1, mm2/m64     | RM   | V/V                   | SSSE3             | Subtract 16-bit signed integer horizontally,\n|                                       |      |                       |                   | pack saturated integers to mm1.             \n| 66 0F 38 07 /r PHSUBSW xmm1, xmm2/m128| RM   | V/V                   | SSSE3             | Subtract 16-bit signed integer horizontally,\n|                                       |      |                       |                   | pack saturated integers to xmm1.            \n| VEX.NDS.128.66.0F38.WIG 07 /r VPHSUBSW| RVM  | V/V                   | AVX               | Subtract 16-bit signed integer horizontally,\n| xmm1, xmm2, xmm3/m128                 |      |                       |                   | pack saturated integers to xmm1.            \n| VEX.NDS.256.66.0F38.WIG 07 /r VPHSUBSW| RVM  | V/V                   | AVX2              | Subtract 16-bit signed integer horizontally,\n| ymm1, ymm2, ymm3/m256                 |      |                       |                   | pack saturated integers to ymm1.            \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (r, w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\n(V)PHSUBSW performs horizontal subtraction on each adjacent pair of 16-bit signed\nintegers by subtracting the most significant word from the least significant\nword of each pair in the source and destination operands. The signed, saturated\n16-bit results are packed to the destination operand (first operand). When the\nsource operand is a 128-bit memory operand, the operand must be aligned on a\n16-byte boundary or a general-protection exception (#GP) will be generated.\nLegacy SSE version: Both operands can be MMX registers. The second source operand\ncan be an MMX register or a 64-bit memory location.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM\nregisters. The second source operand is an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the corresponding YMM destination register remain\nunchanged.\n\nIn 64-bit mode, use the REX prefix to access additional registers. VEX.128 encoded\nversion: The first source and destination operands are XMM registers. The second\nsource operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)\nof the destination YMM register are zeroed. VEX.256 encoded version: The first\nsource and destination operands are YMM registers. The second source operand\ncan be an YMM register or a 256-bit memory location.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPHSUBSW (with 64-bit operands)\n  mm1[15-0] = SaturateToSignedWord(mm1[15-0] - mm1[31-16]);\n  mm1[31-16] = SaturateToSignedWord(mm1[47-32] - mm1[63-48]);\n  mm1[47-32] = SaturateToSignedWord(mm2/m64[15-0] - mm2/m64[31-16]);\n  mm1[63-48] = SaturateToSignedWord(mm2/m64[47-32] - mm2/m64[63-48]);\nPHSUBSW (with 128-bit operands)\n  xmm1[15-0] = SaturateToSignedWord(xmm1[15-0] - xmm1[31-16]);\n  xmm1[31-16] = SaturateToSignedWord(xmm1[47-32] - xmm1[63-48]);\n  xmm1[47-32] = SaturateToSignedWord(xmm1[79-64] - xmm1[95-80]);\n  xmm1[63-48] = SaturateToSignedWord(xmm1[111-96] - xmm1[127-112]);\n  xmm1[79-64] = SaturateToSignedWord(xmm2/m128[15-0] - xmm2/m128[31-16]);\n  xmm1[95-80] =SaturateToSignedWord(xmm2/m128[47-32] - xmm2/m128[63-48]);\n  xmm1[111-96] =SaturateToSignedWord(xmm2/m128[79-64] - xmm2/m128[95-80]);\n  xmm1[127-112]= SaturateToSignedWord(xmm2/m128[111-96] - xmm2/m128[127-112]);\nVPHSUBSW (VEX.128 encoded version)\nDEST[15:0]= SaturateToSignedWord(SRC1[15:0] - SRC1[31:16])\nDEST[31:16] = SaturateToSignedWord(SRC1[47:32] - SRC1[63:48])\nDEST[47:32] = SaturateToSignedWord(SRC1[79:64] - SRC1[95:80])\nDEST[63:48] = SaturateToSignedWord(SRC1[111:96] - SRC1[127:112])\nDEST[79:64] = SaturateToSignedWord(SRC2[15:0] - SRC2[31:16])\nDEST[95:80] = SaturateToSignedWord(SRC2[47:32] - SRC2[63:48])\nDEST[111:96] = SaturateToSignedWord(SRC2[79:64] - SRC2[95:80])\nDEST[127:112] = SaturateToSignedWord(SRC2[111:96] - SRC2[127:112])\nDEST[VLMAX-1:128] <- 0\nVPHSUBSW (VEX.256 encoded version)\nDEST[15:0]= SaturateToSignedWord(SRC1[15:0] - SRC1[31:16])\nDEST[31:16] = SaturateToSignedWord(SRC1[47:32] - SRC1[63:48])\nDEST[47:32] = SaturateToSignedWord(SRC1[79:64] - SRC1[95:80])\nDEST[63:48] = SaturateToSignedWord(SRC1[111:96] - SRC1[127:112])\nDEST[79:64] = SaturateToSignedWord(SRC2[15:0] - SRC2[31:16])\nDEST[95:80] = SaturateToSignedWord(SRC2[47:32] - SRC2[63:48])\nDEST[111:96] = SaturateToSignedWord(SRC2[79:64] - SRC2[95:80])\nDEST[127:112] = SaturateToSignedWord(SRC2[111:96] - SRC2[127:112])\nDEST[143:128]= SaturateToSignedWord(SRC1[143:128] - SRC1[159:144])\nDEST[159:144] = SaturateToSignedWord(SRC1[175:160] - SRC1[191:176])\nDEST[175:160] = SaturateToSignedWord(SRC1[207:192] - SRC1[223:208])\nDEST[191:176] = SaturateToSignedWord(SRC1[239:224] - SRC1[255:240])\nDEST[207:192] = SaturateToSignedWord(SRC2[143:128] - SRC2[159:144])\nDEST[223:208] = SaturateToSignedWord(SRC2[175:160] - SRC2[191:176])\nDEST[239:224] = SaturateToSignedWord(SRC2[207:192] - SRC2[223:208])\nDEST[255:240] = SaturateToSignedWord(SRC2[239:224] - SRC2[255:240])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PHSUBSW:   | __m64 _mm_hsubs_pi16 (__m64 a, __m64\n|            | b)                                  \n| (V)PHSUBSW:| __m128i _mm_hsubs_epi16 (__m128i a, \n|            | __m128i b)                          \n| VPHSUBSW:  | __m256i _mm256_hsubs_epi16 (__m256i \n|            | a, __m256i b)                       \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PHSUBSW"
    }, 
    {
      "description": "\nPHSUBW/PHSUBD  -  Packed Horizontal Subtract:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                  \n| 0F 38 05 /r1 PHSUBW mm1, mm2/m64     | RM   | V/V                   | SSSE3             | Subtract 16-bit signed integers horizontally,\n|                                      |      |                       |                   | pack to mm1.                                 \n| 66 0F 38 05 /r PHSUBW xmm1, xmm2/m128| RM   | V/V                   | SSSE3             | Subtract 16-bit signed integers horizontally,\n|                                      |      |                       |                   | pack to xmm1.                                \n| 0F 38 06 /r PHSUBD mm1, mm2/m64      | RM   | V/V                   | SSSE3             | Subtract 32-bit signed integers horizontally,\n|                                      |      |                       |                   | pack to mm1.                                 \n| 66 0F 38 06 /r PHSUBD xmm1, xmm2/m128| RM   | V/V                   | SSSE3             | Subtract 32-bit signed integers horizontally,\n|                                      |      |                       |                   | pack to xmm1.                                \n| VEX.NDS.128.66.0F38.WIG 05 /r VPHSUBW| RVM  | V/V                   | AVX               | Subtract 16-bit signed integers horizontally,\n| xmm1, xmm2, xmm3/m128                |      |                       |                   | pack to xmm1.                                \n| VEX.NDS.128.66.0F38.WIG 06 /r VPHSUBD| RVM  | V/V                   | AVX               | Subtract 32-bit signed integers horizontally,\n| xmm1, xmm2, xmm3/m128                |      |                       |                   | pack to xmm1.                                \n| VEX.NDS.256.66.0F38.WIG 05 /r VPHSUBW| RVM  | V/V                   | AVX2              | Subtract 16-bit signed integers horizontally,\n| ymm1, ymm2, ymm3/m256                |      |                       |                   | pack to ymm1.                                \n| VEX.NDS.256.66.0F38.WIG 06 /r VPHSUBD| RVM  | V/V                   | AVX2              | Subtract 32-bit signed integers horizontally,\n| ymm1, ymm2, ymm3/m256                |      |                       |                   | pack to ymm1.                                \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (r, w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\n(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed\nintegers by subtracting the most significant word from the least significant\nword of each pair in the source and destination operands, and packs the signed\n16-bit results to the destination operand (first operand). (V)PHSUBD performs\nhorizontal subtraction on each adjacent pair of 32-bit signed integers by subtracting\nthe most significant doubleword from the least significant doubleword of each\npair, and packs the signed 32-bit result to the destination operand. When the\nsource operand is a 128-bit memory operand, the operand must be aligned on a\n16-byte boundary or a general-protection exception (#GP) will be generated.\n\nLegacy SSE version: Both operands can be MMX registers. The second source operand\ncan be an MMX register or a 64-bit memory location. 128-bit Legacy SSE version:\nThe first source and destination operands are XMM registers. The second source\noperand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)\nof the corresponding YMM destination register remain unchanged.\n\nIn 64-bit mode, use the REX prefix to access additional registers. VEX.128 encoded\nversion: The first source and destination operands are XMM registers. The second\nsource operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)\nof the destination YMM register are zeroed.\n\nVEX.256 encoded version: The first source and destination operands are YMM registers.\nThe second source operand can be an YMM register or a 256-bit memory location.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPHSUBW (with 64-bit operands)\n  mm1[15-0] = mm1[15-0] - mm1[31-16];\n  mm1[31-16] = mm1[47-32] - mm1[63-48];\n  mm1[47-32] = mm2/m64[15-0] - mm2/m64[31-16];\n  mm1[63-48] = mm2/m64[47-32] - mm2/m64[63-48];\nPHSUBW (with 128-bit operands)\n  xmm1[15-0] = xmm1[15-0] - xmm1[31-16];\n  xmm1[31-16] = xmm1[47-32] - xmm1[63-48];\n  xmm1[47-32] = xmm1[79-64] - xmm1[95-80];\n  xmm1[63-48] = xmm1[111-96] - xmm1[127-112];\n  xmm1[79-64] = xmm2/m128[15-0] - xmm2/m128[31-16];\n  xmm1[95-80] = xmm2/m128[47-32] - xmm2/m128[63-48];\n  xmm1[111-96] = xmm2/m128[79-64] - xmm2/m128[95-80];\n  xmm1[127-112] = xmm2/m128[111-96] - xmm2/m128[127-112];\nVPHSUBW (VEX.128 encoded version)\nDEST[15:0] <- SRC1[15:0] - SRC1[31:16]\nDEST[31:16] <- SRC1[47:32] - SRC1[63:48]\nDEST[47:32] <- SRC1[79:64] - SRC1[95:80]\nDEST[63:48] <- SRC1[111:96] - SRC1[127:112]\nDEST[79:64] <- SRC2[15:0] - SRC2[31:16]\nDEST[95:80] <- SRC2[47:32] - SRC2[63:48]\nDEST[111:96] <- SRC2[79:64] - SRC2[95:80]\nDEST[127:112] <- SRC2[111:96] - SRC2[127:112]\nDEST[VLMAX-1:128] <- 0\nVPHSUBW (VEX.256 encoded version)\nDEST[15:0] <- SRC1[15:0] - SRC1[31:16]\nDEST[31:16] <- SRC1[47:32] - SRC1[63:48]\nDEST[47:32] <- SRC1[79:64] - SRC1[95:80]\nDEST[63:48] <- SRC1[111:96] - SRC1[127:112]\nDEST[79:64] <- SRC2[15:0] - SRC2[31:16]\nDEST[95:80] <- SRC2[47:32] - SRC2[63:48]\nDEST[111:96] <- SRC2[79:64] - SRC2[95:80]\nDEST[127:112] <- SRC2[111:96] - SRC2[127:112]\nDEST[143:128] <- SRC1[143:128] - SRC1[159:144]\nDEST[159:144] <- SRC1[175:160] - SRC1[191:176]\nDEST[175:160] <- SRC1[207:192] - SRC1[223:208]\nDEST[191:176] <- SRC1[239:224] - SRC1[255:240]\nDEST[207:192] <- SRC2[143:128] - SRC2[159:144]\nDEST[223:208] <- SRC2[175:160] - SRC2[191:176]\nDEST[239:224] <- SRC2[207:192] - SRC2[223:208]\nDEST[255:240] <- SRC2[239:224] - SRC2[255:240]\nPHSUBD (with 64-bit operands)\n  mm1[31-0] = mm1[31-0] - mm1[63-32];\n  mm1[63-32] = mm2/m64[31-0] - mm2/m64[63-32];\nPHSUBD (with 128-bit operands)\n  xmm1[31-0] = xmm1[31-0] - xmm1[63-32];\n  xmm1[63-32] = xmm1[95-64] - xmm1[127-96];\n  xmm1[95-64] = xmm2/m128[31-0] - xmm2/m128[63-32];\n  xmm1[127-96] = xmm2/m128[95-64] - xmm2/m128[127-96];\nVPHSUBD (VEX.128 encoded version)\nDEST[31-0] <- SRC1[31-0] - SRC1[63-32]\nDEST[63-32] <- SRC1[95-64] - SRC1[127-96]\nDEST[95-64] <- SRC2[31-0] - SRC2[63-32]\nDEST[127-96] <- SRC2[95-64] - SRC2[127-96]\nDEST[VLMAX-1:128] <- 0\nVPHSUBD (VEX.256 encoded version)\nDEST[31:0] <- SRC1[31:0] - SRC1[63:32]\nDEST[63:32] <- SRC1[95:64] - SRC1[127:96]\nDEST[95:64] <- SRC2[31:0] - SRC2[63:32]\nDEST[127:96] <- SRC2[95:64] - SRC2[127:96]\nDEST[159:128] <- SRC1[159:128] - SRC1[191:160]\nDEST[191:160] <- SRC1[223:192] - SRC1[255:224]\nDEST[223:192] <- SRC2[159:128] - SRC2[191:160]\nDEST[255:224] <- SRC2[223:192] - SRC2[255:224]\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PHSUBW:   | __m64 _mm_hsub_pi16 (__m64 a, __m64       \n|           | b)                                        \n| PHSUBD:   | __m64 _mm_hsub_pi32 (__m64 a, __m64       \n|           | b)                                        \n| (V)PHSUBW:| __m128i _mm_hsub_epi16 (__m128i a, __m128i\n|           | b)                                        \n| (V)PHSUBD:| __m128i _mm_hsub_epi32 (__m128i a, __m128i\n|           | b)                                        \n| VPHSUBW:  | __m256i _mm256_hsub_epi16 (__m256i a,     \n|           | __m256i b)                                \n| VPHSUBD:  | __m256i _mm256_hsub_epi32 (__m256i a,     \n|           | __m256i b)                                \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PHSUBW"
    }, 
    {
      "description": "\nPINSRB/PINSRD/PINSRQ  -  Insert Byte/Dword/Qword:\n| Opcode/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| 66 0F 3A 20 /r ib PINSRB xmm1, r32/m8, | RMI  | V/V                   | SSE4_1            | Insert a byte integer value from r32/m8  \n| imm8                                   |      |                       |                   | into xmm1 at the destination element     \n|                                        |      |                       |                   | in xmm1 specified by imm8.               \n| 66 0F 3A 22 /r ib PINSRD xmm1, r/m32,  | RMI  | V/V                   | SSE4_1            | Insert a dword integer value from r/m32  \n| imm8                                   |      |                       |                   | into the xmm1 at the destination element \n|                                        |      |                       |                   | specified by imm8.                       \n| 66 REX.W 0F 3A 22 /r ib PINSRQ xmm1,   | RMI  | V/N. E.               | SSE4_1            | Insert a qword integer value from r/m64  \n| r/m64, imm8                            |      |                       |                   | into the xmm1 at the destination element \n|                                        |      |                       |                   | specified by imm8.                       \n| VEX.NDS.128.66.0F3A.W0 20 /r ib VPINSRB| RVMI | V1/V                  | AVX               | Merge a byte integer value from r32/m8   \n| xmm1, xmm2, r32/m8, imm8               |      |                       |                   | and rest from xmm2 into xmm1 at the      \n|                                        |      |                       |                   | byte offset in imm8.                     \n| VEX.NDS.128.66.0F3A.W0 22 /r ib VPINSRD| RVMI | V/V                   | AVX               | Insert a dword integer value from r32/m32\n| xmm1, xmm2, r/m32, imm8                |      |                       |                   | and rest from xmm2 into xmm1 at the      \n|                                        |      |                       |                   | dword offset in imm8.                    \n| VEX.NDS.128.66.0F3A.W1 22 /r ib VPINSRQ| RVMI | V/I                   | AVX               | Insert a qword integer value from r64/m64\n| xmm1, xmm2, r/m64, imm8                |      |                       |                   | and rest from xmm2 into xmm1 at the      \n|                                        |      |                       |                   | qword offset in imm8.                    \nNotes: 1. In 64-bit mode, VEX.W1 is ignored for VPINSRB (similar to legacy REX.W=1\nprefix with PINSRB).\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nCopies a byte/dword/qword from the source operand (second operand) and inserts\nit in the destination operand (first operand) at the location specified with\nthe count operand (third operand). (The other elements in the destination register\nare left untouched.) The source operand can be a general-purpose register or\na memory location. (When the source operand is a general-purpose register, PINSRB\ncopies the low byte of the register.) The destination operand is an XMM register.\nThe count operand is an 8-bit immediate. When specifying a qword[dword, byte]location\nin an an XMM register, the [2, 4] least-significant bit(s) of the count operand\nspecify the location. In 64-bit mode, using a REX prefix in the form of REX.R\npermits this instruction to access additional registers (XMM8-XMM15, R8-15).\nUse of REX.W permits the use of 64 bit general purpose registers. 128-bit Legacy\nSSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register\nremain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128) of the destination\nYMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.\nAttempt to execute VPINSRQ in non-64-bit mode will cause #UD.\n\nOperation:\n\nCASE OF\n  PINSRB: SEL <- COUNT[3:0];\n       MASK <- (0FFH << (SEL * 8));\n       TEMP <- (((SRC[7:0] << (SEL *8)) AND MASK);\n  PINSRD: SEL <- COUNT[1:0];\n       MASK <- (0FFFFFFFFH << (SEL * 32));\n       TEMP <- (((SRC << (SEL *32)) AND MASK)\n  PINSRQ: SEL <- COUNT[0]\n       MASK <- (0FFFFFFFFFFFFFFFFH << (SEL * 64));\n       TEMP <- (((SRC << (SEL *32)) AND MASK)\nESAC;\n     DEST <- ((DEST AND NOT MASK) OR TEMP);\nVPINSRB (VEX.128 encoded version)\nSEL <- imm8[3:0]\nDEST[127:0] <- write_b_element(SEL, SRC2, SRC1)\nDEST[VLMAX-1:128] <- 0\nVPINSRD (VEX.128 encoded version)\nSEL <- imm8[1:0]\nDEST[127:0] <- write_d_element(SEL, SRC2, SRC1)\nDEST[VLMAX-1:128] <- 0\nVPINSRQ (VEX.128 encoded version)\nSEL <- imm8[0]\nDEST[127:0] <- write_q_element(SEL, SRC2, SRC1)\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PINSRB:| __m128i _mm_insert_epi8 (__m128i s1, \n|        | int s2, const int ndx);              \n| PINSRD:| __m128i _mm_insert_epi32 (__m128i s2,\n|        | int s, const int ndx);               \n| PINSRQ:| __m128i _mm_insert_epi64(__m128i s2, \n|        | __int64 s, const int ndx);           \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L = 1. If VPINSRQ in non-64-bit\n|    | mode with VEX.W=1.                    \n", 
      "mnem": "PINSRB"
    }, 
    {
      "description": "-R:PINSRB", 
      "mnem": "PINSRD"
    }, 
    {
      "description": "-R:PINSRB", 
      "mnem": "PINSRQ"
    }, 
    {
      "description": "\nPINSRW - Insert Word:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                               \n| 0F C4 /r ib1 PINSRW mm, r32/m16, imm8| RMI  | V/V                   | SSE               | Insert the low word from r32 or from      \n|                                      |      |                       |                   | m16 into mm at the word position specified\n|                                      |      |                       |                   | by imm8.                                  \n| 66 0F C4 /r ib PINSRW xmm, r32/m16,  | RMI  | V/V                   | SSE2              | Move the low word of r32 or from m16      \n| imm8                                 |      |                       |                   | into xmm at the word position specified   \n|                                      |      |                       |                   | by imm8.                                  \n| VEX.NDS.128.66.0F.W0 C4 /r ib VPINSRW| RVMI | V2/V                  | AVX               | Insert a word integer value from r32/m16  \n| xmm1, xmm2, r32/m16, imm8            |      |                       |                   | and rest from xmm2 into xmm1 at the       \n|                                      |      |                       |                   | word offset in imm8.                      \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A. 2. In 64-bit mode, VEX.W1 is ignored for VPINSRW (similar\nto legacy REX.W=1 prefix in PINSRW).\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nCopies a word from the source operand (second operand) and inserts it in the\ndestination operand (first operand) at the location specified with the count\noperand (third operand). (The other words in the destination register are left\nuntouched.) The source operand can be a general-purpose register or a 16-bit\nmemory location. (When the source operand is a general-purpose register, the\nlow word of the register is copied.) The destination operand can be an MMX technology\nregister or an XMM register. The count operand is an 8-bit immediate. When specifying\na word location in an MMX technology register, the 2 least-significant bits\nof the count operand specify the location; for an XMM register, the 3 least-significant\nbits specify the location.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15, R8-15). 128-bit Legacy SSE version:\nBits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register\nare zeroed. VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPINSRW (with 64-bit source operand)\n  SEL <- COUNT AND 3H;\n     CASE (Determine word position) OF\n       SEL <- 0:\n       SEL <- 1:\n       SEL <- 2:\n       SEL <- 3:\n  DEST <- (DEST AND NOT MASK) OR (((SRC << (SEL * 16)) AND MASK);\nPINSRW (with 128-bit source operand)\n  SEL <- COUNT AND 7H;\n     CASE (Determine word position) OF\n       SEL <- 0:\n       SEL <- 1:\n       SEL <- 2:\n       SEL <- 3:\n       SEL <- 4:\n       SEL <- 5:\n       SEL <- 6:\n       SEL <- 7:\n  DEST <- (DEST AND NOT MASK) OR (((SRC << (SEL * 16)) AND MASK);\nVPINSRW (VEX.128 encoded version)\nSEL <- imm8[2:0]\nDEST[127:0] <- write_w_element(SEL, SRC2, SRC1)\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PINSRW:| __m64 _mm_insert_pi16 (__m64 a, int  \n|        | d, int n)                            \n| PINSRW:| __m128i _mm_insert_epi16 ( __m128i a,\n|        | int b, int imm)                      \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L = 1. If VPINSRW in non-64-bit\n|    | mode with VEX.W=1.                    \n", 
      "mnem": "PINSRW"
    }, 
    {
      "description": "\nPMADDUBSW  -  Multiply and Add Packed Signed and Unsigned Bytes:\n| Opcode/Instruction                      | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                         \n| 0F 38 04 /r1 PMADDUBSW mm1, mm2/m64     | RM   | V/V                   | SSSE3             | Multiply signed and unsigned bytes, \n|                                         |      |                       |                   | add horizontal pair of signed words,\n|                                         |      |                       |                   | pack saturated signed-words to mm1. \n| 66 0F 38 04 /r PMADDUBSW xmm1, xmm2/m128| RM   | V/V                   | SSSE3             | Multiply signed and unsigned bytes, \n|                                         |      |                       |                   | add horizontal pair of signed words,\n|                                         |      |                       |                   | pack saturated signed-words to xmm1.\n| VEX.NDS.128.66.0F38.WIG 04 /r VPMADDUBSW| RVM  | V/V                   | AVX               | Multiply signed and unsigned bytes, \n| xmm1, xmm2, xmm3/m128                   |      |                       |                   | add horizontal pair of signed words,\n|                                         |      |                       |                   | pack saturated signed-words to xmm1.\n| VEX.NDS.256.66.0F38.WIG 04 /r VPMADDUBSW| RVM  | V/V                   | AVX2              | Multiply signed and unsigned bytes, \n| ymm1, ymm2, ymm3/m256                   |      |                       |                   | add horizontal pair of signed words,\n|                                         |      |                       |                   | pack saturated signed-words to ymm1.\nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\n(V)PMADDUBSW multiplies vertically each unsigned byte of the destination operand\n(first operand) with the corresponding signed byte of the source operand (second\noperand), producing intermediate signed 16-bit integers. Each adjacent pair\nof signed words is added and the saturated result is packed to the destination\noperand. For example, the lowest-order bytes (bits 7-0) in the source and destination\noperands are multiplied and the intermediate signed word result is added with\nthe corresponding intermediate result from the 2nd lowest-order bytes (bits\n15-8) of the operands; the sign-saturated result is stored in the lowest word\nof the destination register (15-0). The same operation is performed on the other\npairs of adjacent bytes. Both operands can be MMX register or XMM registers.\nWhen the source operand is a 128-bit memory operand, the operand must be aligned\non a 16-byte boundary or a general-protection exception (#GP) will be generated.\n\nIn 64-bit mode, use the REX prefix to access additional registers. 128-bit Legacy\nSSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register\nremain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128) of the destination\nYMM register are zeroed. VEX.256 encoded version: The first source and destination\noperands are YMM registers. The second source operand can be an YMM register\nor a 256-bit memory location.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPMADDUBSW (with 64 bit operands)\n  DEST[15-0] = SaturateToSignedWord(SRC[15-8]*DEST[15-8]+SRC[7-0]*DEST[7-0]);\n  DEST[31-16] = SaturateToSignedWord(SRC[31-24]*DEST[31-24]+SRC[23-16]*DEST[23-16]);\n  DEST[47-32] = SaturateToSignedWord(SRC[47-40]*DEST[47-40]+SRC[39-32]*DEST[39-32]);\n  DEST[63-48] = SaturateToSignedWord(SRC[63-56]*DEST[63-56]+SRC[55-48]*DEST[55-48]);\nPMADDUBSW (with 128 bit operands)\n  DEST[15-0] = SaturateToSignedWord(SRC[15-8]* DEST[15-8]+SRC[7-0]*DEST[7-0]);\n  // Repeat operation for 2nd through 7th word\n  SRC1/DEST[127-112] = SaturateToSignedWord(SRC[127-120]*DEST[127-120]+ SRC[119-112]* DEST[119-112]);\nVPMADDUBSW (VEX.128 encoded version)\nDEST[15:0] <- SaturateToSignedWord(SRC2[15:8]* SRC1[15:8]+SRC2[7:0]*SRC1[7:0])\n// Repeat operation for 2nd through 7th word\nDEST[127:112] <- SaturateToSignedWord(SRC2[127:120]*SRC1[127:120]+ SRC2[119:112]* SRC1[119:112])\nDEST[VLMAX-1:128] <- 0\nVPMADDUBSW (VEX.256 encoded version)\nDEST[15:0] <- SaturateToSignedWord(SRC2[15:8]* SRC1[15:8]+SRC2[7:0]*SRC1[7:0])\n// Repeat operation for 2nd through 15th word\nDEST[255:240] <- SaturateToSignedWord(SRC2[255:248]*SRC1[255:248]+ SRC2[247:240]* SRC1[247:240])\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PMADDUBSW:   | __m64 _mm_maddubs_pi16 (__m64 a, __m64\n|              | b)                                    \n| (V)PMADDUBSW:| __m128i _mm_maddubs_epi16 (__m128i a, \n|              | __m128i b)                            \n| VPMADDUBSW:  | __m256i _mm256_maddubs_epi16 (__m256i \n|              | a, __m256i b)                         \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMADDUBSW"
    }, 
    {
      "description": "\nPMADDWD - Multiply and Add Packed Integers:\n| Opcode/Instruction                  | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| 0F F5 /r1 PMADDWD mm, mm/m64        | RM   | V/V                   | MMX               | Multiply the packed words in mm by the     \n|                                     |      |                       |                   | packed words in mm/m64, add adjacent       \n|                                     |      |                       |                   | doubleword results, and store in mm.       \n| 66 0F F5 /r PMADDWD xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Multiply the packed word integers in       \n|                                     |      |                       |                   | xmm1 by the packed word integers in        \n|                                     |      |                       |                   | xmm2/m128, add adjacent doubleword results,\n|                                     |      |                       |                   | and store in xmm1.                         \n| VEX.NDS.128.66.0F.WIG F5 /r VPMADDWD| RVM  | V/V                   | AVX               | Multiply the packed word integers in       \n| xmm1, xmm2, xmm3/m128               |      |                       |                   | xmm2 by the packed word integers in        \n|                                     |      |                       |                   | xmm3/m128, add adjacent doubleword results,\n|                                     |      |                       |                   | and store in xmm1.                         \n| VEX.NDS.256.66.0F.WIG F5 /r VPMADDWD| RVM  | V/V                   | AVX2              | Multiply the packed word integers in       \n| ymm1, ymm2, ymm3/m256               |      |                       |                   | ymm2 by the packed word integers in        \n|                                     |      |                       |                   | ymm3/m256, add adjacent doubleword results,\n|                                     |      |                       |                   | and store in ymm1.                         \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nMultiplies the individual signed words of the destination operand (first operand)\nby the corresponding signed words of the source operand (second operand), producing\ntemporary signed, doubleword results. The adjacent doubleword results are then\nsummed and stored in the destination operand. For example, the corresponding\nlow-order words (15-0) and (31-16) in the source and destination operands are\nmultiplied by one another and the doubleword results are added together and\nstored in the low doubleword of the destination register (31-0). The same operation\nis performed on the other pairs of adjacent words. (Figure 4-7 shows this operation\nwhen using 64-bit operands).\n\nThe (V)PMADDWD instruction wraps around only in one situation: when the 2 pairs\nof words being operated on in a group are all 8000H. In this case, the result\nwraps around to 80000000H.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). Legacy SSE version: The first source\nand destination operands are MMX registers. The second source operand is an\nMMX register or a 64-bit memory location.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM\nregisters. The second source operand is an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the corresponding YMM destination register remain\nunchanged. VEX.128 encoded version: The first source and destination operands\nare XMM registers. The second source operand is an XMM register or a 128-bit\nmemory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or\na 256-bit memory location. The first source and destination operands are YMM\nregisters.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\n| SRC | X3        | X2| X1        | X0        \n| DEST| Y3 X2 * Y2| Y2| Y1 X1 * Y1| Y0 X0 * Y0\nDEST\n\n| (X3*Y3) + (X2*Y2)                   | (X1*Y1) + (X0*Y0)\n| PMADDWD Execution Model Using 64-bit| Figure 4-7.      \n| Operands                            |                  \nOperation:\n\nPMADDWD (with 64-bit operands)\n  DEST[31:0] <- (DEST[15:0] * SRC[15:0]) + (DEST[31:16] * SRC[31:16]);\n  DEST[63:32] <- (DEST[47:32] * SRC[47:32]) + (DEST[63:48] * SRC[63:48]);\nPMADDWD (with 128-bit operands)\n  DEST[31:0] <- (DEST[15:0] * SRC[15:0]) + (DEST[31:16] * SRC[31:16]);\n  DEST[63:32] <- (DEST[47:32] * SRC[47:32]) + (DEST[63:48] * SRC[63:48]);\n  DEST[95:64] <- (DEST[79:64] * SRC[79:64]) + (DEST[95:80] * SRC[95:80]);\n  DEST[127:96] <- (DEST[111:96] * SRC[111:96]) + (DEST[127:112] * SRC[127:112]);\nVPMADDWD (VEX.128 encoded version)\nDEST[31:0] <- (SRC1[15:0] * SRC2[15:0]) + (SRC1[31:16] * SRC2[31:16])\nDEST[63:32] <- (SRC1[47:32] * SRC2[47:32]) + (SRC1[63:48] * SRC2[63:48])\nDEST[95:64] <- (SRC1[79:64] * SRC2[79:64]) + (SRC1[95:80] * SRC2[95:80])\nDEST[127:96] <- (SRC1[111:96] * SRC2[111:96]) + (SRC1[127:112] * SRC2[127:112])\nDEST[VLMAX-1:128] <- 0\nVPMADDWD (VEX.256 encoded version)\nDEST[31:0] <- (SRC1[15:0] * SRC2[15:0]) + (SRC1[31:16] * SRC2[31:16])\nDEST[63:32] <- (SRC1[47:32] * SRC2[47:32]) + (SRC1[63:48] * SRC2[63:48])\nDEST[95:64] <- (SRC1[79:64] * SRC2[79:64]) + (SRC1[95:80] * SRC2[95:80])\nDEST[127:96] <- (SRC1[111:96] * SRC2[111:96]) + (SRC1[127:112] * SRC2[127:112])\nDEST[159:128] <- (SRC1[143:128] * SRC2[143:128]) + (SRC1[159:144] * SRC2[159:144])\nDEST[191:160] <- (SRC1[175:160] * SRC2[175:160]) + (SRC1[191:176] * SRC2[191:176])\nDEST[223:192] <- (SRC1[207:192] * SRC2[207:192]) + (SRC1[223:208] * SRC2[223:208])\nDEST[255:224] <- (SRC1[239:224] * SRC2[239:224]) + (SRC1[255:240] * SRC2[255:240])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PMADDWD:   | __m64 _mm_madd_pi16(__m64 m1, __m64\n|            | m2)                                \n| (V)PMADDWD:| __m128i _mm_madd_epi16 ( __m128i a,\n|            | __m128i b)                         \n| VPMADDWD:  | __m256i _mm256_madd_epi16 ( __m256i\n|            | a, __m256i b)                      \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMADDWD"
    }, 
    {
      "description": "\nPMAXSB  -  Maximum of Packed Signed Byte Integers:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                           \n| 66 0F 38 3C /r PMAXSB xmm1, xmm2/m128| RM   | V/V                   | SSE4_1            | Compare packed signed byte integers   \n|                                      |      |                       |                   | in xmm1 and xmm2/m128 and store packed\n|                                      |      |                       |                   | maximum values in xmm1.               \n| VEX.NDS.128.66.0F38.WIG 3C /r VPMAXSB| RVM  | V/V                   | AVX               | Compare packed signed byte integers   \n| xmm1, xmm2, xmm3/m128                |      |                       |                   | in xmm2 and xmm3/m128 and store packed\n|                                      |      |                       |                   | maximum values in xmm1.               \n| VEX.NDS.256.66.0F38.WIG 3C /r VPMAXSB| RVM  | V/V                   | AVX2              | Compare packed signed byte integers   \n| ymm1, ymm2, ymm3/m256                |      |                       |                   | in ymm2 and ymm3/m128 and store packed\n|                                      |      |                       |                   | maximum values in ymm1.               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nCompares packed signed byte integers in the destination operand (first operand)\nand the source operand (second operand), and returns the maximum for each packed\nvalue in the destination operand. 128-bit Legacy SSE version: The first source\nand destination operands are XMM registers. The second source operand is an\nXMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: The first\nsource and destination operands are XMM registers. The second source operand\nis an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination\nYMM register are zeroed. VEX.256 encoded version: The second source operand\ncan be an YMM register or a 256-bit memory location. The first source and destination\noperands are YMM registers.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nIF (DEST[7:0] > SRC[7:0])\n  THEN DEST[7:0] <- DEST[7:0];\n  ELSE DEST[7:0] <- SRC[7:0]; FI;\nIF (DEST[15:8] > SRC[15:8])\n  THEN DEST[15:8] <- DEST[15:8];\n  ELSE DEST[15:8] <- SRC[15:8]; FI;\nIF (DEST[23:16] > SRC[23:16])\n  THEN DEST[23:16] <- DEST[23:16];\n  ELSE DEST[23:16] <- SRC[23:16]; FI;\nIF (DEST[31:24] > SRC[31:24])\n  THEN DEST[31:24] <- DEST[31:24];\n  ELSE DEST[31:24] <- SRC[31:24]; FI;\nIF (DEST[39:32] > SRC[39:32])\n  THEN DEST[39:32] <- DEST[39:32];\n  ELSE DEST[39:32] <- SRC[39:32]; FI;\nIF (DEST[47:40] > SRC[47:40])\n  THEN DEST[47:40] <- DEST[47:40];\n  ELSE DEST[47:40] <- SRC[47:40]; FI;\nIF (DEST[55:48] > SRC[55:48])\n  THEN DEST[55:48] <- DEST[55:48];\n  ELSE DEST[55:48] <- SRC[55:48]; FI;\nIF (DEST[63:56] > SRC[63:56])\n  THEN DEST[63:56] <- DEST[63:56];\n  ELSE DEST[63:56] <- SRC[63:56]; FI;\nIF (DEST[71:64] > SRC[71:64])\n  THEN DEST[71:64] <- DEST[71:64];\n  ELSE DEST[71:64] <- SRC[71:64]; FI;\nIF (DEST[79:72] > SRC[79:72])\n  THEN DEST[79:72] <- DEST[79:72];\n  ELSE DEST[79:72] <- SRC[79:72]; FI;\nIF (DEST[87:80] > SRC[87:80])\n  THEN DEST[87:80] <- DEST[87:80];\n  ELSE DEST[87:80] <- SRC[87:80]; FI;\nIF (DEST[95:88] > SRC[95:88])\n  THEN DEST[95:88] <- DEST[95:88];\n  ELSE DEST[95:88] <- SRC[95:88]; FI;\nIF (DEST[103:96] > SRC[103:96])\n  THEN DEST[103:96] <- DEST[103:96];\n  ELSE DEST[103:96] <- SRC[103:96]; FI;\nIF (DEST[111:104] > SRC[111:104])\n  THEN DEST[111:104] <- DEST[111:104];\n  ELSE DEST[111:104] <- SRC[111:104]; FI;\nIF (DEST[119:112] > SRC[119:112])\n  THEN DEST[119:112] <- DEST[119:112];\n  ELSE DEST[119:112] <- SRC[119:112]; FI;\nIF (DEST[127:120] > SRC[127:120])\n  THEN DEST[127:120] <- DEST[127:120];\n  ELSE DEST[127:120] <- SRC[127:120]; FI;\nVPMAXSB (VEX.128 encoded version)\n  IF SRC1[7:0] >SRC2[7:0] THEN\n     DEST[7:0] <- SRC1[7:0];\n  ELSE\n     DEST[7:0] <- SRC2[7:0]; FI;\n  (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n  IF SRC1[127:120] >SRC2[127:120] THEN\n     DEST[127:120] <- SRC1[127:120];\n  ELSE\n     DEST[127:120] <- SRC2[127:120]; FI;\nDEST[VLMAX-1:128] <- 0\nVPMAXSB (VEX.256 encoded version)\n  IF SRC1[7:0] >SRC2[7:0] THEN\n     DEST[7:0] <- SRC1[7:0];\n  ELSE\n     DEST[15:0] <- SRC2[7:0]; FI;\n  (* Repeat operation for 2nd through 31st bytes in source and destination operands *)\n  IF SRC1[255:248] >SRC2[255:248] THEN\n     DEST[255:248] <- SRC1[255:248];\n  ELSE\n     DEST[255:248] <- SRC2[255:248]; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PMAXSB:| __m128i _mm_max_epi8 ( __m128i a, __m128i\n|           | b);                                      \n| VPMAXSB:  | __m256i _mm256_max_epi8 ( __m256i a,     \n|           | __m256i b);                              \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMAXSB"
    }, 
    {
      "description": "\nPMAXSD  -  Maximum of Packed Signed Dword Integers:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                           \n| 66 0F 38 3D /r PMAXSD xmm1, xmm2/m128| RM   | V/V                   | SSE4_1            | Compare packed signed dword integers  \n|                                      |      |                       |                   | in xmm1 and xmm2/m128 and store packed\n|                                      |      |                       |                   | maximum values in xmm1.               \n| VEX.NDS.128.66.0F38.WIG 3D /r VPMAXSD| RVM  | V/V                   | AVX               | Compare packed signed dword integers  \n| xmm1, xmm2, xmm3/m128                |      |                       |                   | in xmm2 and xmm3/m128 and store packed\n|                                      |      |                       |                   | maximum values in xmm1.               \n| VEX.NDS.256.66.0F38.WIG 3D /r VPMAXSD| RVM  | V/V                   | AVX2              | Compare packed signed dword integers  \n| ymm1, ymm2, ymm3/m256                |      |                       |                   | in ymm2 and ymm3/m128 and store packed\n|                                      |      |                       |                   | maximum values in ymm1.               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nCompares packed signed dword integers in the destination operand (first operand)\nand the source operand (second operand), and returns the maximum for each packed\nvalue in the destination operand. 128-bit Legacy SSE version: The first source\nand destination operands are XMM registers. The second source operand is an\nXMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: The first\nsource and destination operands are XMM registers. The second source operand\nis an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination\nYMM register are zeroed. VEX.256 encoded version: The second source operand\ncan be an YMM register or a 256-bit memory location. The first source and destination\noperands are YMM registers.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nIF (DEST[31:0] > SRC[31:0])\n  THEN DEST[31:0] <- DEST[31:0];\n  ELSE DEST[31:0] <- SRC[31:0]; FI;\nIF (DEST[63:32] > SRC[63:32])\n  THEN DEST[63:32] <- DEST[63:32];\n  ELSE DEST[63:32] <- SRC[63:32]; FI;\nIF (DEST[95:64] > SRC[95:64])\n  THEN DEST[95:64] <- DEST[95:64];\n  ELSE DEST[95:64] <- SRC[95:64]; FI;\nIF (DEST[127:96] > SRC[127:96])\n  THEN DEST[127:96] <- DEST[127:96];\n  ELSE DEST[127:96] <- SRC[127:96]; FI;\nVPMAXSD (VEX.128 encoded version)\n  IF SRC1[31:0] > SRC2[31:0] THEN\n     DEST[31:0] <- SRC1[31:0];\n  ELSE\n     DEST[31:0] <- SRC2[31:0]; FI;\n  (* Repeat operation for 2nd through 3rd dwords in source and destination operands *)\n  IF SRC1[127:95] > SRC2[127:95] THEN\n     DEST[127:95] <- SRC1[127:95];\n  ELSE\n     DEST[127:95] <- SRC2[127:95]; FI;\nDEST[VLMAX-1:128] <- 0\nVPMAXSD (VEX.256 encoded version)\n  IF SRC1[31:0] > SRC2[31:0] THEN\n     DEST[31:0] <- SRC1[31:0];\n  ELSE\n     DEST[31:0] <- SRC2[31:0]; FI;\n  (* Repeat operation for 2nd through 7th dwords in source and destination operands *)\n  IF SRC1[255:224] > SRC2[255:224] THEN\n     DEST[255:224] <- SRC1[255:224];\n  ELSE\n     DEST[255:224] <- SRC2[255:224]; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PMAXSD: | __m128i _mm_max_epi32 ( __m128i a, __m128i\n|         | b);                                       \n| VPMAXSD:| __m256i _mm256_max_epi32 ( __m256i a,     \n|         | __m256i b);                               \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMAXSD"
    }, 
    {
      "description": "\nPMAXSW - Maximum of Packed Signed Word Integers:\n| Opcode/Instruction                 | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| 0F EE /r1 PMAXSW mm1, mm2/m64      | RM   | V/V                   | SSE               | Compare signed word integers in mm2/m64  \n|                                    |      |                       |                   | and mm1 and return maximum values.       \n| 66 0F EE /r PMAXSW xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Compare signed word integers in xmm2/m128\n|                                    |      |                       |                   | and xmm1 and return maximum values.      \n| VEX.NDS.128.66.0F.WIG EE /r VPMAXSW| RVM  | V/V                   | AVX               | Compare packed signed word integers      \n| xmm1, xmm2, xmm3/m128              |      |                       |                   | in xmm3/m128 and xmm2 and store packed   \n|                                    |      |                       |                   | maximum values in xmm1.                  \n| VEX.NDS.256.66.0F.WIG EE /r VPMAXSW| RVM  | V/V                   | AVX2              | Compare packed signed word integers      \n| ymm1, ymm2, ymm3/m256              |      |                       |                   | in ymm3/m128 and ymm2 and store packed   \n|                                    |      |                       |                   | maximum values in ymm1.                  \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD compare of the packed signed word integers in the destination\noperand (first operand) and the source operand (second operand), and returns\nthe maximum value for each pair of word integers to the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). Legacy SSE version: The source\noperand can be an MMX technology register or a 64-bit memory location. The destination\noperand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM\nregisters. The second source operand is an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the corresponding YMM destination register remain\nunchanged. VEX.128 encoded version: The first source and destination operands\nare XMM registers. The second source operand is an XMM register or a 128-bit\nmemory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or\na 256-bit memory location. The first source and destination operands are YMM\nregisters.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPMAXSW (64-bit operands)\n  IF DEST[15:0] > SRC[15:0]) THEN\n     DEST[15:0] <- DEST[15:0];\n  ELSE\n     DEST[15:0] <- SRC[15:0]; FI;\n  (* Repeat operation for 2nd and 3rd words in source and destination operands *)\n  IF DEST[63:48] > SRC[63:48]) THEN\n     DEST[63:48] <- DEST[63:48];\n  ELSE\n     DEST[63:48] <- SRC[63:48]; FI;\nPMAXSW (128-bit operands)\n  IF DEST[15:0] > SRC[15:0]) THEN\n     DEST[15:0] <- DEST[15:0];\n  ELSE\n     DEST[15:0] <- SRC[15:0]; FI;\n  (* Repeat operation for 2nd through 7th words in source and destination operands *)\n  IF DEST[127:112] > SRC[127:112]) THEN\n     DEST[127:112] <- DEST[127:112];\n  ELSE\n     DEST[127:112] <- SRC[127:112]; FI;\nVPMAXSW (VEX.128 encoded version)\n  IF SRC1[15:0] > SRC2[15:0] THEN\n     DEST[15:0] <- SRC1[15:0];\n  ELSE\n     DEST[15:0] <- SRC2[15:0]; FI;\n  (* Repeat operation for 2nd through 7th words in source and destination operands *)\n  IF SRC1[127:112] >SRC2[127:112] THEN\n     DEST[127:112] <- SRC1[127:112];\n  ELSE\n     DEST[127:112] <- SRC2[127:112]; FI;\nDEST[VLMAX-1:128] <- 0\nVPMAXSW (VEX.256 encoded version)\n  IF SRC1[15:0] > SRC2[15:0] THEN\n     DEST[15:0] <- SRC1[15:0];\n  ELSE\n     DEST[15:0] <- SRC2[15:0]; FI;\n  (* Repeat operation for 2nd through 15th words in source and destination operands *)\n  IF SRC1[255:240] >SRC2[255:240] THEN\n     DEST[255:240] <- SRC1[255:240];\n  ELSE\n     DEST[255:240] <- SRC2[255:240]; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PMAXSW:   | __m64 _mm_max_pi16(__m64 a, __m64 b)      \n| (V)PMAXSW:| __m128i _mm_max_epi16 ( __m128i a, __m128i\n|           | b)                                        \n| VPMAXSW:  | __m256i _mm256_max_epi16 ( __m256i a,     \n|           | __m256i b)                                \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMAXSW"
    }, 
    {
      "description": "\nPMAXUB - Maximum of Packed Unsigned Byte Integers:\n| Opcode/Instruction                 | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| 0F DE /r1 PMAXUB mm1, mm2/m64      | RM   | V/V                   | SSE               | Compare unsigned byte integers in mm2/m64  \n|                                    |      |                       |                   | and mm1 and returns maximum values.        \n| 66 0F DE /r PMAXUB xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Compare unsigned byte integers in xmm2/m128\n|                                    |      |                       |                   | and xmm1 and returns maximum values.       \n| VEX.NDS.128.66.0F.WIG DE /r VPMAXUB| RVM  | V/V                   | AVX               | Compare packed unsigned byte integers      \n| xmm1, xmm2, xmm3/m128              |      |                       |                   | in xmm2 and xmm3/m128 and store packed     \n|                                    |      |                       |                   | maximum values in xmm1.                    \n| VEX.NDS.256.66.0F.WIG DE /r VPMAXUB| RVM  | V/V                   | AVX2              | Compare packed unsigned byte integers      \n| ymm1, ymm2, ymm3/m256              |      |                       |                   | in ymm2 and ymm3/m256 and store packed     \n|                                    |      |                       |                   | maximum values in ymm1.                    \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD compare of the packed unsigned byte integers in the destination\noperand (first operand) and the source operand (second operand), and returns\nthe maximum value for each pair of byte integers to the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). Legacy SSE version: The source\noperand can be an MMX technology register or a 64-bit memory location. The destination\noperand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM\nregisters. The second source operand is an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the corresponding YMM destination register remain\nunchanged. VEX.128 encoded version: The first source and destination operands\nare XMM registers. The second source operand is an XMM register or a 128-bit\nmemory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or\na 256-bit memory location. The first source and destination operands are YMM\nregisters.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPMAXUB (64-bit operands)\n  IF DEST[7:0] > SRC[17:0]) THEN\n     DEST[7:0] <- DEST[7:0];\n  ELSE\n     DEST[7:0] <- SRC[7:0]; FI;\n  (* Repeat operation for 2nd through 7th bytes in source and destination operands *)\n  IF DEST[63:56] > SRC[63:56]) THEN\n     DEST[63:56] <- DEST[63:56];\n  ELSE\n     DEST[63:56] <- SRC[63:56]; FI;\nPMAXUB (128-bit operands)\n  IF DEST[7:0] > SRC[17:0]) THEN\n     DEST[7:0] <- DEST[7:0];\n  ELSE\n     DEST[7:0] <- SRC[7:0]; FI;\n  (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n  IF DEST[127:120] > SRC[127:120]) THEN\n     DEST[127:120] <- DEST[127:120];\n  ELSE\n     DEST[127:120] <- SRC[127:120]; FI;\nVPMAXUB (VEX.128 encoded version)\n  IF SRC1[7:0] >SRC2[7:0] THEN\n     DEST[7:0] <- SRC1[7:0];\n  ELSE\n     DEST[7:0] <- SRC2[7:0]; FI;\n  (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n  IF SRC1[127:120] >SRC2[127:120] THEN\n     DEST[127:120] <- SRC1[127:120];\n  ELSE\n     DEST[127:120] <- SRC2[127:120]; FI;\nDEST[VLMAX-1:128] <- 0\nVPMAXUB (VEX.256 encoded version)\n  IF SRC1[7:0] >SRC2[7:0] THEN\n     DEST[7:0] <- SRC1[7:0];\n  ELSE\n     DEST[15:0] <- SRC2[7:0]; FI;\n  (* Repeat operation for 2nd through 31st bytes in source and destination operands *)\n  IF SRC1[255:248] >SRC2[255:248] THEN\n     DEST[255:248] <- SRC1[255:248];\n  ELSE\n     DEST[255:248] <- SRC2[255:248]; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PMAXUB:   | __m64 _mm_max_pu8(__m64 a, __m64 b)      \n| (V)PMAXUB:| __m128i _mm_max_epu8 ( __m128i a, __m128i\n|           | b)                                       \n| VPMAXUB:  | __m256i _mm256_max_epu8 ( __m256i a,     \n|           | __m256i b);                              \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMAXUB"
    }, 
    {
      "description": "\nPMAXUD  -  Maximum of Packed Unsigned Dword Integers:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                           \n| 66 0F 38 3F /r PMAXUD xmm1, xmm2/m128| RM   | V/V                   | SSE4_1            | Compare packed unsigned dword integers\n|                                      |      |                       |                   | in xmm1 and xmm2/m128 and store packed\n|                                      |      |                       |                   | maximum values in xmm1.               \n| VEX.NDS.128.66.0F38.WIG 3F /r VPMAXUD| RVM  | V/V                   | AVX               | Compare packed unsigned dword integers\n| xmm1, xmm2, xmm3/m128                |      |                       |                   | in xmm2 and xmm3/m128 and store packed\n|                                      |      |                       |                   | maximum values in xmm1.               \n| VEX.NDS.256.66.0F38.WIG 3F /r VPMAXUD| RVM  | V/V                   | AVX2              | Compare packed unsigned dword integers\n| ymm1, ymm2, ymm3/m256                |      |                       |                   | in ymm2 and ymm3/m256 and store packed\n|                                      |      |                       |                   | maximum values in ymm1.               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nCompares packed unsigned dword integers in the destination operand (first operand)\nand the source operand (second operand), and returns the maximum for each packed\nvalue in the destination operand. 128-bit Legacy SSE version: The first source\nand destination operands are XMM registers. The second source operand is an\nXMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: The first\nsource and destination operands are XMM registers. The second source operand\nis an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination\nYMM register are zeroed. VEX.256 encoded version: The second source operand\ncan be an YMM register or a 256-bit memory location. The first source and destination\noperands are YMM registers.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nIF (DEST[31:0] > SRC[31:0])\n  THEN DEST[31:0] <- DEST[31:0];\n  ELSE DEST[31:0] <- SRC[31:0]; FI;\nIF (DEST[63:32] > SRC[63:32])\n  THEN DEST[63:32] <- DEST[63:32];\n  ELSE DEST[63:32] <- SRC[63:32]; FI;\nIF (DEST[95:64] > SRC[95:64])\n  THEN DEST[95:64] <- DEST[95:64];\n  ELSE DEST[95:64] <- SRC[95:64]; FI;\nIF (DEST[127:96] > SRC[127:96])\n  THEN DEST[127:96] <- DEST[127:96];\n  ELSE DEST[127:96] <- SRC[127:96]; FI;\nVPMAXUD (VEX.128 encoded version)\n  IF SRC1[31:0] > SRC2[31:0] THEN\n     DEST[31:0] <- SRC1[31:0];\n  ELSE\n     DEST[31:0] <- SRC2[31:0]; FI;\n  (* Repeat operation for 2nd through 3rd dwords in source and destination operands *)\n  IF SRC1[127:95] > SRC2[127:95] THEN\n     DEST[127:95] <- SRC1[127:95];\n  ELSE\n     DEST[127:95] <- SRC2[127:95]; FI;\nDEST[VLMAX-1:128] <- 0\nVPMAXUD (VEX.256 encoded version)\n  IF SRC1[31:0] > SRC2[31:0] THEN\n     DEST[31:0] <- SRC1[31:0];\n  ELSE\n     DEST[31:0] <- SRC2[31:0]; FI;\n  (* Repeat operation for 2nd through 7th dwords in source and destination operands *)\n  IF SRC1[255:224] > SRC2[255:224] THEN\n     DEST[255:224] <- SRC1[255:224];\n  ELSE\n     DEST[255:224] <- SRC2[255:224]; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PMAXUD:| __m128i _mm_max_epu32 ( __m128i a, __m128i\n|           | b);                                       \n| VPMAXUD:  | __m256i _mm256_max_epu32 ( __m256i a,     \n|           | __m256i b);                               \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMAXUD"
    }, 
    {
      "description": "\nPMAXUW  -  Maximum of Packed Word Integers:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 66 0F 38 3E /r PMAXUW xmm1, xmm2/m128| RM   | V/V                   | SSE4_1            | Compare packed unsigned word integers  \n|                                      |      |                       |                   | in xmm1 and xmm2/m128 and store packed \n|                                      |      |                       |                   | maximum values in xmm1.                \n| VEX.NDS.128.66.0F38.WIG 3E/r VPMAXUW | RVM  | V/V                   | AVX               | Compare packed unsigned word integers  \n| xmm1, xmm2, xmm3/m128                |      |                       |                   | in xmm3/m128 and xmm2 and store maximum\n|                                      |      |                       |                   | packed values in xmm1.                 \n| VEX.NDS.256.66.0F38.WIG 3E /r VPMAXUW| RVM  | V/V                   | AVX2              | Compare packed unsigned word integers  \n| ymm1, ymm2, ymm3/m256                |      |                       |                   | in ymm3/m256 and ymm2 and store maximum\n|                                      |      |                       |                   | packed values in ymm1.                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nCompares packed unsigned word integers in the destination operand (first operand)\nand the source operand (second operand), and returns the maximum for each packed\nvalue in the destination operand. 128-bit Legacy SSE version: The first source\nand destination operands are XMM registers. The second source operand is an\nXMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: The first\nsource and destination operands are XMM registers. The second source operand\nis an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination\nYMM register are zeroed.\n\nVEX.256 encoded version: The second source operand can be an YMM register or\na 256-bit memory location. The first source and destination operands are YMM\nregisters.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nIF (DEST[15:0] > SRC[15:0])\n  THEN DEST[15:0] <- DEST[15:0];\n  ELSE DEST[15:0] <- SRC[15:0]; FI;\nIF (DEST[31:16] > SRC[31:16])\n  THEN DEST[31:16] <- DEST[31:16];\n  ELSE DEST[31:16] <- SRC[31:16]; FI;\nIF (DEST[47:32] > SRC[47:32])\n  THEN DEST[47:32] <- DEST[47:32];\n  ELSE DEST[47:32] <- SRC[47:32]; FI;\nIF (DEST[63:48] > SRC[63:48])\n  THEN DEST[63:48] <- DEST[63:48];\n  ELSE DEST[63:48] <- SRC[63:48]; FI;\nIF (DEST[79:64] > SRC[79:64])\n  THEN DEST[79:64] <- DEST[79:64];\n  ELSE DEST[79:64] <- SRC[79:64]; FI;\nIF (DEST[95:80] > SRC[95:80])\n  THEN DEST[95:80] <- DEST[95:80];\n  ELSE DEST[95:80] <- SRC[95:80]; FI;\nIF (DEST[111:96] > SRC[111:96])\n  THEN DEST[111:96] <- DEST[111:96];\n  ELSE DEST[111:96] <- SRC[111:96]; FI;\nIF (DEST[127:112] > SRC[127:112])\n  THEN DEST[127:112] <- DEST[127:112];\n  ELSE DEST[127:112] <- SRC[127:112]; FI;\nVPMAXUW (VEX.128 encoded version)\n  IF SRC1[15:0] > SRC2[15:0] THEN\n     DEST[15:0] <- SRC1[15:0];\n  ELSE\n     DEST[15:0] <- SRC2[15:0]; FI;\n  (* Repeat operation for 2nd through 7th words in source and destination operands *)\n  IF SRC1[127:112] >SRC2[127:112] THEN\n     DEST[127:112] <- SRC1[127:112];\n  ELSE\n     DEST[127:112] <- SRC2[127:112]; FI;\nDEST[VLMAX-1:128] <- 0\nVPMAXUW (VEX.256 encoded version)\n  IF SRC1[15:0] > SRC2[15:0] THEN\n     DEST[15:0] <- SRC1[15:0];\n  ELSE\n     DEST[15:0] <- SRC2[15:0]; FI;\n  (* Repeat operation for 2nd through 15th words in source and destination operands *)\n  IF SRC1[255:240] >SRC2[255:240] THEN\n     DEST[255:240] <- SRC1[255:240];\n  ELSE\n     DEST[255:240] <- SRC2[255:240]; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PMAXUW:| __m128i _mm_max_epu16 ( __m128i a, __m128i\n|           | b);                                       \n| VPMAXUW:  | __m256i _mm256_max_epu16 ( __m256i a,     \n|           | __m256i b)                                \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMAXUW"
    }, 
    {
      "description": "\nPMINSB  -  Minimum of Packed Signed Byte Integers:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                           \n| 66 0F 38 38 /r PMINSB xmm1, xmm2/m128| RM   | V/V                   | SSE4_1            | Compare packed signed byte integers   \n|                                      |      |                       |                   | in xmm1 and xmm2/m128 and store packed\n|                                      |      |                       |                   | minimum values in xmm1.               \n| VEX.NDS.128.66.0F38.WIG 38 /r VPMINSB| RVM  | V/V                   | AVX               | Compare packed signed byte integers   \n| xmm1, xmm2, xmm3/m128                |      |                       |                   | in xmm2 and xmm3/m128 and store packed\n|                                      |      |                       |                   | minimum values in xmm1.               \n| VEX.NDS.256.66.0F38.WIG 38 /r VPMINSB| RVM  | V/V                   | AVX2              | Compare packed signed byte integers   \n| ymm1, ymm2, ymm3/m256                |      |                       |                   | in ymm2 and ymm3/m256 and store packed\n|                                      |      |                       |                   | minimum values in ymm1.               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nCompares packed signed byte integers in the destination operand (first operand)\nand the source operand (second operand), and returns the minimum for each packed\nvalue in the destination operand. 128-bit Legacy SSE version: The first source\nand destination operands are XMM registers. The second source operand is an\nXMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: The first\nsource and destination operands are XMM registers. The second source operand\nis an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination\nYMM register are zeroed. VEX.256 encoded version: The second source operand\ncan be an YMM register or a 256-bit memory location. The first source and destination\noperands are YMM registers.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nIF (DEST[7:0] < SRC[7:0])\n  THEN DEST[7:0] <- DEST[7:0];\n  ELSE DEST[7:0] <- SRC[7:0]; FI;\nIF (DEST[15:8] < SRC[15:8])\n  THEN DEST[15:8] <- DEST[15:8];\n  ELSE DEST[15:8] <- SRC[15:8]; FI;\nIF (DEST[23:16] < SRC[23:16])\n  THEN DEST[23:16] <- DEST[23:16];\n  ELSE DEST[23:16] <- SRC[23:16]; FI;\nIF (DEST[31:24] < SRC[31:24])\n  THEN DEST[31:24] <- DEST[31:24];\n  ELSE DEST[31:24] <- SRC[31:24]; FI;\nIF (DEST[39:32] < SRC[39:32])\n  THEN DEST[39:32] <- DEST[39:32];\n  ELSE DEST[39:32] <- SRC[39:32]; FI;\nIF (DEST[47:40] < SRC[47:40])\n  THEN DEST[47:40] <- DEST[47:40];\n  ELSE DEST[47:40] <- SRC[47:40]; FI;\nIF (DEST[55:48] < SRC[55:48])\n  THEN DEST[55:48] <- DEST[55:48];\n  ELSE DEST[55:48] <- SRC[55:48]; FI;\nIF (DEST[63:56] < SRC[63:56])\n  THEN DEST[63:56] <- DEST[63:56];\n  ELSE DEST[63:56] <- SRC[63:56]; FI;\nIF (DEST[71:64] < SRC[71:64])\n  THEN DEST[71:64] <- DEST[71:64];\n  ELSE DEST[71:64] <- SRC[71:64]; FI;\nIF (DEST[79:72] < SRC[79:72])\n  THEN DEST[79:72] <- DEST[79:72];\n  ELSE DEST[79:72] <- SRC[79:72]; FI;\nIF (DEST[87:80] < SRC[87:80])\n  THEN DEST[87:80] <- DEST[87:80];\n  ELSE DEST[87:80] <- SRC[87:80]; FI;\nIF (DEST[95:88] < SRC[95:88])\n  THEN DEST[95:88] <- DEST[95:88];\n  ELSE DEST[95:88] <- SRC[95:88]; FI;\nIF (DEST[103:96] < SRC[103:96])\n  THEN DEST[103:96] <- DEST[103:96];\n  ELSE DEST[103:96] <- SRC[103:96]; FI;\nIF (DEST[111:104] < SRC[111:104])\n  THEN DEST[111:104] <- DEST[111:104];\n  ELSE DEST[111:104] <- SRC[111:104]; FI;\nIF (DEST[119:112] < SRC[119:112])\n  THEN DEST[119:112] <- DEST[119:112];\n  ELSE DEST[119:112] <- SRC[119:112]; FI;\nIF (DEST[127:120] < SRC[127:120])\n  THEN DEST[127:120] <- DEST[127:120];\n  ELSE DEST[127:120] <- SRC[127:120]; FI;\nVPMINSB (VEX.128 encoded version)\n  IF SRC1[7:0] < SRC2[7:0] THEN\n     DEST[7:0] <- SRC1[7:0];\n  ELSE\n     DEST[7:0] <- SRC2[7:0]; FI;\n  (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n  IF SRC1[127:120] < SRC2[127:120] THEN\n     DEST[127:120] <- SRC1[127:120];\n  ELSE\n     DEST[127:120] <- SRC2[127:120]; FI;\nDEST[VLMAX-1:128] <- 0\nVPMINSB (VEX.256 encoded version)\n  IF SRC1[7:0] < SRC2[7:0] THEN\n     DEST[7:0] <- SRC1[7:0];\n  ELSE\n     DEST[15:0] <- SRC2[7:0]; FI;\n  (* Repeat operation for 2nd through 31st bytes in source and destination operands *)\n  IF SRC1[255:248] < SRC2[255:248] THEN\n     DEST[255:248] <- SRC1[255:248];\n  ELSE\n     DEST[255:248] <- SRC2[255:248]; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PMINSB:| __m128i _mm_min_epi8 ( __m128i a, __m128i\n|           | b);                                      \n| VPMINSB:  | __m256i _mm256_min_epi8 ( __m256i a,     \n|           | __m256i b);                              \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMINSB"
    }, 
    {
      "description": "\nPMINSD  -  Minimum of Packed Dword Integers:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                           \n| 66 0F 38 39 /r PMINSD xmm1, xmm2/m128| RM   | V/V                   | SSE4_1            | Compare packed signed dword integers  \n|                                      |      |                       |                   | in xmm1 and xmm2/m128 and store packed\n|                                      |      |                       |                   | minimum values in xmm1.               \n| VEX.NDS.128.66.0F38.WIG 39 /r VPMINSD| RVM  | V/V                   | AVX               | Compare packed signed dword integers  \n| xmm1, xmm2, xmm3/m128                |      |                       |                   | in xmm2 and xmm3/m128 and store packed\n|                                      |      |                       |                   | minimum values in xmm1.               \n| VEX.NDS.256.66.0F38.WIG 39 /r VPMINSD| RVM  | V/V                   | AVX2              | Compare packed signed dword integers  \n| ymm1, ymm2, ymm3/m256                |      |                       |                   | in ymm2 and ymm3/m128 and store packed\n|                                      |      |                       |                   | minimum values in ymm1.               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nCompares packed signed dword integers in the destination operand (first operand)\nand the source operand (second operand), and returns the minimum for each packed\nvalue in the destination operand. 128-bit Legacy SSE version: The first source\nand destination operands are XMM registers. The second source operand is an\nXMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: The first\nsource and destination operands are XMM registers. The second source operand\nis an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination\nYMM register are zeroed. VEX.256 encoded version: The second source operand\ncan be an YMM register or a 256-bit memory location. The first source and destination\noperands are YMM registers.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nIF (DEST[31:0] < SRC[31:0])\n  THEN DEST[31:0] <- DEST[31:0];\n  ELSE DEST[31:0] <- SRC[31:0]; FI;\nIF (DEST[63:32] < SRC[63:32])\n  THEN DEST[63:32] <- DEST[63:32];\n  ELSE DEST[63:32] <- SRC[63:32]; FI;\nIF (DEST[95:64] < SRC[95:64])\n  THEN DEST[95:64] <- DEST[95:64];\n  ELSE DEST[95:64] <- SRC[95:64]; FI;\nIF (DEST[127:96] < SRC[127:96])\n  THEN DEST[127:96] <- DEST[127:96];\n  ELSE DEST[127:96] <- SRC[127:96]; FI;\nVPMINSD (VEX.128 encoded version)\n  IF SRC1[31:0] < SRC2[31:0] THEN\n     DEST[31:0] <- SRC1[31:0];\n  ELSE\n     DEST[31:0] <- SRC2[31:0]; FI;\n  (* Repeat operation for 2nd through 3rd dwords in source and destination operands *)\n  IF SRC1[127:95] < SRC2[127:95] THEN\n     DEST[127:95] <- SRC1[127:95];\n  ELSE\n     DEST[127:95] <- SRC2[127:95]; FI;\nDEST[VLMAX-1:128] <- 0\nVPMINSD (VEX.256 encoded version)\n  IF SRC1[31:0] < SRC2[31:0] THEN\n     DEST[31:0] <- SRC1[31:0];\n  ELSE\n     DEST[31:0] <- SRC2[31:0]; FI;\n  (* Repeat operation for 2nd through 7th dwords in source and destination operands *)\n  IF SRC1[255:224] < SRC2[255:224] THEN\n     DEST[255:224] <- SRC1[255:224];\n  ELSE\n     DEST[255:224] <- SRC2[255:224]; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PMINSD:| __m128i _mm_min_epi32 ( __m128i a, __m128i\n|           | b);                                       \n| VPMINSD:  | __m256i _mm256_min_epi32 (__m256i a,      \n|           | __m256i b);                               \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMINSD"
    }, 
    {
      "description": "\nPMINSW - Minimum of Packed Signed Word Integers:\n| Opcode/Instruction                 | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| 0F EA /r1 PMINSW mm1, mm2/m64      | RM   | V/V                   | SSE               | Compare signed word integers in mm2/m64  \n|                                    |      |                       |                   | and mm1 and return minimum values.       \n| 66 0F EA /r PMINSW xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Compare signed word integers in xmm2/m128\n|                                    |      |                       |                   | and xmm1 and return minimum values.      \n| VEX.NDS.128.66.0F.WIG EA /r VPMINSW| RVM  | V/V                   | AVX               | Compare packed signed word integers      \n| xmm1, xmm2, xmm3/m128              |      |                       |                   | in xmm3/m128 and xmm2 and return packed  \n|                                    |      |                       |                   | minimum values in xmm1.                  \n| VEX.NDS.256.66.0F.WIG EA /r VPMINSW| RVM  | V/V                   | AVX2              | Compare packed signed word integers      \n| ymm1, ymm2, ymm3/m256              |      |                       |                   | in ymm3/m256 and ymm2 and return packed  \n|                                    |      |                       |                   | minimum values in ymm1.                  \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD compare of the packed signed word integers in the destination\noperand (first operand) and the source operand (second operand), and returns\nthe minimum value for each pair of word integers to the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). Legacy SSE version: The source\noperand can be an MMX technology register or a 64-bit memory location. The destination\noperand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM\nregisters. The second source operand is an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the corresponding YMM destination register remain\nunchanged. VEX.128 encoded version: The first source and destination operands\nare XMM registers. The second source operand is an XMM register or a 128-bit\nmemory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or\na 256-bit memory location. The first source and destination operands are YMM\nregisters.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPMINSW (64-bit operands)\n  IF DEST[15:0] < SRC[15:0] THEN\n     DEST[15:0] <- DEST[15:0];\n  ELSE\n     DEST[15:0] <- SRC[15:0]; FI;\n  (* Repeat operation for 2nd and 3rd words in source and destination operands *)\n  IF DEST[63:48] < SRC[63:48] THEN\n     DEST[63:48] <- DEST[63:48];\n  ELSE\n     DEST[63:48] <- SRC[63:48]; FI;\nPMINSW (128-bit operands)\n  IF DEST[15:0] < SRC[15:0] THEN\n     DEST[15:0] <- DEST[15:0];\n  ELSE\n     DEST[15:0] <- SRC[15:0]; FI;\n  (* Repeat operation for 2nd through 7th words in source and destination operands *)\n  IF DEST[127:112] < SRC/m64[127:112] THEN\n     DEST[127:112] <- DEST[127:112];\n  ELSE\n     DEST[127:112] <- SRC[127:112]; FI;\nVPMINSW (VEX.128 encoded version)\n  IF SRC1[15:0] < SRC2[15:0] THEN\n     DEST[15:0] <- SRC1[15:0];\n  ELSE\n     DEST[15:0] <- SRC2[15:0]; FI;\n  (* Repeat operation for 2nd through 7th words in source and destination operands *)\n  IF SRC1[127:112] < SRC2[127:112] THEN\n     DEST[127:112] <- SRC1[127:112];\n  ELSE\n     DEST[127:112] <- SRC2[127:112]; FI;\nDEST[VLMAX-1:128] <- 0\nVPMINSW (VEX.256 encoded version)\n  IF SRC1[15:0] < SRC2[15:0] THEN\n     DEST[15:0] <- SRC1[15:0];\n  ELSE\n     DEST[15:0] <- SRC2[15:0]; FI;\n  (* Repeat operation for 2nd through 15th words in source and destination operands *)\n  IF SRC1[255:240] < SRC2[255:240] THEN\n     DEST[255:240] <- SRC1[255:240];\n  ELSE\n     DEST[255:240] <- SRC2[255:240]; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PMINSW:   | __m64 _mm_min_pi16 (__m64 a, __m64 b)     \n| (V)PMINSW:| __m128i _mm_min_epi16 ( __m128i a, __m128i\n|           | b)                                        \n| VPMINSW:  | __m256i _mm256_min_epi16 ( __m256i a,     \n|           | __m256i b)                                \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.                       \n| #MF| (64-bit operations only) If there is\n|    | a pending x87 FPU exception.        \n", 
      "mnem": "PMINSW"
    }, 
    {
      "description": "\nPMINUB - Minimum of Packed Unsigned Byte Integers:\n| Opcode/Instruction                 | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| 0F DA /r1 PMINUB mm1, mm2/m64      | RM   | V/V                   | SSE               | Compare unsigned byte integers in mm2/m64  \n|                                    |      |                       |                   | and mm1 and returns minimum values.        \n| 66 0F DA /r PMINUB xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Compare unsigned byte integers in xmm2/m128\n|                                    |      |                       |                   | and xmm1 and returns minimum values.       \n| VEX.NDS.128.66.0F.WIG DA /r VPMINUB| RVM  | V/V                   | AVX               | Compare packed unsigned byte integers      \n| xmm1, xmm2, xmm3/m128              |      |                       |                   | in xmm2 and xmm3/m128 and store packed     \n|                                    |      |                       |                   | minimum values in xmm1.                    \n| VEX.NDS.256.66.0F.WIG DA /r VPMINUB| RVM  | V/V                   | AVX2              | Compare packed unsigned byte integers      \n| ymm1, ymm2, ymm3/m256              |      |                       |                   | in ymm2 and ymm3/m256 and store packed     \n|                                    |      |                       |                   | minimum values in ymm1.                    \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD compare of the packed unsigned byte integers in the destination\noperand (first operand) and the source operand (second operand), and returns\nthe minimum value for each pair of byte integers to the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). Legacy SSE version: The source\noperand can be an MMX technology register or a 64-bit memory location. The destination\noperand can be an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM\nregisters. The second source operand is an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the corresponding YMM destination register remain\nunchanged. VEX.128 encoded version: The first source and destination operands\nare XMM registers. The second source operand is an XMM register or a 128-bit\nmemory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or\na 256-bit memory location. The first source and destination operands are YMM\nregisters.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPMINUB (for 64-bit operands)\n  IF DEST[7:0] < SRC[17:0] THEN\n     DEST[7:0] <- DEST[7:0];\n  ELSE\n     DEST[7:0] <- SRC[7:0]; FI;\n  (* Repeat operation for 2nd through 7th bytes in source and destination operands *)\n  IF DEST[63:56] < SRC[63:56] THEN\n     DEST[63:56] <- DEST[63:56];\n  ELSE\n     DEST[63:56] <- SRC[63:56]; FI;\nPMINUB (for 128-bit operands)\n  IF DEST[7:0] < SRC[17:0] THEN\n     DEST[7:0] <- DEST[7:0];\n  ELSE\n     DEST[7:0] <- SRC[7:0]; FI;\n  (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n  IF DEST[127:120] < SRC[127:120] THEN\n     DEST[127:120] <- DEST[127:120];\n  ELSE\n     DEST[127:120] <- SRC[127:120]; FI;\nVPMINUB (VEX.128 encoded version)\nVPMINUB instruction for 128-bit operands:\n  IF SRC1[7:0] < SRC2[7:0] THEN\n     DEST[7:0] <- SRC1[7:0];\n  ELSE\n     DEST[7:0] <- SRC2[7:0]; FI;\n  (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n  IF SRC1[127:120] < SRC2[127:120] THEN\n     DEST[127:120] <- SRC1[127:120];\n  ELSE\n     DEST[127:120] <- SRC2[127:120]; FI;\nDEST[VLMAX-1:128] <- 0\nVPMINUB (VEX.256 encoded version)\nVPMINUB instruction for 128-bit operands:\n  IF SRC1[7:0] < SRC2[7:0] THEN\n     DEST[7:0] <- SRC1[7:0];\n  ELSE\n     DEST[15:0] <- SRC2[7:0]; FI;\n  (* Repeat operation for 2nd through 31st bytes in source and destination operands *)\n  IF SRC1[255:248] < SRC2[255:248] THEN\n     DEST[255:248] <- SRC1[255:248];\n  ELSE\n     DEST[255:248] <- SRC2[255:248]; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PMINUB:   | __m64 _m_min_pu8 (__m64 a, __m64 b)      \n| (V)PMINUB:| __m128i _mm_min_epu8 ( __m128i a, __m128i\n|           | b)                                       \n| VPMINUB:  | __m256i _mm256_min_epu8 ( __m256i a,     \n|           | __m256i b)                               \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMINUB"
    }, 
    {
      "description": "\nPMINUD  -  Minimum of Packed Dword Integers:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                           \n| 66 0F 38 3B /r PMINUD xmm1, xmm2/m128| RM   | V/V                   | SSE4_1            | Compare packed unsigned dword integers\n|                                      |      |                       |                   | in xmm1 and xmm2/m128 and store packed\n|                                      |      |                       |                   | minimum values in xmm1.               \n| VEX.NDS.128.66.0F38.WIG 3B /r VPMINUD| RVM  | V/V                   | AVX               | Compare packed unsigned dword integers\n| xmm1, xmm2, xmm3/m128                |      |                       |                   | in xmm2 and xmm3/m128 and store packed\n|                                      |      |                       |                   | minimum values in xmm1.               \n| VEX.NDS.256.66.0F38.WIG 3B /r VPMINUD| RVM  | V/V                   | AVX2              | Compare packed unsigned dword integers\n| ymm1, ymm2, ymm3/m256                |      |                       |                   | in ymm2 and ymm3/m256 and store packed\n|                                      |      |                       |                   | minimum values in ymm1.               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nCompares packed unsigned dword integers in the destination operand (first operand)\nand the source operand (second operand), and returns the minimum for each packed\nvalue in the destination operand. 128-bit Legacy SSE version: The first source\nand destination operands are XMM registers. The second source operand is an\nXMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: The first\nsource and destination operands are XMM registers. The second source operand\nis an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination\nYMM register are zeroed. VEX.256 encoded version: The second source operand\ncan be an YMM register or a 256-bit memory location. The first source and destination\noperands are YMM registers.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nIF (DEST[31:0] < SRC[31:0])\n  THEN DEST[31:0] <- DEST[31:0];\n  ELSE DEST[31:0] <- SRC[31:0]; FI;\nIF (DEST[63:32] < SRC[63:32])\n  THEN DEST[63:32] <- DEST[63:32];\n  ELSE DEST[63:32] <- SRC[63:32]; FI;\nIF (DEST[95:64] < SRC[95:64])\n  THEN DEST[95:64] <- DEST[95:64];\n  ELSE DEST[95:64] <- SRC[95:64]; FI;\nIF (DEST[127:96] < SRC[127:96])\n  THEN DEST[127:96] <- DEST[127:96];\n  ELSE DEST[127:96] <- SRC[127:96]; FI;\nVPMINUD (VEX.128 encoded version)\nVPMINUD instruction for 128-bit operands:\n  IF SRC1[31:0] < SRC2[31:0] THEN\n     DEST[31:0] <- SRC1[31:0];\n  ELSE\n     DEST[31:0] <- SRC2[31:0]; FI;\n  (* Repeat operation for 2nd through 3rd dwords in source and destination operands *)\n  IF SRC1[127:95] < SRC2[127:95] THEN\n     DEST[127:95] <- SRC1[127:95];\n  ELSE\n     DEST[127:95] <- SRC2[127:95]; FI;\nDEST[VLMAX-1:128] <- 0\nVPMINUD (VEX.256 encoded version)\nVPMINUD instruction for 128-bit operands:\n  IF SRC1[31:0] < SRC2[31:0] THEN\n     DEST[31:0] <- SRC1[31:0];\n  ELSE\n     DEST[31:0] <- SRC2[31:0]; FI;\n  (* Repeat operation for 2nd through 7th dwords in source and destination operands *)\n  IF SRC1[255:224] < SRC2[255:224] THEN\n     DEST[255:224] <- SRC1[255:224];\n  ELSE\n     DEST[255:224] <- SRC2[255:224]; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PMINUD:| __m128i _mm_min_epu32 ( __m128i a, __m128i\n|           | b);                                       \n| VPMINUD:  | __m256i _mm256_min_epu32 ( __m256i a,     \n|           | __m256i b);                               \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMINUD"
    }, 
    {
      "description": "\nPMINUW  -  Minimum of Packed Word Integers:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 66 0F 38 3A /r PMINUW xmm1, xmm2/m128| RM   | V/V                   | SSE4_1            | Compare packed unsigned word integers  \n|                                      |      |                       |                   | in xmm1 and xmm2/m128 and store packed \n|                                      |      |                       |                   | minimum values in xmm1.                \n| VEX.NDS.128.66.0F38.WIG 3A/r VPMINUW | RVM  | V/V                   | AVX               | Compare packed unsigned word integers  \n| xmm1, xmm2, xmm3/m128                |      |                       |                   | in xmm3/m128 and xmm2 and return packed\n|                                      |      |                       |                   | minimum values in xmm1.                \n| VEX.NDS.256.66.0F38.WIG 3A /r VPMINUW| RVM  | V/V                   | AVX2              | Compare packed unsigned word integers  \n| ymm1, ymm2, ymm3/m256                |      |                       |                   | in ymm3/m256 and ymm2 and return packed\n|                                      |      |                       |                   | minimum values in ymm1.                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nCompares packed unsigned word integers in the destination operand (first operand)\nand the source operand (second operand), and returns the minimum for each packed\nvalue in the destination operand. 128-bit Legacy SSE version: The first source\nand destination operands are XMM registers. The second source operand is an\nXMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: The first\nsource and destination operands are XMM registers. The second source operand\nis an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination\nYMM register are zeroed. VEX.256 encoded version: The second source operand\ncan be an YMM register or a 256-bit memory location. The first source and destination\noperands are YMM registers.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nIF (DEST[15:0] < SRC[15:0])\n  THEN DEST[15:0] <- DEST[15:0];\n  ELSE DEST[15:0] <- SRC[15:0]; FI;\nIF (DEST[31:16] < SRC[31:16])\n  THEN DEST[31:16] <- DEST[31:16];\n  ELSE DEST[31:16] <- SRC[31:16]; FI;\nIF (DEST[47:32] < SRC[47:32])\n  THEN DEST[47:32] <- DEST[47:32];\n  ELSE DEST[47:32] <- SRC[47:32]; FI;\nIF (DEST[63:48] < SRC[63:48])\n  THEN DEST[63:48] <- DEST[63:48];\n  ELSE DEST[63:48] <- SRC[63:48]; FI;\nIF (DEST[79:64] < SRC[79:64])\n  THEN DEST[79:64] <- DEST[79:64];\n  ELSE DEST[79:64] <- SRC[79:64]; FI;\nIF (DEST[95:80] < SRC[95:80])\n  THEN DEST[95:80] <- DEST[95:80];\n  ELSE DEST[95:80] <- SRC[95:80]; FI;\nIF (DEST[111:96] < SRC[111:96])\n  THEN DEST[111:96] <- DEST[111:96];\n  ELSE DEST[111:96] <- SRC[111:96]; FI;\nIF (DEST[127:112] < SRC[127:112])\n  THEN DEST[127:112] <- DEST[127:112];\n  ELSE DEST[127:112] <- SRC[127:112]; FI;\nVPMINUW (VEX.128 encoded version)\nVPMINUW instruction for 128-bit operands:\n  IF SRC1[15:0] < SRC2[15:0] THEN\n     DEST[15:0] <- SRC1[15:0];\n  ELSE\n     DEST[15:0] <- SRC2[15:0]; FI;\n  (* Repeat operation for 2nd through 7th words in source and destination operands *)\n  IF SRC1[127:112] < SRC2[127:112] THEN\n     DEST[127:112] <- SRC1[127:112];\n  ELSE\n     DEST[127:112] <- SRC2[127:112]; FI;\nDEST[VLMAX-1:128] <- 0\nVPMINUW (VEX.256 encoded version)\nVPMINUW instruction for 128-bit operands:\n  IF SRC1[15:0] < SRC2[15:0] THEN\n     DEST[15:0] <- SRC1[15:0];\n  ELSE\n     DEST[15:0] <- SRC2[15:0]; FI;\n  (* Repeat operation for 2nd through 15th words in source and destination operands *)\n  IF SRC1[255:240] < SRC2[255:240] THEN\n     DEST[255:240] <- SRC1[255:240];\n  ELSE\n     DEST[255:240] <- SRC2[255:240]; FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PMINUW:| __m128i _mm_min_epu16 ( __m128i a, __m128i\n|           | b);                                       \n| VPMINUW:  | __m256i _mm256_min_epu16 ( __m256i a,     \n|           | __m256i b);                               \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMINUW"
    }, 
    {
      "description": "\nPMOVMSKB - Move Byte Mask:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| 0F D7 /r1 PMOVMSKB reg, mm            | RM   | V/V                   | SSE               | Move a byte mask of mm to reg. The upper\n|                                       |      |                       |                   | bits of r32 or r64 are zeroed           \n| 66 0F D7 /r PMOVMSKB reg, xmm         | RM   | V/V                   | SSE2              | Move a byte mask of xmm to reg. The     \n|                                       |      |                       |                   | upper bits of r32 or r64 are zeroed     \n| VEX.128.66.0F.WIG D7 /r VPMOVMSKB reg,| RM   | V/V                   | AVX               | Move a byte mask of xmm1 to reg. The    \n| xmm1                                  |      |                       |                   | upper bits of r32 or r64 are filled     \n|                                       |      |                       |                   | with zeros.                             \n| VEX.256.66.0F.WIG D7 /r VPMOVMSKB reg,| RM   | V/V                   | AVX2              | Move a 32-bit mask of ymm1 to reg. The  \n| ymm1                                  |      |                       |                   | upper bits of r64 are filled with zeros.\nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nCreates a mask made up of the most significant bit of each byte of the source\noperand (second operand) and stores the result in the low byte or word of the\ndestination operand (first operand). The byte mask is 8 bits for 64-bit source\noperand, 16 bits for 128-bit source operand and 32 bits for 256-bit source operand.\nThe destination operand is a general-purpose register.\n\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15,\nR8-R15) when used with a REX.R prefix. The default operand size is 64-bit in\n64-bit mode. Legacy SSE version: The source operand is an MMX technology register.\n128-bit Legacy SSE version: The source operand is an XMM register.\n\nVEX.128 encoded version: The source operand is an XMM register. VEX.256 encoded\nversion: The source operand is a YMM register. Note: VEX.vvvv is reserved and\nmust be 1111b, VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPMOVMSKB (with 64-bit source operand and r32)\n  r32[0] <- SRC[7];\n  r32[1] <- SRC[15];\n  (* Repeat operation for bytes 2 through 6 *)\n  r32[7] <- SRC[63];\n  r32[31:8] <- ZERO_FILL;\n(V)PMOVMSKB (with 128-bit source operand and r32)\n  r32[0] <- SRC[7];\n  r32[1] <- SRC[15];\n  (* Repeat operation for bytes 2 through 14 *)\n  r32[15] <- SRC[127];\n  r32[31:16] <- ZERO_FILL;\nVPMOVMSKB (with 256-bit source operand and r32)\nr32[0] <- SRC[7];\nr32[1] <- SRC[15];\n(* Repeat operation for bytes 3rd through 31*)\nr32[31] <- SRC[255];\nPMOVMSKB (with 64-bit source operand and r64)\n  r64[0] <- SRC[7];\n  r64[1] <- SRC[15];\n  (* Repeat operation for bytes 2 through 6 *)\n  r64[7] <- SRC[63];\n  r64[63:8] <- ZERO_FILL;\n(V)PMOVMSKB (with 128-bit source operand and r64)\n  r64[0] <- SRC[7];\n  r64[1] <- SRC[15];\n  (* Repeat operation for bytes 2 through 14 *)\n  r64[15] <- SRC[127];\n  r64[63:16] <- ZERO_FILL;\nVPMOVMSKB (with 256-bit source operand and r64)\nr64[0] <- SRC[7];\nr64[1] <- SRC[15];\n(* Repeat operation for bytes 2 through 31*)\nr64[31] <- SRC[255];\nr64[63:32] <- ZERO_FILL;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PMOVMSKB:   | int _mm_movemask_pi8(__m64 a)        \n| (V)PMOVMSKB:| int _mm_movemask_epi8 ( __m128i a)   \n| VPMOVMSKB:  | int _mm256_movemask_epi8 ( __m256i a)\n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 7; additionally\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PMOVMSKB"
    }, 
    {
      "description": "\nPMOVSX  -  Packed Move with Sign Extend:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| 66 0f 38 20 /r PMOVSXBW xmm1, xmm2/m64| RM   | V/V                   | SSE4_1            | Sign extend 8 packed signed 8-bit integers \n|                                       |      |                       |                   | in the low 8 bytes of xmm2/m64 to 8        \n|                                       |      |                       |                   | packed signed 16-bit integers in xmm1.     \n| 66 0f 38 21 /r PMOVSXBD xmm1, xmm2/m32| RM   | V/V                   | SSE4_1            | Sign extend 4 packed signed 8-bit integers \n|                                       |      |                       |                   | in the low 4 bytes of xmm2/m32 to 4        \n|                                       |      |                       |                   | packed signed 32-bit integers in xmm1.     \n| 66 0f 38 22 /r PMOVSXBQ xmm1, xmm2/m16| RM   | V/V                   | SSE4_1            | Sign extend 2 packed signed 8-bit integers \n|                                       |      |                       |                   | in the low 2 bytes of xmm2/m16 to 2        \n|                                       |      |                       |                   | packed signed 64-bit integers in xmm1.     \n| 66 0f 38 23 /r PMOVSXWD xmm1, xmm2/m64| RM   | V/V                   | SSE4_1            | Sign extend 4 packed signed 16-bit integers\n|                                       |      |                       |                   | in the low 8 bytes of xmm2/m64 to 4        \n|                                       |      |                       |                   | packed signed 32-bit integers in xmm1.     \n| 66 0f 38 24 /r PMOVSXWQ xmm1, xmm2/m32| RM   | V/V                   | SSE4_1            | Sign extend 2 packed signed 16-bit integers\n|                                       |      |                       |                   | in the low 4 bytes of xmm2/m32 to 2        \n|                                       |      |                       |                   | packed signed 64-bit integers in xmm1.     \n| 66 0f 38 25 /r PMOVSXDQ xmm1, xmm2/m64| RM   | V/V                   | SSE4_1            | Sign extend 2 packed signed 32-bit integers\n|                                       |      |                       |                   | in the low 8 bytes of xmm2/m64 to 2        \n|                                       |      |                       |                   | packed signed 64-bit integers in xmm1.     \n| VEX.128.66.0F38.WIG 20 /r VPMOVSXBW   | RM   | V/V                   | AVX               | Sign extend 8 packed 8-bit integers        \n| xmm1, xmm2/m64                        |      |                       |                   | in the low 8 bytes of xmm2/m64 to 8        \n|                                       |      |                       |                   | packed 16-bit integers in xmm1.            \n| VEX.128.66.0F38.WIG 21 /r VPMOVSXBD   | RM   | V/V                   | AVX               | Sign extend 4 packed 8-bit integers        \n| xmm1, xmm2/m32                        |      |                       |                   | in the low 4 bytes of xmm2/m32 to 4        \n|                                       |      |                       |                   | packed 32-bit integers in xmm1.            \n| VEX.128.66.0F38.WIG 22 /r VPMOVSXBQ   | RM   | V/V                   | AVX               | Sign extend 2 packed 8-bit integers        \n| xmm1, xmm2/m16                        |      |                       |                   | in the low 2 bytes of xmm2/m16 to 2        \n|                                       |      |                       |                   | packed 64-bit integers in xmm1.            \n| VEX.128.66.0F38.WIG 23 /r VPMOVSXWD   | RM   | V/V                   | AVX               | Sign extend 4 packed 16-bit integers       \n| xmm1, xmm2/m64                        |      |                       |                   | in the low 8 bytes of xmm2/m64 to 4        \n|                                       |      |                       |                   | packed 32-bit integers in xmm1.            \n| VEX.128.66.0F38.WIG 24 /r VPMOVSXWQ   | RM   | V/V                   | AVX               | Sign extend 2 packed 16-bit integers       \n| xmm1, xmm2/m32                        |      |                       |                   | in the low 4 bytes of xmm2/m32 to 2        \n|                                       |      |                       |                   | packed 64-bit integers in xmm1.            \n| VEX.128.66.0F38.WIG 25 /r VPMOVSXDQ   | RM   | V/V                   | AVX               | Sign extend 2 packed 32-bit integers       \n| xmm1, xmm2/m64                        |      |                       |                   | in the low 8 bytes of xmm2/m64 to 2        \n|                                       |      |                       |                   | packed 64-bit integers in xmm1.            \n| VEX.256.66.0F38.WIG 20 /r VPMOVSXBW   | RM   | V/V                   | AVX2              | Sign extend 16 packed 8-bit integers       \n| ymm1, xmm2/m128                       |      |                       |                   | in xmm2/m128 to 16 packed 16-bit integers  \n|                                       |      |                       |                   | in ymm1.                                   \n| VEX.256.66.0F38.WIG 21 /r VPMOVSXBD   | RM   | V/V                   | AVX2              | Sign extend 8 packed 8-bit integers        \n| ymm1, xmm2/m64                        |      |                       |                   | in the low 8 bytes of xmm2/m64 to 8        \n|                                       |      |                       |                   | packed 32-bit integers in ymm1.            \n| VEX.256.66.0F38.WIG 22 /r VPMOVSXBQ   | RM   | V/V                   | AVX2              | Sign extend 4 packed 8-bit integers        \n| ymm1, xmm2/m32                        |      |                       |                   | in the low 4 bytes of xmm2/m32 to 4        \n|                                       |      |                       |                   | packed 64-bit integers in ymm1.            \n| VEX.256.66.0F38.WIG 23 /r VPMOVSXWD   | RM   | V/V                   | AVX2              | Sign extend 8 packed 16-bit integers       \n| ymm1, xmm2/m128                       |      |                       |                   | in the low 16 bytes of xmm2/m128 to        \n|                                       |      |                       |                   | 8 packed 32bit integers in ymm1.           \n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| VEX.256.66.0F38.WIG 24 /r VPMOVSXWQ   | RM   | V/V                   | AVX2              | Sign extend 4 packed 16-bit integers       \n| ymm1, xmm2/m64                        |      |                       |                   | in the low 8 bytes of xmm2/m64 to 4        \n|                                       |      |                       |                   | packed 64-bit integers in ymm1.            \n| VEX.256.66.0F38.WIG 25 /r VPMOVSXDQ   | RM   | V/V                   | AVX2              | Sign extend 4 packed 32-bit integers       \n| ymm1, xmm2/m128                       |      |                       |                   | in the low 16 bytes of xmm2/m128 to        \n|                                       |      |                       |                   | 4 packed 64bit integers in ymm1.           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nSign-extend the low byte/word/dword values in each word/dword/qword element\nof the source operand (second operand) to word/dword/qword integers and stored\nas packed data in the destination operand (first operand). 128-bit Legacy SSE\nversion: Bits (VLMAX-1:128) of the corresponding YMM destination register remain\nunchanged. VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM\nregister are zeroed. VEX.256 encoded version: The destination register is YMM\nRegister. Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise\nthe instruction will #UD.\n\nOperation:\n\nPMOVSXBW\n  DEST[15:0] <- SignExtend(SRC[7:0]);\n  DEST[31:16] <- SignExtend(SRC[15:8]);\n  DEST[47:32] <- SignExtend(SRC[23:16]);\n  DEST[63:48] <- SignExtend(SRC[31:24]);\n  DEST[79:64] <- SignExtend(SRC[39:32]);\n  DEST[95:80] <- SignExtend(SRC[47:40]);\n  DEST[111:96] <- SignExtend(SRC[55:48]);\n  DEST[127:112] <- SignExtend(SRC[63:56]);\nPMOVSXBD\n  DEST[31:0] <- SignExtend(SRC[7:0]);\n  DEST[63:32] <- SignExtend(SRC[15:8]);\n  DEST[95:64] <- SignExtend(SRC[23:16]);\n  DEST[127:96] <- SignExtend(SRC[31:24]);\nPMOVSXBQ\n  DEST[63:0] <- SignExtend(SRC[7:0]);\n  DEST[127:64] <- SignExtend(SRC[15:8]);\nPMOVSXWD\n  DEST[31:0] <- SignExtend(SRC[15:0]);\n  DEST[63:32] <- SignExtend(SRC[31:16]);\n  DEST[95:64] <- SignExtend(SRC[47:32]);\n  DEST[127:96] <- SignExtend(SRC[63:48]);\nPMOVSXWQ\n  DEST[63:0] <- SignExtend(SRC[15:0]);\n  DEST[127:64] <- SignExtend(SRC[31:16]);\nPMOVSXDQ\n  DEST[63:0] <- SignExtend(SRC[31:0]);\n  DEST[127:64] <- SignExtend(SRC[63:32]);\nVPMOVSXBW (VEX.128 encoded version)\nPacked_Sign_Extend_BYTE_to_WORD()\nDEST[VLMAX-1:128] <- 0\nVPMOVSXBD (VEX.128 encoded version)\nPacked_Sign_Extend_BYTE_to_DWORD()\nDEST[VLMAX-1:128] <- 0\nVPMOVSXBQ (VEX.128 encoded version)\nPacked_Sign_Extend_BYTE_to_QWORD()\nDEST[VLMAX-1:128] <- 0\nVPMOVSXWD (VEX.128 encoded version)\nPacked_Sign_Extend_WORD_to_DWORD()\nDEST[VLMAX-1:128] <- 0\nVPMOVSXWQ (VEX.128 encoded version)\nPacked_Sign_Extend_WORD_to_QWORD()\nDEST[VLMAX-1:128] <- 0\nVPMOVSXDQ (VEX.128 encoded version)\nPacked_Sign_Extend_DWORD_to_QWORD()\nDEST[VLMAX-1:128] <- 0\nVPMOVSXBW (VEX.256 encoded version)\nPacked_Sign_Extend_BYTE_to_WORD(DEST[127:0], SRC[63:0])\nPacked_Sign_Extend_BYTE_to_WORD(DEST[255:128], SRC[127:64])\nVPMOVSXBD (VEX.256 encoded version)\nPacked_Sign_Extend_BYTE_to_DWORD(DEST[127:0], SRC[31:0])\nPacked_Sign_Extend_BYTE_to_DWORD(DEST[255:128], SRC[63:32])\nVPMOVSXBQ (VEX.256 encoded version)\nPacked_Sign_Extend_BYTE_to_QWORD(DEST[127:0], SRC[15:0])\nPacked_Sign_Extend_BYTE_to_QWORD(DEST[255:128], SRC[31:16])\nVPMOVSXWD (VEX.256 encoded version)\nPacked_Sign_Extend_WORD_to_DWORD(DEST[127:0], SRC[63:0])\nPacked_Sign_Extend_WORD_to_DWORD(DEST[255:128], SRC[127:64])\nVPMOVSXWQ (VEX.256 encoded version)\nPacked_Sign_Extend_WORD_to_QWORD(DEST[127:0], SRC[31:0])\nPacked_Sign_Extend_WORD_to_QWORD(DEST[255:128], SRC[63:32])\nVPMOVSXDQ (VEX.256 encoded version)\nPacked_Sign_Extend_DWORD_to_QWORD(DEST[127:0], SRC[63:0])\nPacked_Sign_Extend_DWORD_to_QWORD(DEST[255:128], SRC[127:64])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PMOVSXBW:| __m128i _mm_ cvtepi8_epi16 ( __m128i   \n|             | a);                                    \n| VPMOVSXBW:  | __m256i _mm256_cvtepi8_epi16 ( __m128i \n|             | a);                                    \n| (V)PMOVSXBD:| __m128i _mm_ cvtepi8_epi32 ( __m128i   \n|             | a);                                    \n| VPMOVSXBD:  | __m256i _mm256_cvtepi8_epi32 ( __m128i \n|             | a);                                    \n| (V)PMOVSXBQ:| __m128i _mm_ cvtepi8_epi64 ( __m128i   \n|             | a);                                    \n| VPMOVSXBQ:  | __m256i _mm256_cvtepi8_epi64 ( __m128i \n|             | a);                                    \n| (V)PMOVSXWD:| __m128i _mm_ cvtepi16_epi32 ( __m128i  \n|             | a);                                    \n| VPMOVSXWD:  | __m256i _mm256_cvtepi16_epi32 ( __m128i\n|             | a);                                    \n| (V)PMOVSXWQ:| __m128i _mm_ cvtepi16_epi64 ( __m128i  \n|             | a);                                    \n| VPMOVSXWQ:  | __m256i _mm256_cvtepi16_epi64 ( __m128i\n|             | a);                                    \n| (V)PMOVSXDQ:| __m128i _mm_ cvtepi32_epi64 ( __m128i  \n|             | a);                                    \n| VPMOVSXDQ:  | __m256i _mm256_cvtepi32_epi64 ( __m128i\n|             | a);                                    \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PMOVSX"
    }, 
    {
      "description": "\nPMOVZX  -  Packed Move with Zero Extend:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                         \n| 66 0f 38 30 /r PMOVZXBW xmm1, xmm2/m64| RM   | V/V                   | SSE4_1            | Zero extend 8 packed 8-bit integers \n|                                       |      |                       |                   | in the low 8 bytes of xmm2/m64 to 8 \n|                                       |      |                       |                   | packed 16-bit integers in xmm1.     \n| 66 0f 38 31 /r PMOVZXBD xmm1, xmm2/m32| RM   | V/V                   | SSE4_1            | Zero extend 4 packed 8-bit integers \n|                                       |      |                       |                   | in the low 4 bytes of xmm2/m32 to 4 \n|                                       |      |                       |                   | packed 32-bit integers in xmm1.     \n| 66 0f 38 32 /r PMOVZXBQ xmm1, xmm2/m16| RM   | V/V                   | SSE4_1            | Zero extend 2 packed 8-bit integers \n|                                       |      |                       |                   | in the low 2 bytes of xmm2/m16 to 2 \n|                                       |      |                       |                   | packed 64-bit integers in xmm1.     \n| 66 0f 38 33 /r PMOVZXWD xmm1, xmm2/m64| RM   | V/V                   | SSE4_1            | Zero extend 4 packed 16-bit integers\n|                                       |      |                       |                   | in the low 8 bytes of xmm2/m64 to 4 \n|                                       |      |                       |                   | packed 32-bit integers in xmm1.     \n| 66 0f 38 34 /r PMOVZXWQ xmm1, xmm2/m32| RM   | V/V                   | SSE4_1            | Zero extend 2 packed 16-bit integers\n|                                       |      |                       |                   | in the low 4 bytes of xmm2/m32 to 2 \n|                                       |      |                       |                   | packed 64-bit integers in xmm1.     \n| 66 0f 38 35 /r PMOVZXDQ xmm1, xmm2/m64| RM   | V/V                   | SSE4_1            | Zero extend 2 packed 32-bit integers\n|                                       |      |                       |                   | in the low 8 bytes of xmm2/m64 to 2 \n|                                       |      |                       |                   | packed 64-bit integers in xmm1.     \n| VEX.128.66.0F38.WIG 30 /r VPMOVZXBW   | RM   | V/V                   | AVX               | Zero extend 8 packed 8-bit integers \n| xmm1, xmm2/m64                        |      |                       |                   | in the low 8 bytes of xmm2/m64 to 8 \n|                                       |      |                       |                   | packed 16-bit integers in xmm1.     \n| VEX.128.66.0F38.WIG 31 /r VPMOVZXBD   | RM   | V/V                   | AVX               | Zero extend 4 packed 8-bit integers \n| xmm1, xmm2/m32                        |      |                       |                   | in the low 4 bytes of xmm2/m32 to 4 \n|                                       |      |                       |                   | packed 32-bit integers in xmm1.     \n| VEX.128.66.0F38.WIG 32 /r VPMOVZXBQ   | RM   | V/V                   | AVX               | Zero extend 2 packed 8-bit integers \n| xmm1, xmm2/m16                        |      |                       |                   | in the low 2 bytes of xmm2/m16 to 2 \n|                                       |      |                       |                   | packed 64-bit integers in xmm1.     \n| VEX.128.66.0F38.WIG 33 /r VPMOVZXWD   | RM   | V/V                   | AVX               | Zero extend 4 packed 16-bit integers\n| xmm1, xmm2/m64                        |      |                       |                   | in the low 8 bytes of xmm2/m64 to 4 \n|                                       |      |                       |                   | packed 32-bit integers in xmm1.     \n| VEX.128.66.0F38.WIG 34 /r VPMOVZXWQ   | RM   | V/V                   | AVX               | Zero extend 2 packed 16-bit integers\n| xmm1, xmm2/m32                        |      |                       |                   | in the low 4 bytes of xmm2/m32 to 2 \n|                                       |      |                       |                   | packed 64-bit integers in xmm1.     \n| VEX.128.66.0F38.WIG 35 /r VPMOVZXDQ   | RM   | V/V                   | AVX               | Zero extend 2 packed 32-bit integers\n| xmm1, xmm2/m64                        |      |                       |                   | in the low 8 bytes of xmm2/m64 to 2 \n|                                       |      |                       |                   | packed 64-bit integers in xmm1.     \n| VEX.256.66.0F38.WIG 30 /r VPMOVZXBW   | RM   | V/V                   | AVX2              | Zero extend 16 packed 8-bit integers\n| ymm1, xmm2/m128                       |      |                       |                   | in the low 16 bytes of xmm2/m128 to \n|                                       |      |                       |                   | 16 packed 16-bit integers in ymm1.  \n| VEX.256.66.0F38.WIG 31 /r VPMOVZXBD   | RM   | V/V                   | AVX2              | Zero extend 8 packed 8-bit integers \n| ymm1, xmm2/m64                        |      |                       |                   | in the low 8 bytes of xmm2/m64 to 8 \n|                                       |      |                       |                   | packed 32-bit integers in ymm1.     \n| VEX.256.66.0F38.WIG 32 /r VPMOVZXBQ   | RM   | V/V                   | AVX2              | Zero extend 4 packed 8-bit integers \n| ymm1, xmm2/m32                        |      |                       |                   | in the low 4 bytes of xmm2/m32 to 4 \n|                                       |      |                       |                   | packed 64-bit integers in ymm1.     \n| VEX.256.66.0F38.WIG 33 /r VPMOVZXWD   | RM   | V/V                   | AVX2              | Zero extend 8 packed 16-bit integers\n| ymm1, xmm2/m128                       |      |                       |                   | in the low 16 bytes of xmm2/m128 to \n|                                       |      |                       |                   | 8 packed 32bit integers in ymm1.    \n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                         \n| VEX.256.66.0F38.WIG 34 /r VPMOVZXWQ   | RM   | V/V                   | AVX2              | Zero extend 4 packed 16-bit integers\n| ymm1, xmm2/m64                        |      |                       |                   | in the low 8 bytes of xmm2/m64 to 4 \n|                                       |      |                       |                   | packed 64-bit integers in xmm1.     \n| VEX.256.66.0F38.WIG 35 /r VPMOVZXDQ   | RM   | V/V                   | AVX2              | Zero extend 4 packed 32-bit integers\n| ymm1, xmm2/m128                       |      |                       |                   | in the low 16 bytes of xmm2/m128 to \n|                                       |      |                       |                   | 4 packed 64bit integers in ymm1.    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nZero-extend the low byte/word/dword values in each word/dword/qword element\nof the source operand (second operand) to word/dword/qword integers and stored\nas packed data in the destination operand (first operand). 128-bit Legacy SSE\nversion: Bits (VLMAX-1:128) of the corresponding YMM destination register remain\nunchanged. VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM\nregister are zeroed. VEX.256 encoded version: The destination register is YMM\nRegister.\n\nNote: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the\ninstruction will #UD.\n\nOperation:\n\nPMOVZXBW\n  DEST[15:0] <- ZeroExtend(SRC[7:0]);\n  DEST[31:16] <- ZeroExtend(SRC[15:8]);\n  DEST[47:32] <- ZeroExtend(SRC[23:16]);\n  DEST[63:48] <- ZeroExtend(SRC[31:24]);\n  DEST[79:64] <- ZeroExtend(SRC[39:32]);\n  DEST[95:80] <- ZeroExtend(SRC[47:40]);\n  DEST[111:96] <- ZeroExtend(SRC[55:48]);\n  DEST[127:112] <- ZeroExtend(SRC[63:56]);\nPMOVZXBD\n  DEST[31:0] <- ZeroExtend(SRC[7:0]);\n  DEST[63:32] <- ZeroExtend(SRC[15:8]);\n  DEST[95:64] <- ZeroExtend(SRC[23:16]);\n  DEST[127:96] <- ZeroExtend(SRC[31:24]);\nPMOVZXQB\n  DEST[63:0] <- ZeroExtend(SRC[7:0]);\n  DEST[127:64] <- ZeroExtend(SRC[15:8]);\nPMOVZXWD\n  DEST[31:0] <- ZeroExtend(SRC[15:0]);\n  DEST[63:32] <- ZeroExtend(SRC[31:16]);\n  DEST[95:64] <- ZeroExtend(SRC[47:32]);\n  DEST[127:96] <- ZeroExtend(SRC[63:48]);\nPMOVZXWQ\n  DEST[63:0] <- ZeroExtend(SRC[15:0]);\n  DEST[127:64] <- ZeroExtend(SRC[31:16]);\nPMOVZXDQ\n  DEST[63:0] <- ZeroExtend(SRC[31:0]);\n  DEST[127:64] <- ZeroExtend(SRC[63:32]);\nVPMOVZXBW (VEX.128 encoded version)\nPacked_Zero_Extend_BYTE_to_WORD()\nDEST[VLMAX-1:128] <- 0\nVPMOVZXBD (VEX.128 encoded version)\nPacked_Zero_Extend_BYTE_to_DWORD()\nDEST[VLMAX-1:128] <- 0\nVPMOVZXBQ (VEX.128 encoded version)\nPacked_Zero_Extend_BYTE_to_QWORD()\nDEST[VLMAX-1:128] <- 0\nVPMOVZXWD (VEX.128 encoded version)\nPacked_Zero_Extend_WORD_to_DWORD()\nDEST[VLMAX-1:128] <- 0\nVPMOVZXWQ (VEX.128 encoded version)\nPacked_Zero_Extend_WORD_to_QWORD()\nDEST[VLMAX-1:128] <- 0\nVPMOVZXDQ (VEX.128 encoded version)\nPacked_Zero_Extend_DWORD_to_QWORD()\nDEST[VLMAX-1:128] <- 0\nVPMOVZXBW (VEX.256 encoded version)\nPacked_Zero_Extend_BYTE_to_WORD(DEST[127:0], SRC[63:0])\nPacked_Zero_Extend_BYTE_to_WORD(DEST[255:128], SRC[127:64])\nVPMOVZXBD (VEX.256 encoded version)\nPacked_Zero_Extend_BYTE_to_DWORD(DEST[127:0], SRC[31:0])\nPacked_Zero_Extend_BYTE_to_DWORD(DEST[255:128], SRC[63:32])\nVPMOVZXBQ (VEX.256 encoded version)\nPacked_Zero_Extend_BYTE_to_QWORD(DEST[127:0], SRC[15:0])\nPacked_Zero_Extend_BYTE_to_QWORD(DEST[255:128], SRC[31:16])\nVPMOVZXWD (VEX.256 encoded version)\nPacked_Zero_Extend_WORD_to_DWORD(DEST[127:0], SRC[63:0])\nPacked_Zero_Extend_WORD_to_DWORD(DEST[255:128], SRC[127:64])\nVPMOVZXWQ (VEX.256 encoded version)\nPacked_Zero_Extend_WORD_to_QWORD(DEST[127:0], SRC[31:0])\nPacked_Zero_Extend_WORD_to_QWORD(DEST[255:128], SRC[63:32])\nVPMOVZXDQ (VEX.256 encoded version)\nPacked_Zero_Extend_DWORD_to_QWORD(DEST[127:0], SRC[63:0])\nPacked_Zero_Extend_DWORD_to_QWORD(DEST[255:128], SRC[127:64])\n\nFlags Affected:\nNone\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PMOVZXBW:| __m128i _mm_ cvtepu8_epi16 ( __m128i   \n|             | a);                                    \n| VPMOVZXBW:  | __m256i _mm256_cvtepu8_epi16 ( __m128i \n|             | a);                                    \n| (V)PMOVZXBD:| __m128i _mm_ cvtepu8_epi32 ( __m128i   \n|             | a);                                    \n| VPMOVZXBD:  | __m256i _mm256_cvtepu8_epi32 ( __m128i \n|             | a);                                    \n| (V)PMOVZXBQ:| __m128i _mm_ cvtepu8_epi64 ( __m128i   \n|             | a);                                    \n| VPMOVZXBQ:  | __m256i _mm256_cvtepu8_epi64 ( __m128i \n|             | a);                                    \n| (V)PMOVZXWD:| __m128i _mm_ cvtepu16_epi32 ( __m128i  \n|             | a);                                    \n| VPMOVZXWD:  | __m256i _mm256_cvtepu16_epi32 ( __m128i\n|             | a);                                    \n| (V)PMOVZXWQ:| __m128i _mm_ cvtepu16_epi64 ( __m128i  \n|             | a);                                    \n| VPMOVZXWQ:  | __m256i _mm256_cvtepu16_epi64 ( __m128i\n|             | a);                                    \n| (V)PMOVZXDQ:| __m128i _mm_ cvtepu32_epi64 ( __m128i  \n|             | a);                                    \n| VPMOVZXDQ:  | __m256i _mm256_cvtepu32_epi64 ( __m128i\n|             | a);                                    \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PMOVZX"
    }, 
    {
      "description": "\nPMULDQ  -  Multiply Packed Signed Dword Integers:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                               \n| 66 0F 38 28 /r PMULDQ xmm1, xmm2/m128| RM   | V/V                   | SSE4_1            | Multiply the packed signed dword integers \n|                                      |      |                       |                   | in xmm1 and xmm2/m128 and store the       \n|                                      |      |                       |                   | quadword product in xmm1.                 \n| VEX.NDS.128.66.0F38.WIG 28 /r VPMULDQ| RVM  | V/V                   | AVX               | Multiply packed signed doubleword integers\n| xmm1, xmm2, xmm3/m128                |      |                       |                   | in xmm2 by packed signed doubleword       \n|                                      |      |                       |                   | integers in xmm3/m128, and store the      \n|                                      |      |                       |                   | quadword results in xmm1.                 \n| VEX.NDS.256.66.0F38.WIG 28 /r VPMULDQ| RVM  | V/V                   | AVX2              | Multiply packed signed doubleword integers\n| ymm1, ymm2, ymm3/m256                |      |                       |                   | in ymm2 by packed signed doubleword       \n|                                      |      |                       |                   | integers in ymm3/m256, and store the      \n|                                      |      |                       |                   | quadword results in ymm1.                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nMultiplies the first source operand by the second source operand and stores\nthe result in the destination operand. For PMULDQ and VPMULDQ (VEX.128 encoded\nversion), the second source operand is two packed signed doubleword integers\nstored in the first (low) and third doublewords of an XMM register or a 128-bit\nmemory location. The first source operand is two packed signed doubleword integers\nstored in the first and third doublewords of an XMM register. The destination\ncontains two packed signed quadword integers stored in an XMM register. For\n128-bit memory operands, 128 bits are fetched from memory, but only the first\nand third doublewords are used in the computation. For VPMULDQ (VEX.256 encoded\nversion), the second source operand is four packed signed doubleword integers\nstored in the first (low), third, fifth and seventh doublewords of an YMM register\nor a 256-bit memory location. The first source operand is four packed signed\ndoubleword integers stored in the first, third, fifth and seventh doublewords\nof an XMM register. The destination contains four packed signed quadword integers\nstored in an YMM register. For 256-bit memory operands, 256 bits are fetched\nfrom memory, but only the first, third, fifth and seventh doublewords are used\nin the computation. When a quadword result is too large to be represented in\n64 bits (overflow), the result is wrapped around and the low 64 bits are written\nto the destination element (that is, the carry is ignored). 128-bit Legacy SSE\nversion: The first source and destination operands are XMM registers. The second\nsource operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)\nof the corresponding YMM destination register remain unchanged. VEX.128 encoded\nversion: The first source and destination operands are XMM registers. The second\nsource operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)\nof the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction\nwill #UD. VEX.256 encoded version: The second source operand can be an YMM register\nor a 256-bit memory location. The first source and destination operands are\nYMM registers.\n\nOperation:\n\nPMULDQ (128-bit Legacy SSE version)\nDEST[63:0] <- DEST[31:0] * SRC[31:0]\nDEST[127:64] <- DEST[95:64] * SRC[95:64]\nDEST[VLMAX-1:128] (Unmodified)\nVPMULDQ (VEX.128 encoded version)\nDEST[63:0] <- SRC1[31:0] * SRC2[31:0]\nDEST[127:64] <- SRC1[95:64] * SRC2[95:64]\nDEST[VLMAX-1:128] <- 0\nVPMULDQ (VEX.256 encoded version)\nDEST[63:0] <- SRC1[31:0] * SRC2[31:0]\nDEST[127:64] <- SRC1[95:64] * SRC2[95:64]\nDEST[191:128] <- SRC1[159:128] * SRC2[159:128]\nDEST[255:192] <- SRC1[223:192] * SRC2[223:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PMULDQ:| __m128i _mm_mul_epi32( __m128i a, __m128i\n|           | b);                                      \n| VPMULDQ:  | __m256i _mm256_mul_epi32( __m256i a,     \n|           | __m256i b);                              \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PMULDQ"
    }, 
    {
      "description": "\nPMULHRSW  -  Packed Multiply High with Round and Scale:\n| Opcode/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 0F 38 0B /r1 PMULHRSW mm1, mm2/m64     | RM   | V/V                   | SSSE3             | Multiply 16-bit signed words, scale    \n|                                        |      |                       |                   | and round signed doublewords, pack high\n|                                        |      |                       |                   | 16 bits to mm1.                        \n| 66 0F 38 0B /r PMULHRSW xmm1, xmm2/m128| RM   | V/V                   | SSSE3             | Multiply 16-bit signed words, scale    \n|                                        |      |                       |                   | and round signed doublewords, pack high\n|                                        |      |                       |                   | 16 bits to xmm1.                       \n| VEX.NDS.128.66.0F38.WIG 0B /r VPMULHRSW| RVM  | V/V                   | AVX               | Multiply 16-bit signed words, scale    \n| xmm1, xmm2, xmm3/m128                  |      |                       |                   | and round signed doublewords, pack high\n|                                        |      |                       |                   | 16 bits to xmm1.                       \n| VEX.NDS.256.66.0F38.WIG 0B /r VPMULHRSW| RVM  | V/V                   | AVX2              | Multiply 16-bit signed words, scale    \n| ymm1, ymm2, ymm3/m256                  |      |                       |                   | and round signed doublewords, pack high\n|                                        |      |                       |                   | 16 bits to ymm1.                       \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPMULHRSW multiplies vertically each signed 16-bit integer from the destination\noperand (first operand) with the corresponding signed 16-bit integer of the\nsource operand (second operand), producing intermediate, signed 32bit integers.\nEach intermediate 32-bit integer is truncated to the 18 most significant bits.\nRounding is always performed by adding 1 to the least significant bit of the\n18-bit intermediate result. The final result is obtained by selecting the 16\nbits immediately to the right of the most significant bit of each 18-bit intermediate\nresult and packed to the destination operand.\n\nWhen the source operand is a 128-bit memory operand, the operand must be aligned\non a 16-byte boundary or a general-protection exception (#GP) will be generated.\n\nIn 64-bit mode, use the REX prefix to access additional registers. Legacy SSE\nversion: Both operands can be MMX registers. The second source operand is an\nMMX register or a 64bit memory location.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM\nregisters. The second source operand is an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the corresponding YMM destination register remain\nunchanged. VEX.128 encoded version: The first source and destination operands\nare XMM registers. The second source operand is an XMM register or a 128-bit\nmemory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\nVEX.L must be 0, otherwise the instruction will #UD. VEX.256 encoded version:\nThe second source operand can be an YMM register or a 256-bit memory location.\nThe first source and destination operands are YMM registers.\n\nOperation:\n\nPMULHRSW (with 64-bit operands)\n  temp0[31:0] = INT32 ((DEST[15:0] * SRC[15:0]) >>14) + 1;\n  temp1[31:0] = INT32 ((DEST[31:16] * SRC[31:16]) >>14) + 1;\n  temp2[31:0] = INT32 ((DEST[47:32] * SRC[47:32]) >> 14) + 1;\n  temp3[31:0] = INT32 ((DEST[63:48] * SRc[63:48]) >> 14) + 1;\n  DEST[15:0] = temp0[16:1];\n  DEST[31:16] = temp1[16:1];\n  DEST[47:32] = temp2[16:1];\n  DEST[63:48] = temp3[16:1];\nPMULHRSW (with 128-bit operand)\n  temp0[31:0] = INT32 ((DEST[15:0] * SRC[15:0]) >>14) + 1;\n  temp1[31:0] = INT32 ((DEST[31:16] * SRC[31:16]) >>14) + 1;\n  temp2[31:0] = INT32 ((DEST[47:32] * SRC[47:32]) >>14) + 1;\n  temp3[31:0] = INT32 ((DEST[63:48] * SRC[63:48]) >>14) + 1;\n  temp4[31:0] = INT32 ((DEST[79:64] * SRC[79:64]) >>14) + 1;\n  temp5[31:0] = INT32 ((DEST[95:80] * SRC[95:80]) >>14) + 1;\n  temp6[31:0] = INT32 ((DEST[111:96] * SRC[111:96]) >>14) + 1;\n  temp7[31:0] = INT32 ((DEST[127:112] * SRC[127:112) >>14) + 1;\n  DEST[15:0] = temp0[16:1];\n  DEST[31:16] = temp1[16:1];\n  DEST[47:32] = temp2[16:1];\n  DEST[63:48] = temp3[16:1];\n  DEST[79:64] = temp4[16:1];\n  DEST[95:80] = temp5[16:1];\n  DEST[111:96] = temp6[16:1];\n  DEST[127:112] = temp7[16:1];\nVPMULHRSW (VEX.128 encoded version)\ntemp0[31:0] <- INT32 ((SRC1[15:0] * SRC2[15:0]) >>14) + 1\ntemp1[31:0] <- INT32 ((SRC1[31:16] * SRC2[31:16]) >>14) + 1\ntemp2[31:0] <- INT32 ((SRC1[47:32] * SRC2[47:32]) >>14) + 1\ntemp3[31:0] <- INT32 ((SRC1[63:48] * SRC2[63:48]) >>14) + 1\ntemp4[31:0] <- INT32 ((SRC1[79:64] * SRC2[79:64]) >>14) + 1\ntemp5[31:0] <- INT32 ((SRC1[95:80] * SRC2[95:80]) >>14) + 1\ntemp6[31:0] <- INT32 ((SRC1[111:96] * SRC2[111:96]) >>14) + 1\ntemp7[31:0] <- INT32 ((SRC1[127:112] * SRC2[127:112) >>14) + 1\nDEST[15:0] <- temp0[16:1]\nDEST[31:16] <- temp1[16:1]\nDEST[47:32] <- temp2[16:1]\nDEST[63:48] <- temp3[16:1]\nDEST[79:64] <- temp4[16:1]\nDEST[95:80] <- temp5[16:1]\nDEST[111:96] <- temp6[16:1]\nDEST[127:112] <- temp7[16:1]\nDEST[VLMAX-1:128] <- 0\nVPMULHRSW (VEX.256 encoded version)\ntemp0[31:0] <- INT32 ((SRC1[15:0] * SRC2[15:0]) >>14) + 1\ntemp1[31:0] <- INT32 ((SRC1[31:16] * SRC2[31:16]) >>14) + 1\ntemp2[31:0] <- INT32 ((SRC1[47:32] * SRC2[47:32]) >>14) + 1\ntemp3[31:0] <- INT32 ((SRC1[63:48] * SRC2[63:48]) >>14) + 1\ntemp4[31:0] <- INT32 ((SRC1[79:64] * SRC2[79:64]) >>14) + 1\ntemp5[31:0] <- INT32 ((SRC1[95:80] * SRC2[95:80]) >>14) + 1\ntemp6[31:0] <- INT32 ((SRC1[111:96] * SRC2[111:96]) >>14) + 1\ntemp7[31:0] <- INT32 ((SRC1[127:112] * SRC2[127:112) >>14) + 1\ntemp8[31:0] <- INT32 ((SRC1[143:128] * SRC2[143:128]) >>14) + 1\ntemp9[31:0] <- INT32 ((SRC1[159:144] * SRC2[159:144]) >>14) + 1\ntemp10[31:0] <- INT32 ((SRC1[75:160] * SRC2[175:160]) >>14) + 1\ntemp11[31:0] <- INT32 ((SRC1[191:176] * SRC2[191:176]) >>14) + 1\ntemp12[31:0] <- INT32 ((SRC1[207:192] * SRC2[207:192]) >>14) + 1\ntemp13[31:0] <- INT32 ((SRC1[223:208] * SRC2[223:208]) >>14) + 1\ntemp14[31:0] <- INT32 ((SRC1[239:224] * SRC2[239:224]) >>14) + 1\ntemp15[31:0] <- INT32 ((SRC1[255:240] * SRC2[255:240) >>14) + 1\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PMULHRSW:   | __m64 _mm_mulhrs_pi16 (__m64 a, __m64\n|             | b)                                   \n| (V)PMULHRSW:| __m128i _mm_mulhrs_epi16 (__m128i a, \n|             | __m128i b)                           \n| VPMULHRSW:  | __m256i _mm256_mulhrs_epi16 (__m256i \n|             | a, __m256i b)                        \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMULHRSW"
    }, 
    {
      "description": "\nPMULHUW - Multiply Packed Unsigned Integers and Store High Result:\n| Opcode/Instruction                  | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                               \n| 0F E4 /r1 PMULHUW mm1, mm2/m64      | RM   | V/V                   | SSE               | Multiply the packed unsigned word integers\n|                                     |      |                       |                   | in mm1 register and mm2/m64, and store    \n|                                     |      |                       |                   | the high 16 bits of the results in mm1.   \n| 66 0F E4 /r PMULHUW xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Multiply the packed unsigned word integers\n|                                     |      |                       |                   | in xmm1 and xmm2/m128, and store the      \n|                                     |      |                       |                   | high 16 bits of the results in xmm1.      \n| VEX.NDS.128.66.0F.WIG E4 /r VPMULHUW| RVM  | V/V                   | AVX               | Multiply the packed unsigned word integers\n| xmm1, xmm2, xmm3/m128               |      |                       |                   | in xmm2 and xmm3/m128, and store the      \n|                                     |      |                       |                   | high 16 bits of the results in xmm1.      \n| VEX.NDS.256.66.0F.WIG E4 /r VPMULHUW| RVM  | V/V                   | AVX2              | Multiply the packed unsigned word integers\n| ymm1, ymm2, ymm3/m256               |      |                       |                   | in ymm2 and ymm3/m256, and store the      \n|                                     |      |                       |                   | high 16 bits of the results in ymm1.      \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD unsigned multiply of the packed unsigned word integers in the\ndestination operand (first operand) and the source operand (second operand),\nand stores the high 16 bits of each 32-bit intermediate results in the destination\noperand. (Figure 4-8 shows this operation when using 64-bit operands.)\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). Legacy SSE version: The source\noperand can be an MMX technology register or a 64-bit memory location. The destination\noperand is an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM\nregisters. The second source operand is an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the corresponding YMM destination register remain\nunchanged. VEX.128 encoded version: The first source and destination operands\nare XMM registers. The second source operand is an XMM register or a 128-bit\nmemory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\nVEX.L must be 0, otherwise the instruction will #UD. VEX.256 encoded version:\nThe second source operand can be an YMM register or a 256-bit memory location.\nThe first source and destination operands are YMM registers.\n\n| SRC | X3             | X2| X1             | X0             \n| DEST| Y3 Z2 = X2 * Y2| Y2| Y1 Z1 = X1 * Y1| Y0 Z0 = X0 * Y0\nDEST\n\n| Z3[31:16]PMULHUW and PMULHW Instruction| Z2[31:16]| Z1[31:16]| Z0[31:16]Figure 4-8.\n| Operation Using 64-bit Operands        |          |          |                     \nOperation:\n\nPMULHUW (with 64-bit operands)\n  TEMP0[31:0] <-\n  TEMP1[31:0] <-\n  TEMP2[31:0] <-\n  TEMP3[31:0] <-\n  DEST[15:0] <-\n  DEST[31:16] <-\n  DEST[47:32] <-\n  DEST[63:48] <-\nPMULHUW (with 128-bit operands)\n  TEMP0[31:0] <-\n  TEMP1[31:0] <-\n  TEMP2[31:0] <-\n  TEMP3[31:0] <-\n  TEMP4[31:0] <-\n  TEMP5[31:0] <-\n  TEMP6[31:0] <-\n  TEMP7[31:0] <-\n  DEST[15:0] <-\n  DEST[31:16] <-\n  DEST[47:32] <-\n  DEST[63:48] <-\n  DEST[79:64] <-\n  DEST[95:80] <-\n  DEST[111:96] <-\n  DEST[127:112] <- TEMP7[31:16];\nVPMULHUW (VEX.128 encoded version)\nTEMP0[31:0] <- SRC1[15:0] * SRC2[15:0]\nTEMP1[31:0] <- SRC1[31:16] * SRC2[31:16]\nTEMP2[31:0] <- SRC1[47:32] * SRC2[47:32]\nTEMP3[31:0] <- SRC1[63:48] * SRC2[63:48]\nTEMP4[31:0] <- SRC1[79:64] * SRC2[79:64]\nTEMP5[31:0] <- SRC1[95:80] * SRC2[95:80]\nTEMP6[31:0] <- SRC1[111:96] * SRC2[111:96]\nTEMP7[31:0] <- SRC1[127:112] * SRC2[127:112]\nDEST[15:0] <- TEMP0[31:16]\nDEST[31:16] <- TEMP1[31:16]\nDEST[47:32] <- TEMP2[31:16]\nDEST[63:48] <- TEMP3[31:16]\nDEST[79:64] <- TEMP4[31:16]\nDEST[95:80] <- TEMP5[31:16]\nDEST[111:96] <- TEMP6[31:16]\nDEST[127:112] <- TEMP7[31:16]\nDEST[VLMAX-1:128] <- 0\nPMULHUW (VEX.256 encoded version)\nTEMP0[31:0] <- SRC1[15:0] * SRC2[15:0]\nTEMP1[31:0] <- SRC1[31:16] * SRC2[31:16]\nTEMP2[31:0] <- SRC1[47:32] * SRC2[47:32]\nTEMP3[31:0] <- SRC1[63:48] * SRC2[63:48]\nTEMP4[31:0] <- SRC1[79:64] * SRC2[79:64]\nTEMP5[31:0] <- SRC1[95:80] * SRC2[95:80]\nTEMP6[31:0] <- SRC1[111:96] * SRC2[111:96]\nTEMP7[31:0] <- SRC1[127:112] * SRC2[127:112]\nTEMP8[31:0] <- SRC1[143:128] * SRC2[143:128]\nTEMP9[31:0] <- SRC1[159:144] * SRC2[159:144]\nTEMP10[31:0] <- SRC1[175:160] * SRC2[175:160]\nTEMP11[31:0] <- SRC1[191:176] * SRC2[191:176]\nTEMP12[31:0] <- SRC1[207:192] * SRC2[207:192]\nTEMP13[31:0] <- SRC1[223:208] * SRC2[223:208]\nTEMP14[31:0] <- SRC1[239:224] * SRC2[239:224]\nTEMP15[31:0] <- SRC1[255:240] * SRC2[255:240]\nDEST[15:0] <- TEMP0[31:16]\nDEST[31:16] <- TEMP1[31:16]\nDEST[47:32] <- TEMP2[31:16]\nDEST[63:48] <- TEMP3[31:16]\nDEST[79:64] <- TEMP4[31:16]\nDEST[95:80] <- TEMP5[31:16]\nDEST[111:96] <- TEMP6[31:16]\nDEST[127:112] <- TEMP7[31:16]\nDEST[143:128] <- TEMP8[31:16]\nDEST[159:144] <- TEMP9[31:16]\nDEST[175:160] <- TEMP10[31:16]\nDEST[191:176] <- TEMP11[31:16]\nDEST[207:192] <- TEMP12[31:16]\nDEST[223:208] <- TEMP13[31:16]\nDEST[239:224] <- TEMP14[31:16]\nDEST[255:240] <- TEMP15[31:16]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PMULHUW:   | __m64 _mm_mulhi_pu16(__m64 a, __m64 \n|            | b)                                  \n| (V)PMULHUW:| __m128i _mm_mulhi_epu16 ( __m128i a,\n|            | __m128i b)                          \n| VPMULHUW:  | __m256i _mm256_mulhi_epu16 ( __m256i\n|            | a, __m256i b)                       \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMULHUW"
    }, 
    {
      "description": "\nPMULHW - Multiply Packed Signed Integers and Store High Result:\n| Opcode/Instruction                 | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| 0F E5 /r1 PMULHW mm, mm/m64        | RM   | V/V                   | MMX               | Multiply the packed signed word integers\n|                                    |      |                       |                   | in mm1 register and mm2/m64, and store  \n|                                    |      |                       |                   | the high 16 bits of the results in mm1. \n| 66 0F E5 /r PMULHW xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Multiply the packed signed word integers\n|                                    |      |                       |                   | in xmm1 and xmm2/m128, and store the    \n|                                    |      |                       |                   | high 16 bits of the results in xmm1.    \n| VEX.NDS.128.66.0F.WIG E5 /r VPMULHW| RVM  | V/V                   | AVX               | Multiply the packed signed word integers\n| xmm1, xmm2, xmm3/m128              |      |                       |                   | in xmm2 and xmm3/m128, and store the    \n|                                    |      |                       |                   | high 16 bits of the results in xmm1.    \n| VEX.NDS.256.66.0F.WIG E5 /r VPMULHW| RVM  | V/V                   | AVX2              | Multiply the packed signed word integers\n| ymm1, ymm2, ymm3/m256              |      |                       |                   | in ymm2 and ymm3/m256, and store the    \n|                                    |      |                       |                   | high 16 bits of the results in ymm1.    \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD signed multiply of the packed signed word integers in the destination\noperand (first operand) and the source operand (second operand), and stores\nthe high 16 bits of each intermediate 32-bit result in the destination operand.\n(Figure 4-8 shows this operation when using 64-bit operands.)\n\nn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). Legacy SSE version: The source\noperand can be an MMX technology register or a 64-bit memory location. The destination\noperand is an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM\nregisters. The second source operand is an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the corresponding YMM destination register remain\nunchanged. VEX.128 encoded version: The first source and destination operands\nare XMM registers. The second source operand is an XMM register or a 128-bit\nmemory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\nVEX.L must be 0, otherwise the instruction will #UD. VEX.256 encoded version:\nThe second source operand can be an YMM register or a 256-bit memory location.\nThe first source and destination operands are YMM registers.\n\nOperation:\n\nPMULHW (with 64-bit operands)\n  TEMP0[31:0] <-\n  TEMP1[31:0] <-\n  TEMP2[31:0] <-\n  TEMP3[31:0] <-\n  DEST[15:0] <-\n  DEST[31:16] <-\n  DEST[47:32] <-\n  DEST[63:48] <-\nPMULHW (with 128-bit operands)\n  TEMP0[31:0] <-\n  TEMP1[31:0] <-\n  TEMP2[31:0] <-\n  TEMP3[31:0] <-\n  TEMP4[31:0] <-\n  TEMP5[31:0] <-\n  TEMP6[31:0] <-\n  TEMP7[31:0] <-\n  DEST[15:0] <-\n  DEST[31:16] <-\n  DEST[47:32] <-\n  DEST[63:48] <-\n  DEST[79:64] <-\n  DEST[95:80] <-\n  DEST[111:96] <-\n  DEST[127:112] <- TEMP7[31:16];\nVPMULHW (VEX.128 encoded version)\nTEMP0[31:0] <- SRC1[15:0] * SRC2[15:0] (*Signed Multiplication*)\nTEMP1[31:0] <- SRC1[31:16] * SRC2[31:16]\nTEMP2[31:0] <- SRC1[47:32] * SRC2[47:32]\nTEMP3[31:0] <- SRC1[63:48] * SRC2[63:48]\nTEMP4[31:0] <- SRC1[79:64] * SRC2[79:64]\nTEMP5[31:0] <- SRC1[95:80] * SRC2[95:80]\nTEMP6[31:0] <- SRC1[111:96] * SRC2[111:96]\nTEMP7[31:0] <- SRC1[127:112] * SRC2[127:112]\nDEST[15:0] <- TEMP0[31:16]\nDEST[31:16] <- TEMP1[31:16]\nDEST[47:32] <- TEMP2[31:16]\nDEST[63:48] <- TEMP3[31:16]\nDEST[79:64] <- TEMP4[31:16]\nDEST[95:80] <- TEMP5[31:16]\nDEST[111:96] <- TEMP6[31:16]\nDEST[127:112] <- TEMP7[31:16]\nDEST[VLMAX-1:128] <- 0\nPMULHW (VEX.256 encoded version)\nTEMP0[31:0] <- SRC1[15:0] * SRC2[15:0] (*Signed Multiplication*)\nTEMP1[31:0] <- SRC1[31:16] * SRC2[31:16]\nTEMP2[31:0] <- SRC1[47:32] * SRC2[47:32]\nTEMP3[31:0] <- SRC1[63:48] * SRC2[63:48]\nTEMP4[31:0] <- SRC1[79:64] * SRC2[79:64]\nTEMP5[31:0] <- SRC1[95:80] * SRC2[95:80]\nTEMP6[31:0] <- SRC1[111:96] * SRC2[111:96]\nTEMP7[31:0] <- SRC1[127:112] * SRC2[127:112]\nTEMP8[31:0] <- SRC1[143:128] * SRC2[143:128]\nTEMP9[31:0] <- SRC1[159:144] * SRC2[159:144]\nTEMP10[31:0] <- SRC1[175:160] * SRC2[175:160]\nTEMP11[31:0] <- SRC1[191:176] * SRC2[191:176]\nTEMP12[31:0] <- SRC1[207:192] * SRC2[207:192]\nTEMP13[31:0] <- SRC1[223:208] * SRC2[223:208]\nTEMP14[31:0] <- SRC1[239:224] * SRC2[239:224]\nTEMP15[31:0] <- SRC1[255:240] * SRC2[255:240]\nDEST[15:0] <- TEMP0[31:16]\nDEST[31:16] <- TEMP1[31:16]\nDEST[47:32] <- TEMP2[31:16]\nDEST[63:48] <- TEMP3[31:16]\nDEST[79:64] <- TEMP4[31:16]\nDEST[95:80] <- TEMP5[31:16]\nDEST[111:96] <- TEMP6[31:16]\nDEST[127:112] <- TEMP7[31:16]\nDEST[143:128] <- TEMP8[31:16]\nDEST[159:144] <- TEMP9[31:16]\nDEST[175:160] <- TEMP10[31:16]\nDEST[191:176] <- TEMP11[31:16]\nDEST[207:192] <- TEMP12[31:16]\nDEST[223:208] <- TEMP13[31:16]\nDEST[239:224] <- TEMP14[31:16]\nDEST[255:240] <- TEMP15[31:16]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PMULHW:   | __m64 _mm_mulhi_pi16 (__m64 m1, __m64\n|           | m2)                                  \n| (V)PMULHW:| __m128i _mm_mulhi_epi16 ( __m128i a, \n|           | __m128i b)                           \n| VPMULHW:  | __m256i _mm256_mulhi_epi16 ( __m256i \n|           | a, __m256i b)                        \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMULHW"
    }, 
    {
      "description": "\nPMULLD  -  Multiply Packed Signed Dword Integers and Store Low Result:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| 66 0F 38 40 /r PMULLD xmm1, xmm2/m128| RM   | V/V                   | SSE4_1            | Multiply the packed dword signed integers\n|                                      |      |                       |                   | in xmm1 and xmm2/m128 and store the      \n|                                      |      |                       |                   | low 32 bits of each product in xmm1.     \n| VEX.NDS.128.66.0F38.WIG 40 /r VPMULLD| RVM  | V/V                   | AVX               | Multiply the packed dword signed integers\n| xmm1, xmm2, xmm3/m128                |      |                       |                   | in xmm2 and xmm3/m128 and store the      \n|                                      |      |                       |                   | low 32 bits of each product in xmm1.     \n| VEX.NDS.256.66.0F38.WIG 40 /r VPMULLD| RVM  | V/V                   | AVX2              | Multiply the packed dword signed integers\n| ymm1, ymm2, ymm3/m256                |      |                       |                   | in ymm2 and ymm3/m256 and store the      \n|                                      |      |                       |                   | low 32 bits of each product in ymm1.     \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms four signed multiplications from four pairs of signed dword integers\nand stores the lower 32 bits of the four 64-bit products in the destination\noperand (first operand). Each dword element in the destination operand is multiplied\nwith the corresponding dword element of the source operand (second operand)\nto obtain a 64-bit intermediate product. 128-bit Legacy SSE version: The first\nsource and destination operands are XMM registers. The second source operand\nis an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: The first\nsource and destination operands are XMM registers. The second source operand\nis an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination\nYMM register are zeroed. VEX.256 encoded version: The second source operand\ncan be an YMM register or a 256-bit memory location. The first source and destination\noperands are YMM registers.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nTemp0[63:0] <- DEST[31:0] * SRC[31:0];\nTemp1[63:0] <- DEST[63:32] * SRC[63:32];\nTemp2[63:0] <- DEST[95:64] * SRC[95:64];\nTemp3[63:0] <- DEST[127:96] * SRC[127:96];\nDEST[31:0] <- Temp0[31:0];\nDEST[63:32] <- Temp1[31:0];\nDEST[95:64] <- Temp2[31:0];\nDEST[127:96] <- Temp3[31:0];\nVPMULLD (VEX.128 encoded version)\nTemp0[63:0] <- SRC1[31:0] * SRC2[31:0]\nTemp1[63:0] <- SRC1[63:32] * SRC2[63:32]\nTemp2[63:0] <- SRC1[95:64] * SRC2[95:64]\nTemp3[63:0] <- SRC1[127:96] * SRC2[127:96]\nDEST[31:0] <- Temp0[31:0]\nDEST[63:32] <- Temp1[31:0]\nDEST[95:64] <- Temp2[31:0]\nDEST[127:96] <- Temp3[31:0]\nDEST[VLMAX-1:128] <- 0\nVPMULLD (VEX.256 encoded version)\nTemp0[63:0] <- SRC1[31:0] * SRC2[31:0]\nTemp1[63:0] <- SRC1[63:32] * SRC2[63:32]\nTemp2[63:0] <- SRC1[95:64] * SRC2[95:64]\nTemp3[63:0] <- SRC1[127:96] * SRC2[127:96]\nTemp4[63:0] <- SRC1[159:128] * SRC2[159:128]\nTemp5[63:0] <- SRC1[191:160] * SRC2[191:160]\nTemp6[63:0] <- SRC1[223:192] * SRC2[223:192]\nTemp7[63:0] <- SRC1[255:224] * SRC2[255:224]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PMULLUD:| __m128i _mm_mullo_epi32(__m128i a, __m128i\n|            | b);                                       \n| VPMULLD:   | __m256i _mm256_mullo_epi32(__m256i a,     \n|            | __m256i b);                               \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMULLD"
    }, 
    {
      "description": "\nPMULLW - Multiply Packed Signed Integers and Store Low Result:\n| Opcode/Instruction                 | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| 0F D5 /r1 PMULLW mm, mm/m64        | RM   | V/V                   | MMX               | Multiply the packed signed word integers \n|                                    |      |                       |                   | in mm1 register and mm2/m64, and store   \n|                                    |      |                       |                   | the low 16 bits of the results in mm1.   \n| 66 0F D5 /r PMULLW xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Multiply the packed signed word integers \n|                                    |      |                       |                   | in xmm1 and xmm2/m128, and store the     \n|                                    |      |                       |                   | low 16 bits of the results in xmm1.      \n| VEX.NDS.128.66.0F.WIG D5 /r VPMULLW| RVM  | V/V                   | AVX               | Multiply the packed dword signed integers\n| xmm1, xmm2, xmm3/m128              |      |                       |                   | in xmm2 and xmm3/m128 and store the      \n|                                    |      |                       |                   | low 32 bits of each product in xmm1.     \n| VEX.NDS.256.66.0F.WIG D5 /r VPMULLW| RVM  | V/V                   | AVX2              | Multiply the packed signed word integers \n| ymm1, ymm2, ymm3/m256              |      |                       |                   | in ymm2 and ymm3/m256, and store the     \n|                                    |      |                       |                   | low 16 bits of the results in ymm1.      \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD signed multiply of the packed signed word integers in the destination\noperand (first operand) and the source operand (second operand), and stores\nthe low 16 bits of each intermediate 32-bit result in the destination operand.\n(Figure 4-8 shows this operation when using 64-bit operands.)\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). Legacy SSE version: The source\noperand can be an MMX technology register or a 64-bit memory location. The destination\noperand is an MMX technology register.\n\n128-bit Legacy SSE version: The first source and destination operands are XMM\nregisters. The second source operand is an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the corresponding YMM destination register remain\nunchanged. VEX.128 encoded version: The first source and destination operands\nare XMM registers. The second source operand is an XMM register or a 128-bit\nmemory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\nVEX.L must be 0, otherwise the instruction will #UD. VEX.256 encoded version:\nThe second source operand can be an YMM register or a 256-bit memory location.\nThe first source and destination operands are YMM registers.\n\n| SRC                                    | X3             | X2      | X1             | X0                 \n| DEST                                   | Y3 Z2 = X2 * Y2| Y2      | Y1 Z1 = X1 * Y1| Y0 Z0 = X0 * Y0    \n| DEST PMULLU Instruction Operation Using| Z3[15:0]       | Z2[15:0]| Z1[15:0]       | Z0[15:0]Figure 4-9.\n| 64-bit Operands                        |                |         |                |                    \nOperation:\n\nPMULLW (with 64-bit operands)\n  TEMP0[31:0] <-\n  TEMP1[31:0] <-\n  TEMP2[31:0] <-\n  TEMP3[31:0] <-\n  DEST[15:0] <-\n  DEST[31:16] <-\n  DEST[47:32] <-\n  DEST[63:48] <-\nPMULLW (with 128-bit operands)\n  TEMP0[31:0] <-\n  TEMP1[31:0] <-\n  TEMP2[31:0] <-\n  TEMP3[31:0] <-\n  TEMP4[31:0] <-\n  TEMP5[31:0] <-\n  TEMP6[31:0] <-\n  TEMP7[31:0] <-\n  DEST[15:0] <-\n  DEST[31:16] <-\n  DEST[47:32] <-\n  DEST[63:48] <-\n  DEST[79:64] <-\n  DEST[95:80] <-\n  DEST[111:96] <-\n  DEST[127:112] <- TEMP7[15:0];\nVPMULLW (VEX.128 encoded version)\nTemp0[31:0] <- SRC1[15:0] * SRC2[15:0]\nTemp1[31:0] <- SRC1[31:16] * SRC2[31:16]\nTemp2[31:0] <- SRC1[47:32] * SRC2[47:32]\nTemp3[31:0] <- SRC1[63:48] * SRC2[63:48]\nTemp4[31:0] <- SRC1[79:64] * SRC2[79:64]\nTemp5[31:0] <- SRC1[95:80] * SRC2[95:80]\nTemp6[31:0] <- SRC1[111:96] * SRC2[111:96]\nTemp7[31:0] <- SRC1[127:112] * SRC2[127:112]\nDEST[15:0] <- Temp0[15:0]\nDEST[31:16] <- Temp1[15:0]\nDEST[47:32] <- Temp2[15:0]\nDEST[63:48] <- Temp3[15:0]\nDEST[79:64] <- Temp4[15:0]\nDEST[95:80] <- Temp5[15:0]\nDEST[111:96] <- Temp6[15:0]\nDEST[127:112] <- Temp7[15:0]\nDEST[VLMAX-1:128] <- 0\nVPMULLD (VEX.256 encoded version)\nTemp0[63:0] <- SRC1[31:0] * SRC2[31:0]\nTemp1[63:0] <- SRC1[63:32] * SRC2[63:32]\nTemp2[63:0] <- SRC1[95:64] * SRC2[95:64]\nTemp3[63:0] <- SRC1[127:96] * SRC2[127:96]\nTemp4[63:0] <- SRC1[159:128] * SRC2[159:128]\nTemp5[63:0] <- SRC1[191:160] * SRC2[191:160]\nTemp6[63:0] <- SRC1[223:192] * SRC2[223:192]\nTemp7[63:0] <- SRC1[255:224] * SRC2[255:224]\nDEST[31:0] <- Temp0[31:0]\nDEST[63:32] <- Temp1[31:0]\nDEST[95:64] <- Temp2[31:0]\nDEST[127:96] <- Temp3[31:0]\nDEST[159:128] <- Temp4[31:0]\nDEST[191:160] <- Temp5[31:0]\nDEST[223:192] <- Temp6[31:0]\nDEST[255:224] <- Temp7[31:0]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PMULLW:   | __m64 _mm_mullo_pi16(__m64 m1, __m64\n|           | m2)                                 \n| (V)PMULLW:| __m128i _mm_mullo_epi16 ( __m128i a,\n|           | __m128i b)                          \n| VPMULLW:  | __m256i _mm256_mullo_epi16 ( __m256i\n|           | a, __m256i b);                      \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMULLW"
    }, 
    {
      "description": "\nPMULUDQ - Multiply Packed Unsigned Doubleword Integers:\n| Opcode/Instruction                  | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| 0F F4 /r1 PMULUDQ mm1, mm2/m64      | RM   | V/V                   | SSE2              | Multiply unsigned doubleword integer     \n|                                     |      |                       |                   | in mm1 by unsigned doubleword integer    \n|                                     |      |                       |                   | in mm2/m64, and store the quadword result\n|                                     |      |                       |                   | in mm1.                                  \n| 66 0F F4 /r PMULUDQ xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Multiply packed unsigned doubleword      \n|                                     |      |                       |                   | integers in xmm1 by packed unsigned      \n|                                     |      |                       |                   | doubleword integers in xmm2/m128, and    \n|                                     |      |                       |                   | store the quadword results in xmm1.      \n| VEX.NDS.128.66.0F.WIG F4 /r VPMULUDQ| RVM  | V/V                   | AVX               | Multiply packed unsigned doubleword      \n| xmm1, xmm2, xmm3/m128               |      |                       |                   | integers in xmm2 by packed unsigned      \n|                                     |      |                       |                   | doubleword integers in xmm3/m128, and    \n|                                     |      |                       |                   | store the quadword results in xmm1.      \n| VEX.NDS.256.66.0F.WIG F4 /r VPMULUDQ| RVM  | V/V                   | AVX2              | Multiply packed unsigned doubleword      \n| ymm1, ymm2, ymm3/m256               |      |                       |                   | integers in ymm2 by packed unsigned      \n|                                     |      |                       |                   | doubleword integers in ymm3/m256, and    \n|                                     |      |                       |                   | store the quadword results in ymm1.      \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nMultiplies the first operand (destination operand) by the second operand (source\noperand) and stores the result in the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE version: The source operand can be an unsigned doubleword integer\nstored in the low doubleword of an MMX technology register or a 64-bit memory\nlocation. The destination operand can be an unsigned doubleword integer stored\nin the low doubleword an MMX technology register. The result is an unsigned\nquadword integer stored in the destination an MMX technology register. When\na quadword result is too large to be represented in 64 bits (overflow), the\nresult is wrapped around and the low 64 bits are written to the destination\nelement (that is, the carry is ignored).\n\nFor 64-bit memory operands, 64 bits are fetched from memory, but only the low\ndoubleword is used in the computation.\n\n128-bit Legacy SSE version: The second source operand is two packed unsigned\ndoubleword integers stored in the first (low) and third doublewords of an XMM\nregister or a 128-bit memory location. For 128-bit memory operands, 128 bits\nare fetched from memory, but only the first and third doublewords are used in\nthe computation.The first source operand is two packed unsigned doubleword integers\nstored in the first and third doublewords of an XMM register. The destination\ncontains two packed unsigned quadword integers stored in an XMM register. Bits\n(VLMAX1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is two packed unsigned doubleword\nintegers stored in the first (low) and third doublewords of an XMM register\nor a 128-bit memory location. For 128-bit memory operands, 128 bits are fetched\nfrom memory, but only the first and third doublewords are used in the computation.The\nfirst\n\nsource operand is two packed unsigned doubleword integers stored in the first\nand third doublewords of an XMM register. The destination contains two packed\nunsigned quadword integers stored in an XMM register. Bits (VLMAX1:128) of the\ndestination YMM register are zeroed. VEX.256 encoded version: The second source\noperand is four packed unsigned doubleword integers stored in the first (low),\nthird, fifth and seventh doublewords of a YMM register or a 256-bit memory location.\nFor 256-bit memory operands, 256 bits are fetched from memory, but only the\nfirst, third, fifth and seventh doublewords are used in the computation.The\nfirst source operand is four packed unsigned doubleword integers stored in the\nfirst, third, fifth and seventh doublewords of an YMM register. The destination\ncontains four packed unaligned quadword integers stored in an YMM register.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPMULUDQ (with 64-Bit operands)\n  DEST[63:0] <- DEST[31:0] * SRC[31:0];\nPMULUDQ (with 128-Bit operands)\n  DEST[63:0] <- DEST[31:0] * SRC[31:0];\n  DEST[127:64] <- DEST[95:64] * SRC[95:64];\nVPMULUDQ (VEX.128 encoded version)\nDEST[63:0] <- SRC1[31:0] * SRC2[31:0]\nDEST[127:64] <- SRC1[95:64] * SRC2[95:64]\nDEST[VLMAX-1:128] <- 0\nVPMULUDQ (VEX.256 encoded version)\nDEST[63:0] <- SRC1[31:0] * SRC2[31:0]\nDEST[127:64] <- SRC1[95:64] * SRC2[95:64\nDEST[191:128] <- SRC1[159:128] * SRC2[159:128]\nDEST[255:192] <- SRC1[223:192] * SRC2[223:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PMULUDQ:   | __m64 _mm_mul_su32 (__m64 a, __m64 b)     \n| (V)PMULUDQ:| __m128i _mm_mul_epu32 ( __m128i a, __m128i\n|            | b)                                        \n| VPMULUDQ:  | __m256i _mm256_mul_epu32( __m256i a,      \n|            | __m256i b);                               \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PMULUDQ"
    }, 
    {
      "description": "\nPOP - Pop a Value from the Stack:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                         \n| 8F /0 | POP r/m16  | M    | Valid      | Valid          | Pop top of stack into m16; increment\n|       |            |      |            |                | stack pointer.                      \n| 8F /0 | POP r/m32  | M    | N.E.       | Valid          | Pop top of stack into m32; increment\n|       |            |      |            |                | stack pointer.                      \n| 8F /0 | POP r/m64  | M    | Valid      | N.E.           | Pop top of stack into m64; increment\n|       |            |      |            |                | stack pointer. Cannot encode 32-bit \n|       |            |      |            |                | operand size.                       \n| 58+ rw| POP r16    | O    | Valid      | Valid          | Pop top of stack into r16; increment\n|       |            |      |            |                | stack pointer.                      \n| 58+ rd| POP r32    | O    | N.E.       | Valid          | Pop top of stack into r32; increment\n|       |            |      |            |                | stack pointer.                      \n| 58+ rd| POP r64    | O    | Valid      | N.E.           | Pop top of stack into r64; increment\n|       |            |      |            |                | stack pointer. Cannot encode 32-bit \n|       |            |      |            |                | operand size.                       \n| 1F    | POP DS     | NP   | Invalid    | Valid          | Pop top of stack into DS; increment \n|       |            |      |            |                | stack pointer.                      \n| 07    | POP ES     | NP   | Invalid    | Valid          | Pop top of stack into ES; increment \n|       |            |      |            |                | stack pointer.                      \n| 17    | POP SS     | NP   | Invalid    | Valid          | Pop top of stack into SS; increment \n|       |            |      |            |                | stack pointer.                      \n| 0F A1 | POP FS     | NP   | Valid      | Valid          | Pop top of stack into FS; increment \n|       |            |      |            |                | stack pointer by 16 bits.           \n| 0F A1 | POP FS     | NP   | N.E.       | Valid          | Pop top of stack into FS; increment \n|       |            |      |            |                | stack pointer by 32 bits.           \n| 0F A1 | POP FS     | NP   | Valid      | N.E.           | Pop top of stack into FS; increment \n|       |            |      |            |                | stack pointer by 64 bits.           \n| 0F A9 | POP GS     | NP   | Valid      | Valid          | Pop top of stack into GS; increment \n|       |            |      |            |                | stack pointer by 16 bits.           \n| 0F A9 | POP GS     | NP   | N.E.       | Valid          | Pop top of stack into GS; increment \n|       |            |      |            |                | stack pointer by 32 bits.           \n| 0F A9 | POP GS     | NP   | Valid      | N.E.           | Pop top of stack into GS; increment \n|       |            |      |            |                | stack pointer by 64 bits.           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1      | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)  | NA       | NA       | NA       \n| O    | opcode + rd (w)| NA       | NA       | NA       \n| NP   | NA             | NA       | NA       | NA       \n\nDescription:\nLoads the value from the top of the stack to the location specified with the\ndestination operand (or explicit opcode) and then increments the stack pointer.\nThe destination operand can be a general-purpose register, memory location,\nor segment register.\n\nAddress and operand sizes are determined and used as follows:\n\n - Address size. The D flag in the current code-segment descriptor determines the\ndefault address size; it may be overridden by an instruction prefix (67H). The\naddress size is used only when writing to a destination operand in memory.\n - Operand size. The D flag in the current code-segment descriptor determines the\ndefault operand size; it may be overridden by instruction prefixes (66H or REX.W).\nThe operand size (16, 32, or 64 bits) determines the amount by which the stack\npointer is incremented (2, 4 or 8).\n - Stack-address size. Outside of 64-bit mode, the B flag in the current stack-segment\ndescriptor determines the size of the stack pointer (16 or 32 bits); in 64-bit\nmode, the size of the stack pointer is always 64 bits. The stack-address size\ndetermines the width of the stack pointer when reading from the stack in memory\nand when incrementing the stack pointer. (As stated above, the amount by which\nthe stack pointer is incremented is determined by the operand size.)\n\nIf the destination operand is one of the segment registers DS, ES, FS, GS, or\nSS, the value loaded into the register must be a valid segment selector. In\nprotected mode, popping a segment selector into a segment register automatically\ncauses the descriptor information associated with that segment selector to be\nloaded into the hidden (shadow) part of the segment register and causes the\nselector and the descriptor information to be validated (see the \u201cOperation\u201d\nsection below).\n\nA NULL value (0000-0003) may be popped into the DS, ES, FS, or GS register without\ncausing a general protection fault. However, any subsequent attempt to reference\na segment whose corresponding segment register is loaded with a NULL value causes\na general protection exception (#GP). In this situation, no memory reference\noccurs and the saved value of the segment register is NULL.\n\nThe POP instruction cannot pop a value into the CS register. To load the CS\nregister from the stack, use the RET instruction.\n\nIf the ESP register is used as a base register for addressing a destination\noperand in memory, the POP instruction computes the effective address of the\noperand after it increments the ESP register. For the case of a 16-bit stack\nwhere ESP wraps to 0H as a result of the POP instruction, the resulting location\nof the memory write is processorfamily-specific.\n\nThe POP ESP instruction increments the stack pointer (ESP) before data at the\nold top of stack is written into the destination.\n\nA POP SS instruction inhibits all interrupts, including the NMI interrupt, until\nafter execution of the next instruction. This action allows sequential execution\nof POP SS and MOV ESP, EBP instructions without the danger of having an invalid\nstack during an interrupt1. However, use of the LSS instruction is the preferred\nmethod of loading the SS and ESP registers.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional\nregisters (R8-R15). When in 64-bit mode, POPs using 32-bit operands are not\nencodable and POPs to DS, ES, SS are not valid. See the summary chart at the\nbeginning of this section for encoding data and limits.\n\nOperation:\n\nIF StackAddrSize = 32\n  THEN\n     IF OperandSize = 32\n       THEN\n          DEST <- SS:ESP; (* Copy a doubleword *)\n          ESP <- ESP + 4;\n       ELSE (* OperandSize = 16*)\n          DEST <- SS:ESP; (* Copy a word *)\n1.\n  may not be triggered. However, in a sequence of instructions that POP the SS register, only the first instruction in the sequence is\n  guaranteed to delay an interrupt.\n  In the following sequence, interrupts may be recognized before POP ESP executes:\n  POP SS\n  POP SS\n  POP ESP\n          ESP <- ESP + 2;\n     FI;\n  ELSE IF StackAddrSize = 64\n     THEN\n       IF OperandSize = 64\n          THEN\n             DEST <- SS:RSP; (* Copy quadword *)\n             RSP <- RSP + 8;\n          ELSE (* OperandSize = 16*)\n             DEST <- SS:RSP; (* Copy a word *)\n             RSP <- RSP + 2;\n       FI;\n     FI;\n  ELSE StackAddrSize = 16\n     THEN\n       IF OperandSize = 16\n          THEN\n             DEST <- SS:SP; (* Copy a word *)\n             SP <- SP + 2;\n          ELSE (* OperandSize = 32 *)\n             DEST <- SS:SP; (* Copy a doubleword *)\n             SP <- SP + 4;\n       FI;\nFI;\nLoading a segment register while in protected mode results in special actions, as described in the following listing.\nThese checks are performed on the segment selector and the segment descriptor it points to.\n64-BIT_MODE\nIF FS, or GS is loaded with non-NULL selector;\n  THEN\n     IF segment selector index is outside descriptor table limits\n       OR segment is not a data or readable code segment\n       OR ((segment is a data or nonconforming code segment)\n          AND (both RPL and CPL > DPL))\n             THEN #GP(selector);\n       IF segment not marked present\n          THEN #NP(selector);\n     ELSE\n       SegmentRegister <- segment selector;\n       SegmentRegister <- segment descriptor;\n     FI;\nFI;\nIF FS, or GS is loaded with a NULL selector;\n     THEN\n       SegmentRegister <- segment selector;\n       SegmentRegister <- segment descriptor;\nFI;\nPREOTECTED MODE OR COMPATIBILITY MODE;\nIF SS is loaded;\n  THEN\n     IF segment selector is NULL\n       THEN #GP(0);\n     FI;\n     IF segment selector index is outside descriptor table limits\n       or segment selector's RPL != CPL\n       or segment is not a writable data segment\n       or DPL != CPL\n          THEN #GP(selector);\n     FI;\n     IF segment not marked present\n       THEN #SS(selector);\n       ELSE\n          SS <- segment selector;\n          SS <- segment descriptor;\n     FI;\nFI;\nIF DS, ES, FS, or GS is loaded with non-NULL selector;\n  THEN\n     IF segment selector index is outside descriptor table limits\n       or segment is not a data or readable code segment\n       or ((segment is a data or nonconforming code segment)\n       and (both RPL and CPL > DPL))\n          THEN #GP(selector);\n     FI;\n     IF segment not marked present\n       THEN #NP(selector);\n       ELSE\n          SegmentRegister <- segment selector;\n          SegmentRegister <- segment descriptor;\n     FI;\nFI;\nIF DS, ES, FS, or GS is loaded with a NULL selector\n  THEN\n     SegmentRegister <- segment selector;\n     SegmentRegister <- segment descriptor;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)       | If attempt is made to load SS register        \n|              | with NULL segment selector. If the destination\n|              | operand is in a non-writable segment.         \n|              | If a memory operand effective address         \n|              | is outside the CS, DS, ES, FS, or GS          \n|              | segment limit. If the DS, ES, FS, or          \n|              | GS register is used to access memory          \n|              | and it contains a NULL segment selector.      \n| #GP(selector)| If segment selector index is outside          \n|              | descriptor table limits. If the SS register   \n|              | is being loaded and the segment selector's    \n|              | RPL and the segment descriptor's DPL          \n|              | are not equal to the CPL.                     \nIf the SS register is being loaded and the segment pointed to is a non-writable\ndata segment. If the DS, ES, FS, or GS register is being loaded and the segment\npointed to is not a data or readable code segment. If the DS, ES, FS, or GS\nregister is being loaded and the segment pointed to is a data or nonconforming\ncode segment, but both the RPL and the CPL are greater than the DPL.\n\n| #SS(0)         | If the current top of stack is not within\n|                | the stack segment. If a memory operand   \n|                | effective address is outside the SS      \n|                | segment limit.                           \n| #SS(selector)  | If the SS register is being loaded and   \n|                | the segment pointed to is marked not     \n|                | present.                                 \n| #NP            | If the DS, ES, FS, or GS register is     \n|                | being loaded and the segment pointed     \n|                | to is marked not present.                \n| #PF(fault-code)| If a page fault occurs.                  \n| #AC(0)         | If an unaligned memory reference is      \n|                | made while the current privilege level   \n|                | is 3 and alignment checking is enabled.  \n| #UD            | If the LOCK prefix is used.              \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address    \n|                | is outside the CS, DS, ES, FS, or GS     \n|                | segment limit.                           \n| #PF(fault-code)| If a page fault occurs.                  \n| #AC(0)         | If an unaligned memory reference is      \n|                | made while alignment checking is enabled.\n| #UD            | If the LOCK prefix is used.              \n\nCompatibility Mode Exceptions:\nSame as for protected mode exceptions.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #SS(U)         | If the stack address is in a non-canonical \n|                | form.                                      \n| #GP(selector)  | If the descriptor is outside the descriptor\n|                | table limit. If the FS or GS register      \n|                | is being loaded and the segment pointed    \n|                | to is not a data or readable code segment. \n|                | If the FS or GS register is being loaded   \n|                | and the segment pointed to is a data       \n|                | or nonconforming code segment, but both    \n|                | the RPL and the CPL are greater than       \n|                | the DPL.                                   \n| #AC(0)         | If an unaligned memory reference is        \n|                | made while alignment checking is enabled.  \n| #PF(fault-code)| If a page fault occurs.                    \n| #NP            | If the FS or GS register is being loaded   \n|                | and the segment pointed to is marked       \n|                | not present.                               \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "POP"
    }, 
    {
      "description": "\nPOPA/POPAD - Pop All General-Purpose Registers:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 61    | POPA       | NP   | Invalid    | Valid          | Pop DI, SI, BP, BX, DX, CX, and AX.  \n| 61    | POPAD      | NP   | Invalid    | Valid          | Pop EDI, ESI, EBP, EBX, EDX, ECX, and\n|       |            |      |            |                | EAX.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nPops doublewords (POPAD) or words (POPA) from the stack into the general-purpose\nregisters. The registers are loaded in the following order: EDI, ESI, EBP, EBX,\nEDX, ECX, and EAX (if the operand-size attribute is 32) and DI, SI, BP, BX,\nDX, CX, and AX (if the operand-size attribute is 16). (These instructions reverse\nthe operation of the PUSHA/PUSHAD instructions.) The value on the stack for\nthe ESP or SP register is ignored. Instead, the ESP or SP register is incremented\nafter each register is loaded.\n\nThe POPA (pop all) and POPAD (pop all double) mnemonics reference the same opcode.\nThe POPA instruction is intended for use when the operand-size attribute is\n16 and the POPAD instruction for when the operand-size attribute is 32. Some\nassemblers may force the operand size to 16 when POPA is used and to 32 when\nPOPAD is used (using the operand-size override prefix [66H] if necessary). Others\nmay treat these mnemonics as synonyms (POPA/POPAD) and use the current setting\nof the operand-size attribute to determine the size of values to be popped from\nthe stack, regardless of the mnemonic used. (The D flag in the current code\nsegment's segment descriptor determines the operand-size attribute.)\n\nThis instruction executes as described in non-64-bit modes. It is not valid\nin 64-bit mode.\n\nOperation:\n\nIF 64-Bit Mode\n  THEN\n     #UD;\nELSE\n  IF OperandSize = 32 (* Instruction = POPAD *)\n  THEN\n     EDI <- Pop();\n     ESI <- Pop();\n     EBP <- Pop();\n     Increment ESP by 4; (* Skip next 4 bytes of stack *)\n     EBX <- Pop();\n     EDX <- Pop();\n     ECX <- Pop();\n     EAX <- Pop();\n  ELSE (* OperandSize = 16, instruction = POPA *)\n     DI <- Pop();\n     SI <- Pop();\n     BP <- Pop();\n     Increment ESP by 2; (* Skip next 2 bytes of stack *)\n     BX <- Pop();\n     DX <- Pop();\n     CX <- Pop();\n     AX <- Pop();\n  FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #SS(0)         | If the starting or ending stack address\n|                | is not within the stack segment.       \n| #PF(fault-code)| If a page fault occurs.                \n| #AC(0)         | If an unaligned memory reference is    \n|                | made while the current privilege level \n|                | is 3 and alignment checking is enabled.\n| #UD            | If the LOCK prefix is used.            \n\nReal-Address Mode Exceptions:\n| #SS| If the starting or ending stack address\n|    | is not within the stack segment.       \n| #UD| If the LOCK prefix is used.            \n\nVirtual-8086 Mode Exceptions:\n| #SS(0)         | If the starting or ending stack address  \n|                | is not within the stack segment.         \n| #PF(fault-code)| If a page fault occurs.                  \n| #AC(0)         | If an unaligned memory reference is      \n|                | made while alignment checking is enabled.\n| #UD            | If the LOCK prefix is used.              \n\nCompatibility Mode Exceptions:\nSame as for protected mode exceptions.\n\n\n64-Bit Mode Exceptions:\n| #UD| If in 64-bit mode.\n", 
      "mnem": "POPA"
    }, 
    {
      "description": "-R:POPA", 
      "mnem": "POPAD"
    }, 
    {
      "description": "\nPOPCNT  -  Return the Count of Number of Bits Set to 1:\n| Opcode           | Instruction      | Op/En| 64-Bit Mode| Compat/Leg Mode| Description    \n| F3               | POPCNT r16, r/m16| RM   | Valid      | Valid          | POPCNT on r/m16\n| F3               | POPCNT r32, r/m32| RM   | Valid      | Valid          | POPCNT on r/m32\n| F3 REX.W 0F B8 /r| POPCNT r64, r/m64| RM   | Valid      | N.E.           | POPCNT on r/m64\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nThis instruction calculates of number of bits set to 1 in the second operand\n(source) and returns the count in the first operand (a destination register).\n\nOperation:\n\nCount = 0;\nFor (i=0; i < OperandSize; i++)\n{\n     THEN Count++; FI;\n}\nDEST <- Count;\n\nFlags Affected:\nOF, SF, ZF, AF, CF, PF are all cleared. ZF is set if SRC = 0, otherwise ZF is\ncleared\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| POPCNT:| int _mm_popcnt_u32(unsigned int a);    \n| POPCNT:| int64_t _mm_popcnt_u64(unsigned __int64\n|        | a);                                    \n\nProtected Mode Exceptions:\n| #GP(0)          | If a memory operand effective address    \n|                 | is outside the CS, DS, ES, FS or GS      \n|                 | segments.                                \n| #SS(0)          | If a memory operand effective address    \n|                 | is outside the SS segment limit.         \n| #PF (fault-code)| For a page fault.                        \n| #AC(0)          | If an unaligned memory reference is      \n|                 | made while the current privilege level   \n|                 | is 3 and alignment checking is enabled.  \n| #UD             | If CPUID.01H:ECX.POPCNT [Bit 23] = 0.    \n|                 | If LOCK prefix is used. Either the prefix\n|                 | REP (F3h) or REPN (F2H) is used.         \n\nReal-Address Mode Exceptions:\n| #GP(0)| If any part of the operand lies outside  \n|       | of the effective address space from      \n|       | 0 to 0FFFFH.                             \n| #SS(0)| If a memory operand effective address    \n|       | is outside the SS segment limit.         \n| #UD   | If CPUID.01H:ECX.POPCNT [Bit 23] = 0.    \n|       | If LOCK prefix is used. Either the prefix\n|       | REP (F3h) or REPN (F2H) is used.         \n\nVirtual 8086 Mode Exceptions:\n| #GP(0)          | If any part of the operand lies outside  \n|                 | of the effective address space from      \n|                 | 0 to 0FFFFH.                             \n| #SS(0)          | If a memory operand effective address    \n|                 | is outside the SS segment limit.         \n| #PF (fault-code)| For a page fault.                        \n| #AC(0)          | If an unaligned memory reference is      \n|                 | made while alignment checking is enabled.\n| #UD             | If CPUID.01H:ECX.POPCNT [Bit 23] = 0.    \n|                 | If LOCK prefix is used. Either the prefix\n|                 | REP (F3h) or REPN (F2H) is used.         \n\nCompatibility Mode Exceptions:\nSame exceptions as in Protected Mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)          | If the memory address is in a non-canonical\n|                 | form.                                      \n| #SS(0)          | If a memory address referencing the        \n|                 | SS segment is in a non-canonical form.     \n| #PF (fault-code)| For a page fault.                          \n| #AC(0)          | If alignment checking is enabled and       \n|                 | an unaligned memory reference is made      \n|                 | while the current privilege level is       \n|                 | 3.                                         \n| #UD             | If CPUID.01H:ECX.POPCNT [Bit 23] = 0.      \n|                 | If LOCK prefix is used. Either the prefix  \n|                 | REP (F3h) or REPN (F2H) is used.           \n", 
      "mnem": "POPCNT"
    }, 
    {
      "description": "\nPOPF/POPFD/POPFQ - Pop Stack into EFLAGS Register:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 9D    | POPF       | NP   | Valid      | Valid          | Pop top of stack into lower 16 bits  \n|       |            |      |            |                | of EFLAGS.                           \n| 9D    | POPFD      | NP   | N.E.       | Valid          | Pop top of stack into EFLAGS.        \n| 9D    | POPFQ      | NP   | Valid      | N.E.           | Pop top of stack and zero-extend into\n|       |            |      |            |                | RFLAGS.                              \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nPops a doubleword (POPFD) from the top of the stack (if the current operand-size\nattribute is 32) and stores the value in the EFLAGS register, or pops a word\nfrom the top of the stack (if the operand-size attribute is 16) and stores it\nin the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These\ninstructions reverse the operation of the PUSHF/PUSHFD instructions.\n\nThe POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same\nopcode. The POPF instruction is intended for use when the operand-size attribute\nis 16; the POPFD instruction is intended for use when the operand-size attribute\nis 32. Some assemblers may force the operand size to 16 for POPF and to 32 for\nPOPFD. Others may treat the mnemonics as synonyms (POPF/POPFD) and use the setting\nof the operand-size attribute to determine the size of values to pop from the\nstack.\n\nThe effect of POPF/POPFD on the EFLAGS register changes, depending on the mode\nof operation. When the processor is operating in protected mode at privilege\nlevel 0 (or in real-address mode, the equivalent to privilege level 0), all\nnon-reserved flags in the EFLAGS register except RF1, VIP, VIF, and VM may be\nmodified. VIP, VIF and VM remain unaffected.\n\nWhen operating in protected mode with a privilege level greater than 0, but\nless than or equal to IOPL, all flags can be modified except the IOPL field\nand VIP, VIF, and VM. Here, the IOPL flags are unaffected, the VIP and VIF flags\nare cleared, and the VM flag is unaffected. The interrupt flag (IF) is altered\nonly when executing at a level at least as privileged as the IOPL. If a POPF/POPFD\ninstruction is executed with insufficient privilege, an exception does not occur\nbut privileged bits do not change.\n\nWhen operating in virtual-8086 mode, the IOPL must be equal to 3 to use POPF/POPFD\ninstructions; VM, RF, IOPL, VIP, and VIF are unaffected. If the IOPL is less\nthan 3, POPF/POPFD causes a general-protection exception (#GP).\n\nIn 64-bit mode, use REX.W to pop the top of stack to RFLAGS. The mnemonic assigned\nis POPFQ (note that the 32bit operand is not encodable). POPFQ pops 64 bits\nfrom the stack, loads the lower 32 bits into RFLAGS, and zero extends the upper\nbits of RFLAGS.\n\nSee Chapter 3 of the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 1, for more information about the EFLAGS registers.\n\nOperation:\n\nIF VM = 0 (* Not in Virtual-8086 Mode *)\n  THEN IF CPL = 0\n     THEN\n       IF OperandSize = 32;\n          THEN\n             EFLAGS <- Pop(); (* 32-bit pop *)\n             (* All non-reserved flags except RF, VIP, VIF, and VM can be modified;\n             VIP and VIF are cleared; RF, VM, and all reserved bits are unaffected. *)\n          ELSE IF (Operandsize = 64)\n1.\n             RFLAGS = Pop(); (* 64-bit pop *)\n             (* All non-reserved flags except RF, VIP, VIF, and VM can be modified; VIP\n             and VIF are cleared; RF, VM, and all reserved bits are unaffected.*)\n          ELSE (* OperandSize = 16 *)\n             EFLAGS[15:0] <- Pop(); (* 16-bit pop *)\n             (* All non-reserved flags can be modified. *)\n       FI;\n     ELSE (* CPL > 0 *)\n       IF OperandSize = 32\n          THEN\n             IF CPL > IOPL\n               THEN\n                  EFLAGS <- Pop(); (* 32-bit pop *)\n                  (* All non-reserved bits except IF, IOPL, RF, VIP, and\n                  VIF can be modified; IF, IOPL, RF, VM, and all reserved\n                  bits are unaffected; VIP and VIF are cleared. *)\n               ELSE\n                  EFLAGS <- Pop(); (* 32-bit pop *)\n                  (* All non-reserved bits except IOPL, RF, VIP, and VIF can be\n                  modified; IOPL, RF, VM, and all reserved bits are\n                  unaffected; VIP and VIF are cleared. *)\n             FI;\n          ELSE IF (Operandsize = 64)\n             IF CPL > IOPL\n               THEN\n                  RFLAGS <- Pop(); (* 64-bit pop *)\n                  (* All non-reserved bits except IF, IOPL, RF, VIP, and\n                  VIF can be modified; IF, IOPL, RF, VM, and all reserved\n                  bits are unaffected; VIP and VIF are cleared. *)\n               ELSE\n                  RFLAGS <- Pop(); (* 64-bit pop *)\n                  (* All non-reserved bits except IOPL, RF, VIP, and VIF can be\n                  modified; IOPL, RF, VM, and all reserved bits are\n                  unaffected; VIP and VIF are cleared. *)\n             FI;\n          ELSE (* OperandSize = 16 *)\n             EFLAGS[15:0] <- Pop(); (* 16-bit pop *)\n             (* All non-reserved bits except IOPL can be modified; IOPL and all\n             reserved bits are unaffected. *)\n       FI;\n     FI;\n  ELSE\n     IF IOPL = 3\n       THEN IF OperandSize = 32\n          THEN\n             EFLAGS <- Pop();\n             (* All non-reserved bits except VM, RF, IOPL, VIP, and VIF can be\n             modified; VM, RF, IOPL, VIP, VIF, and all reserved bits are unaffected. *)\n          ELSE\n             EFLAGS[15:0] <- Pop(); FI;\n             (* All non-reserved bits except IOPL can be modified;\n             IOPL and all reserved bits are unaffected. *)\n     ELSE (* IOPL < 3 *)\n       #GP(0);\n     FI;\n  FI;\nFI;\n\nFlags Affected:\nAll flags may be affected; see the Operation section for details.\n\n\nProtected Mode Exceptions:\n| #SS(0)         | If the top of stack is not within the  \n|                | stack segment.                         \n| #PF(fault-code)| If a page fault occurs.                \n| #AC(0)         | If an unaligned memory reference is    \n|                | made while the current privilege level \n|                | is 3 and alignment checking is enabled.\n| #UD            | If the LOCK prefix is used.            \n\nReal-Address Mode Exceptions:\n| #SS| If the top of stack is not within the\n|    | stack segment.                       \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If the I/O privilege level is less than        \n|                | 3. If an attempt is made to execute            \n|                | the POPF/POPFD instruction with an operand-size\n|                | override prefix.                               \n| #SS(0)         | If the top of stack is not within the          \n|                | stack segment.                                 \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If an unaligned memory reference is            \n|                | made while alignment checking is enabled.      \n| #UD            | If the LOCK prefix is used.                    \n\nCompatibility Mode Exceptions:\nSame as for protected mode exceptions.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #SS(0)         | If the stack address is in a non-canonical \n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "POPF"
    }, 
    {
      "description": "-R:POPF", 
      "mnem": "POPFD"
    }, 
    {
      "description": "-R:POPF", 
      "mnem": "POPFQ"
    }, 
    {
      "description": "\nPOR - Bitwise Logical OR:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                      \n| 0F EB /r1 POR mm, mm/m64              | RM   | V/V                   | MMX               | Bitwise OR of mm/m64 and mm.     \n| 66 0F EB /r POR xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Bitwise OR of xmm2/m128 and xmm1.\n| VEX.NDS.128.66.0F.WIG EB /r VPOR xmm1,| RVM  | V/V                   | AVX               | Bitwise OR of xmm2/m128 and xmm3.\n| xmm2, xmm3/m128                       |      |                       |                   |                                  \n| VEX.NDS.256.66.0F.WIG EB /r VPOR ymm1,| RVM  | V/V                   | AVX2              | Bitwise OR of ymm2/m256 and ymm3.\n| ymm2, ymm3/m256                       |      |                       |                   |                                  \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a bitwise logical OR operation on the source operand (second operand)\nand the destination operand (first operand) and stores the result in the destination\noperand. Each bit of the result is set to 1 if either or both of the corresponding\nbits of the first and second operands are 1; otherwise, it is set to 0.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). Legacy SSE version: The source\noperand can be an MMX technology register or a 64-bit memory location. The destination\noperand is an MMX technology register.\n\n128-bit Legacy SSE version: The second source operand is an XMM register or\na 128-bit memory location. The first source and destination operands can be\nXMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register\nremain unchanged. VEX.128 encoded version: The second source operand is an XMM\nregister or a 128-bit memory location. The first source and destination operands\ncan be XMM registers. Bits (VLMAX-1:128) of the destination YMM register are\nzeroed. VEX.256 encoded version: The second source operand is an YMM register\nor a 256-bit memory location. The first source and destination operands can\nbe YMM registers.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPOR (128-bit Legacy SSE version)\nDEST <- DEST OR SRC\nDEST[VLMAX-1:128] (Unmodified)\nVPOR (VEX.128 encoded version)\nDEST <- SRC1 OR SRC2\nDEST[VLMAX-1:128] <- 0\nVPOR (VEX.256 encoded version)\nDEST <- SRC1 OR SRC2\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| POR:   | __m64 _mm_or_si64(__m64 m1, __m64 m2)   \n| (V)POR:| __m128i _mm_or_si128(__m128i m1, __m128i\n|        | m2)                                     \n| VPOR:  | __m256i _mm256_or_si256 ( __m256i a,    \n|        | __m256i b)                              \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "POR"
    }, 
    {
      "description": "\nPREFETCHW - Prefetch Data into Caches in Anticipation of a Write:\n| Opcode/Instruction   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| 0F 0D /1 PREFETCHW m8| A    | V/V                   | PRFCHW            | Move data from m8 closer to the processor\n|                      |      |                       |                   | in anticipation of a write.              \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nFetches the cache line of data from memory that contains the byte specified\nwith the source operand to a location in the 1st or 2nd level cache and invalidates\nall other cached instances of the line. The source operand is a byte memory\nlocation. If the line selected is already present in the lowest level cache\nand is already in an exclusively owned state, no data movement occurs. Prefetches\nfrom non-writeback memory are ignored. The PREFETCHW instruction is merely a\nhint and does not affect program behavior. If executed, this instruction moves\ndata closer to the processor and invalidates any other cached copy in anticipation\nof the line being written to in the future. The characteristic of prefetch locality\nhints is implementation-dependent, and can be overloaded or ignored by a processor\nimplementation. The amount of data prefetched is also processor implementation-dependent.\nIt will, however, be a minimum of 32 bytes. It should be noted that processors\nare free to speculatively fetch and cache data with exclusive ownership from\nsystem memory regions that permit such accesses (that is, the WB memory type).\nA PREFETCHW instruction is considered a hint to this speculative behavior. Because\nthis speculative fetching can occur at any time and is not tied to instruction\nexecution, a PREFETCHW instruction is not ordered with respect to the fence\ninstructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHW\ninstruction is also unordered with respect to CLFLUSH instructions, other PREFETCHW\ninstructions, or any other general instruction It is ordered with respect to\nserializing instructions such as CPUID, WRMSR, OUT, and MOV CR. This instruction's\noperation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nFETCH_WITH_EXCLUSIVE_OWNERSHIP (m8);\n\nFlags Affected:\nAll flags are affected\n\n\nC/C++ Compiler Intrinsic Equivalent:\nvoid _m_prefetchw( void * );\n\n\nProtected Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nReal-Address Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nVirtual-8086 Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nCompatibility Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\n64-Bit Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n", 
      "mnem": "PREFETCHW"
    }, 
    {
      "description": "\nPREFETCHh - Prefetch Data Into Caches:\n| Opcode  | Instruction   | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                              \n| 0F 18 /1| PREFETCHT0 m8 | M    | Valid      | Valid          | Move data from m8 closer to the processor\n|         |               |      |            |                | using T0 hint.                           \n| 0F 18 /2| PREFETCHT1 m8 | M    | Valid      | Valid          | Move data from m8 closer to the processor\n|         |               |      |            |                | using T1 hint.                           \n| 0F 18 /3| PREFETCHT2 m8 | M    | Valid      | Valid          | Move data from m8 closer to the processor\n|         |               |      |            |                | using T2 hint.                           \n| 0F 18 /0| PREFETCHNTA m8| M    | Valid      | Valid          | Move data from m8 closer to the processor\n|         |               |      |            |                | using NTA hint.                          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nFetches the line of data from memory that contains the byte specified with the\nsource operand to a location in the cache hierarchy specified by a locality\nhint:\n\n - T0 (temporal data) - prefetch data into all levels of the cache hierarchy.  - Pentium\nIII processor - 1st- or 2nd-level cache.  - Pentium 4 and Intel Xeon processors - 2nd-level\ncache.\n - T1 (temporal data with respect to first level cache) - prefetch data into level\n2 cache and higher.  - Pentium III processor - 2nd-level cache.  - Pentium 4 and Intel\nXeon processors - 2nd-level cache.\n - T2 (temporal data with respect to second level cache) - prefetch data into level\n2 cache and higher.  - Pentium III processor - 2nd-level cache.  - Pentium 4 and Intel\nXeon processors - 2nd-level cache.\n - NTA (non-temporal data with respect to all cache levels) - prefetch data into\nnon-temporal cache structure and into a location close to the processor, minimizing\ncache pollution.  - Pentium III processor - 1st-level cache  - Pentium 4 and Intel\nXeon processors - 2nd-level cache\n\nThe source operand is a byte memory location. (The locality hints are encoded\ninto the machine level instruction using bits 3 through 5 of the ModR/M byte.)\n\nIf the line selected is already present in the cache hierarchy at a level closer\nto the processor, no data movement occurs. Prefetches from uncacheable or WC\nmemory are ignored.\n\nThe PREFETCHh instruction is merely a hint and does not affect program behavior.\nIf executed, this instruction moves data closer to the processor in anticipation\nof future use.\n\nThe implementation of prefetch locality hints is implementation-dependent, and\ncan be overloaded or ignored by a processor implementation. The amount of data\nprefetched is also processor implementation-dependent. It will, however, be\na minimum of 32 bytes.\n\nIt should be noted that processors are free to speculatively fetch and cache\ndata from system memory regions that are assigned a memory-type that permits\nspeculative reads (that is, the WB, WC, and WT memory types). A PREFETCHh instruction\nis considered a hint to this speculative behavior. Because this speculative\nfetching can occur at any time and is not tied to instruction execution, a PREFETCHh\ninstruction is not ordered with respect to the fence instructions (MFENCE, SFENCE,\nand LFENCE) or locked memory references. A PREFETCHh instruction is also\n\nunordered with respect to CLFLUSH instructions, other PREFETCHh instructions,\nor any other general instruction. It is ordered with respect to serializing\ninstructions such as CPUID, WRMSR, OUT, and MOV CR.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nFETCH (m8);\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nvoid _mm_prefetch(char *p, int i)\n\nThe argument \u201c*p\u201d gives the address of the byte (and corresponding cache line)\nto be prefetched. The value \u201ci\u201dgives a constant (_MM_HINT_T0, _MM_HINT_T1, _MM_HINT_T2,\nor _MM_HINT_NTA) that specifies the type of prefetch operation to be performed.\n\n\nNumeric Exceptions:\nNone.\n\n\nExceptions (All Operating Modes):\n| #UD| If the LOCK prefix is used.\n", 
      "mnem": "PREFETCHh"
    }, 
    {
      "description": "\nPSADBW - Compute Sum of Absolute Differences:\n| Opcode/Instruction                 | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                               \n| 0F F6 /r1 PSADBW mm1, mm2/m64      | RM   | V/V                   | SSE               | Computes the absolute differences of      \n|                                    |      |                       |                   | the packed unsigned byte integers from    \n|                                    |      |                       |                   | mm2 /m64 and mm1; differences are then    \n|                                    |      |                       |                   | summed to produce an unsigned word integer\n|                                    |      |                       |                   | result.                                   \n| 66 0F F6 /r PSADBW xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Computes the absolute differences of      \n|                                    |      |                       |                   | the packed unsigned byte integers from    \n|                                    |      |                       |                   | xmm2 /m128 and xmm1; the 8 low differences\n|                                    |      |                       |                   | and 8 high differences are then summed    \n|                                    |      |                       |                   | separately to produce two unsigned word   \n|                                    |      |                       |                   | integer results.                          \n| VEX.NDS.128.66.0F.WIG F6 /r VPSADBW| RVM  | V/V                   | AVX               | Computes the absolute differences of      \n| xmm1, xmm2, xmm3/m128              |      |                       |                   | the packed unsigned byte integers from    \n|                                    |      |                       |                   | xmm3 /m128 and xmm2; the 8 low differences\n|                                    |      |                       |                   | and 8 high differences are then summed    \n|                                    |      |                       |                   | separately to produce two unsigned word   \n|                                    |      |                       |                   | integer results.                          \n| VEX.NDS.256.66.0F.WIG F6 /r VPSADBW| RVM  | V/V                   | AVX2              | Computes the absolute differences of      \n| ymm1, ymm2, ymm3/m256              |      |                       |                   | the packed unsigned byte integers from    \n|                                    |      |                       |                   | ymm3 /m256 and ymm2; then each consecutive\n|                                    |      |                       |                   | 8 differences are summed separately       \n|                                    |      |                       |                   | to produce four unsigned word integer     \n|                                    |      |                       |                   | results.                                  \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nComputes the absolute value of the difference of 8 unsigned byte integers from\nthe source operand (second operand) and from the destination operand (first\noperand). These 8 differences are then summed to produce an unsigned word integer\nresult that is stored in the destination operand. Figure 4-10 shows the operation\nof the PSADBW instruction when using 64-bit operands.\n\nWhen operating on 64-bit operands, the word integer result is stored in the\nlow word of the destination operand, and the remaining bytes in the destination\noperand are cleared to all 0s.\n\nWhen operating on 128-bit operands, two packed results are computed. Here, the\n8 low-order bytes of the source and destination operands are operated on to\nproduce a word result that is stored in the low word of the destination operand,\nand the 8 high-order bytes are operated on to produce a word result that is\nstored in bits 64 through 79 of the destination operand. The remaining bytes\nof the destination operand are cleared.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). Legacy SSE version: The source\noperand can be an MMX technology register or a 64-bit memory location. The destination\noperand is an MMX technology register.\n\n128-bit Legacy SSE version: The first source operand and destination register\nare XMM registers. The second source operand is an XMM register or a 128-bit\nmemory location. Bits (VLMAX-1:128) of the corresponding YMM destination register\nremain unchanged.\n\nVEX.128 encoded version: The first source operand and destination register are\nXMM registers. The second source operand is an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.256\nencoded version: The first source operand and destination register are YMM registers.\nThe second source operand is an YMM register or a 256-bit memory location.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\n| SRC Figure 4-10.| X7 Y7 ABS(X7:Y7) 00H| X6 Y6 ABS(X6:Y6) 00H PSADBW Instruction| X5 Y5 ABS(X5:Y5) 00H| X4 Y4 ABS(X4:Y4) 00H| X3 Y3 ABS(X3:Y3) 00H| X2 Y2 ABS(X2:Y2) 00H| X1 Y1 ABS(X1:Y1) SUM(TEMP7...TEMP0)| X0 Y0 ABS(X0:Y0) DEST\n|                 |                     | Operation Using 64-bit Operands        |                     |                     |                     |                     |                                    |                      \nOperation:\n\nPSADBW (when using 64-bit operands)\n  TEMP0 <- ABS(DEST[7:0] \u2212 SRC[7:0]);\n  (* Repeat operation for bytes 2 through 6 *)\n  TEMP7 <- ABS(DEST[63:56] \u2212 SRC[63:56]);\n  DEST[15:0] <- SUM(TEMP0:TEMP7);\n  DEST[63:16] <- 000000000000H;\nPSADBW (when using 128-bit operands)\n  TEMP0 <- ABS(DEST[7:0] \u2212 SRC[7:0]);\n  (* Repeat operation for bytes 2 through 14 *)\n  TEMP15 <- ABS(DEST[127:120] \u2212 SRC[127:120]);\n  DEST[15:0] <- SUM(TEMP0:TEMP7);\n  DEST[63:16] <- 000000000000H;\n  DEST[79:64] <- SUM(TEMP8:TEMP15);\n  DEST[127:80] <- 000000000000H;\n  DEST[VLMAX-1:128] (Unmodified)\nVPSADBW (VEX.128 encoded version)\nTEMP0 <- ABS(SRC1[7:0] - SRC2[7:0])\n(* Repeat operation for bytes 2 through 14 *)\nTEMP15 <- ABS(SRC1[127:120] - SRC2[127:120])\nDEST[15:0] <-SUM(TEMP0:TEMP7)\nDEST[63:16] <- 000000000000H\nDEST[79:64] <- SUM(TEMP8:TEMP15)\nDEST[127:80] <- 00000000000\nDEST[VLMAX-1:128] <- 0\nVPSADBW (VEX.256 encoded version)\nTEMP0 <- ABS(SRC1[7:0] - SRC2[7:0])\n(* Repeat operation for bytes 2 through 30*)\nTEMP31 <- ABS(SRC1[255:248] - SRC2[255:248])\nDEST[15:0] <-SUM(TEMP0:TEMP7)\nDEST[63:16] <- 000000000000H\nDEST[79:64] <- SUM(TEMP8:TEMP15)\nDEST[127:80] <- 00000000000H\nDEST[143:128] <-SUM(TEMP16:TEMP23)\nDEST[191:144] <- 000000000000H\nDEST[207:192] <- SUM(TEMP24:TEMP31)\nDEST[223:208] <- 00000000000H\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PSADBW:   | __m64 _mm_sad_pu8(__m64 a,__m64 b)     \n| (V)PSADBW:| __m128i _mm_sad_epu8(__m128i a, __m128i\n|           | b)                                     \n| VPSADBW:  | __m256i _mm256_sad_epu8( __m256i a,    \n|           | __m256i b)                             \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PSADBW"
    }, 
    {
      "description": "\nPSHUFB  -  Packed Shuffle Bytes:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| 0F 38 00 /r1 PSHUFB mm1, mm2/m64     | RM   | V/V                   | SSSE3             | Shuffle bytes in mm1 according to contents \n|                                      |      |                       |                   | of mm2/m64.                                \n| 66 0F 38 00 /r PSHUFB xmm1, xmm2/m128| RM   | V/V                   | SSSE3             | Shuffle bytes in xmm1 according to contents\n|                                      |      |                       |                   | of xmm2/m128.                              \n| VEX.NDS.128.66.0F38.WIG 00 /r VPSHUFB| RVM  | V/V                   | AVX               | Shuffle bytes in xmm2 according to contents\n| xmm1, xmm2, xmm3/m128                |      |                       |                   | of xmm3/m128.                              \n| VEX.NDS.256.66.0F38.WIG 00 /r VPSHUFB| RVM  | V/V                   | AVX2              | Shuffle bytes in ymm2 according to contents\n| ymm1, ymm2, ymm3/m256                |      |                       |                   | of ymm3/m256.                              \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPSHUFB performs in-place shuffles of bytes in the destination operand (the first\noperand) according to the shuffle control mask in the source operand (the second\noperand). The instruction permutes the data in the destination operand, leaving\nthe shuffle mask unaffected. If the most significant bit (bit[7]) of each byte\nof the shuffle control mask is set, then constant zero is written in the result\nbyte. Each byte in the shuffle control mask forms an index to permute the corresponding\nbyte in the destination operand. The value of each index is the least significant\n4 bits (128-bit operation) or 3 bits (64-bit operation) of the shuffle control\nbyte. When the source operand is a 128-bit memory operand, the operand must\nbe aligned on a 16-byte boundary or a general-protection exception (#GP) will\nbe generated.\n\nIn 64-bit mode, use the REX prefix to access additional registers. Legacy SSE\nversion: Both operands can be MMX registers.\n\n128-bit Legacy SSE version: The first source operand and the destination operand\nare the same. Bits (VLMAX1:128) of the corresponding YMM destination register\nremain unchanged. VEX.128 encoded version: The destination operand is the first\noperand, the first source operand is the second operand, the second source operand\nis the third operand. Bits (VLMAX-1:128) of the destination YMM register are\nzeroed. VEX.256 encoded version: Bits (255:128) of the destination YMM register\nstores the 16-byte shuffle result of the upper 16 bytes of the first source\noperand, using the upper 16-bytes of the second source operand as control mask.\nThe value of each index is for the high 128-bit lane is the least significant\n4 bits of the respective shuffle control byte. The index value selects a source\ndata element within each 128-bit lane.\n\nNote: VEX.L must be 0, otherwise the instruction will #UD.\n\nOperation:\n\nPSHUFB (with 64 bit operands)\n  for i = 0 to 7 {\n     if (SRC[(i * 8)+7] = 1 ) then\n       DEST[(i*8)+7...(i*8)+0] <- 0;\n     else\n       index[2..0] <- SRC[(i*8)+2 .. (i*8)+0];\n       DEST[(i*8)+7...(i*8)+0] <- DEST[(index*8+7)..(index*8+0)];\n     endif;\n  }\nPSHUFB (with 128 bit operands)\n  for i = 0 to 15 {\n     if (SRC[(i * 8)+7] = 1 ) then\n       DEST[(i*8)+7..(i*8)+0] <- 0;\n     else\n       index[3..0] <- SRC[(i*8)+3 .. (i*8)+0];\n       DEST[(i*8)+7..(i*8)+0] <- DEST[(index*8+7)..(index*8+0)];\n     endif\n  }\nDEST[VLMAX-1:128] <- 0\nVPSHUFB (VEX.128 encoded version)\nfor i = 0 to 15 {\n  if (SRC2[(i * 8)+7] = 1) then\n     DEST[(i*8)+7..(i*8)+0] <- 0;\n     else\n     index[3..0] <- SRC2[(i*8)+3 .. (i*8)+0];\n     DEST[(i*8)+7..(i*8)+0] <- SRC1[(index*8+7)..(index*8+0)];\n  endif\n}\nDEST[VLMAX-1:128] <- 0\nVPSHUFB (VEX.256 encoded version)\nfor i = 0 to 15 {\n  if (SRC2[(i * 8)+7] == 1 ) then\n     DEST[(i*8)+7..(i*8)+0] <- 0;\n     else\n     index[3..0] <- SRC2[(i*8)+3 .. (i*8)+0];\n     DEST[(i*8)+7..(i*8)+0] <- SRC1[(index*8+7)..(index*8+0)];\n  endif\n  if (SRC2[128 + (i * 8)+7] == 1 ) then\n     DEST[128 + (i*8)+7..(i*8)+0] <- 0;\n     else\n     index[3..0] <- SRC2[128 + (i*8)+3 .. (i*8)+0];\n     DEST[128 + (i*8)+7..(i*8)+0] <- SRC1[128 + (index*8+7)..(index*8+0)];\n  endif\n}\n                                 MM2\n              07H\n                                 MM1\n              04H\n                                 MM1\n              04H\n| Figure 4-11.| PSHUB with 64-Bit Operands\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PSHUFB:   | __m64 _mm_shuffle_pi8 (__m64 a, __m64\n|           | b)                                   \n| (V)PSHUFB:| __m128i _mm_shuffle_epi8 (__m128i a, \n|           | __m128i b)                           \n| VPSHUFB:  | __m256i _mm256_shuffle_epi8(__m256i  \n|           | a, __m256i b)                        \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PSHUFB"
    }, 
    {
      "description": "\nPSHUFD - Shuffle Packed Doublewords:\n| Opcode/Instruction                      | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 66 0F 70 /r ib PSHUFD xmm1, xmm2/m128,  | RMI  | V/V                   | SSE2              | Shuffle the doublewords in xmm2/m128   \n| imm8                                    |      |                       |                   | based on the encoding in imm8 and store\n|                                         |      |                       |                   | the result in xmm1.                    \n| VEX.128.66.0F.WIG 70 /r ib VPSHUFD xmm1,| RMI  | V/V                   | AVX               | Shuffle the doublewords in xmm2/m128   \n| xmm2/m128, imm8                         |      |                       |                   | based on the encoding in imm8 and store\n|                                         |      |                       |                   | the result in xmm1.                    \n| VEX.256.66.0F.WIG 70 /r ib VPSHUFD ymm1,| RMI  | V/V                   | AVX2              | Shuffle the doublewords in ymm2/m256   \n| ymm2/m256, imm8                         |      |                       |                   | based on the encoding in imm8 and store\n|                                         |      |                       |                   | the result in ymm1.                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8     | NA       \n\nDescription:\nCopies doublewords from source operand (second operand) and inserts them in\nthe destination operand (first operand) at the locations selected with the order\noperand (third operand). Figure 4-12 shows the operation of the 256-bit VPSHUFD\ninstruction and the encoding of the order operand. Each 2-bit field in the order\noperand selects the contents of one doubleword location within a 128-bit lane\nand copy to the target element in the destination operand. For example, bits\n0 and 1 of the order operand targets the first doubleword element in the low\nand high 128-bit lane of the destination operand for 256-bit VPSHUFD. The encoded\nvalue of bits 1:0 of the order operand (see the field encoding in Figure 4-12)\ndetermines which doubleword element (from the respective 128-bit lane) of the\nsource operand will be copied to doubleword 0 of the destination operand. For\n128-bit operation, only the low 128-bit lane are operative. The source operand\ncan be an XMM register or a 128-bit memory location. The destination operand\nis an XMM register. The order operand is an 8-bit immediate. Note that this\ninstruction permits a doubleword in the source operand to be copied to more\nthan one doubleword location in the destination operand.\n\n| SRC Encoding of Fields in Operand| X7 Y7 ORDER Figure 4-12.| X6 Y6 00B - X4 01B - X5 10B - X6 11B| X5 Y5 ORDER 256-bit VPSHUFD Instruction| X4 Y4 4 3| X3 Y3 0| X2 Y2 Encoding of Fields in ORDER Operand| X1 Y1 00B - X0 01B - X1 10B - X2 11B| X0 Y0\n|                                  |                         | - X7                                | Operation                              |          |        |                                          | - X3                                |      \nThe source operand can be an XMM register or a 128-bit memory location. The\ndestination operand is an XMM register. The order operand is an 8-bit immediate.\nNote that this instruction permits a doubleword in the source operand to be\ncopied to more than one doubleword location in the destination operand.\n\nLegacy SSE instructions: In 64-bit mode using a REX prefix in the form of REX.R\npermits this instruction to access additional registers (XMM8-XMM15). 128-bit\nLegacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128) of the\ndestination YMM register are zeroed. VEX.256 encoded version: Bits (255:128)\nof the destination stores the shuffled results of the upper 16 bytes of the\nsource operand using the immediate byte as the order operand.\n\nNote: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the\ninstruction will #UD.\n\nOperation:\n\nPSHUFD (128-bit Legacy SSE version)\nDEST[31:0] <- (SRC >> (ORDER[1:0] * 32))[31:0];\nDEST[63:32] <- (SRC >> (ORDER[3:2] * 32))[31:0];\nDEST[95:64] <- (SRC >> (ORDER[5:4] * 32))[31:0];\nDEST[127:96] <- (SRC >> (ORDER[7:6] * 32))[31:0];\nDEST[VLMAX-1:128] (Unmodified)\nVPSHUFD (VEX.128 encoded version)\nDEST[31:0] <- (SRC >> (ORDER[1:0] * 32))[31:0];\nDEST[63:32] <- (SRC >> (ORDER[3:2] * 32))[31:0];\nDEST[95:64] <- (SRC >> (ORDER[5:4] * 32))[31:0];\nDEST[127:96] <- (SRC >> (ORDER[7:6] * 32))[31:0];\nDEST[VLMAX-1:128] <- 0\nVPSHUFD (VEX.256 encoded version)\nDEST[31:0] <- (SRC[127:0] >> (ORDER[1:0] * 32))[31:0];\nDEST[63:32] <- (SRC[127:0] >> (ORDER[3:2] * 32))[31:0];\nDEST[95:64] <- (SRC[127:0] >> (ORDER[5:4] * 32))[31:0];\nDEST[127:96] <- (SRC[127:0] >> (ORDER[7:6] * 32))[31:0];\nDEST[159:128] <- (SRC[255:128] >> (ORDER[1:0] * 32))[31:0];\nDEST[191:160] <- (SRC[255:128] >> (ORDER[3:2] * 32))[31:0];\nDEST[223:192] <- (SRC[255:128] >> (ORDER[5:4] * 32))[31:0];\nDEST[255:224] <- (SRC[255:128] >> (ORDER[7:6] * 32))[31:0];\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PSHUFD:| __m128i _mm_shuffle_epi32(__m128i a,\n|           | int n)                              \n| VPSHUFD:  | __m256i _mm256_shuffle_epi32(__m256i\n|           | a, const int n)                     \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PSHUFD"
    }, 
    {
      "description": "\nPSHUFHW - Shuffle Packed High Words:\n| Opcode/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| F3 0F 70 /r ib PSHUFHW xmm1, xmm2/m128,| RMI  | V/V                   | SSE2              | Shuffle the high words in xmm2/m128    \n| imm8                                   |      |                       |                   | based on the encoding in imm8 and store\n|                                        |      |                       |                   | the result in xmm1.                    \n| VEX.128.F3.0F.WIG 70 /r ib VPSHUFHW    | RMI  | V/V                   | AVX               | Shuffle the high words in xmm2/m128    \n| xmm1, xmm2/m128, imm8                  |      |                       |                   | based on the encoding in imm8 and store\n|                                        |      |                       |                   | the result in xmm1.                    \n| VEX.256.F3.0F.WIG 70 /r ib VPSHUFHW    | RMI  | V/V                   | AVX2              | Shuffle the high words in ymm2/m256    \n| ymm1, ymm2/m256, imm8                  |      |                       |                   | based on the encoding in imm8 and store\n|                                        |      |                       |                   | the result in ymm1.                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8     | NA       \n\nDescription:\nCopies words from the high quadword of a 128-bit lane of the source operand\nand inserts them in the high quadword of the destination operand at word locations\n(of the respective lane) selected with the immediate operand. This 256-bit operation\nis similar to the in-lane operation used by the 256-bit VPSHUFD instruction,\nwhich is illustrated in Figure 4-12. For 128-bit operation, only the low 128-bit\nlane is operative. Each 2-bit field in the immediate operand selects the contents\nof one word location in the high quadword of the destination operand. The binary\nencodings of the immediate operand fields select words (0, 1, 2 or 3, 4) from\nthe high quadword of the source operand to be copied to the destination operand.\nThe low quadword of the source operand is copied to the low quadword of the\ndestination operand, for each 128-bit lane. Note that this instruction permits\na word in the high quadword of the source operand to be copied to more than\none word location in the high quadword of the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\ndestination operand is an XMM register. The source operand can be an XMM register\nor a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: The destination operand\nis an XMM register. The source operand can be an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.vvvv\nis reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will\n#UD. VEX.256 encoded version: The destination operand is an YMM register. The\nsource operand can be an YMM register or a 256-bit memory location. Note: In\nVEX encoded versions VEX.vvvv is reserved and must be 1111b otherwise instructions\nwill #UD.\n\nOperation:\n\nPSHUFHW (128-bit Legacy SSE version)\nDEST[63:0] <- SRC[63:0]\nDEST[79:64] <- (SRC >> (imm[1:0] *16))[79:64]\nDEST[95:80] <- (SRC >> (imm[3:2] * 16))[79:64]\nDEST[111:96] <- (SRC >> (imm[5:4] * 16))[79:64]\nDEST[127:112] <- (SRC >> (imm[7:6] * 16))[79:64]\nDEST[VLMAX-1:128] (Unmodified)\nVPSHUFHW (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0]\nDEST[79:64] <- (SRC1 >> (imm[1:0] *16))[79:64]\nDEST[95:80] <- (SRC1 >> (imm[3:2] * 16))[79:64]\nDEST[111:96] <- (SRC1 >> (imm[5:4] * 16))[79:64]\nDEST[127:112] <- (SRC1 >> (imm[7:6] * 16))[79:64]\nDEST[VLMAX-1:128] <- 0\nVPSHUFHW (VEX.256 encoded version)\nDEST[63:0] <- SRC1[63:0]\nDEST[79:64] <- (SRC1 >> (imm[1:0] *16))[79:64]\nDEST[95:80] <- (SRC1 >> (imm[3:2] * 16))[79:64]\nDEST[111:96] <- (SRC1 >> (imm[5:4] * 16))[79:64]\nDEST[127:112] <- (SRC1 >> (imm[7:6] * 16))[79:64]\nDEST[191:128] <- SRC1[191:128]\nDEST[207192] <- (SRC1 >> (imm[1:0] *16))[207:192]\nDEST[223:208] <- (SRC1 >> (imm[3:2] * 16))[207:192]\nDEST[239:224] <- (SRC1 >> (imm[5:4] * 16))[207:192]\nDEST[255:240] <- (SRC1 >> (imm[7:6] * 16))[207:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PSHUFHW:| __m128i _mm_shufflehi_epi16(__m128i   \n|            | a, int n)                             \n| VPSHUFHW:  | __m256i _mm256_shufflehi_epi16(__m256i\n|            | a, const int n)                       \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PSHUFHW"
    }, 
    {
      "description": "\nPSHUFLW - Shuffle Packed Low Words:\n| Opcode/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| F2 0F 70 /r ib PSHUFLW xmm1, xmm2/m128,| RMI  | V/V                   | SSE2              | Shuffle the low words in xmm2/m128 based\n| imm8                                   |      |                       |                   | on the encoding in imm8 and store the   \n|                                        |      |                       |                   | result in xmm1.                         \n| VEX.128.F2.0F.WIG 70 /r ib VPSHUFLW    | RMI  | V/V                   | AVX               | Shuffle the low words in xmm2/m128 based\n| xmm1, xmm2/m128, imm8                  |      |                       |                   | on the encoding in imm8 and store the   \n|                                        |      |                       |                   | result in xmm1.                         \n| VEX.256.F2.0F.WIG 70 /r ib VPSHUFLW    | RMI  | V/V                   | AVX2              | Shuffle the low words in ymm2/m256 based\n| ymm1, ymm2/m256, imm8                  |      |                       |                   | on the encoding in imm8 and store the   \n|                                        |      |                       |                   | result in ymm1.                         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8     | NA       \n\nDescription:\nCopies words from the low quadword of a 128-bit lane of the source operand and\ninserts them in the low quadword of the destination operand at word locations\n(of the respective lane) selected with the immediate operand. The 256-bit operation\nis similar to the in-lane operation used by the 256-bit VPSHUFD instruction,\nwhich is illustrated in Figure 4-12. For 128-bit operation, only the low 128-bit\nlane is operative. Each 2-bit field in the immediate operand selects the contents\nof one word location in the low quadword of the destination operand. The binary\nencodings of the immediate operand fields select words (0, 1, 2 or 3) from the\nlow quadword of the source operand to be copied to the destination operand.\nThe high quadword of the source operand is copied to the high quadword of the\ndestination operand, for each 128-bit lane. Note that this instruction permits\na word in the low quadword of the source operand to be copied to more than one\nword location in the low quadword of the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\ndestination operand is an XMM register. The source operand can be an XMM register\nor a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: The destination operand\nis an XMM register. The source operand can be an XMM register or a 128-bit memory\nlocation. Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.256\nencoded version: The destination operand is an YMM register. The source operand\ncan be an YMM register or a 256-bit memory location.\n\nNote: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise instructions\nwill #UD.\n\nOperation:\n\nPSHUFLW (128-bit Legacy SSE version)\nDEST[15:0] <- (SRC >> (imm[1:0] *16))[15:0]\nDEST[31:16] <- (SRC >> (imm[3:2] * 16))[15:0]\nDEST[47:32] <- (SRC >> (imm[5:4] * 16))[15:0]\nDEST[63:48] <- (SRC >> (imm[7:6] * 16))[15:0]\nDEST[127:64] <- SRC[127:64]\nDEST[VLMAX-1:128] (Unmodified)\nVPSHUFLW (VEX.128 encoded version)\nDEST[15:0] <- (SRC1 >> (imm[1:0] *16))[15:0]\nDEST[31:16] <- (SRC1 >> (imm[3:2] * 16))[15:0]\nDEST[47:32] <- (SRC1 >> (imm[5:4] * 16))[15:0]\nDEST[63:48] <- (SRC1 >> (imm[7:6] * 16))[15:0]\nDEST[127:64] <- SRC[127:64]\nDEST[VLMAX-1:128] <- 0\nVPSHUFLW (VEX.256 encoded version)\nDEST[15:0] <- (SRC1 >> (imm[1:0] *16))[15:0]\nDEST[31:16] <- (SRC1 >> (imm[3:2] * 16))[15:0]\nDEST[47:32] <- (SRC1 >> (imm[5:4] * 16))[15:0]\nDEST[63:48] <- (SRC1 >> (imm[7:6] * 16))[15:0]\nDEST[127:64] <- SRC1[127:64]\nDEST[143:128] <- (SRC1 >> (imm[1:0] *16))[143:128]\nDEST[159:144] <- (SRC1 >> (imm[3:2] * 16))[143:128]\nDEST[175:160] <- (SRC1 >> (imm[5:4] * 16))[143:128]\nDEST[191:176] <- (SRC1 >> (imm[7:6] * 16))[143:128]\nDEST[255:192] <- SRC1[255:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PSHUFLW:| __m128i _mm_shufflelo_epi16(__m128i   \n|            | a, int n)                             \n| VPSHUFLW:  | __m256i _mm256_shufflelo_epi16(__m256i\n|            | a, const int n)                       \n\nFlags Affected:\nNone.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1. If VEX.vvvv != 1111B.\n", 
      "mnem": "PSHUFLW"
    }, 
    {
      "description": "\nPSHUFW - Shuffle Packed Words:\n| Opcode/Instruction                   | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                              \n| 0F 70 /r ib PSHUFW mm1, mm2/m64, imm8| RMI  | Valid      | Valid          | Shuffle the words in mm2/m64 based on    \n|                                      |      |            |                | the encoding in imm8 and store the result\n|                                      |      |            |                | in mm1.                                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8     | NA       \n\nDescription:\nCopies words from the source operand (second operand) and inserts them in the\ndestination operand (first operand) at word locations selected with the order\noperand (third operand). This operation is similar to the operation used by\nthe PSHUFD instruction, which is illustrated in Figure 4-12. For the PSHUFW\ninstruction, each 2-bit field in the order operand selects the contents of one\nword location in the destination operand. The encodings of the order operand\nfields select words from the source operand to be copied to the destination\noperand.\n\nThe source operand can be an MMX technology register or a 64-bit memory location.\nThe destination operand is an MMX technology register. The order operand is\nan 8-bit immediate. Note that this instruction permits a word in the source\noperand to be copied to more than one word location in the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nOperation:\n\nDEST[15:0] <- (SRC >> (ORDER[1:0] * 16))[15:0];\nDEST[31:16] <- (SRC >> (ORDER[3:2] * 16))[15:0];\nDEST[47:32] <- (SRC >> (ORDER[5:4] * 16))[15:0];\nDEST[63:48] <- (SRC >> (ORDER[7:6] * 16))[15:0];\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PSHUFW:| __m64 _mm_shuffle_pi16(__m64 a, int\n|        | n)                                 \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Table 22-7, \u201cException Conditions for SIMD/MMX Instructions with Memory\nReference,\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 3A.\n\n", 
      "mnem": "PSHUFW"
    }, 
    {
      "description": "\nPSIGNB/PSIGNW/PSIGND  -  Packed SIGN:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                    \n| 0F 38 08 /r1 PSIGNB mm1, mm2/m64     | RM   | V/V                   | SSSE3             | Negate/zero/preserve packed byte integers      \n|                                      |      |                       |                   | in mm1 depending on the corresponding          \n|                                      |      |                       |                   | sign in mm2/m64.                               \n| 66 0F 38 08 /r PSIGNB xmm1, xmm2/m128| RM   | V/V                   | SSSE3             | Negate/zero/preserve packed byte integers      \n|                                      |      |                       |                   | in xmm1 depending on the corresponding         \n|                                      |      |                       |                   | sign in xmm2/m128.                             \n| 0F 38 09 /r1 PSIGNW mm1, mm2/m64     | RM   | V/V                   | SSSE3             | Negate/zero/preserve packed word integers      \n|                                      |      |                       |                   | in mm1 depending on the corresponding          \n|                                      |      |                       |                   | sign in mm2/m128.                              \n| 66 0F 38 09 /r PSIGNW xmm1, xmm2/m128| RM   | V/V                   | SSSE3             | Negate/zero/preserve packed word integers      \n|                                      |      |                       |                   | in xmm1 depending on the corresponding         \n|                                      |      |                       |                   | sign in xmm2/m128.                             \n| 0F 38 0A /r1 PSIGND mm1, mm2/m64     | RM   | V/V                   | SSSE3             | Negate/zero/preserve packed doubleword         \n|                                      |      |                       |                   | integers in mm1 depending on the corresponding \n|                                      |      |                       |                   | sign in mm2/m128.                              \n| 66 0F 38 0A /r PSIGND xmm1, xmm2/m128| RM   | V/V                   | SSSE3             | Negate/zero/preserve packed doubleword         \n|                                      |      |                       |                   | integers in xmm1 depending on the corresponding\n|                                      |      |                       |                   | sign in xmm2/m128.                             \n| VEX.NDS.128.66.0F38.WIG 08 /r VPSIGNB| RVM  | V/V                   | AVX               | Negate/zero/preserve packed byte integers      \n| xmm1, xmm2, xmm3/m128                |      |                       |                   | in xmm2 depending on the corresponding         \n|                                      |      |                       |                   | sign in xmm3/m128.                             \n| VEX.NDS.128.66.0F38.WIG 09 /r VPSIGNW| RVM  | V/V                   | AVX               | Negate/zero/preserve packed word integers      \n| xmm1, xmm2, xmm3/m128                |      |                       |                   | in xmm2 depending on the corresponding         \n|                                      |      |                       |                   | sign in xmm3/m128.                             \n| VEX.NDS.128.66.0F38.WIG 0A /r VPSIGND| RVM  | V/V                   | AVX               | Negate/zero/preserve packed doubleword         \n| xmm1, xmm2, xmm3/m128                |      |                       |                   | integers in xmm2 depending on the corresponding\n|                                      |      |                       |                   | sign in xmm3/m128.                             \n| VEX.NDS.256.66.0F38.WIG 08 /r VPSIGNB| RVM  | V/V                   | AVX2              | Negate packed byte integers in ymm2            \n| ymm1, ymm2, ymm3/m256                |      |                       |                   | if the corresponding sign in ymm3/m256         \n|                                      |      |                       |                   | is less than zero.                             \n| VEX.NDS.256.66.0F38.WIG 09 /r VPSIGNW| RVM  | V/V                   | AVX2              | Negate packed 16-bit integers in ymm2          \n| ymm1, ymm2, ymm3/m256                |      |                       |                   | if the corresponding sign in ymm3/m256         \n|                                      |      |                       |                   | is less than zero.                             \n| VEX.NDS.256.66.0F38.WIG 0A /r VPSIGND| RVM  | V/V                   | AVX2              | Negate packed doubleword integers in           \n| ymm1, ymm2, ymm3/m256                |      |                       |                   | ymm2 if the corresponding sign in ymm3/m256    \n|                                      |      |                       |                   | is less than zero.                             \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\n(V)PSIGNB/(V)PSIGNW/(V)PSIGND negates each data element of the destination operand\n(the first operand) if the signed integer value of the corresponding data element\nin the source operand (the second operand) is less than zero. If the signed\ninteger value of a data element in the source operand is positive, the corresponding\ndata element in the destination operand is unchanged. If a data element in the\nsource operand is zero, the corresponding data element in the destination operand\nis set to zero.\n\n(V)PSIGNB operates on signed bytes. (V)PSIGNW operates on 16-bit signed words.\n(V)PSIGND operates on signed 32-bit integers. When the source operand is a 128bit\nmemory operand, the operand must be aligned on a 16-byte boundary or a general-protection\nexception (#GP) will be generated.\n\nLegacy SSE instructions: Both operands can be MMX registers. In 64-bit mode,\nuse the REX prefix to access additional registers. 128-bit Legacy SSE version:\nThe first source and destination operands are XMM registers. The second source\noperand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)\nof the corresponding YMM destination register remain unchanged. VEX.128 encoded\nversion: The first source and destination operands are XMM registers. The second\nsource operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)\nof the destination YMM register are zeroed. VEX.L must be 0, otherwise instructions\nwill #UD. VEX.256 encoded version: The first source and destination operands\nare YMM registers. The second source operand is an YMM register or a 256-bit\nmemory location.\n\nOperation:\n\nPSIGNB (with 64 bit operands)\n  IF (SRC[7:0] < 0 )\n     DEST[7:0] <- Neg(DEST[7:0])\n  ELSEIF (SRC[7:0] = 0 )\n     DEST[7:0] <- 0\n  ELSEIF (SRC[7:0] > 0 )\n     DEST[7:0] <- DEST[7:0]\n  Repeat operation for 2nd through 7th bytes\n  IF (SRC[63:56] < 0 )\n     DEST[63:56] <- Neg(DEST[63:56])\n  ELSEIF (SRC[63:56] = 0 )\n     DEST[63:56] <- 0\n  ELSEIF (SRC[63:56] > 0 )\n     DEST[63:56] <- DEST[63:56]\nPSIGNB (with 128 bit operands)\n  IF (SRC[7:0] < 0 )\n     DEST[7:0] <- Neg(DEST[7:0])\n  ELSEIF (SRC[7:0] = 0 )\n     DEST[7:0] <- 0\n  ELSEIF (SRC[7:0] > 0 )\n     DEST[7:0] <- DEST[7:0]\n  Repeat operation for 2nd through 15th bytes\n  IF (SRC[127:120] < 0 )\n     DEST[127:120] <- Neg(DEST[127:120])\n  ELSEIF (SRC[127:120] = 0 )\n     DEST[127:120] <- 0\n  ELSEIF (SRC[127:120] > 0 )\n     DEST[127:120] <- DEST[127:120]\nVPSIGNB (VEX.128 encoded version)\nDEST[127:0] <-BYTE_SIGN(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPSIGNB (VEX.256 encoded version)\nDEST[255:0] <-BYTE_SIGN_256b(SRC1, SRC2)\nPSIGNW (with 64 bit operands)\n  IF (SRC[15:0] < 0 )\n     DEST[15:0] <- Neg(DEST[15:0])\n  ELSEIF (SRC[15:0] = 0 )\n     DEST[15:0] <- 0\n  ELSEIF (SRC[15:0] > 0 )\n     DEST[15:0] <- DEST[15:0]\nRepeat operation for 2nd through 3rd words\n  IF (SRC[63:48] < 0 )\n     DEST[63:48] <- Neg(DEST[63:48])\n  ELSEIF (SRC[63:48] = 0 )\n     DEST[63:48] <- 0\n  ELSEIF (SRC[63:48] > 0 )\n     DEST[63:48] <- DEST[63:48]\nPSIGNW (with 128 bit operands)\n  IF (SRC[15:0] < 0 )\n     DEST[15:0] <- Neg(DEST[15:0])\n  ELSEIF (SRC[15:0] = 0 )\n     DEST[15:0] <- 0\n  ELSEIF (SRC[15:0] > 0 )\n     DEST[15:0] <- DEST[15:0]\n  Repeat operation for 2nd through 7th words\n  IF (SRC[127:112] < 0 )\n     DEST[127:112] <- Neg(DEST[127:112])\n  ELSEIF (SRC[127:112] = 0 )\n     DEST[127:112] <- 0\n  ELSEIF (SRC[127:112] > 0 )\n     DEST[127:112] <- DEST[127:112]\nVPSIGNW (VEX.128 encoded version)\nDEST[127:0] <-WORD_SIGN(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPSIGNW (VEX.256 encoded version)\nDEST[255:0] <-WORD_SIGN(SRC1, SRC2)\nPSIGND (with 64 bit operands)\n  IF (SRC[31:0] < 0 )\n     DEST[31:0] <- Neg(DEST[31:0])\n  ELSEIF (SRC[31:0] = 0 )\n     DEST[31:0] <- 0\n  ELSEIF (SRC[31:0] > 0 )\n     DEST[31:0] <- DEST[31:0]\n  IF (SRC[63:32] < 0 )\n     DEST[63:32] <- Neg(DEST[63:32])\n  ELSEIF (SRC[63:32] = 0 )\n     DEST[63:32] <- 0\n  ELSEIF (SRC[63:32] > 0 )\n     DEST[63:32] <- DEST[63:32]\nPSIGND (with 128 bit operands)\n  IF (SRC[31:0] < 0 )\n     DEST[31:0] <- Neg(DEST[31:0])\n  ELSEIF (SRC[31:0] = 0 )\n     DEST[31:0] <- 0\n  ELSEIF (SRC[31:0] > 0 )\n     DEST[31:0] <- DEST[31:0]\n  Repeat operation for 2nd through 3rd double words\n  IF (SRC[127:96] < 0 )\n     DEST[127:96] <- Neg(DEST[127:96])\n  ELSEIF (SRC[127:96] = 0 )\n     DEST[127:96] <- 0\n  ELSEIF (SRC[127:96] > 0 )\n     DEST[127:96] <- DEST[127:96]\nVPSIGND (VEX.128 encoded version)\nDEST[127:0] <-DWORD_SIGN(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPSIGND (VEX.256 encoded version)\nDEST[255:0] <-DWORD_SIGN(SRC1, SRC2)\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PSIGNB:   | __m64 _mm_sign_pi8 (__m64 a, __m64 b)     \n| (V)PSIGNB:| __m128i _mm_sign_epi8 (__m128i a, __m128i \n|           | b)                                        \n| VPSIGNB:  | __m256i _mm256_sign_epi8 (__m256i a,      \n|           | __m256i b)                                \n| PSIGNW:   | __m64 _mm_sign_pi16 (__m64 a, __m64       \n|           | b)                                        \n| (V)PSIGNW:| __m128i _mm_sign_epi16 (__m128i a, __m128i\n|           | b)                                        \n| VPSIGNW:  | __m256i _mm256_sign_epi16 (__m256i a,     \n|           | __m256i b)                                \n| PSIGND:   | __m64 _mm_sign_pi32 (__m64 a, __m64       \n|           | b)                                        \n| (V)PSIGND:| __m128i _mm_sign_epi32 (__m128i a, __m128i\n|           | b)                                        \n| VPSIGND:  | __m256i _mm256_sign_epi32 (__m256i a,     \n|           | __m256i b)                                \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PSIGNB"
    }, 
    {
      "description": "-R:PSIGNB", 
      "mnem": "PSIGND"
    }, 
    {
      "description": "-R:PSIGNB", 
      "mnem": "PSIGNW"
    }, 
    {
      "description": "-R:PSLLW", 
      "mnem": "PSLLD"
    }, 
    {
      "description": "\nPSLLDQ - Shift Double Quadword Left Logical:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| 66 0F 73 /7 ib PSLLDQ xmm1, imm8      | MI   | V/V                   | SSE2              | Shift xmm1 left by imm8 bytes while     \n|                                       |      |                       |                   | shifting in 0s.                         \n| VEX.NDD.128.66.0F.WIG 73 /7 ib VPSLLDQ| VMI  | V/V                   | AVX               | Shift xmm2 left by imm8 bytes while     \n| xmm1, xmm2, imm8                      |      |                       |                   | shifting in 0s and store result in xmm1.\n| VEX.NDD.256.66.0F.WIG 73 /7 ib VPSLLDQ| VMI  | V/V                   | AVX2              | Shift ymm2 left by imm8 bytes while     \n| ymm1, ymm2, imm8                      |      |                       |                   | shifting in 0s and store result in ymm1.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| MI   | ModRM:r/m (r, w)| imm8         | NA       | NA       \n| VMI  | VEX.vvvv (w)    | ModRM:r/m (r)| imm8     | NA       \n\nDescription:\nShifts the destination operand (first operand) to the left by the number of\nbytes specified in the count operand (second operand). The empty low-order bytes\nare cleared (set to all 0s). If the value specified by the count operand is\ngreater than 15, the destination operand is set to all 0s. The count operand\nis an 8-bit immediate. 128-bit Legacy SSE version: The source and destination\noperands are the same. Bits (VLMAX-1:128) of the corresponding YMM destination\nregister remain unchanged. VEX.128 encoded version: The source and destination\noperands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register\nare zeroed. VEX.256 encoded version: The source operand is a YMM register. The\ndestination operand is a YMM register. The count operand applies to both the\nlow and high 128-bit lanes.\n\nNote: VEX.vvvv encodes the destination register, and VEX.B + ModRM.r/m encodes\nthe source register. VEX.L must be 0, otherwise instructions will #UD.\n\nOperation:\n\nPSLLDQ(128-bit Legacy SSE version)\nTEMP <- COUNT\nIF (TEMP > 15) THEN TEMP <- 16; FI\nDEST <- DEST << (TEMP * 8)\nDEST[VLMAX-1:128] (Unmodified)\nVPSLLDQ (VEX.128 encoded version)\nTEMP <- COUNT\nIF (TEMP > 15) THEN TEMP <- 16; FI\nDEST <- SRC << (TEMP * 8)\nDEST[VLMAX-1:128] <- 0\nVPSLLDQ (VEX.256 encoded version)\nTEMP <- COUNT\nIF (TEMP > 15) THEN TEMP \uf002 16; FI\nDEST[127:0] <- SRC[127:0] << (TEMP * 8)\nDEST[255:128] <- SRC[255:128] << (TEMP * 8)\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| (V)PSLLDQ:| __m128i _mm_slli_si128 ( __m128i a,\n|           | int imm)                           \n| VPSLLDQ:  | __m256i _mm256_slli_si256 ( __m256i\n|           | a, const int imm)                  \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 7; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PSLLDQ"
    }, 
    {
      "description": "-R:PSLLW", 
      "mnem": "PSLLQ"
    }, 
    {
      "description": "\nPSLLW/PSLLD/PSLLQ - Shift Packed Data Left Logical:\n| Opcode/Instruction                      | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                 \n| 0F F1 /r1 PSLLW mm, mm/m64              | RM   | V/V                   | MMX               | Shift words in mm left mm/m64 while         \n|                                         |      |                       |                   | shifting in 0s.                             \n| 66 0F F1 /r PSLLW xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Shift words in xmm1 left by xmm2/m128       \n|                                         |      |                       |                   | while shifting in 0s.                       \n| 0F 71 /6 ib PSLLW mm1, imm8             | MI   | V/V                   | MMX               | Shift words in mm left by imm8 while        \n|                                         |      |                       |                   | shifting in 0s.                             \n| 66 0F 71 /6 ib PSLLW xmm1, imm8         | MI   | V/V                   | SSE2              | Shift words in xmm1 left by imm8 while      \n|                                         |      |                       |                   | shifting in 0s.                             \n| 0F F2 /r1 PSLLD mm, mm/m64              | RM   | V/V                   | MMX               | Shift doublewords in mm left by mm/m64      \n|                                         |      |                       |                   | while shifting in 0s.                       \n| 66 0F F2 /r PSLLD xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Shift doublewords in xmm1 left by xmm2/m128 \n|                                         |      |                       |                   | while shifting in 0s.                       \n| 0F 72 /6 ib1 PSLLD mm, imm8             | MI   | V/V                   | MMX               | Shift doublewords in mm left by imm8        \n|                                         |      |                       |                   | while shifting in 0s.                       \n| 66 0F 72 /6 ib PSLLD xmm1, imm8         | MI   | V/V                   | SSE2              | Shift doublewords in xmm1 left by imm8      \n|                                         |      |                       |                   | while shifting in 0s.                       \n| 0F F3 /r1 PSLLQ mm, mm/m64              | RM   | V/V                   | MMX               | Shift quadword in mm left by mm/m64         \n|                                         |      |                       |                   | while shifting in 0s.                       \n| 66 0F F3 /r PSLLQ xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Shift quadwords in xmm1 left by xmm2/m128   \n|                                         |      |                       |                   | while shifting in 0s.                       \n| 0F 73 /6 ib1 PSLLQ mm, imm8             | MI   | V/V                   | MMX               | Shift quadword in mm left by imm8 while     \n|                                         |      |                       |                   | shifting in 0s.                             \n| 66 0F 73 /6 ib PSLLQ xmm1, imm8         | MI   | V/V                   | SSE2              | Shift quadwords in xmm1 left by imm8        \n|                                         |      |                       |                   | while shifting in 0s.                       \n| VEX.NDS.128.66.0F.WIG F1 /r VPSLLW xmm1,| RVM  | V/V                   | AVX               | Shift words in xmm2 left by amount specified\n| xmm2, xmm3/m128                         |      |                       |                   | in xmm3/m128 while shifting in 0s.          \n| VEX.NDD.128.66.0F.WIG 71 /6 ib VPSLLW   | VMI  | V/V                   | AVX               | Shift words in xmm2 left by imm8 while      \n| xmm1, xmm2, imm8                        |      |                       |                   | shifting in 0s.                             \n| VEX.NDS.128.66.0F.WIG F2 /r VPSLLD xmm1,| RVM  | V/V                   | AVX               | Shift doublewords in xmm2 left by amount    \n| xmm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting       \n|                                         |      |                       |                   | in 0s.                                      \n| VEX.NDD.128.66.0F.WIG 72 /6 ib VPSLLD   | VMI  | V/V                   | AVX               | Shift doublewords in xmm2 left by imm8      \n| xmm1, xmm2, imm8                        |      |                       |                   | while shifting in 0s.                       \n| VEX.NDS.128.66.0F.WIG F3 /r VPSLLQ xmm1,| RVM  | V/V                   | AVX               | Shift quadwords in xmm2 left by amount      \n| xmm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting       \n|                                         |      |                       |                   | in 0s.                                      \n| VEX.NDD.128.66.0F.WIG 73 /6 ib VPSLLQ   | VMI  | V/V                   | AVX               | Shift quadwords in xmm2 left by imm8        \n| xmm1, xmm2, imm8                        |      |                       |                   | while shifting in 0s.                       \n| VEX.NDS.256.66.0F.WIG F1 /r VPSLLW ymm1,| RVM  | V/V                   | AVX2              | Shift words in ymm2 left by amount specified\n| ymm2, xmm3/m128                         |      |                       |                   | in xmm3/m128 while shifting in 0s.          \n| VEX.NDD.256.66.0F.WIG 71 /6 ib VPSLLW   | VMI  | V/V                   | AVX2              | Shift words in ymm2 left by imm8 while      \n| ymm1, ymm2, imm8                        |      |                       |                   | shifting in 0s.                             \n| VEX.NDS.256.66.0F.WIG F2 /r VPSLLD ymm1,| RVM  | V/V                   | AVX2              | Shift doublewords in ymm2 left by amount    \n| ymm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting       \n|                                         |      |                       |                   | in 0s.                                      \n| VEX.NDD.256.66.0F.WIG 72 /6 ib VPSLLD   | VMI  | V/V                   | AVX2              | Shift doublewords in ymm2 left by imm8      \n| ymm1, ymm2, imm8                        |      |                       |                   | while shifting in 0s.                       \n| VEX.NDS.256.66.0F.WIG F3 /r VPSLLQ ymm1,| RVM  | V/V                   | AVX2              | Shift quadwords in ymm2 left by amount      \n| ymm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting       \n|                                         |      |                       |                   | in 0s.                                      \n| VEX.NDD.256.66.0F.WIG 73 /6 ib VPSLLQ   | VMI  | V/V                   | AVX2              | Shift quadwords in ymm2 left by imm8        \n| ymm1, ymm2, imm8                        |      |                       |                   | while shifting in 0s.                       \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| MI   | ModRM:r/m (r, w)| imm8         | NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n| VMI  | VEX.vvvv (w)    | ModRM:r/m (r)| imm8         | NA       \n\nDescription:\nShifts the bits in the individual data elements (words, doublewords, or quadword)\nin the destination operand (first operand) to the left by the number of bits\nspecified in the count operand (second operand). As the bits in the data elements\nare shifted left, the empty low-order bits are cleared (set to 0). If the value\nspecified by the count operand is greater than 15 (for words), 31 (for doublewords),\nor 63 (for a quadword), then the destination operand is set to all 0s. Figure\n4-13 gives an example of shifting words in a 64-bit operand.\n\nPre-Shift\n\n| X3 PSLLW, PSLLD, and PSLLQ Instruction| X2 X2 << COUNT| X1 X1 << COUNT| X0 DEST Shift Left with Zero Extension\n| Operation Using 64-bit Operand        |               |               | X0 << COUNT DEST Figure 4-13.         \nThe (V)PSLLW instruction shifts each of the words in the destination operand\nto the left by the number of bits specified in the count operand; the (V)PSLLD\ninstruction shifts each of the doublewords in the destination operand; and the\n(V)PSLLQ instruction shifts the quadword (or quadwords) in the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions: The destination operand is an MMX technology register;\nthe count operand can be either an MMX technology register or an 64-bit memory\nlocation. 128-bit Legacy SSE version: The destination and first source operands\nare XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register\nremain unchanged. The count operand can be either an XMM register or a 128-bit\nmemory location or an 8-bit immediate. If the count operand is a memory address,\n128 bits are loaded but the upper 64 bits are ignored.\n\nVEX.128 encoded version: The destination and first source operands are XMM registers.\nBits (VLMAX-1:128) of the destination YMM register are zeroed. The count operand\ncan be either an XMM register or a 128-bit memory location or an 8-bit immediate.\nIf the count operand is a memory address, 128 bits are loaded but the upper\n64 bits are ignored. VEX.256 encoded version: The destination and first source\noperands are YMM registers. The count operand can be either an XMM register\nor a 128-bit memory location or an 8-bit immediate.\n\nNote: For shifts with an immediate count (VEX.128.66.0F 71-73 /6), VEX.vvvv\nencodes the destination register, and VEX.B + ModRM.r/m encodes the source register.\nVEX.L must be 0, otherwise instructions will #UD.\n\nOperation:\n\nPSLLW (with 64-bit operand)\n  IF (COUNT > 15)\n  THEN\n     DEST[64:0] <- 0000000000000000H;\n  ELSE\n     DEST[15:0] <- ZeroExtend(DEST[15:0] << COUNT);\n     (* Repeat shift operation for 2nd and 3rd words *)\n     DEST[63:48] <- ZeroExtend(DEST[63:48] << COUNT);\n  FI;\nPSLLD (with 64-bit operand)\n  IF (COUNT > 31)\n  THEN\n     DEST[64:0] <- 0000000000000000H;\n  ELSE\n     DEST[31:0] <- ZeroExtend(DEST[31:0] << COUNT);\n     DEST[63:32] <- ZeroExtend(DEST[63:32] << COUNT);\n  FI;\nPSLLQ (with 64-bit operand)\n  IF (COUNT > 63)\n  THEN\n     DEST[64:0] <- 0000000000000000H;\n  ELSE\n     DEST <- ZeroExtend(DEST << COUNT);\n  FI;\nPSLLW (with 128-bit operand)\n  COUNT <- COUNT_SOURCE[63:0];\n  IF (COUNT > 15)\n  THEN\n     DEST[128:0] <- 00000000000000000000000000000000H;\n  ELSE\n     DEST[15:0]\n     (* Repeat shift operation for 2nd through 7th words *)\n     DEST[127:112] <- ZeroExtend(DEST[127:112] << COUNT);\n  FI;\nPSLLD (with 128-bit operand)\n  COUNT <- COUNT_SOURCE[63:0];\n  IF (COUNT > 31)\n  THEN\n     DEST[128:0] <- 00000000000000000000000000000000H;\n  ELSE\n     DEST[31:0]\n     (* Repeat shift operation for 2nd and 3rd doublewords *)\n     DEST[127:96] <- ZeroExtend(DEST[127:96] << COUNT);\n  FI;\nPSLLQ (with 128-bit operand)\n  COUNT <- COUNT_SOURCE[63:0];\n  IF (COUNT > 63)\n  THEN\n     DEST[128:0] <- 00000000000000000000000000000000H;\n  ELSE\n     DEST[63:0]\n     DEST[127:64] <- ZeroExtend(DEST[127:64] << COUNT);\n  FI;\nPSLLW (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_WORDS(DEST, SRC)\nDEST[VLMAX-1:128] (Unmodified)\nPSLLW (xmm, imm8)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_WORDS(DEST, imm8)\nDEST[VLMAX-1:128] (Unmodified)\nVPSLLD (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_DWORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPSLLD (xmm, imm8)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_DWORDS(SRC1, imm8)\nDEST[VLMAX-1:128] <- 0\nPSLLD (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_DWORDS(DEST, SRC)\nDEST[VLMAX-1:128] (Unmodified)\nPSLLD (xmm, imm8)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_DWORDS(DEST, imm8)\nDEST[VLMAX-1:128] (Unmodified)\nVPSLLQ (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_QWORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPSLLQ (xmm, imm8)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_QWORDS(SRC1, imm8)\nDEST[VLMAX-1:128] <- 0\nPSLLQ (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_QWORDS(DEST, SRC)\nDEST[VLMAX-1:128] (Unmodified)\nPSLLQ (xmm, imm8)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_QWORDS(DEST, imm8)\nDEST[VLMAX-1:128] (Unmodified)\nVPSLLW (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_WORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPSLLW (xmm, imm8)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_WORDS(SRC1, imm8)\nDEST[VLMAX-1:128] <- 0\nPSLLW (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_WORDS(DEST, SRC)\nDEST[VLMAX-1:128] (Unmodified)\nPSLLW (xmm, imm8)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_WORDS(DEST, imm8)\nDEST[VLMAX-1:128] (Unmodified)\nVPSLLD (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_DWORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPSLLD (xmm, imm8)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_DWORDS(SRC1, imm8)\nDEST[VLMAX-1:128] <- 0\nVPSLLW (ymm, ymm, xmm/m128)\nDEST[255:0] <- LOGICAL_LEFT_SHIFT_WORDS_256b(SRC1, SRC2)\nVPSLLW (ymm, imm8)\nDEST[255:0] <- LOGICAL_LEFT_SHIFT_WORD_256bS(SRC1, imm8)\nVPSLLD (ymm, ymm, xmm/m128)\nDEST[255:0] <- LOGICAL_LEFT_SHIFT_DWORDS_256b(SRC1, SRC2)\nVPSLLD (ymm, imm8)\nDEST[127:0] <- LOGICAL_LEFT_SHIFT_DWORDS_256b(SRC1, imm8)\nVPSLLQ (ymm, ymm, xmm/m128)\nDEST[255:0] <- LOGICAL_LEFT_SHIFT_QWORDS_256b(SRC1, SRC2)\nVPSLLQ (ymm, imm8)\nDEST[255:0] <- LOGICAL_LEFT_SHIFT_QWORDS_256b(SRC1, imm8)\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PSLLW:   | __m64 _mm_slli_pi16 (__m64 m, int count) \n| PSLLW:   | __m64 _mm_sll_pi16(__m64 m, __m64 count) \n| (V)PSLLW:| __m128i _mm_slli_pi16(__m64 m, int count)\n| (V)PSLLW:| __m128i _mm_slli_pi16(__m128i m, __m128i \n|          | count)                                   \n| VPSLLW:  | __m256i _mm256_slli_epi16 (__m256i m,    \n|          | int count)                               \n| VPSLLW:  | __m256i _mm256_sll_epi16 (__m256i m,     \n|          | __m128i count)                           \n| PSLLD:   | count)                                   \n| PSLLD:   | __m64 _mm_sll_pi32(__m64 m, __m64 count) \n| (V)PSLLD:| count)                                   \n| (V)PSLLD:| __m128i _mm_sll_epi32(__m128i m, __m128i \n|          | count)                                   \n| VPSLLD:  | __m256i _mm256_slli_epi32 (__m256i m,    \n|          | int count)                               \n| VPSLLD:  | __m256i _mm256_sll_epi32 (__m256i m,     \n|          | __m128i count)                           \n| PSLLQ:   | count)                                   \n| PSLLQ:   | __m64 _mm_sll_si64(__m64 m, __m64 count) \n| (V)PSLLQ:| count)                                   \n| (V)PSLLQ:| __m128i _mm_sll_epi64(__m128i m, __m128i \n|          | count)                                   \n| VPSLLQ:  | __m256i _mm256_slli_epi64 (__m256i m,    \n|          | int count)                               \n| VPSLLQ:  | __m256i _mm256_sll_epi64 (__m256i m,     \n|          | __m128i count)                           \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4 and 7 for non-VEX-encoded instructions; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PSLLW"
    }, 
    {
      "description": "-R:PSRAW", 
      "mnem": "PSRAD"
    }, 
    {
      "description": "\nPSRAW/PSRAD - Shift Packed Data Right Arithmetic:\n| Opcode/Instruction                      | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| 0F E1 /r1 PSRAW mm, mm/m64              | RM   | V/V                   | MMX               | Shift words in mm right by mm/m64 while  \n|                                         |      |                       |                   | shifting in sign bits.                   \n| 66 0F E1 /r PSRAW xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Shift words in xmm1 right by xmm2/m128   \n|                                         |      |                       |                   | while shifting in sign bits.             \n| 0F 71 /4 ib1 PSRAW mm, imm8             | MI   | V/V                   | MMX               | Shift words in mm right by imm8 while    \n|                                         |      |                       |                   | shifting in sign bits                    \n| 66 0F 71 /4 ib PSRAW xmm1, imm8         | MI   | V/V                   | SSE2              | Shift words in xmm1 right by imm8 while  \n|                                         |      |                       |                   | shifting in sign bits                    \n| 0F E2 /r1 PSRAD mm, mm/m64              | RM   | V/V                   | MMX               | Shift doublewords in mm right by mm/m64  \n|                                         |      |                       |                   | while shifting in sign bits.             \n| 66 0F E2 /r PSRAD xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Shift doubleword in xmm1 right by xmm2   \n|                                         |      |                       |                   | /m128 while shifting in sign bits.       \n| 0F 72 /4 ib1 PSRAD mm, imm8             | MI   | V/V                   | MMX               | Shift doublewords in mm right by imm8    \n|                                         |      |                       |                   | while shifting in sign bits.             \n| 66 0F 72 /4 ib PSRAD xmm1, imm8         | MI   | V/V                   | SSE2              | Shift doublewords in xmm1 right by imm8  \n|                                         |      |                       |                   | while shifting in sign bits.             \n| VEX.NDS.128.66.0F.WIG E1 /r VPSRAW xmm1,| RVM  | V/V                   | AVX               | Shift words in xmm2 right by amount      \n| xmm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting    \n|                                         |      |                       |                   | in sign bits.                            \n| VEX.NDD.128.66.0F.WIG 71 /4 ib VPSRAW   | VMI  | V/V                   | AVX               | Shift words in xmm2 right by imm8 while  \n| xmm1, xmm2, imm8                        |      |                       |                   | shifting in sign bits.                   \n| VEX.NDS.128.66.0F.WIG E2 /r VPSRAD xmm1,| RVM  | V/V                   | AVX               | Shift doublewords in xmm2 right by amount\n| xmm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting    \n|                                         |      |                       |                   | in sign bits.                            \n| VEX.NDD.128.66.0F.WIG 72 /4 ib VPSRAD   | VMI  | V/V                   | AVX               | Shift doublewords in xmm2 right by imm8  \n| xmm1, xmm2, imm8                        |      |                       |                   | while shifting in sign bits.             \n| VEX.NDS.256.66.0F.WIG E1 /r VPSRAW ymm1,| RVM  | V/V                   | AVX2              | Shift words in ymm2 right by amount      \n| ymm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting    \n|                                         |      |                       |                   | in sign bits.                            \n| VEX.NDD.256.66.0F.WIG 71 /4 ib VPSRAW   | VMI  | V/V                   | AVX2              | Shift words in ymm2 right by imm8 while  \n| ymm1, ymm2, imm8                        |      |                       |                   | shifting in sign bits.                   \n| VEX.NDS.256.66.0F.WIG E2 /r VPSRAD ymm1,| RVM  | V/V                   | AVX2              | Shift doublewords in ymm2 right by amount\n| ymm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting    \n|                                         |      |                       |                   | in sign bits.                            \n| VEX.NDD.256.66.0F.WIG 72 /4 ib VPSRAD   | VMI  | V/V                   | AVX2              | Shift doublewords in ymm2 right by imm8  \n| ymm1, ymm2, imm8                        |      |                       |                   | while shifting in sign bits.             \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| MI   | ModRM:r/m (r, w)| imm8         | NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n| VMI  | VEX.vvvv (w)    | ModRM:r/m (r)| imm8         | NA       \n\nDescription:\nShifts the bits in the individual data elements (words or doublewords) in the\ndestination operand (first operand) to the right by the number of bits specified\nin the count operand (second operand). As the bits in the data elements are\nshifted right, the empty high-order bits are filled with the initial value of\nthe sign bit of the data element. If the value specified by the count operand\nis greater than 15 (for words) or 31 (for doublewords), each destination data\nelement is filled with the initial value of the sign bit of the element. (Figure\n4-14 gives an example of shifting words in a 64-bit operand.)\n\nPre-Shift\n\n| X3 PSRAW and PSRAD Instruction Operation| X2 X2 >> COUNT| X1 X1 >> COUNT| X0 DEST Shift Right with Sign Extension\n| Using a 64-bit Operand                  |               |               | X0 >> COUNT DEST Figure 4-14.          \nNote that only the first 64-bits of a 128-bit count operand are checked to compute\nthe count. If the second source operand is a memory address, 128 bits are loaded.\n\nThe (V)PSRAW instruction shifts each of the words in the destination operand\nto the right by the number of bits specified in the count operand, and the (V)PSRAD\ninstruction shifts each of the doublewords in the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions: The destination operand is an MMX technology register;\nthe count operand can be either an MMX technology register or an 64-bit memory\nlocation. 128-bit Legacy SSE version: The destination and first source operands\nare XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register\nremain unchanged. The count operand can be either an XMM register or a 128-bit\nmemory location or an 8-bit immediate. If the count operand is a memory address,\n128 bits are loaded but the upper 64 bits are ignored. VEX.128 encoded version:\nThe destination and first source operands are XMM registers. Bits (VLMAX-1:128)\nof the destination YMM register are zeroed. The count operand can be either\nan XMM register or a 128-bit memory location or an 8-bit immediate. If the count\noperand is a memory address, 128 bits are loaded but the upper 64 bits are ignored.\nVEX.256 encoded version: The destination and first source operands are YMM registers.\nThe count operand can be either an XMM register or a 128-bit memory location\nor an 8-bit immediate.\n\nNote: For shifts with an immediate count (VEX.128.66.0F 71-73 /4), VEX.vvvv\nencodes the destination register, and VEX.B + ModRM.r/m encodes the source register.\nVEX.L must be 0, otherwise instructions will #UD.\n\nOperation:\n\nPSRAW (with 64-bit operand)\n  IF (COUNT > 15)\n     THEN COUNT <- 16;\n  FI;\n  DEST[15:0] <- SignExtend(DEST[15:0] >> COUNT);\n  (* Repeat shift operation for 2nd and 3rd words *)\n  DEST[63:48] <- SignExtend(DEST[63:48] >> COUNT);\nPSRAD (with 64-bit operand)\n  IF (COUNT > 31)\n     THEN COUNT <- 32;\n  FI;\n  DEST[31:0] <- SignExtend(DEST[31:0] >> COUNT);\n  DEST[63:32] <- SignExtend(DEST[63:32] >> COUNT);\nPSRAW (with 128-bit operand)\n  COUNT <- COUNT_SOURCE[63:0];\n  IF (COUNT > 15)\n     THEN COUNT <- 16;\n  FI;\n  DEST[15:0]\n  (* Repeat shift operation for 2nd through 7th words *)\n  DEST[127:112] <- SignExtend(DEST[127:112] >> COUNT);\nPSRAD (with 128-bit operand)\n  COUNT <- COUNT_SOURCE[63:0];\n  IF (COUNT > 31)\n     THEN COUNT <- 32;\n  FI;\n  DEST[31:0]\n  (* Repeat shift operation for 2nd and 3rd doublewords *)\n  DEST[127:96] <- SignExtend(DEST[127:96] >>COUNT);\nPSRAW (xmm, xmm, xmm/m128)\nDEST[127:0] <- ARITHMETIC_RIGHT_SHIFT_WORDS(DEST, SRC)\nDEST[VLMAX-1:128] (Unmodified)\nPSRAW (xmm, imm8)\nDEST[127:0] <- ARITHMETIC_RIGHT_SHIFT_WORDS(DEST, imm8)\nDEST[VLMAX-1:128] (Unmodified)\nVPSRAW (xmm, xmm, xmm/m128)\nDEST[127:0] <- ARITHMETIC_RIGHT_SHIFT_WORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPSRAW (xmm, imm8)\nDEST[127:0] <- ARITHMETIC_RIGHT_SHIFT_WORDS(SRC1, imm8)\nDEST[VLMAX-1:128] <- 0\nPSRAD (xmm, xmm, xmm/m128)\nDEST[127:0] <- ARITHMETIC_RIGHT_SHIFT_DWORDS(DEST, SRC)\nDEST[VLMAX-1:128] (Unmodified)\nPSRAD (xmm, imm8)\nDEST[127:0] <- ARITHMETIC_RIGHT_SHIFT_DWORDS(DEST, imm8)\nDEST[VLMAX-1:128] (Unmodified)\nVPSRAD (xmm, xmm, xmm/m128)\nDEST[127:0] <- ARITHMETIC_RIGHT_SHIFT_DWORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPSRAD (xmm, imm8)\nDEST[127:0] <- ARITHMETIC_RIGHT_SHIFT_DWORDS(SRC1, imm8)\nDEST[VLMAX-1:128] <- 0\nVPSRAW (ymm, ymm, xmm/m128)\nDEST[255:0] <- ARITHMETIC_RIGHT_SHIFT_WORDS_256b(SRC1, SRC2)\nVPSRAW (ymm, imm8)\nDEST[255:0] <- ARITHMETIC_RIGHT_SHIFT_WORDS_256b(SRC1, imm8)\nVPSRAD (ymm, ymm, xmm/m128)\nDEST[255:0] <- ARITHMETIC_RIGHT_SHIFT_DWORDS_256b(SRC1, SRC2)\nVPSRAD (ymm, imm8)\nDEST[255:0] <- ARITHMETIC_RIGHT_SHIFT_DWORDS_256b(SRC1, imm8)\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PSRAW:   | __m64 _mm_srai_pi16 (__m64 m, int count) \n| PSRAW:   | __m64 _mm_sra_pi16 (__m64 m, __m64 count)\n| (V)PSRAW:| count)                                   \n| (V)PSRAW:| __m128i _mm_sra_epi16(__m128i m, __m128i \n|          | count)                                   \n| VPSRAW:  | __m256i _mm256_srai_epi16 (__m256i m,    \n|          | int count)                               \n| VPSRAW:  | __m256i _mm256_sra_epi16 (__m256i m,     \n|          | __m128i count)                           \n| PSRAD:   | __m64 _mm_srai_pi32 (__m64 m, int count) \n| PSRAD:   | __m64 _mm_sra_pi32 (__m64 m, __m64 count)\n| (V)PSRAD:| count)                                   \n| (V)PSRAD:| __m128i _mm_sra_epi32 (__m128i m, __m128i\n|          | count)                                   \n| VPSRAD:  | __m256i _mm256_srai_epi32 (__m256i m,    \n|          | int count)                               \n| VPSRAD:  | __m256i _mm256_sra_epi32 (__m256i m,     \n|          | __m128i count)                           \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4 and 7 for non-VEX-encoded instructions; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PSRAW"
    }, 
    {
      "description": "-R:PSRLW", 
      "mnem": "PSRLD"
    }, 
    {
      "description": "\nPSRLDQ - Shift Double Quadword Right Logical:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 66 0F 73 /3 ib PSRLDQ xmm1, imm8      | MI   | V/V                   | SSE2              | Shift xmm1 right by imm8 while shifting\n|                                       |      |                       |                   | in 0s.                                 \n| VEX.NDD.128.66.0F.WIG 73 /3 ib VPSRLDQ| VMI  | V/V                   | AVX               | Shift xmm2 right by imm8 bytes while   \n| xmm1, xmm2, imm8                      |      |                       |                   | shifting in 0s.                        \n| VEX.NDD.256.66.0F.WIG 73 /3 ib VPSRLDQ| VMI  | V/V                   | AVX2              | Shift ymm1 right by imm8 bytes while   \n| ymm1, ymm2, imm8                      |      |                       |                   | shifting in 0s.                        \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| MI   | ModRM:r/m (r, w)| imm8         | NA       | NA       \n| VMI  | VEX.vvvv (w)    | ModRM:r/m (r)| imm8     | NA       \n\nDescription:\nShifts the destination operand (first operand) to the right by the number of\nbytes specified in the count operand (second operand). The empty high-order\nbytes are cleared (set to all 0s). If the value specified by the count operand\nis greater than 15, the destination operand is set to all 0s. The count operand\nis an 8-bit immediate.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsource and destination operands are the same. Bits (VLMAX-1:128) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: The source\nand destination operands are XMM registers. Bits (VLMAX-1:128) of the destination\nYMM register are zeroed. VEX.256 encoded version: The source operand is a YMM\nregister. The destination operand is a YMM register. The count operand applies\nto both the low and high 128-bit lanes.\n\nNote: VEX.vvvv encodes the destination register, and VEX.B + ModRM.r/m encodes\nthe source register. VEX.L must be 0, otherwise instructions will #UD.\n\nOperation:\n\nPSRLDQ(128-bit Legacy SSE version)\nTEMP <- COUNT\nIF (TEMP > 15) THEN TEMP <- 16; FI\nDEST <- DEST >> (TEMP * 8)\nDEST[VLMAX-1:128] (Unmodified)\nVPSRLDQ (VEX.128 encoded version)\nTEMP <- COUNT\nIF (TEMP > 15) THEN TEMP <- 16; FI\nDEST <- SRC >> (TEMP * 8)\nDEST[VLMAX-1:128] <- 0\nVPSRLDQ (VEX.256 encoded version)\nTEMP <- COUNT\nIF (TEMP > 15) THEN TEMP <- 16; FI\nDEST[127:0] <- SRC[127:0] >> (TEMP * 8)\nDEST[255:128] <- SRC[255:128] >> (TEMP * 8)\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| (V)PSRLDQ:| __m128i _mm_srli_si128 ( __m128i a,\n|           | int imm)                           \n| VPSRLDQ:  | __m256i _mm256_srli_si256 ( __m256i\n|           | a, const int imm)                  \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 7; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PSRLDQ"
    }, 
    {
      "description": "-R:PSRLW", 
      "mnem": "PSRLQ"
    }, 
    {
      "description": "\nPSRLW/PSRLD/PSRLQ - Shift Packed Data Right Logical:\n| Opcode/Instruction                      | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| 0F D1 /r1 PSRLW mm, mm/m64              | RM   | V/V                   | MMX               | Shift words in mm right by amount specified\n|                                         |      |                       |                   | in mm/m64 while shifting in 0s.            \n| 66 0F D1 /r PSRLW xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Shift words in xmm1 right by amount        \n|                                         |      |                       |                   | specified in xmm2/m128 while shifting      \n|                                         |      |                       |                   | in 0s.                                     \n| 0F 71 /2 ib1 PSRLW mm, imm8             | MI   | V/V                   | MMX               | Shift words in mm right by imm8 while      \n|                                         |      |                       |                   | shifting in 0s.                            \n| 66 0F 71 /2 ib PSRLW xmm1, imm8         | MI   | V/V                   | SSE2              | Shift words in xmm1 right by imm8 while    \n|                                         |      |                       |                   | shifting in 0s.                            \n| 0F D2 /r1 PSRLD mm, mm/m64              | RM   | V/V                   | MMX               | Shift doublewords in mm right by amount    \n|                                         |      |                       |                   | specified in mm/m64 while shifting in      \n|                                         |      |                       |                   | 0s.                                        \n| 66 0F D2 /r PSRLD xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Shift doublewords in xmm1 right by amount  \n|                                         |      |                       |                   | specified in xmm2 /m128 while shifting     \n|                                         |      |                       |                   | in 0s.                                     \n| 0F 72 /2 ib1 PSRLD mm, imm8             | MI   | V/V                   | MMX               | Shift doublewords in mm right by imm8      \n|                                         |      |                       |                   | while shifting in 0s.                      \n| 66 0F 72 /2 ib PSRLD xmm1, imm8         | MI   | V/V                   | SSE2              | Shift doublewords in xmm1 right by imm8    \n|                                         |      |                       |                   | while shifting in 0s.                      \n| 0F D3 /r1 PSRLQ mm, mm/m64              | RM   | V/V                   | MMX               | Shift mm right by amount specified in      \n|                                         |      |                       |                   | mm/m64 while shifting in 0s.               \n| 66 0F D3 /r PSRLQ xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Shift quadwords in xmm1 right by amount    \n|                                         |      |                       |                   | specified in xmm2/m128 while shifting      \n|                                         |      |                       |                   | in 0s.                                     \n| 0F 73 /2 ib1 PSRLQ mm, imm8             | MI   | V/V                   | MMX               | Shift mm right by imm8 while shifting      \n|                                         |      |                       |                   | in 0s.                                     \n| 66 0F 73 /2 ib PSRLQ xmm1, imm8         | MI   | V/V                   | SSE2              | Shift quadwords in xmm1 right by imm8      \n|                                         |      |                       |                   | while shifting in 0s.                      \n| VEX.NDS.128.66.0F.WIG D1 /r VPSRLW xmm1,| RVM  | V/V                   | AVX               | Shift words in xmm2 right by amount        \n| xmm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting      \n|                                         |      |                       |                   | in 0s.                                     \n| VEX.NDD.128.66.0F.WIG 71 /2 ib VPSRLW   | VMI  | V/V                   | AVX               | Shift words in xmm2 right by imm8 while    \n| xmm1, xmm2, imm8                        |      |                       |                   | shifting in 0s.                            \n| VEX.NDS.128.66.0F.WIG D2 /r VPSRLD xmm1,| RVM  | V/V                   | AVX               | Shift doublewords in xmm2 right by amount  \n| xmm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting      \n|                                         |      |                       |                   | in 0s.                                     \n| VEX.NDD.128.66.0F.WIG 72 /2 ib VPSRLD   | VMI  | V/V                   | AVX               | Shift doublewords in xmm2 right by imm8    \n| xmm1, xmm2, imm8                        |      |                       |                   | while shifting in 0s.                      \n| VEX.NDS.128.66.0F.WIG D3 /r VPSRLQ xmm1,| RVM  | V/V                   | AVX               | Shift quadwords in xmm2 right by amount    \n| xmm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting      \n|                                         |      |                       |                   | in 0s.                                     \n| VEX.NDD.128.66.0F.WIG 73 /2 ib VPSRLQ   | VMI  | V/V                   | AVX               | Shift quadwords in xmm2 right by imm8      \n| xmm1, xmm2, imm8                        |      |                       |                   | while shifting in 0s.                      \n| VEX.NDS.256.66.0F.WIG D1 /r VPSRLW ymm1,| RVM  | V/V                   | AVX2              | Shift words in ymm2 right by amount        \n| ymm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting      \n|                                         |      |                       |                   | in 0s.                                     \n| VEX.NDD.256.66.0F.WIG 71 /2 ib VPSRLW   | VMI  | V/V                   | AVX2              | Shift words in ymm2 right by imm8 while    \n| ymm1, ymm2, imm8                        |      |                       |                   | shifting in 0s.                            \n| VEX.NDS.256.66.0F.WIG D2 /r VPSRLD ymm1,| RVM  | V/V                   | AVX2              | Shift doublewords in ymm2 right by amount  \n| ymm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting      \n|                                         |      |                       |                   | in 0s.                                     \n| VEX.NDD.256.66.0F.WIG 72 /2 ib VPSRLD   | VMI  | V/V                   | AVX2              | Shift doublewords in ymm2 right by imm8    \n| ymm1, ymm2, imm8                        |      |                       |                   | while shifting in 0s.                      \n| VEX.NDS.256.66.0F.WIG D3 /r VPSRLQ ymm1,| RVM  | V/V                   | AVX2              | Shift quadwords in ymm2 right by amount    \n| ymm2, xmm3/m128                         |      |                       |                   | specified in xmm3/m128 while shifting      \n|                                         |      |                       |                   | in 0s.                                     \n| VEX.NDD.256.66.0F.WIG 73 /2 ib VPSRLQ   | VMI  | V/V                   | AVX2              | Shift quadwords in ymm2 right by imm8      \n| ymm1, ymm2, imm8                        |      |                       |                   | while shifting in 0s.                      \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| MI   | ModRM:r/m (r, w)| imm8         | NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n| VMI  | VEX.vvvv (w)    | ModRM:r/m (r)| imm8         | NA       \n\nDescription:\nShifts the bits in the individual data elements (words, doublewords, or quadword)\nin the destination operand (first operand) to the right by the number of bits\nspecified in the count operand (second operand). As the bits in the data elements\nare shifted right, the empty high-order bits are cleared (set to 0). If the\nvalue specified by the count operand is greater than 15 (for words), 31 (for\ndoublewords), or 63 (for a quadword), then the destination operand is set to\nall 0s. Figure 4-15 gives an example of shifting words in a 64-bit operand.\n\nNote that only the first 64-bits of a 128-bit count operand are checked to compute\nthe count.\n\nPre-Shift\n\n| X3 PSRLW, PSRLD, and PSRLQ Instruction| X2 X2 >> COUNT| X1 X1 >> COUNT| X0 DEST Shift Right with Zero Extension\n| Operation Using 64-bit Operand        |               |               | X0 >> COUNT DEST Figure 4-15.          \nThe (V)PSRLW instruction shifts each of the words in the destination operand\nto the right by the number of bits specified in the count operand; the (V)PSRLD\ninstruction shifts each of the doublewords in the destination operand; and the\nPSRLQ instruction shifts the quadword (or quadwords) in the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions: The destination operand is an MMX technology register;\nthe count operand can be either an MMX technology register or an 64-bit memory\nlocation. 128-bit Legacy SSE version: The destination operand is an XMM register;\nthe count operand can be either an XMM register or a 128-bit memory location,\nor an 8-bit immediate. If the count operand is a memory address, 128 bits\n\nare loaded but the upper 64 bits are ignored. Bits (VLMAX-1:128) of the corresponding\nYMM destination register remain unchanged. VEX.128 encoded version: The destination\noperand is an XMM register; the count operand can be either an XMM register\nor a 128-bit memory location, or an 8-bit immediate. If the count operand is\na memory address, 128 bits are loaded but the upper 64 bits are ignored. Bits\n(VLMAX-1:128) of the destination YMM register are zeroed.\n\nVEX.256 encoded version: The destination and first source operands are YMM registers.\nThe count operand can be either an YMM register or a 128-bit memory location\nor an 8-bit immediate.\n\nNote: For shifts with an immediate count (VEX.128.66.0F 71-73 /2), VEX.vvvv\nencodes the destination register, and VEX.B + ModRM.r/m encodes the source register.\nVEX.L must be 0, otherwise instructions will #UD.\n\nOperation:\n\nPSRLW (with 64-bit operand)\n  IF (COUNT > 15)\n  THEN\n     DEST[64:0] <- 0000000000000000H\n  ELSE\n     DEST[15:0] <- ZeroExtend(DEST[15:0] >> COUNT);\n     (* Repeat shift operation for 2nd and 3rd words *)\n     DEST[63:48] <- ZeroExtend(DEST[63:48] >> COUNT);\n  FI;\nPSRLD (with 64-bit operand)\n  IF (COUNT > 31)\n  THEN\n     DEST[64:0] <- 0000000000000000H\n  ELSE\n     DEST[31:0] <- ZeroExtend(DEST[31:0] >> COUNT);\n     DEST[63:32] <- ZeroExtend(DEST[63:32] >> COUNT);\n  FI;\nPSRLQ (with 64-bit operand)\n  IF (COUNT > 63)\n  THEN\n     DEST[64:0] <- 0000000000000000H\n  ELSE\n     DEST <- ZeroExtend(DEST >> COUNT);\n  FI;\nPSRLW (with 128-bit operand)\n  COUNT <- COUNT_SOURCE[63:0];\n  IF (COUNT > 15)\n  THEN\n     DEST[128:0] <- 00000000000000000000000000000000H\n  ELSE\n     DEST[15:0]\n     (* Repeat shift operation for 2nd through 7th words *)\n     DEST[127:112] <- ZeroExtend(DEST[127:112] >> COUNT);\n  FI;\nPSRLD (with 128-bit operand)\n  COUNT <- COUNT_SOURCE[63:0];\n  IF (COUNT > 31)\n  THEN\n     DEST[128:0] <- 00000000000000000000000000000000H\n  ELSE\n     DEST[31:0]\n     (* Repeat shift operation for 2nd and 3rd doublewords *)\n     DEST[127:96] <- ZeroExtend(DEST[127:96] >> COUNT);\n  FI;\nPSRLQ (with 128-bit operand)\n  COUNT <- COUNT_SOURCE[63:0];\n  IF (COUNT > 15)\n  THEN\n     DEST[128:0] <- 00000000000000000000000000000000H\n  ELSE\n     DEST[63:0]\n     DEST[127:64] <- ZeroExtend(DEST[127:64] >> COUNT);\n  FI;\nPSRLW (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_RIGHT_SHIFT_WORDS(DEST, SRC)\nDEST[VLMAX-1:128] (Unmodified)\nPSRLW (xmm, imm8)\nDEST[127:0] <- LOGICAL_RIGHT_SHIFT_WORDS(DEST, imm8)\nDEST[VLMAX-1:128] (Unmodified)\nVPSRLW (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_RIGHT_SHIFT_WORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPSRLW (xmm, imm8)\nDEST[127:0] <- LOGICAL_RIGHT_SHIFT_WORDS(SRC1, imm8)\nDEST[VLMAX-1:128] <- 0\nPSRLD (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_RIGHT_SHIFT_DWORDS(DEST, SRC)\nDEST[VLMAX-1:128] (Unmodified)\nPSRLD (xmm, imm8)\nDEST[127:0] <- LOGICAL_RIGHT_SHIFT_DWORDS(DEST, imm8)\nDEST[VLMAX-1:128] (Unmodified)\nVPSRLD (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_RIGHT_SHIFT_DWORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPSRLD (xmm, imm8)\nDEST[127:0] <- LOGICAL_RIGHT_SHIFT_DWORDS(SRC1, imm8)\nDEST[VLMAX-1:128] <- 0\nPSRLQ (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_RIGHT_SHIFT_QWORDS(DEST, SRC)\nDEST[VLMAX-1:128] (Unmodified)\nPSRLQ (xmm, imm8)\nDEST[127:0] <- LOGICAL_RIGHT_SHIFT_QWORDS(DEST, imm8)\nDEST[VLMAX-1:128] (Unmodified)\nVPSRLQ (xmm, xmm, xmm/m128)\nDEST[127:0] <- LOGICAL_RIGHT_SHIFT_QWORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPSRLQ (xmm, imm8)\nDEST[127:0] <- LOGICAL_RIGHT_SHIFT_QWORDS(SRC1, imm8)\nDEST[VLMAX-1:128] <- 0\nVPSRLW (ymm, ymm, xmm/m128)\nDEST[255:0] <- LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1, SRC2)\nVPSRLW (ymm, imm8)\nDEST[255:0] <- LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1, imm8)\nVPSRLD (ymm, ymm, xmm/m128)\nDEST[255:0] <- LOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC1, SRC2)\nVPSRLD (ymm, imm8)\nDEST[255:0] <- LOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC1, imm8)\nVPSRLQ (ymm, ymm, xmm/m128)\nDEST[255:0] <- LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1, SRC2)\nVPSRLQ (ymm, imm8)\nDEST[255:0] <- LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1, imm8)\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PSRLW: PSRLW: (V)PSRLW: (V)PSRLW: VPSRLW:| __m64 _mm_srli_pi16(__m64 m, int __m64         | count)\n| VPSRLW:                                  | _mm_srl_pi16 (__m64 m, __m64 count)            |       \n|                                          | __m128i _mm_srli_epi16 (__m128i m, int         |       \n|                                          | count) __m128i _mm_srl_epi16 (__m128i          |       \n|                                          | m, __m128i count) __m256i _mm256_srli_epi16    |       \n|                                          | (__m256i m, int count) __m256i _mm256_srl_epi16|       \n|                                          | (__m256i m, __m128i count)                     |       \n| PSRLD: PSRLD:                            | __m64 _mm_srli_pi32 (__m64 m, int __m64        | count)\n|                                          | _mm_srl_pi32 (__m64 m, __m64 count)            |       \n| (V)PSRLD: (V)PSRLD: VPSRLD: VPSRLD:      | __m128i _mm_srli_epi32 (__m128i m, int         | count)\n|                                          | __m128i _mm_srl_epi32 (__m128i m, __m128i      |       \n|                                          | count) __m256i _mm256_srli_epi32 (__m256i      |       \n|                                          | m, int count) __m256i _mm256_srl_epi32         |       \n|                                          | (__m256i m, __m128i count)                     |       \n| PSRLQ: PSRLQ:                            | __m64 _mm_srli_si64 (__m64 m, int __m64        | count)\n|                                          | _mm_srl_si64 (__m64 m, __m64 count)            |       \n| (V)PSRLQ: (V)PSRLQ: VPSRLQ: VPSRLQ:      | __m128i _mm_srli_epi64 (__m128i m, int         | count)\n|                                          | __m128i _mm_srl_epi64 (__m128i m, __m128i      |       \n|                                          | count) __m256i _mm256_srli_epi64 (__m256i      |       \n|                                          | m, int count) __m256i _mm256_srl_epi64         |       \n|                                          | (__m256i m, __m128i count)                     |       \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4 and 7 for non-VEX-encoded instructions; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PSRLW"
    }, 
    {
      "description": "\nPSUBB/PSUBW/PSUBD - Subtract Packed Integers:\n| Opcode/Instruction                      | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                               \n| 0F F8 /r1 PSUBB mm, mm/m64              | RM   | V/V                   | MMX               | Subtract packed byte integers in mm/m64   \n|                                         |      |                       |                   | from packed byte integers in mm.          \n| 66 0F F8 /r PSUBB xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Subtract packed byte integers in xmm2/m128\n|                                         |      |                       |                   | from packed byte integers in xmm1.        \n| 0F F9 /r1 PSUBW mm, mm/m64              | RM   | V/V                   | MMX               | Subtract packed word integers in mm/m64   \n|                                         |      |                       |                   | from packed word integers in mm.          \n| 66 0F F9 /r PSUBW xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Subtract packed word integers in xmm2/m128\n|                                         |      |                       |                   | from packed word integers in xmm1.        \n| 0F FA /r1 PSUBD mm, mm/m64              | RM   | V/V                   | MMX               | Subtract packed doubleword integers       \n|                                         |      |                       |                   | in mm/m64 from packed doubleword integers \n|                                         |      |                       |                   | in mm.                                    \n| 66 0F FA /r PSUBD xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Subtract packed doubleword integers       \n|                                         |      |                       |                   | in xmm2/mem128 from packed doubleword     \n|                                         |      |                       |                   | integers in xmm1.                         \n| VEX.NDS.128.66.0F.WIG F8 /r VPSUBB xmm1,| RVM  | V/V                   | AVX               | Subtract packed byte integers in xmm3/m128\n| xmm2, xmm3/m128                         |      |                       |                   | from xmm2.                                \n| VEX.NDS.128.66.0F.WIG F9 /r VPSUBW xmm1,| RVM  | V/V                   | AVX               | Subtract packed word integers in xmm3/m128\n| xmm2, xmm3/m128                         |      |                       |                   | from xmm2.                                \n| VEX.NDS.128.66.0F.WIG FA /r VPSUBD xmm1,| RVM  | V/V                   | AVX               | Subtract packed doubleword integers       \n| xmm2, xmm3/m128                         |      |                       |                   | in xmm3/m128 from xmm2.                   \n| VEX.NDS.256.66.0F.WIG F8 /r VPSUBB ymm1,| RVM  | V/V                   | AVX2              | Subtract packed byte integers in ymm3/m256\n| ymm2, ymm3/m256                         |      |                       |                   | from ymm2.                                \n| VEX.NDS.256.66.0F.WIG F9 /r VPSUBW ymm1,| RVM  | V/V                   | AVX2              | Subtract packed word integers in ymm3/m256\n| ymm2, ymm3/m256                         |      |                       |                   | from ymm2.                                \n| VEX.NDS.256.66.0F.WIG FA /r VPSUBD ymm1,| RVM  | V/V                   | AVX2              | Subtract packed doubleword integers       \n| ymm2, ymm3/m256                         |      |                       |                   | in ymm3/m256 from ymm2.                   \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD subtract of the packed integers of the source operand (second\noperand) from the packed integers of the destination operand (first operand),\nand stores the packed integer results in the destination operand. See Figure\n9-4 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1, for an illustration of a SIMD operation. Overflow is handled with wraparound,\nas described in the following paragraphs.\n\nThe (V)PSUBB instruction subtracts packed byte integers. When an individual\nresult is too large or too small to be represented in a byte, the result is\nwrapped around and the low 8 bits are written to the destination element.\n\nThe (V)PSUBW instruction subtracts packed word integers. When an individual\nresult is too large or too small to be represented in a word, the result is\nwrapped around and the low 16 bits are written to the destination element.\n\nThe (V)PSUBD instruction subtracts packed doubleword integers. When an individual\nresult is too large or too small to be represented in a doubleword, the result\nis wrapped around and the low 32 bits are written to the destination element.\n\nNote that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either\nunsigned or signed (two's complement notation) packed integers; however, it\ndoes not set bits in the EFLAGS register to indicate overflow and/or a carry.\nTo prevent undetected overflow conditions, software must control the ranges\nof values upon which it operates.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE version: When operating on 64-bit operands, the destination operand\nmust be an MMX technology register and the source operand can be either an MMX\ntechnology register or a 64-bit memory location. 128-bit Legacy SSE version:\nThe second source operand is an XMM register or a 128-bit memory location. The\nfirst source operand and destination operands are XMM registers. Bits (VLMAX-1:128)\nof the corresponding YMM destination register remain unchanged. VEX.128 encoded\nversion: The second source operand is an XMM register or a 128-bit memory location.\nThe first source operand and destination operands are XMM registers. Bits (VLMAX-1:128)\nof the destination YMM register are zeroed. VEX.256 encoded version: The second\nsource operand is an YMM register or a 256-bit memory location. The first source\noperand and destination operands are YMM registers.\n\nNote: VEX.L must be 0, otherwise instructions will #UD.\n\nOperation:\n\nPSUBB (with 64-bit operands)\n  DEST[7:0] <- DEST[7:0] \u2212 SRC[7:0];\n  (* Repeat subtract operation for 2nd through 7th byte *)\n  DEST[63:56] <- DEST[63:56] \u2212 SRC[63:56];\nPSUBB (with 128-bit operands)\n  DEST[7:0] <- DEST[7:0] \u2212 SRC[7:0];\n  (* Repeat subtract operation for 2nd through 14th byte *)\n  DEST[127:120] <- DEST[111:120] \u2212 SRC[127:120];\nVPSUBB (VEX.128 encoded version)\nDEST[7:0] <- SRC1[7:0]-SRC2[7:0]\nDEST[15:8] <- SRC1[15:8]-SRC2[15:8]\nDEST[23:16] <- SRC1[23:16]-SRC2[23:16]\nDEST[31:24] <- SRC1[31:24]-SRC2[31:24]\nDEST[39:32] <- SRC1[39:32]-SRC2[39:32]\nDEST[47:40] <- SRC1[47:40]-SRC2[47:40]\nDEST[55:48] <- SRC1[55:48]-SRC2[55:48]\nDEST[63:56] <- SRC1[63:56]-SRC2[63:56]\nDEST[71:64] <- SRC1[71:64]-SRC2[71:64]\nDEST[79:72] <- SRC1[79:72]-SRC2[79:72]\nDEST[87:80] <- SRC1[87:80]-SRC2[87:80]\nDEST[95:88] <- SRC1[95:88]-SRC2[95:88]\nDEST[103:96] <- SRC1[103:96]-SRC2[103:96]\nDEST[111:104] <- SRC1[111:104]-SRC2[111:104]\nDEST[119:112] <- SRC1[119:112]-SRC2[119:112]\nDEST[127:120] <- SRC1[127:120]-SRC2[127:120]\nDEST[VLMAX-1:128] <- 00\nVPSUBB (VEX.256 encoded version)\nDEST[7:0] <- SRC1[7:0]-SRC2[7:0]\nDEST[15:8] <- SRC1[15:8]-SRC2[15:8]\nDEST[23:16] <- SRC1[23:16]-SRC2[23:16]\nDEST[31:24] <- SRC1[31:24]-SRC2[31:24]\nDEST[39:32] <- SRC1[39:32]-SRC2[39:32]\nDEST[47:40] <- SRC1[47:40]-SRC2[47:40]\nDEST[55:48] <- SRC1[55:48]-SRC2[55:48]\nDEST[63:56] <- SRC1[63:56]-SRC2[63:56]\nDEST[71:64] <- SRC1[71:64]-SRC2[71:64]\nDEST[79:72] <- SRC1[79:72]-SRC2[79:72]\nDEST[87:80] <- SRC1[87:80]-SRC2[87:80]\nDEST[95:88] <- SRC1[95:88]-SRC2[95:88]\nDEST[103:96] <- SRC1[103:96]-SRC2[103:96]\nDEST[111:104] <- SRC1[111:104]-SRC2[111:104]\nDEST[119:112] <- SRC1[119:112]-SRC2[119:112]\nDEST[127:120] <- SRC1[127:120]-SRC2[127:120]\nDEST[135:128] <- SRC1[135:128]-SRC2[135:128]\nDEST[143:136] <- SRC1[143:136]-SRC2[143:136]\nDEST[151:144] <- SRC1[151:144]-SRC2[151:144]\nDEST[159:152] <- SRC1[159:152]-SRC2[159:152]\nDEST[167:160] <- SRC1[167:160]-SRC2[167:160]\nDEST[175:168] <- SRC1[175:168]-SRC2[175:168]\nDEST[183:176] <- SRC1[183:176]-SRC2[183:176]\nDEST[191:184] <- SRC1[191:184]-SRC2[191:184]\nDEST[199:192] <- SRC1[199:192]-SRC2[199:192]\nDEST[207:200] <- SRC1[207:200]-SRC2[207:200]\nDEST[215:208] <- SRC1[215:208]-SRC2[215:208]\nDEST[223:216] <- SRC1[223:216]-SRC2[223:216]\nDEST[231:224] <- SRC1[231:224]-SRC2[231:224]\nDEST[239:232] <- SRC1[239:232]-SRC2[239:232]\nDEST[247:240] <- SRC1[247:240]-SRC2[247:240]\nDEST[255:248] <- SRC1[255:248]-SRC2[255:248]\nPSUBW (with 64-bit operands)\n  DEST[15:0] <- DEST[15:0] \u2212 SRC[15:0];\n  (* Repeat subtract operation for 2nd and 3rd word *)\n  DEST[63:48] <- DEST[63:48] \u2212 SRC[63:48];\nPSUBW (with 128-bit operands)\n  DEST[15:0]\n  (* Repeat subtract operation for 2nd through 7th word *)\n  DEST[127:112] <- DEST[127:112] \u2212 SRC[127:112];\nVPSUBW (VEX.128 encoded version)\nDEST[15:0] <- SRC1[15:0]-SRC2[15:0]\nDEST[31:16] <- SRC1[31:16]-SRC2[31:16]\nDEST[47:32] <- SRC1[47:32]-SRC2[47:32]\nDEST[63:48] <- SRC1[63:48]-SRC2[63:48]\nDEST[79:64] <- SRC1[79:64]-SRC2[79:64]\nDEST[95:80] <- SRC1[95:80]-SRC2[95:80]\nDEST[111:96] <- SRC1[111:96]-SRC2[111:96]\nDEST[127:112] <- SRC1[127:112]-SRC2[127:112]\nDEST[VLMAX-1:128] <- 0\nVPSUBW (VEX.256 encoded version)\nDEST[15:0] <- SRC1[15:0]-SRC2[15:0]\nDEST[31:16] <- SRC1[31:16]-SRC2[31:16]\nDEST[47:32] <- SRC1[47:32]-SRC2[47:32]\nDEST[63:48] <- SRC1[63:48]-SRC2[63:48]\nDEST[79:64] <- SRC1[79:64]-SRC2[79:64]\nDEST[95:80] <- SRC1[95:80]-SRC2[95:80]\nDEST[111:96] <- SRC1[111:96]-SRC2[111:96]\nDEST[127:112] <- SRC1[127:112]-SRC2[127:112]\nDEST[143:128] <- SRC1[143:128]-SRC2[143:128]\nDEST[159:144] <- SRC1[159:144]-SRC2[159:144]\nDEST[175:160] <- SRC1[175:160]-SRC2[175:160]\nDEST[191:176] <- SRC1[191:176]-SRC2[191:176]\nDEST[207:192] <- SRC1207:192]-SRC2[207:192]\nDEST[223:208] <- SRC1[223:208]-SRC2[223:208]\nDEST[239:224] <- SRC1[239:224]-SRC2[239:224]\nDEST[255:240] <- SRC1[255:240]-SRC2[255:240]\nPSUBD (with 64-bit operands)\n  DEST[31:0] <- DEST[31:0] \u2212 SRC[31:0];\n  DEST[63:32] <- DEST[63:32] \u2212 SRC[63:32];\nPSUBD (with 128-bit operands)\n  DEST[31:0]\n  (* Repeat subtract operation for 2nd and 3rd doubleword *)\n  DEST[127:96] <- DEST[127:96] \u2212 SRC[127:96];\nVPSUBD (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0]-SRC2[31:0]\nDEST[63:32] <- SRC1[63:32]-SRC2[63:32]\nDEST[95:64] <- SRC1[95:64]-SRC2[95:64]\nDEST[127:96] <- SRC1[127:96]-SRC2[127:96]\nDEST[VLMAX-1:128] <- 0\nVPSUBD (VEX.256 encoded version)\nDEST[31:0] <- SRC1[31:0]-SRC2[31:0]\nDEST[63:32] <- SRC1[63:32]-SRC2[63:32]\nDEST[95:64] <- SRC1[95:64]-SRC2[95:64]\nDEST[127:96] <- SRC1[127:96]-SRC2[127:96]\nDEST[159:128] <- SRC1[159:128]-SRC2[159:128]\nDEST[191:160] <- SRC1[191:160]-SRC2[191:160]\nDEST[223:192] <- SRC1[223:192]-SRC2[223:192]\nDEST[255:224] <- SRC1[255:224]-SRC2[255:224]\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PSUBB:   | __m64 _mm_sub_pi8(__m64 m1, __m64 m2)     \n| (V)PSUBB:| __m128i _mm_sub_epi8 ( __m128i a, __m128i \n|          | b)                                        \n| VPSUBB:  | __m256i _mm256_sub_epi8 ( __m256i a,      \n|          | __m256i b)                                \n| PSUBW:   | __m64 _mm_sub_pi16(__m64 m1, __m64 m2)    \n| (V)PSUBW:| __m128i _mm_sub_epi16 ( __m128i a, __m128i\n|          | b)                                        \n| VPSUBW:  | __m256i _mm256_sub_epi16 ( __m256i a,     \n|          | __m256i b)                                \n| PSUBD:   | __m64 _mm_sub_pi32(__m64 m1, __m64 m2)    \n| (V)PSUBD:| __m128i _mm_sub_epi32 ( __m128i a, __m128i\n|          | b)                                        \n| VPSUBD:  | __m256i _mm256_sub_epi32 ( __m256i a,     \n|          | __m256i b)                                \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PSUBB"
    }, 
    {
      "description": "-R:PSUBB", 
      "mnem": "PSUBD"
    }, 
    {
      "description": "\nPSUBQ - Subtract Packed Quadword Integers:\n| Opcode/Instruction                      | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                          \n| 0F FB /r1 PSUBQ mm1, mm2/m64            | RM   | V/V                   | SSE2              | Subtract quadword integer in mm1 from\n|                                         |      |                       |                   | mm2 /m64.                            \n| 66 0F FB /r PSUBQ xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Subtract packed quadword integers in \n|                                         |      |                       |                   | xmm1 from xmm2 /m128.                \n| VEX.NDS.128.66.0F.WIG FB/r VPSUBQ xmm1, | RVM  | V/V                   | AVX               | Subtract packed quadword integers in \n| xmm2, xmm3/m128                         |      |                       |                   | xmm3/m128 from xmm2.                 \n| VEX.NDS.256.66.0F.WIG FB /r VPSUBQ ymm1,| RVM  | V/V                   | AVX2              | Subtract packed quadword integers in \n| ymm2, ymm3/m256                         |      |                       |                   | ymm3/m256 from ymm2.                 \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nSubtracts the second operand (source operand) from the first operand (destination\noperand) and stores the result in the destination operand. When packed quadword\noperands are used, a SIMD subtract is performed. When a quadword result is too\nlarge to be represented in 64 bits (overflow), the result is wrapped around\nand the low 64 bits are written to the destination element (that is, the carry\nis ignored).\n\nNote that the (V)PSUBQ instruction can operate on either unsigned or signed\n(two's complement notation) integers; however, it does not set bits in the EFLAGS\nregister to indicate overflow and/or a carry. To prevent undetected overflow\nconditions, software must control the ranges of the values upon which it operates.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE version: The source operand can be a quadword integer stored in an\nMMX technology register or a 64bit memory location. 128-bit Legacy SSE version:\nThe second source operand is an XMM register or a 128-bit memory location. The\nfirst source operand and destination operands are XMM registers. Bits (VLMAX-1:128)\nof the corresponding YMM destination register remain unchanged. VEX.128 encoded\nversion: The second source operand is an XMM register or a 128-bit memory location.\nThe first source operand and destination operands are XMM registers. Bits (VLMAX-1:128)\nof the destination YMM register are zeroed. VEX.256 encoded version: The second\nsource operand is an YMM register or a 256-bit memory location. The first source\noperand and destination operands are YMM registers.\n\nNote: VEX.L must be 0, otherwise instructions will #UD.\n\nOperation:\n\nPSUBQ (with 64-Bit operands)\n  DEST[63:0] <- DEST[63:0] \u2212 SRC[63:0];\nPSUBQ (with 128-Bit operands)\n  DEST[63:0] <- DEST[63:0] \u2212 SRC[63:0];\n  DEST[127:64] <- DEST[127:64] \u2212 SRC[127:64];\nVPSUBQ (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0]-SRC2[63:0]\nDEST[127:64] <- SRC1[127:64]-SRC2[127:64]\nDEST[VLMAX-1:128] <- 0\nVPSUBQ (VEX.256 encoded version)\nDEST[63:0] <- SRC1[63:0]-SRC2[63:0]\nDEST[127:64] <- SRC1[127:64]-SRC2[127:64]\nDEST[191:128] <- SRC1[191:128]-SRC2[191:128]\nDEST[255:192] <- SRC1[255:192]-SRC2[255:192]\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PSUBQ:   | __m64 _mm_sub_si64(__m64 m1, __m64 m2)   \n| (V)PSUBQ:| __m128i _mm_sub_epi64(__m128i m1, __m128i\n|          | m2)                                      \n| VPSUBQ:  | __m256i _mm256_sub_epi64(__m256i m1,     \n|          | __m256i m2)                              \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PSUBQ"
    }, 
    {
      "description": "\nPSUBSB/PSUBSW - Subtract Packed Signed Integers with Signed Saturation:\n| Opcode/Instruction                 | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| 0F E8 /r1 PSUBSB mm, mm/m64        | RM   | V/V                   | MMX               | Subtract signed packed bytes in mm/m64     \n|                                    |      |                       |                   | from signed packed bytes in mm and saturate\n|                                    |      |                       |                   | results.                                   \n| 66 0F E8 /r PSUBSB xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Subtract packed signed byte integers       \n|                                    |      |                       |                   | in xmm2/m128 from packed signed byte       \n|                                    |      |                       |                   | integers in xmm1 and saturate results.     \n| 0F E9 /r1 PSUBSW mm, mm/m64        | RM   | V/V                   | MMX               | Subtract signed packed words in mm/m64     \n|                                    |      |                       |                   | from signed packed words in mm and saturate\n|                                    |      |                       |                   | results.                                   \n| 66 0F E9 /r PSUBSW xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Subtract packed signed word integers       \n|                                    |      |                       |                   | in xmm2/m128 from packed signed word       \n|                                    |      |                       |                   | integers in xmm1 and saturate results.     \n| VEX.NDS.128.66.0F.WIG E8 /r VPSUBSB| RVM  | V/V                   | AVX               | Subtract packed signed byte integers       \n| xmm1, xmm2, xmm3/m128              |      |                       |                   | in xmm3/m128 from packed signed byte       \n|                                    |      |                       |                   | integers in xmm2 and saturate results.     \n| VEX.NDS.128.66.0F.WIG E9 /r VPSUBSW| RVM  | V/V                   | AVX               | Subtract packed signed word integers       \n| xmm1, xmm2, xmm3/m128              |      |                       |                   | in xmm3/m128 from packed signed word       \n|                                    |      |                       |                   | integers in xmm2 and saturate results.     \n| VEX.NDS.256.66.0F.WIG E8 /r VPSUBSB| RVM  | V/V                   | AVX2              | Subtract packed signed byte integers       \n| ymm1, ymm2, ymm3/m256              |      |                       |                   | in ymm3/m256 from packed signed byte       \n|                                    |      |                       |                   | integers in ymm2 and saturate results.     \n| VEX.NDS.256.66.0F.WIG E9 /r VPSUBSW| RVM  | V/V                   | AVX2              | Subtract packed signed word integers       \n| ymm1, ymm2, ymm3/m256              |      |                       |                   | in ymm3/m256 from packed signed word       \n|                                    |      |                       |                   | integers in ymm2 and saturate results.     \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD subtract of the packed signed integers of the source operand\n(second operand) from the packed signed integers of the destination operand\n(first operand), and stores the packed integer results in the destination operand.\nSee Figure 9-4 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 1, for an illustration of a SIMD operation. Overflow is handled\nwith signed saturation, as described in the following paragraphs.\n\nThe (V)PSUBSB instruction subtracts packed signed byte integers. When an individual\nbyte result is beyond the range of a signed byte integer (that is, greater than\n7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written\nto the destination operand.\n\nThe (V)PSUBSW instruction subtracts packed signed word integers. When an individual\nword result is beyond the range of a signed word integer (that is, greater than\n7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively,\nis written to the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE version: When operating on 64-bit operands, the destination operand\nmust be an MMX technology register and the source operand can be either an MMX\ntechnology register or a 64-bit memory location. 128-bit Legacy SSE version:\nThe second source operand is an XMM register or a 128-bit memory location. The\nfirst source operand and destination operands are XMM registers. Bits (VLMAX-1:128)\nof the corresponding YMM destination register remain unchanged. VEX.128 encoded\nversion: The second source operand is an XMM register or a 128-bit memory location.\nThe first source operand and destination operands are XMM registers. Bits (VLMAX-1:128)\nof the destination YMM register are zeroed. VEX.256 encoded version: The second\nsource operand is an YMM register or a 256-bit memory location. The first source\noperand and destination operands are YMM registers.\n\nNote: VEX.L must be 0, otherwise instructions will #UD.\n\nOperation:\n\nPSUBSB (with 64-bit operands)\n  DEST[7:0] <- SaturateToSignedByte (DEST[7:0] \u2212 SRC (7:0]);\n  (* Repeat subtract operation for 2nd through 7th bytes *)\n  DEST[63:56] <- SaturateToSignedByte (DEST[63:56] \u2212 SRC[63:56] );\nPSUBSB (with 128-bit operands)\n  DEST[7:0] <- SaturateToSignedByte (DEST[7:0] \u2212 SRC[7:0]);\n  (* Repeat subtract operation for 2nd through 14th bytes *)\n  DEST[127:120] <- SaturateToSignedByte (DEST[127:120] \u2212 SRC[127:120]);\nVPSUBSB (VEX.128 encoded version)\nDEST[7:0] <- SaturateToSignedByte (SRC1[7:0] - SRC2[7:0]);\n(* Repeat subtract operation for 2nd through 14th bytes *)\nDEST[127:120] <- SaturateToSignedByte (SRC1[127:120] - SRC2[127:120]);\nDEST[VLMAX-1:128] <- 0\nVPSUBSB (VEX.256 encoded version)\nDEST[7:0] <- SaturateToSignedByte (SRC1[7:0] - SRC2[7:0]);\n(* Repeat subtract operation for 2nd through 31th bytes *)\nDEST[255:248] <- SaturateToSignedByte (SRC1[255:248] - SRC2[255:248]);\nPSUBSW (with 64-bit operands)\n  DEST[15:0] <- SaturateToSignedWord (DEST[15:0] \u2212 SRC[15:0] );\n  (* Repeat subtract operation for 2nd and 7th words *)\n  DEST[63:48] <- SaturateToSignedWord (DEST[63:48] \u2212 SRC[63:48] );\nPSUBSW (with 128-bit operands)\n  DEST[15:0]\n  (* Repeat subtract operation for 2nd through 7th words *)\n  DEST[127:112] <- SaturateToSignedWord (DEST[127:112] \u2212 SRC[127:112]);\nVPSUBSW (VEX.128 encoded version)\nDEST[15:0] <- SaturateToSignedWord (SRC1[15:0] - SRC2[15:0]);\n(* Repeat subtract operation for 2nd through 7th words *)\nDEST[127:112] <- SaturateToSignedWord (SRC1[127:112] - SRC2[127:112]);\nDEST[VLMAX-1:128] <- 0\nVPSUBSW (VEX.256 encoded version)\nDEST[15:0] <- SaturateToSignedWord (SRC1[15:0] - SRC2[15:0]);\n(* Repeat subtract operation for 2nd through 15th words *)\nDEST[255:240] <- SaturateToSignedWord (SRC1[255:240] - SRC2[255:240]);\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PSUBSB:   | __m64 _mm_subs_pi8(__m64 m1, __m64 m2)    \n| (V)PSUBSB:| __m128i _mm_subs_epi8(__m128i m1, __m128i \n|           | m2)                                       \n| VPSUBSB:  | __m256i _mm256_subs_epi8(__m256i m1,      \n|           | __m256i m2)                               \n| PSUBSW:   | __m64 _mm_subs_pi16(__m64 m1, __m64       \n|           | m2)                                       \n| (V)PSUBSW:| __m128i _mm_subs_epi16(__m128i m1, __m128i\n|           | m2)                                       \n| VPSUBSW:  | __m256i _mm256_subs_epi16(__m256i m1,     \n|           | __m256i m2)                               \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PSUBSB"
    }, 
    {
      "description": "-R:PSUBSB", 
      "mnem": "PSUBSW"
    }, 
    {
      "description": "\nPSUBUSB/PSUBUSW - Subtract Packed Unsigned Integers with Unsigned Saturation:\n| Opcode/Instruction                  | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| 0F D8 /r1 PSUBUSB mm, mm/m64        | RM   | V/V                   | MMX               | Subtract unsigned packed bytes in mm/m64\n|                                     |      |                       |                   | from unsigned packed bytes in mm and    \n|                                     |      |                       |                   | saturate result.                        \n| 66 0F D8 /r PSUBUSB xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Subtract packed unsigned byte integers  \n|                                     |      |                       |                   | in xmm2/m128 from packed unsigned byte  \n|                                     |      |                       |                   | integers in xmm1 and saturate result.   \n| 0F D9 /r1 PSUBUSW mm, mm/m64        | RM   | V/V                   | MMX               | Subtract unsigned packed words in mm/m64\n|                                     |      |                       |                   | from unsigned packed words in mm and    \n|                                     |      |                       |                   | saturate result.                        \n| 66 0F D9 /r PSUBUSW xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Subtract packed unsigned word integers  \n|                                     |      |                       |                   | in xmm2/m128 from packed unsigned word  \n|                                     |      |                       |                   | integers in xmm1 and saturate result.   \n| VEX.NDS.128.66.0F.WIG D8 /r VPSUBUSB| RVM  | V/V                   | AVX               | Subtract packed unsigned byte integers  \n| xmm1, xmm2, xmm3/m128               |      |                       |                   | in xmm3/m128 from packed unsigned byte  \n|                                     |      |                       |                   | integers in xmm2 and saturate result.   \n| VEX.NDS.128.66.0F.WIG D9 /r VPSUBUSW| RVM  | V/V                   | AVX               | Subtract packed unsigned word integers  \n| xmm1, xmm2, xmm3/m128               |      |                       |                   | in xmm3/m128 from packed unsigned word  \n|                                     |      |                       |                   | integers in xmm2 and saturate result.   \n| VEX.NDS.256.66.0F.WIG D8 /r VPSUBUSB| RVM  | V/V                   | AVX2              | Subtract packed unsigned byte integers  \n| ymm1, ymm2, ymm3/m256               |      |                       |                   | in ymm3/m256 from packed unsigned byte  \n|                                     |      |                       |                   | integers in ymm2 and saturate result.   \n| VEX.NDS.256.66.0F.WIG D9 /r VPSUBUSW| RVM  | V/V                   | AVX2              | Subtract packed unsigned word integers  \n| ymm1, ymm2, ymm3/m256               |      |                       |                   | in ymm3/m256 from packed unsigned word  \n|                                     |      |                       |                   | integers in ymm2 and saturate result.   \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD subtract of the packed unsigned integers of the source operand\n(second operand) from the packed unsigned integers of the destination operand\n(first operand), and stores the packed unsigned integer results in the destination\noperand. See Figure 9-4 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 1, for an illustration of a SIMD operation. Overflow is handled\nwith unsigned saturation, as described in the following paragraphs.\n\nThese instructions can operate on either 64-bit or 128-bit operands.\n\nThe (V)PSUBUSB instruction subtracts packed unsigned byte integers. When an\nindividual byte result is less than zero, the saturated value of 00H is written\nto the destination operand.\n\nThe (V)PSUBUSW instruction subtracts packed unsigned word integers. When an\nindividual word result is less than zero, the saturated value of 0000H is written\nto the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE version: When operating on 64-bit operands, the destination operand\nmust be an MMX technology register and the source operand can be either an MMX\ntechnology register or a 64-bit memory location. 128-bit Legacy SSE version:\nThe second source operand is an XMM register or a 128-bit memory location. The\nfirst source operand and destination operands are XMM registers. Bits (VLMAX-1:128)\nof the corresponding YMM destination register remain unchanged. VEX.128 encoded\nversion: The second source operand is an XMM register or a 128-bit memory location.\nThe first source operand and destination operands are XMM registers. Bits (VLMAX-1:128)\nof the destination YMM register are zeroed. VEX.256 encoded version: The second\nsource operand is an YMM register or a 256-bit memory location. The first source\noperand and destination operands are YMM registers.\n\nNote: VEX.L must be 0, otherwise instructions will #UD.\n\nOperation:\n\nPSUBUSB (with 64-bit operands)\n  DEST[7:0] <- SaturateToUnsignedByte (DEST[7:0] \u2212 SRC (7:0] );\n  (* Repeat add operation for 2nd through 7th bytes *)\n  DEST[63:56] <- SaturateToUnsignedByte (DEST[63:56] \u2212 SRC[63:56];\nPSUBUSB (with 128-bit operands)\n  DEST[7:0] <- SaturateToUnsignedByte (DEST[7:0] \u2212 SRC[7:0]);\n  (* Repeat add operation for 2nd through 14th bytes *)\n  DEST[127:120] <- SaturateToUnSignedByte (DEST[127:120] \u2212 SRC[127:120]);\nVPSUBUSB (VEX.128 encoded version)\nDEST[7:0] <- SaturateToUnsignedByte (SRC1[7:0] - SRC2[7:0]);\n(* Repeat subtract operation for 2nd through 14th bytes *)\nDEST[127:120] <- SaturateToUnsignedByte (SRC1[127:120] - SRC2[127:120]);\nDEST[VLMAX-1:128] <- 0\nVPSUBUSB (VEX.256 encoded version)\nDEST[7:0] <- SaturateToUnsignedByte (SRC1[7:0] - SRC2[7:0]);\n(* Repeat subtract operation for 2nd through 31st bytes *)\nDEST[255:148] <- SaturateToUnsignedByte (SRC1[255:248] - SRC2[255:248]);\nPSUBUSW (with 64-bit operands)\n  DEST[15:0] <- SaturateToUnsignedWord (DEST[15:0] \u2212 SRC[15:0] );\n  (* Repeat add operation for 2nd and 3rd words *)\n  DEST[63:48] <- SaturateToUnsignedWord (DEST[63:48] \u2212 SRC[63:48] );\nPSUBUSW (with 128-bit operands)\n  DEST[15:0]\n  (* Repeat add operation for 2nd through 7th words *)\n  DEST[127:112] <- SaturateToUnSignedWord (DEST[127:112] \u2212 SRC[127:112]);\nVPSUBUSW (VEX.128 encoded version)\nDEST[15:0] <- SaturateToUnsignedWord (SRC1[15:0] - SRC2[15:0]);\n(* Repeat subtract operation for 2nd through 7th words *)\nDEST[127:112] <- SaturateToUnsignedWord (SRC1[127:112] - SRC2[127:112]);\nDEST[VLMAX-1:128] <- 0\nVPSUBUSW (VEX.256 encoded version)\nDEST[15:0] <- SaturateToUnsignedWord (SRC1[15:0] - SRC2[15:0]);\n(* Repeat subtract operation for 2nd through 15th words *)\nDEST[255:240] <- SaturateToUnsignedWord (SRC1[255:240] - SRC2[255:240]);\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PSUBUSB:                                           | __m64 _mm_subs_pu8(__m64 m1, __m64 m2)   \n| (V)PSUBUSB:                                        | __m128i _mm_subs_epu8(__m128i m1, __m128i\n|                                                    | m2)                                      \n| VPSUBUSB:                                          | __m256i _mm256_subs_epu8(__m256i m1,     \n|                                                    | __m256i m2)                              \n| PSUBUSW: (V)PSUBUSW: __m128i _mm_subs_epu16(__m128i| __m64 _mm_subs_pu16(__m64 m1, __m64      \n| m1, __m128i m2)                                    | m2)                                      \n| VPSUBUSW:                                          | __m256i _mm256_subs_epu16(__m256i m1,    \n|                                                    | __m256i m2)                              \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PSUBUSB"
    }, 
    {
      "description": "-R:PSUBUSB", 
      "mnem": "PSUBUSW"
    }, 
    {
      "description": "-R:PSUBB", 
      "mnem": "PSUBW"
    }, 
    {
      "description": "\nPTEST- Logical Compare:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                           \n| 66 0F 38 17 /r PTEST xmm1, xmm2/m128  | RM   | V/V                   | SSE4_1            | Set ZF if xmm2/m128 AND xmm1 result   \n|                                       |      |                       |                   | is all 0s. Set CF if xmm2/m128 AND NOT\n|                                       |      |                       |                   | xmm1 result is all 0s.                \n| VEX.128.66.0F38.WIG 17 /r VPTEST xmm1,| RM   | V/V                   | AVX               | Set ZF and CF depending on bitwise AND\n| xmm2/m128                             |      |                       |                   | and ANDN of sources.                  \n| VEX.256.66.0F38.WIG 17 /r VPTEST ymm1,| RM   | V/V                   | AVX               | Set ZF and CF depending on bitwise AND\n| ymm2/m256                             |      |                       |                   | and ANDN of sources.                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nPTEST and VPTEST set the ZF flag if all bits in the result are 0 of the bitwise\nAND of the first source operand (first operand) and the second source operand\n(second operand). VPTEST sets the CF flag if all bits in the result are 0 of\nthe bitwise AND of the second source operand (second operand) and the logical\nNOT of the destination operand. The first source register is specified by the\nModR/M reg field. 128-bit versions: The first source register is an XMM register.\nThe second source register can be an XMM register or a 128-bit memory location.\nThe destination register is not modified. VEX.256 encoded version: The first\nsource register is a YMM register. The second source register can be a YMM register\nor a 256-bit memory location. The destination register is not modified. Note:\nIn VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions\nwill #UD.\n\nOperation:\n\n(V)PTEST (128-bit version)\nIF (SRC[127:0] BITWISE AND DEST[127:0] = 0)\n  THEN ZF <- 1;\n  ELSE ZF <- 0;\nIF (SRC[127:0] BITWISE AND NOT DEST[127:0] = 0)\n  THEN CF <- 1;\n  ELSE CF <- 0;\nDEST (unmodified)\nAF <- OF <- PF <- SF <- 0;\nVPTEST (VEX.256 encoded version)\nIF (SRC[255:0] BITWISE AND DEST[255:0] = 0) THEN ZF <- 1;\n  ELSE ZF <- 0;\nIF (SRC[255:0] BITWISE AND NOT DEST[255:0] = 0) THEN CF <- 1;\n  ELSE CF <- 0;\nDEST (unmodified)\nAF <- OF <- PF <- SF <- 0;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nPTEST\n\nint _mm_testz_si128 (__m128i s1, __m128i s2);\n\nint _mm_testc_si128 (__m128i s1, __m128i s2);\n\nint _mm_testnzc_si128 (__m128i s1, __m128i s2);\n\nVPTEST\n\nint _mm256_testz_si256 (__m256i s1, __m256i s2);\n\nint _mm256_testc_si256 (__m256i s1, __m256i s2);\n\nint _mm256_testnzc_si256 (__m256i s1, __m256i s2);\n\nint _mm_testz_si128 (__m128i s1, __m128i s2);\n\nint _mm_testc_si128 (__m128i s1, __m128i s2);\n\nint _mm_testnzc_si128 (__m128i s1, __m128i s2);\n\n\nFlags Affected:\nThe 0F, AF, PF, SF flags are cleared and the ZF, CF flags are set according\nto the operation.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "PTEST"
    }, 
    {
      "description": "\nPUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ -  Unpack High Data:\n| Opcode/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                 \n| 0F 68 /r1 PUNPCKHBW mm, mm/m64         | RM   | V/V                   | MMX               | Unpack and interleave high-order bytes      \n|                                        |      |                       |                   | from mm and mm/m64 into mm.                 \n| 66 0F 68 /r PUNPCKHBW xmm1, xmm2/m128  | RM   | V/V                   | SSE2              | Unpack and interleave high-order bytes      \n|                                        |      |                       |                   | from xmm1 and xmm2/m128 into xmm1.          \n| 0F 69 /r1 PUNPCKHWD mm, mm/m64         | RM   | V/V                   | MMX               | Unpack and interleave high-order words      \n|                                        |      |                       |                   | from mm and mm/m64 into mm.                 \n| 66 0F 69 /r PUNPCKHWD xmm1, xmm2/m128  | RM   | V/V                   | SSE2              | Unpack and interleave high-order words      \n|                                        |      |                       |                   | from xmm1 and xmm2/m128 into xmm1.          \n| 0F 6A /r1 PUNPCKHDQ mm, mm/m64         | RM   | V/V                   | MMX               | Unpack and interleave high-order doublewords\n|                                        |      |                       |                   | from mm and mm/m64 into mm.                 \n| 66 0F 6A /r PUNPCKHDQ xmm1, xmm2/m128  | RM   | V/V                   | SSE2              | Unpack and interleave high-order doublewords\n|                                        |      |                       |                   | from xmm1 and xmm2/m128 into xmm1.          \n| 66 0F 6D /r PUNPCKHQDQ xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Unpack and interleave high-order quadwords  \n|                                        |      |                       |                   | from xmm1 and xmm2/m128 into xmm1.          \n| VEX.NDS.128.66.0F.WIG 68/r VPUNPCKHBW  | RVM  | V/V                   | AVX               | Interleave high-order bytes from xmm2       \n| xmm1,xmm2, xmm3/m128                   |      |                       |                   | and xmm3/m128 into xmm1.                    \n| VEX.NDS.128.66.0F.WIG 69/r VPUNPCKHWD  | RVM  | V/V                   | AVX               | Interleave high-order words from xmm2       \n| xmm1,xmm2, xmm3/m128                   |      |                       |                   | and xmm3/m128 into xmm1.                    \n| VEX.NDS.128.66.0F.WIG 6A/r VPUNPCKHDQ  | RVM  | V/V                   | AVX               | Interleave high-order doublewords from      \n| xmm1, xmm2, xmm3/m128                  |      |                       |                   | xmm2 and xmm3/m128 into xmm1.               \n| VEX.NDS.128.66.0F.WIG 6D/r VPUNPCKHQDQ | RVM  | V/V                   | AVX               | Interleave high-order quadword from         \n| xmm1, xmm2, xmm3/m128                  |      |                       |                   | xmm2 and xmm3/m128 into xmm1 register.      \n| VEX.NDS.256.66.0F.WIG 68 /r VPUNPCKHBW | RVM  | V/V                   | AVX2              | Interleave high-order bytes from ymm2       \n| ymm1, ymm2, ymm3/m256                  |      |                       |                   | and ymm3/m256 into ymm1 register.           \n| VEX.NDS.256.66.0F.WIG 69 /r VPUNPCKHWD | RVM  | V/V                   | AVX2              | Interleave high-order words from ymm2       \n| ymm1, ymm2, ymm3/m256                  |      |                       |                   | and ymm3/m256 into ymm1 register.           \n| VEX.NDS.256.66.0F.WIG 6A /r VPUNPCKHDQ | RVM  | V/V                   | AVX2              | Interleave high-order doublewords from      \n| ymm1, ymm2, ymm3/m256                  |      |                       |                   | ymm2 and ymm3/m256 into ymm1 register.      \n| VEX.NDS.256.66.0F.WIG 6D /r VPUNPCKHQDQ| RVM  | V/V                   | AVX2              | Interleave high-order quadword from         \n| ymm1, ymm2, ymm3/m256                  |      |                       |                   | ymm2 and ymm3/m256 into ymm1 register.      \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nUnpacks and interleaves the high-order data elements (bytes, words, doublewords,\nor quadwords) of the destination operand (first operand) and source operand\n(second operand) into the destination operand. Figure 4-16 shows the unpack\noperation for bytes in 64-bit operands. The low-order data elements are ignored.\n\n| SRC SRC| Y7 DEST Figure 4-16. 255 Y7| Y6 Y7 Y6 Figure 4-17.| Y5 X7 Y5| Y4 Y6 PUNPCKHBW Instruction Operation| Y3 X6 Y3| Y2 Y5 Y2 256-bit VPUNPCKHDQ Instruction| Y1 X5 Y1 DEST| Y0 X4 0 Y0 255 Y7| X7 255 X7 Y6| X6 X6 X6| X5 X5 Y3| X4 X4 X3| X3 X3 Y2| X2 X2 X2| X1 X1 0| X0 31 X0| DEST 0\n|        |                            |                      |         | Using 64-bit Operands Y4             |         | Operation                              |              |                  |             |         |         |         |         |         |        |         |       \nWhen the source data comes from a 64-bit memory operand, the full 64-bit operand\nis accessed from memory, but the instruction uses only the high-order 32 bits.\nWhen the source data comes from a 128-bit memory operand, an implementation\nmay fetch only the appropriate 64 bits; however, alignment to a 16-byte boundary\nand normal segment checking will still be enforced.\n\nThe (V)PUNPCKHBW instruction interleaves the high-order bytes of the source\nand destination operands, the (V)PUNPCKHWD instruction interleaves the high-order\nwords of the source and destination operands, the (V)PUNPCKHDQ instruction interleaves\nthe high-order doubleword (or doublewords) of the source and destination operands,\nand the (V)PUNPCKHQDQ instruction interleaves the high-order quadwords of the\nsource and destination operands.\n\nThese instructions can be used to convert bytes to words, words to doublewords,\ndoublewords to quadwords, and quadwords to double quadwords, respectively, by\nplacing all 0s in the source operand. Here, if the source operand contains all\n0s, the result (stored in the destination operand) contains zero extensions\nof the high-order data elements from the original value in the destination operand.\nFor example, with the (V)PUNPCKHBW instruction the high-order bytes are zero\nextended (that is, unpacked into unsigned word integers), and with the (V)PUNPCKHWD\ninstruction, the high-order words are zero extended (unpacked into unsigned\ndoubleword integers).\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE versions: The source operand can be an MMX technology register or\na 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE versions: The second source operand is an XMM register or\na 128-bit memory location. The first source operand and destination operands\nare XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register\nremain unchanged.\n\nVEX.128 encoded versions: The second source operand is an XMM register or a\n128-bit memory location. The first source operand and destination operands are\nXMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand is an YMM register or a 256-bit\nmemory location. The first source operand and destination operands are YMM registers.\n\nNote: VEX.L must be 0, otherwise instructions will #UD.\n\nOperation:\n\nPUNPCKHBW instruction with 64-bit operands:\n  DEST[7:0] <- DEST[39:32];\n  DEST[15:8] <- SRC[39:32];\n  DEST[23:16] <- DEST[47:40];\n  DEST[31:24] <- SRC[47:40];\n  DEST[39:32] <- DEST[55:48];\n  DEST[47:40] <- SRC[55:48];\n  DEST[55:48] <- DEST[63:56];\n  DEST[63:56] <- SRC[63:56];\nPUNPCKHW instruction with 64-bit operands:\n  DEST[15:0] <- DEST[47:32];\n  DEST[31:16] <- SRC[47:32];\n  DEST[47:32] <- DEST[63:48];\n  DEST[63:48] <- SRC[63:48];\nPUNPCKHDQ instruction with 64-bit operands:\n  DEST[31:0] <- DEST[63:32];\n  DEST[63:32] <- SRC[63:32];\nPUNPCKHBW instruction with 128-bit operands:\n  DEST[7:0]<- DEST[71:64];\n  DEST[15:8]\n  DEST[23:16] <- DEST[79:72];\n  DEST[31:24] <- SRC[79:72];\n  DEST[39:32] <- DEST[87:80];\n  DEST[47:40] <- SRC[87:80];\n  DEST[55:48] <- DEST[95:88];\n  DEST[63:56] <- SRC[95:88];\n  DEST[71:64] <- DEST[103:96];\n  DEST[79:72] <- SRC[103:96];\n  DEST[87:80] <- DEST[111:104];\n  DEST[95:88] <- SRC[111:104];\n  DEST[103:96]\n  DEST[111:104] <- SRC[119:112];\n  DEST[119:112] <- DEST[127:120];\n  DEST[127:120] <- SRC[127:120];\nPUNPCKHWD instruction with 128-bit operands:\n  DEST[15:0]\n  DEST[31:16] <- SRC[79:64];\n  DEST[47:32] <- DEST[95:80];\n  DEST[63:48] <- SRC[95:80];\n  DEST[79:64] <- DEST[111:96];\n  DEST[95:80] <- SRC[111:96];\n  DEST[111:96]\n  DEST[127:112] <- SRC[127:112];\nPUNPCKHDQ instruction with 128-bit operands:\n  DEST[31:0] <- DEST[95:64];\n  DEST[63:32]\n  DEST[95:64]\n  DEST[127:96] <- SRC[127:96];\nPUNPCKHQDQ instruction:\n  DEST[63:0] <- DEST[127:64];\n  DEST[127:64] <- SRC[127:64];\nINTERLEAVE_HIGH_BYTES_256b (SRC1, SRC2)\nDEST[7:0] <- SRC1[71:64]\nDEST[15:8] <- SRC2[71:64]\nDEST[23:16] <- SRC1[79:72]\nDEST[31:24] <- SRC2[79:72]\nDEST[39:32] <- SRC1[87:80]\nDEST[47:40] <- SRC2[87:80]\nDEST[55:48] <- SRC1[95:88]\nDEST[63:56] <-SRC2[95:88]\nDEST[71:64] <- SRC1[103:96]\nDEST[79:72] <- SRC2[103:96]\nDEST[87:80] <- SRC1[111:104]\nDEST[95:88] <- SRC2[111:104]\nDEST[103:96] <- SRC1[119:112]\nDEST[111:104] <- SRC2[119:112]\nDEST[119:112] <- SRC1[127:120]\nDEST[127:120] <- SRC2[127:120]\nDEST[135:128] <- SRC1[199:192]\nDEST[143:136] <- SRC2[199:192]\nDEST[151:144] <- SRC1[207:200]\nDEST[159:152] <- SRC2[207:200]\nDEST[167:160] <- SRC1[215:208]\nDEST[175:168] <- SRC2[215:208]\nDEST[183:176] <- SRC1[223:216]\nDEST[191:184] <-SRC2[223:216]\nDEST[199:192] <- SRC1[231:224]\nDEST[207:200] <- SRC2[231:224]\nDEST[215:208] <- SRC1[239:232]\nDEST[223:216] <- SRC2[239:232]\nDEST[231:224] <- SRC1[247:240]\nDEST[239:232] <- SRC2[247:240]\nDEST[247:240] <- SRC1[255:248]\nDEST[255:248] <- SRC2[255:248]\nINTERLEAVE_HIGH_BYTES (SRC1, SRC2)\nDEST[7:0] <- SRC1[71:64]\nDEST[15:8] <- SRC2[71:64]\nDEST[23:16] <- SRC1[79:72]\nDEST[31:24] <- SRC2[79:72]\nDEST[39:32] <- SRC1[87:80]\nDEST[47:40] <- SRC2[87:80]\nDEST[55:48] <- SRC1[95:88]\nDEST[63:56] <-SRC2[95:88]\nDEST[71:64] <- SRC1[103:96]\nDEST[79:72] <- SRC2[103:96]\nDEST[87:80] <- SRC1[111:104]\nDEST[95:88] <- SRC2[111:104]\nDEST[103:96] <- SRC1[119:112]\nDEST[111:104] <- SRC2[119:112]\nDEST[119:112] <- SRC1[127:120]\nDEST[127:120] <- SRC2[127:120]\nINTERLEAVE_HIGH_WORDS_256b(SRC1, SRC2)\nDEST[15:0] <- SRC1[79:64]\nDEST[31:16] <- SRC2[79:64]\nDEST[47:32] <- SRC1[95:80]\nDEST[63:48] <- SRC2[95:80]\nDEST[79:64] <- SRC1[111:96]\nDEST[95:80] <- SRC2[111:96]\nDEST[111:96] <- SRC1[127:112]\nDEST[127:112] <- SRC2[127:112]\nDEST[143:128] <- SRC1[207:192]\nDEST[159:144] <- SRC2[207:192]\nDEST[175:160] <- SRC1[223:208]\nDEST[191:176] <- SRC2[223:208]\nDEST[207:192] <- SRC1[239:224]\nDEST[223:208] <- SRC2[239:224]\nDEST[239:224] <- SRC1[255:240]\nDEST[255:240] <- SRC2[255:240]\nINTERLEAVE_HIGH_WORDS (SRC1, SRC2)\nDEST[15:0] <- SRC1[79:64]\nDEST[31:16] <- SRC2[79:64]\nDEST[47:32] <- SRC1[95:80]\nDEST[63:48] <- SRC2[95:80]\nDEST[79:64] <- SRC1[111:96]\nDEST[95:80] <- SRC2[111:96]\nDEST[111:96] <-SRC1[127:112]\nDEST[127:112] <- SRC2[127:112]\nINTERLEAVE_HIGH_DWORDS_256b(SRC1, SRC2)\nDEST[31:0] <- SRC1[95:64]\nDEST[63:32] <- SRC2[95:64]\nDEST[95:64] <- SRC1[127:96]\nDEST[127:96] <- SRC2[127:96]\nDEST[159:128] <- SRC1[223:192]\nDEST[191:160] <- SRC2[223:192]\nDEST[223:192] <- SRC1[255:224]\nDEST[255:224] <- SRC2[255:224]\nINTERLEAVE_HIGH_DWORDS(SRC1, SRC2)\nDEST[31:0] <- SRC1[95:64]\nDEST[63:32] <- SRC2[95:64]\nDEST[95:64] <- SRC1[127:96]\nDEST[127:96] <- SRC2[127:96]\nINTERLEAVE_HIGH_QWORDS_256b(SRC1, SRC2)\nDEST[63:0] <- SRC1[127:64]\nDEST[127:64] <- SRC2[127:64]\nDEST[191:128] <- SRC1[255:192]\nDEST[255:192] <- SRC2[255:192]\nINTERLEAVE_HIGH_QWORDS(SRC1, SRC2)\nDEST[63:0] <- SRC1[127:64]\nDEST[127:64] <- SRC2[127:64]\nPUNPCKHBW (128-bit Legacy SSE Version)\nDEST[127:0] <- INTERLEAVE_HIGH_BYTES(DEST, SRC)\nDEST[VLMAX-1:128] (Unmodified)\nVPUNPCKHBW (VEX.128 encoded version)\nDEST[127:0] <- INTERLEAVE_HIGH_BYTES(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPUNPCKHBW (VEX.256 encoded version)\nDEST[255:0] <- INTERLEAVE_HIGH_BYTES_256b(SRC1, SRC2)\nPUNPCKHWD (128-bit Legacy SSE Version)\nDEST[127:0] <- INTERLEAVE_HIGH_WORDS(DEST, SRC)\nDEST[VLMAX-1:128] (Unmodified)\nVPUNPCKHWD (VEX.128 encoded version)\nDEST[127:0] <- INTERLEAVE_HIGH_WORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPUNPCKHWD (VEX.256 encoded version)\nDEST[255:0] <- INTERLEAVE_HIGH_WORDS_256b(SRC1, SRC2)\nPUNPCKHDQ (128-bit Legacy SSE Version)\nDEST[127:0] <- INTERLEAVE_HIGH_DWORDS(DEST, SRC)\nDEST[VLMAX-1:128] (Unmodified)\nVPUNPCKHDQ (VEX.128 encoded version)\nDEST[127:0] <- INTERLEAVE_HIGH_DWORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPUNPCKHDQ (VEX.256 encoded version)\nDEST[255:0] <- INTERLEAVE_HIGH_DWORDS_256b(SRC1, SRC2)\nPUNPCKHQDQ (128-bit Legacy SSE Version)\nDEST[127:0] <- INTERLEAVE_HIGH_QWORDS(DEST, SRC)\nDEST[255:127] (Unmodified)\nVPUNPCKHQDQ (VEX.128 encoded version)\nDEST[127:0] <- INTERLEAVE_HIGH_QWORDS(SRC1, SRC2)\nDEST[255:127] <- 0\nVPUNPCKHQDQ (VEX.256 encoded version)\nDEST[255:0] <- INTERLEAVE_HIGH_QWORDS_256(SRC1, SRC2)\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PUNPCKHBW:    | __m64 _mm_unpackhi_pi8(__m64 m1, __m64       \n|               | m2)                                          \n| (V)PUNPCKHBW: | __m128i _mm_unpackhi_epi8(__m128i m1,        \n|               | __m128i m2)                                  \n| VPUNPCKHBW:   | __m256i _mm256_unpackhi_epi8(__m256i         \n|               | m1, __m256i m2)                              \n| PUNPCKHWD:    | __m64 _mm_unpackhi_pi16(__m64 m1,__m64       \n|               | m2)                                          \n| (V)PUNPCKHWD: | __m128i _mm_unpackhi_epi16(__m128i m1,__m128i\n|               | m2)                                          \n| VPUNPCKHWD:   | __m256i _mm256_unpackhi_epi16(__m256i        \n|               | m1,__m256i m2)                               \n| PUNPCKHDQ:    | __m64 _mm_unpackhi_pi32(__m64 m1, __m64      \n|               | m2)                                          \n| (V)PUNPCKHDQ: | __m128i _mm_unpackhi_epi32(__m128i m1,       \n|               | __m128i m2)                                  \n| VPUNPCKHDQ:   | __m256i _mm256_unpackhi_epi32(__m256i        \n|               | m1, __m256i m2)                              \n| (V)PUNPCKHQDQ:| __m128i _mm_unpackhi_epi64 ( __m128i         \n|               | a, __m128i b)                                \n| VPUNPCKHQDQ:  | __m256i _mm256_unpackhi_epi64 ( __m256i      \n|               | a, __m256i b)                                \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PUNPCKHBW"
    }, 
    {
      "description": "-R:PUNPCKHBW", 
      "mnem": "PUNPCKHDQ"
    }, 
    {
      "description": "-R:PUNPCKHBW", 
      "mnem": "PUNPCKHQDQ"
    }, 
    {
      "description": "-R:PUNPCKHBW", 
      "mnem": "PUNPCKHWD"
    }, 
    {
      "description": "\nPUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ - Unpack Low Data:\n| Opcode/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 0F 60 /r1 PUNPCKLBW mm, mm/m32         | RM   | V/V                   | MMX               | Interleave low-order bytes from mm and \n|                                        |      |                       |                   | mm/m32 into mm.                        \n| 66 0F 60 /r PUNPCKLBW xmm1, xmm2/m128  | RM   | V/V                   | SSE2              | Interleave low-order bytes from xmm1   \n|                                        |      |                       |                   | and xmm2/m128 into xmm1.               \n| 0F 61 /r1 PUNPCKLWD mm, mm/m32         | RM   | V/V                   | MMX               | Interleave low-order words from mm and \n|                                        |      |                       |                   | mm/m32 into mm.                        \n| 66 0F 61 /r PUNPCKLWD xmm1, xmm2/m128  | RM   | V/V                   | SSE2              | Interleave low-order words from xmm1   \n|                                        |      |                       |                   | and xmm2/m128 into xmm1.               \n| 0F 62 /r1 PUNPCKLDQ mm, mm/m32         | RM   | V/V                   | MMX               | Interleave low-order doublewords from  \n|                                        |      |                       |                   | mm and mm/m32 into mm.                 \n| 66 0F 62 /r PUNPCKLDQ xmm1, xmm2/m128  | RM   | V/V                   | SSE2              | Interleave low-order doublewords from  \n|                                        |      |                       |                   | xmm1 and xmm2/m128 into xmm1.          \n| 66 0F 6C /r PUNPCKLQDQ xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Interleave low-order quadword from xmm1\n|                                        |      |                       |                   | and xmm2/m128 into xmm1 register.      \n| VEX.NDS.128.66.0F.WIG 60/r VPUNPCKLBW  | RVM  | V/V                   | AVX               | Interleave low-order bytes from xmm2   \n| xmm1,xmm2, xmm3/m128                   |      |                       |                   | and xmm3/m128 into xmm1.               \n| VEX.NDS.128.66.0F.WIG 61/r VPUNPCKLWD  | RVM  | V/V                   | AVX               | Interleave low-order words from xmm2   \n| xmm1,xmm2, xmm3/m128                   |      |                       |                   | and xmm3/m128 into xmm1.               \n| VEX.NDS.128.66.0F.WIG 62/r VPUNPCKLDQ  | RVM  | V/V                   | AVX               | Interleave low-order doublewords from  \n| xmm1, xmm2, xmm3/m128                  |      |                       |                   | xmm2 and xmm3/m128 into xmm1.          \n| VEX.NDS.128.66.0F.WIG 6C/r VPUNPCKLQDQ | RVM  | V/V                   | AVX               | Interleave low-order quadword from xmm2\n| xmm1, xmm2, xmm3/m128                  |      |                       |                   | and xmm3/m128 into xmm1 register.      \n| VEX.NDS.256.66.0F.WIG 60 /r VPUNPCKLBW | RVM  | V/V                   | AVX2              | Interleave low-order bytes from ymm2   \n| ymm1, ymm2, ymm3/m256                  |      |                       |                   | and ymm3/m256 into ymm1 register.      \n| VEX.NDS.256.66.0F.WIG 61 /r VPUNPCKLWD | RVM  | V/V                   | AVX2              | Interleave low-order words from ymm2   \n| ymm1, ymm2, ymm3/m256                  |      |                       |                   | and ymm3/m256 into ymm1 register.      \n| VEX.NDS.256.66.0F.WIG 62 /r VPUNPCKLDQ | RVM  | V/V                   | AVX2              | Interleave low-order doublewords from  \n| ymm1, ymm2, ymm3/m256                  |      |                       |                   | ymm2 and ymm3/m256 into ymm1 register. \n| VEX.NDS.256.66.0F.WIG 6C /r VPUNPCKLQDQ| RVM  | V/V                   | AVX2              | Interleave low-order quadword from ymm2\n| ymm1, ymm2, ymm3/m256                  |      |                       |                   | and ymm3/m256 into ymm1 register.      \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nUnpacks and interleaves the low-order data elements (bytes, words, doublewords,\nand quadwords) of the destination operand (first operand) and source operand\n(second operand) into the destination operand. (Figure 4-18 shows the unpack\noperation for bytes in 64-bit operands.). The high-order data elements are ignored.\n\n| SRC SRC| Y7 Figure 4-18. 255 Y7| Y6 Y6 Figure 4-19.| Y5 Y5| Y4 PUNPCKLBW Instruction Operation Using| Y3 Y3| Y2 Y2 256-bit VPUNPCKLDQ Instruction| Y1 DEST Y1 DEST| Y0 Y3 0 Y0 255 Y5| X7 Y2 255 X7 Y4| X6 X2 X6 X4| X5 Y1 X5 Y1| X4 X1 X4 X1| X3 Y0 X3 Y0| X2 X0 X2 X0| X1 X1 0| X0 31 X0| DEST 0\n|        |                       |                   |      | 64-bit Operands Y4                      |      | Operation                           |                |                  |                |            |            |            |            |            |        |         |       \nWhen the source data comes from a 128-bit memory operand, an implementation\nmay fetch only the appropriate 64 bits; however, alignment to a 16-byte boundary\nand normal segment checking will still be enforced.\n\nThe (V)PUNPCKLBW instruction interleaves the low-order bytes of the source and\ndestination operands, the (V)PUNPCKLWD instruction interleaves the low-order\nwords of the source and destination operands, the (V)PUNPCKLDQ instruction interleaves\nthe low-order doubleword (or doublewords) of the source and destination operands,\nand the (V)PUNPCKLQDQ instruction interleaves the low-order quadwords of the\nsource and destination operands.\n\nThese instructions can be used to convert bytes to words, words to doublewords,\ndoublewords to quadwords, and quadwords to double quadwords, respectively, by\nplacing all 0s in the source operand. Here, if the source operand contains all\n0s, the result (stored in the destination operand) contains zero extensions\nof the high-order data elements from the original value in the destination operand.\nFor example, with the (V)PUNPCKLBW instruction the high-order bytes are zero\nextended (that is, unpacked into unsigned word integers), and with the (V)PUNPCKLWD\ninstruction, the high-order words are zero extended (unpacked into unsigned\ndoubleword integers).\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE versions: The source operand can be an MMX technology register or\na 32-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE versions: The second source operand is an XMM register or\na 128-bit memory location. The first source operand and destination operands\nare XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register\nremain unchanged. VEX.128 encoded versions: The second source operand is an\nXMM register or a 128-bit memory location. The first source operand and destination\noperands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register\nare zeroed.\n\nVEX.256 encoded version: The second source operand is an YMM register or a 256-bit\nmemory location. The first source operand and destination operands are YMM registers.\n\nNote: VEX.L must be 0, otherwise instructions will #UD.\n\nOperation:\n\nPUNPCKLBW instruction with 64-bit operands:\n  DEST[63:56] <- SRC[31:24];\n  DEST[55:48] <- DEST[31:24];\n  DEST[47:40] <- SRC[23:16];\n  DEST[39:32] <- DEST[23:16];\n  DEST[31:24] <- SRC[15:8];\n  DEST[23:16] <- DEST[15:8];\n  DEST[15:8] <- SRC[7:0];\n  DEST[7:0] <- DEST[7:0];\nPUNPCKLWD instruction with 64-bit operands:\n  DEST[63:48] <- SRC[31:16];\n  DEST[47:32] <- DEST[31:16];\n  DEST[31:16] <- SRC[15:0];\n  DEST[15:0] <- DEST[15:0];\nPUNPCKLDQ instruction with 64-bit operands:\n  DEST[63:32] <- SRC[31:0];\n  DEST[31:0] <- DEST[31:0];\nPUNPCKLBW instruction with 128-bit operands:\n  DEST[7:0]<- DEST[7:0];\n  DEST[15:8]\n  DEST[23:16] <- DEST[15:8];\n  DEST[31:24] <- SRC[15:8];\n  DEST[39:32] <- DEST[23:16];\n  DEST[47:40] <- SRC[23:16];\n  DEST[55:48] <- DEST[31:24];\n  DEST[63:56] <- SRC[31:24];\n  DEST[71:64] <- DEST[39:32];\n  DEST[79:72] <- SRC[39:32];\n  DEST[87:80] <- DEST[47:40];\n  DEST[95:88] <- SRC[47:40];\n  DEST[103:96]\n  DEST[111:104] <- SRC[55:48];\n  DEST[119:112] <- DEST[63:56];\n  DEST[127:120] <- SRC[63:56];\nPUNPCKLWD instruction with 128-bit operands:\n  DEST[15:0]\n  DEST[31:16] <- SRC[15:0];\n  DEST[47:32] <- DEST[31:16];\n  DEST[63:48] <- SRC[31:16];\n  DEST[79:64] <- DEST[47:32];\n  DEST[95:80] <- SRC[47:32];\n  DEST[111:96]\n  DEST[127:112] <- SRC[63:48];\nPUNPCKLDQ instruction with 128-bit operands:\n  DEST[31:0] <- DEST[31:0];\n  DEST[63:32]\n  DEST[95:64]\n  DEST[127:96] <- SRC[63:32];\nPUNPCKLQDQ\n  DEST[63:0] <- DEST[63:0];\n  DEST[127:64] <- SRC[63:0];\nINTERLEAVE_BYTES_256b (SRC1, SRC2)\nDEST[7:0] <- SRC1[7:0]\nDEST[15:8] <- SRC2[7:0]\nDEST[23:16] <- SRC1[15:8]\nDEST[31:24] <- SRC2[15:8]\nDEST[39:32] <- SRC1[23:16]\nDEST[47:40] <- SRC2[23:16]\nDEST[55:48] <- SRC1[31:24]\nDEST[63:56] <-SRC2[31:24]\nDEST[71:64] <- SRC1[39:32]\nDEST[79:72] <- SRC2[39:32]\nDEST[87:80] <- SRC1[47:40]\nDEST[95:88] <- SRC2[47:40]\nDEST[103:96] <- SRC1[55:48]\nDEST[111:104] <- SRC2[55:48]\nDEST[119:112] <- SRC1[63:56]\nDEST[127:120] <- SRC2[63:56]\nDEST[135:128] <- SRC1[135:128]\nDEST[143:136] <- SRC2[135:128]\nDEST[151:144] <- SRC1[143:136]\nDEST[159:152] <- SRC2[143:136]\nDEST[167:160] <- SRC1[151:144]\nDEST[175:168] <- SRC2[151:144]\nDEST[183:176] <- SRC1[159:152]\nDEST[191:184] <-SRC2[159:152]\nDEST[199:192] <- SRC1[167:160]\nDEST[207:200] <- SRC2[167:160]\nDEST[215:208] <- SRC1[175:168]\nDEST[223:216] <- SRC2[175:168]\nDEST[231:224] <- SRC1[183:176]\nDEST[239:232] <- SRC2[183:176]\nDEST[247:240] <- SRC1[191:184]\nDEST[255:248] <- SRC2[191:184]\nINTERLEAVE_BYTES (SRC1, SRC2)\nDEST[7:0] <- SRC1[7:0]\nDEST[15:8] <- SRC2[7:0]\nDEST[23:16] <- SRC2[15:8]\nDEST[31:24] <- SRC2[15:8]\nDEST[39:32] <- SRC1[23:16]\nDEST[47:40] <- SRC2[23:16]\nDEST[55:48] <- SRC1[31:24]\nDEST[63:56] <-SRC2[31:24]\nDEST[71:64] <- SRC1[39:32]\nDEST[79:72] <- SRC2[39:32]\nDEST[87:80] <- SRC1[47:40]\nDEST[95:88] <- SRC2[47:40]\nDEST[103:96] <- SRC1[55:48]\nDEST[111:104] <- SRC2[55:48]\nDEST[119:112] <- SRC1[63:56]\nDEST[127:120] <- SRC2[63:56]\nINTERLEAVE_WORDS_256b(SRC1, SRC2)\nDEST[15:0] <- SRC1[15:0]\nDEST[31:16] <- SRC2[15:0]\nDEST[47:32] <- SRC1[31:16]\nDEST[63:48] <- SRC2[31:16]\nDEST[79:64] <- SRC1[47:32]\nDEST[95:80] <- SRC2[47:32]\nDEST[111:96] <- SRC1[63:48]\nDEST[127:112] <- SRC2[63:48]\nDEST[143:128] <- SRC1[143:128]\nDEST[159:144] <- SRC2[143:128]\nDEST[175:160] <- SRC1[159:144]\nDEST[191:176] <- SRC2[159:144]\nDEST[207:192] <- SRC1[175:160]\nDEST[223:208] <- SRC2[175:160]\nDEST[239:224] <- SRC1[191:176]\nDEST[255:240] <- SRC2[191:176]\nINTERLEAVE_WORDS (SRC1, SRC2)\nDEST[15:0] <- SRC1[15:0]\nDEST[31:16] <- SRC2[15:0]\nDEST[47:32] <- SRC1[31:16]\nDEST[63:48] <- SRC2[31:16]\nDEST[79:64] <- SRC1[47:32]\nDEST[95:80] <- SRC2[47:32]\nDEST[111:96] <- SRC1[63:48]\nDEST[127:112] <- SRC2[63:48]\nINTERLEAVE_DWORDS_256b(SRC1, SRC2)\nDEST[31:0] <- SRC1[31:0]\nDEST[63:32] <- SRC2[31:0]\nDEST[95:64] <- SRC1[63:32]\nDEST[127:96] <- SRC2[63:32]\nDEST[159:128] <- SRC1[159:128]\nDEST[191:160] <- SRC2[159:128]\nDEST[223:192] <- SRC1[191:160]\nDEST[255:224] <- SRC2[191:160]\nINTERLEAVE_DWORDS(SRC1, SRC2)\nDEST[31:0] <- SRC1[31:0]\nDEST[63:32] <- SRC2[31:0]\nDEST[95:64] <- SRC1[63:32]\nDEST[127:96] <- SRC2[63:32]\nINTERLEAVE_QWORDS_256b(SRC1, SRC2)\nDEST[63:0] <- SRC1[63:0]\nDEST[127:64] <- SRC2[63:0]\nDEST[191:128] <- SRC1[191:128]\nDEST[255:192] <- SRC2[191:128]\nINTERLEAVE_QWORDS(SRC1, SRC2)\nDEST[63:0] <- SRC1[63:0]\nDEST[127:64] <- SRC2[63:0]\nPUNPCKLBW (128-bit Legacy SSE Version)\nDEST[127:0] <- INTERLEAVE_BYTES(DEST, SRC)\nDEST[255:127] (Unmodified)\nVPUNPCKLBW (VEX.128 encoded instruction)\nDEST[127:0] <- INTERLEAVE_BYTES(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPUNPCKLBW (VEX.256 encoded instruction)\nDEST[255:0] <- INTERLEAVE_BYTES_128b(SRC1, SRC2)\nPUNPCKLWD (128-bit Legacy SSE Version)\nDEST[127:0] <- INTERLEAVE_WORDS(DEST, SRC)\nDEST[255:127] (Unmodified)\nVPUNPCKLWD (VEX.128 encoded instruction)\nDEST[127:0] <- INTERLEAVE_WORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPUNPCKLWD (VEX.256 encoded instruction)\nDEST[255:0] <- INTERLEAVE_WORDS(SRC1, SRC2)\nPUNPCKLDQ (128-bit Legacy SSE Version)\nDEST[127:0] <- INTERLEAVE_DWORDS(DEST, SRC)\nDEST[255:127] (Unmodified)\nVPUNPCKLDQ (VEX.128 encoded instruction)\nDEST[127:0] <- INTERLEAVE_DWORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPUNPCKLDQ (VEX.256 encoded instruction)\nDEST[255:0] <- INTERLEAVE_DWORDS(SRC1, SRC2)\nPUNPCKLQDQ (128-bit Legacy SSE Version)\nDEST[127:0] <- INTERLEAVE_QWORDS(DEST, SRC)\nDEST[255:127] (Unmodified)\nVPUNPCKLQDQ (VEX.128 encoded instruction)\nDEST[127:0] <- INTERLEAVE_QWORDS(SRC1, SRC2)\nDEST[VLMAX-1:128] <- 0\nVPUNPCKLQDQ (VEX.256 encoded instruction)\nDEST[255:0] <- INTERLEAVE_QWORDS(SRC1, SRC2)\n\nIntel C/C++ Compiler Intrinsic Equivalents:\n| PUNPCKLBW:    | __m64 _mm_unpacklo_pi8 (__m64 m1, __m64 \n|               | m2)                                     \n| (V)PUNPCKLBW: | __m128i _mm_unpacklo_epi8 (__m128i m1,  \n|               | __m128i m2)                             \n| VPUNPCKLBW:   | __m256i _mm256_unpacklo_epi8 (__m256i   \n|               | m1, __m256i m2)                         \n| PUNPCKLWD:    | __m64 _mm_unpacklo_pi16 (__m64 m1, __m64\n|               | m2)                                     \n| (V)PUNPCKLWD: | __m128i _mm_unpacklo_epi16 (__m128i     \n|               | m1, __m128i m2)                         \n| VPUNPCKLWD:   | __m256i _mm256_unpacklo_epi16 (__m256i  \n|               | m1, __m256i m2)                         \n| PUNPCKLDQ:    | __m64 _mm_unpacklo_pi32 (__m64 m1, __m64\n|               | m2)                                     \n| (V)PUNPCKLDQ: | __m128i _mm_unpacklo_epi32 (__m128i     \n|               | m1, __m128i m2)                         \n| VPUNPCKLDQ:   | __m256i _mm256_unpacklo_epi32 (__m256i  \n|               | m1, __m256i m2)                         \n| (V)PUNPCKLQDQ:| __m128i _mm_unpacklo_epi64 (__m128i     \n|               | m1, __m128i m2)                         \n| VPUNPCKLQDQ:  | __m256i _mm256_unpacklo_epi64 (__m256i  \n|               | m1, __m256i m2)                         \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PUNPCKLBW"
    }, 
    {
      "description": "-R:PUNPCKLBW", 
      "mnem": "PUNPCKLDQ"
    }, 
    {
      "description": "-R:PUNPCKLBW", 
      "mnem": "PUNPCKLQDQ"
    }, 
    {
      "description": "-R:PUNPCKLBW", 
      "mnem": "PUNPCKLWD"
    }, 
    {
      "description": "\nPUSH - Push Word, Doubleword or Quadword Onto the Stack:\n| Opcode*| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description\n| FF /6  | PUSH r/m16 | M    | Valid      | Valid          | Push r/m16.\n| FF /6  | PUSH r/m32 | M    | N.E.       | Valid          | Push r/m32.\n| FF /6  | PUSH r/m64 | M    | Valid      | N.E.           | Push r/m64.\n| 50+rw  | PUSH r16   | O    | Valid      | Valid          | Push r16.  \n| 50+rd  | PUSH r32   | O    | N.E.       | Valid          | Push r32.  \n| 50+rd  | PUSH r64   | O    | Valid      | N.E.           | Push r64.  \n| 6A ib  | PUSH imm8  | I    | Valid      | Valid          | Push imm8. \n| 68 iw  | PUSH imm16 | I    | Valid      | Valid          | Push imm16.\n| 68 id  | PUSH imm32 | I    | Valid      | Valid          | Push imm32.\n| 0E     | PUSH CS    | NP   | Invalid    | Valid          | Push CS.   \n| 16     | PUSH SS    | NP   | Invalid    | Valid          | Push SS.   \n| 1E     | PUSH DS    | NP   | Invalid    | Valid          | Push DS.   \n| 06     | PUSH ES    | NP   | Invalid    | Valid          | Push ES.   \n| 0F A0  | PUSH FS    | NP   | Valid      | Valid          | Push FS.   \n| 0F A8  | PUSH GS    | NP   | Valid      | Valid          | Push GS.   \nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1      | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)  | NA       | NA       | NA       \n| O    | opcode + rd (r)| NA       | NA       | NA       \n| I    | imm8/16/32     | NA       | NA       | NA       \n| NP   | NA             | NA       | NA       | NA       \n\nDescription:\nDecrements the stack pointer and then stores the source operand on the top of\nthe stack. Address and operand sizes are determined and used as follows:\n\n - Address size. The D flag in the current code-segment descriptor determines the\ndefault address size; it may be overridden by an instruction prefix (67H). The\naddress size is used only when referencing a source operand in memory.\n - Operand size. The D flag in the current code-segment descriptor determines the\ndefault operand size; it may be overridden by instruction prefixes (66H or REX.W).\nThe operand size (16, 32, or 64 bits) determines the amount by which the stack\npointer is decremented (2, 4 or 8). If the source operand is an immediate of\nsize less than the operand size, a sign-extended value is pushed on the stack.\nIf the source operand is a segment register (16 bits) and the operand size is\n64-bits, a zeroextended value is pushed on the stack; if the operand size is\n32-bits, either a zero-extended value is pushed on the stack or the segment\nselector is written on the stack using a 16-bit move. For the last case, all\nrecent Core and Atom processors perform a 16-bit move, leaving the upper portion\nof the stack location unmodified.\n - Stack-address size. Outside of 64-bit mode, the B flag in the current stack-segment\ndescriptor determines the size of the stack pointer (16 or 32 bits); in 64-bit\nmode, the size of the stack pointer is always 64 bits. The stack-address size\ndetermines the width of the stack pointer when writing to the stack in memory\nand when decrementing the stack pointer. (As stated above, the amount by which\nthe stack pointer is decremented is determined by the operand size.) If the\noperand size is less than the stack-address size, the PUSH instruction may result\nin a misaligned stack pointer (a stack pointer that is not aligned on a doubleword\nor quadword boundary).\n\nThe PUSH ESP instruction pushes the value of the ESP register as it existed\nbefore the instruction was executed. If a PUSH instruction uses a memory operand\nin which the ESP register is used for computing the operand address, the address\nof the operand is computed before the ESP register is decremented.\n\nIf the ESP or SP register is 1 when the PUSH instruction is executed in real-address\nmode, a stack-fault exception (#SS) is generated (because the limit of the stack\nsegment is violated). Its delivery encounters a second stackfault exception\n(for the same reason), causing generation of a double-fault exception (#DF).\nDelivery of the double-fault exception encounters a third stack-fault exception,\nand the logical processor enters shutdown mode. See the discussion of the double-fault\nexception in Chapter 6 of the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nIA-32 Architecture Compatibility:\nFor IA-32 processors from the Intel 286 on, the PUSH ESP instruction pushes\nthe value of the ESP register as it existed before the instruction was executed.\n(This is also true for Intel 64 architecture, real-address and virtual8086 modes\nof IA-32 architecture.) For the Intel\u00ae 8086 processor, the PUSH SP instruction\npushes the new value of the SP register (that is the value after it has been\ndecremented by 2).\n\nOperation:\n\n(* See Description section for possible sign-extension or zero-extension of source operand and for *)\n(* a case in which the size of the memory store may be smaller than the instruction's operand size *)\nIF StackAddrSize = 64\n  THEN\n     IF OperandSize = 64\n       THEN\n          RSP <- RSP - 8;\n          Memory[SS:RSP] <- SRC;\n     ELSE IF OperandSize = 32\n       THEN\n          RSP <- RSP - 4;\n          Memory[SS:RSP] <- SRC;\n       ELSE (* OperandSize = 16 *)\n          RSP <- RSP - 2;\n          Memory[SS:RSP] <- SRC;\n     FI;\nELSE IF StackAddrSize = 32\n  THEN\n     IF OperandSize = 64\n       THEN\n          ESP <- ESP - 8;\n          Memory[SS:ESP] <- SRC;\n     ELSE IF OperandSize = 32\n       THEN\n          ESP <- ESP - 4;\n          Memory[SS:ESP] <- SRC;\n       ELSE (* OperandSize = 16 *)\n          ESP <- ESP - 2;\n          Memory[SS:ESP] <- SRC;\n     FI;\n  ELSE (* StackAddrSize = 16 *)\n     IF OperandSize = 32\n       THEN\n          SP <- SP - 4;\n          Memory[SS:SP] <- SRC;\n       ELSE (* OperandSize = 16 *)\n          SP <- SP - 2;\n          Memory[SS:SP] <- SRC;\n     FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address   \n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit. If the DS, ES, FS, or    \n|                | GS register is used to access memory    \n|                | and it contains a NULL segment selector.\n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made   \n|                | while the current privilege level is    \n|                | 3.                                      \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address  \n|    | is outside the CS, DS, ES, FS, or GS   \n|    | segment limit.                         \n| #SS| If a memory operand effective address  \n|    | is outside the SS segment limit. If    \n|    | the new value of the SP or ESP register\n|    | is outside the stack segment limit.    \n| #UD| If the LOCK prefix is used.            \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #SS(0)         | If the stack address is in a non-canonical \n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used. If the PUSH    \n|                | is of CS, SS, DS, or ES.                   \n", 
      "mnem": "PUSH"
    }, 
    {
      "description": "\nPUSHA/PUSHAD - Push All General-Purpose Registers:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| 60    | PUSHA      | NP   | Invalid    | Valid          | Push AX, CX, DX, BX, original SP, BP, \n|       |            |      |            |                | SI, and DI.                           \n| 60    | PUSHAD     | NP   | Invalid    | Valid          | Push EAX, ECX, EDX, EBX, original ESP,\n|       |            |      |            |                | EBP, ESI, and EDI.                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nPushes the contents of the general-purpose registers onto the stack. The registers\nare stored on the stack in the following order: EAX, ECX, EDX, EBX, ESP (original\nvalue), EBP, ESI, and EDI (if the current operand-size attribute is 32) and\nAX, CX, DX, BX, SP (original value), BP, SI, and DI (if the operand-size attribute\nis 16). These instructions perform the reverse operation of the POPA/POPAD instructions.\nThe value pushed for the ESP or SP register is its value before prior to pushing\nthe first register (see the \u201cOperation\u201d section below).\n\nThe PUSHA (push all) and PUSHAD (push all double) mnemonics reference the same\nopcode. The PUSHA instruction is intended for use when the operand-size attribute\nis 16 and the PUSHAD instruction for when the operandsize attribute is 32. Some\nassemblers may force the operand size to 16 when PUSHA is used and to 32 when\nPUSHAD is used. Others may treat these mnemonics as synonyms (PUSHA/PUSHAD)\nand use the current setting of the operand-size attribute to determine the size\nof values to be pushed from the stack, regardless of the mnemonic used.\n\nIn the real-address mode, if the ESP or SP register is 1, 3, or 5 when PUSHA/PUSHAD\nexecutes: an #SS exception is generated but not delivered (the stack error reported\nprevents #SS delivery). Next, the processor generates a #DF exception and enters\na shutdown state as described in the #DF discussion in Chapter 6 of the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 3A.\n\nThis instruction executes as described in compatibility mode and legacy mode.\nIt is not valid in 64-bit mode.\n\nOperation:\n\nIF 64-bit Mode\n  THEN #UD\nFI;\nIF OperandSize = 32 (* PUSHAD instruction *)\n  THEN\n     Temp <- (ESP);\n     Push(EAX);\n     Push(ECX);\n     Push(EDX);\n     Push(EBX);\n     Push(Temp);\n     Push(EBP);\n     Push(ESI);\n     Push(EDI);\n  ELSE (* OperandSize = 16, PUSHA instruction *)\n     Temp <- (SP);\n     Push(AX);\n     Push(CX);\n     Push(DX);\n     Push(BX);\n     Push(Temp);\n     Push(BP);\n     Push(SI);\n     Push(DI);\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #SS(0)         | If the starting or ending stack address\n|                | is outside the stack segment limit.    \n| #PF(fault-code)| If a page fault occurs.                \n| #AC(0)         | If an unaligned memory reference is    \n|                | made while the current privilege level \n|                | is 3 and alignment checking is enabled.\n| #UD            | If the LOCK prefix is used.            \n\nReal-Address Mode Exceptions:\n| #GP| If the ESP or SP register contains 7,\n|    | 9, 11, 13, or 15.                    \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If the ESP or SP register contains 7,    \n|                | 9, 11, 13, or 15.                        \n| #PF(fault-code)| If a page fault occurs.                  \n| #AC(0)         | If an unaligned memory reference is      \n|                | made while alignment checking is enabled.\n| #UD            | If the LOCK prefix is used.              \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #UD| If in 64-bit mode.\n", 
      "mnem": "PUSHA"
    }, 
    {
      "description": "-R:PUSHA", 
      "mnem": "PUSHAD"
    }, 
    {
      "description": "\nPUSHF/PUSHFD - Push EFLAGS Register onto the Stack:\n| Opcode*| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                  \n| 9C     | PUSHF      | NP   | Valid      | Valid          | Push lower 16 bits of EFLAGS.\n| 9C     | PUSHFD     | NP   | N.E.       | Valid          | Push EFLAGS.                 \n| 9C     | PUSHFQ     | NP   | Valid      | N.E.           | Push RFLAGS.                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nDecrements the stack pointer by 4 (if the current operand-size attribute is\n32) and pushes the entire contents of the EFLAGS register onto the stack, or\ndecrements the stack pointer by 2 (if the operand-size attribute is 16) and\npushes the lower 16 bits of the EFLAGS register (that is, the FLAGS register)\nonto the stack. These instructions reverse the operation of the POPF/POPFD instructions.\n\nWhen copying the entire EFLAGS register to the stack, the VM and RF flags (bits\n16 and 17) are not copied; instead, the values for these flags are cleared in\nthe EFLAGS image stored on the stack. See Chapter 3 of the Intel\u00ae 64 and IA-32\nArchitectures Software Developer's Manual, Volume 1, for more information about\nthe EFLAGS register.\n\nThe PUSHF (push flags) and PUSHFD (push flags double) mnemonics reference the\nsame opcode. The PUSHF instruction is intended for use when the operand-size\nattribute is 16 and the PUSHFD instruction for when the operand-size attribute\nis 32. Some assemblers may force the operand size to 16 when PUSHF is used and\nto 32 when PUSHFD is used. Others may treat these mnemonics as synonyms (PUSHF/PUSHFD)\nand use the current setting of the operand-size attribute to determine the size\nof values to be pushed from the stack, regardless of the mnemonic used.\n\nIn 64-bit mode, the instruction's default operation is to decrement the stack\npointer (RSP) by 8 and pushes RFLAGS on the stack. 16-bit operation is supported\nusing the operand size override prefix 66H. 32-bit operand size cannot be encoded\nin this mode. When copying RFLAGS to the stack, the VM and RF flags (bits 16\nand 17) are not copied; instead, values for these flags are cleared in the RFLAGS\nimage stored on the stack.\n\nWhen in virtual-8086 mode and the I/O privilege level (IOPL) is less than 3,\nthe PUSHF/PUSHFD instruction causes a general protection exception (#GP).\n\nIn the real-address mode, if the ESP or SP register is 1 when PUSHF/PUSHFD instruction\nexecutes: an #SS exception is generated but not delivered (the stack error reported\nprevents #SS delivery). Next, the processor generates a #DF exception and enters\na shutdown state as described in the #DF discussion in Chapter 6 of the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 3A.\n\nOperation:\n\nIF (PE = 0) or (PE = 1 and ((VM = 0) or (VM = 1 and IOPL = 3)))\n(* Real-Address Mode, Protected mode, or Virtual-8086 mode with IOPL equal to 3 *)\n  THEN\n     IF OperandSize = 32\n       THEN\n          push (EFLAGS AND 00FCFFFFH);\n          (* VM and RF EFLAG bits are cleared in image stored on the stack *)\n       ELSE\n          push (EFLAGS); (* Lower 16 bits only *)\n     FI;\n  ELSE IF 64-bit MODE (* In 64-bit Mode *)\n     IF OperandSize = 64\n       THEN\n          push (RFLAGS AND 00000000_00FCFFFFH);\n          (* VM and RF RFLAG bits are cleared in image stored on the stack; *)\n       ELSE\n          push (EFLAGS); (* Lower 16 bits only *)\n     FI;\n  ELSE (* In Virtual-8086 Mode with IOPL less than 3 *)\n     #GP(0); (* Trap to virtual-8086 monitor *)\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #SS(0)         | If the new value of the ESP register   \n|                | is outside the stack segment boundary. \n| #PF(fault-code)| If a page fault occurs.                \n| #AC(0)         | If an unaligned memory reference is    \n|                | made while the current privilege level \n|                | is 3 and alignment checking is enabled.\n| #UD            | If the LOCK prefix is used.            \n\nReal-Address Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If the I/O privilege level is less than  \n|                | 3.                                       \n| #PF(fault-code)| If a page fault occurs.                  \n| #AC(0)         | If an unaligned memory reference is      \n|                | made while alignment checking is enabled.\n| #UD            | If the LOCK prefix is used.              \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #SS(0)         | If the stack address is in a non-canonical \n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If an unaligned memory reference is        \n|                | made while the current privilege level     \n|                | is 3 and alignment checking is enabled.    \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "PUSHF"
    }, 
    {
      "description": "-R:PUSHF", 
      "mnem": "PUSHFD"
    }, 
    {
      "description": "-R:PUSHF", 
      "mnem": "PUSHFQ"
    }, 
    {
      "description": "\nPXOR - Logical Exclusive OR:\n| Opcode*/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                       \n| 0F EF /r1 PXOR mm, mm/m64              | RM   | V/V                   | MMX               | Bitwise XOR of mm/m64 and mm.     \n| 66 0F EF /r PXOR xmm1, xmm2/m128       | RM   | V/V                   | SSE2              | Bitwise XOR of xmm2/m128 and xmm1.\n| VEX.NDS.128.66.0F.WIG EF /r VPXOR xmm1,| RVM  | V/V                   | AVX               | Bitwise XOR of xmm3/m128 and xmm2.\n| xmm2, xmm3/m128                        |      |                       |                   |                                   \n| VEX.NDS.256.66.0F.WIG EF /r VPXOR ymm1,| RVM  | V/V                   | AVX2              | Bitwise XOR of ymm3/m256 and ymm2.\n| ymm2, ymm3/m256                        |      |                       |                   |                                   \nNotes: 1. See note in Section 2.4, \u201cInstruction Exception Specification\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 2A\nand Section 22.25.3, \u201cException Conditions of Legacy SIMD Instructions Operating\non MMX Registers\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a bitwise logical exclusive-OR (XOR) operation on the source operand\n(second operand) and the destination operand (first operand) and stores the\nresult in the destination operand. Each bit of the result is 1 if the corresponding\nbits of the two operands are different; each bit is 0 if the corresponding bits\nof the operands are the same.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\nLegacy SSE instructions: The source operand can be an MMX technology register\nor a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE version: The second source operand is an XMM register or\na 128-bit memory location. The first source operand and destination operands\nare XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register\nremain unchanged. VEX.128 encoded version: The second source operand is an XMM\nregister or a 128-bit memory location. The first source operand and destination\noperands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register\nare zeroed. VEX.256 encoded version: The second source operand is an YMM register\nor a 256-bit memory location. The first source operand and destination operands\nare YMM registers.\n\nNote: VEX.L must be 0, otherwise instructions will #UD.\n\nOperation:\n\nPXOR (128-bit Legacy SSE version)\nDEST <- DEST XOR SRC\nDEST[VLMAX-1:128] (Unmodified)\nVPXOR (VEX.128 encoded version)\nDEST <- SRC1 XOR SRC2\nDEST[VLMAX-1:128] <- 0\nVPXOR (VEX.256 encoded version)\nDEST <- SRC1 XOR SRC2\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| PXOR:   | __m64 _mm_xor_si64 (__m64 m1, __m64       \n|         | m2)                                       \n| (V)PXOR:| __m128i _mm_xor_si128 ( __m128i a, __m128i\n|         | b)                                        \n| VPXOR:  | __m256i _mm256_xor_si256 ( __m256i a,     \n|         | __m256i b)                                \n\nFlags Affected:\nNone.\n\n\nNumeric Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 1.\n", 
      "mnem": "PXOR"
    }, 
    {
      "description": "\nRCL/RCR/ROL/ROR- - Rotate:\n| Opcode**        | Instruction    | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                              \n| D0 /2           | RCL r/m8, 1    | M1   | Valid      | Valid          | Rotate 9 bits (CF, r/m8) left once.      \n| REX + D0 /2     | RCL r/m8*, 1   | M1   | Valid      | N.E.           | Rotate 9 bits (CF, r/m8) left once.      \n| D2 /2           | RCL r/m8, CL   | MC   | Valid      | Valid          | Rotate 9 bits (CF, r/m8) left CL times.  \n| REX + D2 /2     | RCL r/m8*, CL  | MC   | Valid      | N.E.           | Rotate 9 bits (CF, r/m8) left CL times.  \n| C0 /2 ib        | RCL r/m8, imm8 | MI   | Valid      | Valid          | Rotate 9 bits (CF, r/m8) left imm8 times.\n| REX + C0 /2 ib  | RCL r/m8*, imm8| MI   | Valid      | N.E.           | Rotate 9 bits (CF, r/m8) left imm8 times.\n| D1 /2           | RCL r/m16, 1   | M1   | Valid      | Valid          | Rotate 17 bits (CF, r/m16) left once.    \n| D3 /2           | RCL r/m16, CL  | MC   | Valid      | Valid          | Rotate 17 bits (CF, r/m16) left CL times.\n| C1 /2 ib        | RCL r/m16, imm8| MI   | Valid      | Valid          | Rotate 17 bits (CF, r/m16) left imm8     \n|                 |                |      |            |                | times.                                   \n| D1 /2           | RCL r/m32, 1   | M1   | Valid      | Valid          | Rotate 33 bits (CF, r/m32) left once.    \n| REX.W + D1 /2   | RCL r/m64, 1   | M1   | Valid      | N.E.           | Rotate 65 bits (CF, r/m64) left once.    \n|                 |                |      |            |                | Uses a 6 bit count.                      \n| D3 /2           | RCL r/m32, CL  | MC   | Valid      | Valid          | Rotate 33 bits (CF, r/m32) left CL times.\n| REX.W + D3 /2   | RCL r/m64, CL  | MC   | Valid      | N.E.           | Rotate 65 bits (CF, r/m64) left CL times.\n|                 |                |      |            |                | Uses a 6 bit count.                      \n| C1 /2 ib        | RCL r/m32, imm8| MI   | Valid      | Valid          | Rotate 33 bits (CF, r/m32) left imm8     \n|                 |                |      |            |                | times.                                   \n| REX.W + C1 /2 ib| RCL r/m64, imm8| MI   | Valid      | N.E.           | Rotate 65 bits (CF, r/m64) left imm8     \n|                 |                |      |            |                | times. Uses a 6 bit count.               \n| D0 /3           | RCR r/m8, 1    | M1   | Valid      | Valid          | Rotate 9 bits (CF, r/m8) right once.     \n| REX + D0 /3     | RCR r/m8*, 1   | M1   | Valid      | N.E.           | Rotate 9 bits (CF, r/m8) right once.     \n| D2 /3           | RCR r/m8, CL   | MC   | Valid      | Valid          | Rotate 9 bits (CF, r/m8) right CL times. \n| REX + D2 /3     | RCR r/m8*, CL  | MC   | Valid      | N.E.           | Rotate 9 bits (CF, r/m8) right CL times. \n| C0 /3 ib        | RCR r/m8, imm8 | MI   | Valid      | Valid          | Rotate 9 bits (CF, r/m8) right imm8      \n|                 |                |      |            |                | times.                                   \n| REX + C0 /3 ib  | RCR r/m8*, imm8| MI   | Valid      | N.E.           | Rotate 9 bits (CF, r/m8) right imm8      \n|                 |                |      |            |                | times.                                   \n| D1 /3           | RCR r/m16, 1   | M1   | Valid      | Valid          | Rotate 17 bits (CF, r/m16) right once.   \n| D3 /3           | RCR r/m16, CL  | MC   | Valid      | Valid          | Rotate 17 bits (CF, r/m16) right CL      \n|                 |                |      |            |                | times.                                   \n| C1 /3 ib        | RCR r/m16, imm8| MI   | Valid      | Valid          | Rotate 17 bits (CF, r/m16) right imm8    \n|                 |                |      |            |                | times.                                   \n| D1 /3           | RCR r/m32, 1   | M1   | Valid      | Valid          | Rotate 33 bits (CF, r/m32) right once.   \n|                 |                |      |            |                | Uses a 6 bit count.                      \n| REX.W + D1 /3   | RCR r/m64, 1   | M1   | Valid      | N.E.           | Rotate 65 bits (CF, r/m64) right once.   \n|                 |                |      |            |                | Uses a 6 bit count.                      \n| D3 /3           | RCR r/m32, CL  | MC   | Valid      | Valid          | Rotate 33 bits (CF, r/m32) right CL      \n|                 |                |      |            |                | times.                                   \n| REX.W + D3 /3   | RCR r/m64, CL  | MC   | Valid      | N.E.           | Rotate 65 bits (CF, r/m64) right CL      \n|                 |                |      |            |                | times. Uses a 6 bit count.               \n| C1 /3 ib        | RCR r/m32, imm8| MI   | Valid      | Valid          | Rotate 33 bits (CF, r/m32) right imm8    \n|                 |                |      |            |                | times.                                   \n| REX.W + C1 /3 ib| RCR r/m64, imm8| MI   | Valid      | N.E.           | Rotate 65 bits (CF, r/m64) right imm8    \n|                 |                |      |            |                | times. Uses a 6 bit count.               \n| D0 /0           | ROL r/m8, 1    | M1   | Valid      | Valid          | Rotate 8 bits r/m8 left once.            \n| REX + D0 /0     | ROL r/m8*, 1   | M1   | Valid      | N.E.           | Rotate 8 bits r/m8 left once             \n| D2 /0           | ROL r/m8, CL   | MC   | Valid      | Valid          | Rotate 8 bits r/m8 left CL times.        \n| REX + D2 /0     | ROL r/m8*, CL  | MC   | Valid      | N.E.           | Rotate 8 bits r/m8 left CL times.        \n| C0 /0 ib        | ROL r/m8, imm8 | MI   | Valid      | Valid          | Rotate 8 bits r/m8 left imm8 times.      \n| Opcode**        | Instruction    | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                              \n| REX + C0 /0 ib  | ROL r/m8*, imm8| MI   | Valid      | N.E.           | Rotate 8 bits r/m8 left imm8 times.      \n| D1 /0           | ROL r/m16, 1   | M1   | Valid      | Valid          | Rotate 16 bits r/m16 left once.          \n| D3 /0           | ROL r/m16, CL  | MC   | Valid      | Valid          | Rotate 16 bits r/m16 left CL times.      \n| C1 /0 ib        | ROL r/m16, imm8| MI   | Valid      | Valid          | Rotate 16 bits r/m16 left imm8 times.    \n| D1 /0           | ROL r/m32, 1   | M1   | Valid      | Valid          | Rotate 32 bits r/m32 left once.          \n| REX.W + D1 /0   | ROL r/m64, 1   | M1   | Valid      | N.E.           | Rotate 64 bits r/m64 left once. Uses     \n|                 |                |      |            |                | a 6 bit count.                           \n| D3 /0           | ROL r/m32, CL  | MC   | Valid      | Valid          | Rotate 32 bits r/m32 left CL times.      \n| REX.W + D3 /0   | ROL r/m64, CL  | MC   | Valid      | N.E.           | Rotate 64 bits r/m64 left CL times.      \n|                 |                |      |            |                | Uses a 6 bit count.                      \n| C1 /0 ib        | ROL r/m32, imm8| MI   | Valid      | Valid          | Rotate 32 bits r/m32 left imm8 times.    \n| REX.W + C1 /0 ib| ROL r/m64, imm8| MI   | Valid      | N.E.           | Rotate 64 bits r/m64 left imm8 times.    \n|                 |                |      |            |                | Uses a 6 bit count.                      \n| D0 /1           | ROR r/m8, 1    | M1   | Valid      | Valid          | Rotate 8 bits r/m8 right once.           \n| REX + D0 /1     | ROR r/m8*, 1   | M1   | Valid      | N.E.           | Rotate 8 bits r/m8 right once.           \n| D2 /1           | ROR r/m8, CL   | MC   | Valid      | Valid          | Rotate 8 bits r/m8 right CL times.       \n| REX + D2 /1     | ROR r/m8*, CL  | MC   | Valid      | N.E.           | Rotate 8 bits r/m8 right CL times.       \n| C0 /1 ib        | ROR r/m8, imm8 | MI   | Valid      | Valid          | Rotate 8 bits r/m16 right imm8 times.    \n| REX + C0 /1 ib  | ROR r/m8*, imm8| MI   | Valid      | N.E.           | Rotate 8 bits r/m16 right imm8 times.    \n| D1 /1           | ROR r/m16, 1   | M1   | Valid      | Valid          | Rotate 16 bits r/m16 right once.         \n| D3 /1           | ROR r/m16, CL  | MC   | Valid      | Valid          | Rotate 16 bits r/m16 right CL times.     \n| C1 /1 ib        | ROR r/m16, imm8| MI   | Valid      | Valid          | Rotate 16 bits r/m16 right imm8 times.   \n| D1 /1           | ROR r/m32, 1   | M1   | Valid      | Valid          | Rotate 32 bits r/m32 right once.         \n| REX.W + D1 /1   | ROR r/m64, 1   | M1   | Valid      | N.E.           | Rotate 64 bits r/m64 right once. Uses    \n|                 |                |      |            |                | a 6 bit count.                           \n| D3 /1           | ROR r/m32, CL  | MC   | Valid      | Valid          | Rotate 32 bits r/m32 right CL times.     \n| REX.W + D3 /1   | ROR r/m64, CL  | MC   | Valid      | N.E.           | Rotate 64 bits r/m64 right CL times.     \n|                 |                |      |            |                | Uses a 6 bit count.                      \n| C1 /1 ib        | ROR r/m32, imm8| MI   | Valid      | Valid          | Rotate 32 bits r/m32 right imm8 times.   \n| REX.W + C1 /1 ib| ROR r/m64, imm8| MI   | Valid      | N.E.           | Rotate 64 bits r/m64 right imm8 times.   \n|                 |                |      |            |                | Uses a 6 bit count.                      \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH. ** See IA-32 Architecture\nCompatibility section below.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M1   | ModRM:r/m (w)| 1        | NA       | NA       \n| MC   | ModRM:r/m (w)| CL       | NA       | NA       \n| MI   | ModRM:r/m (w)| imm8     | NA       | NA       \n\nDescription:\nShifts (rotates) the bits of the first operand (destination operand) the number\nof bit positions specified in the second operand (count operand) and stores\nthe result in the destination operand. The destination operand can be a register\nor a memory location; the count operand is an unsigned integer that can be an\nimmediate or a value in the CL register. In legacy and compatibility mode, the\nprocessor restricts the count to a number between 0 and 31 by masking all the\nbits in the count operand except the 5 least-significant bits.\n\nThe rotate left (ROL) and rotate through carry left (RCL) instructions shift\nall the bits toward more-significant bit positions, except for the most-significant\nbit, which is rotated to the least-significant bit location. The rotate right\n(ROR) and rotate through carry right (RCR) instructions shift all the bits toward\nless significant bit positions, except for the least-significant bit, which\nis rotated to the most-significant bit location.\n\nThe RCL and RCR instructions include the CF flag in the rotation. The RCL instruction\nshifts the CF flag into the least-significant bit and shifts the most-significant\nbit into the CF flag. The RCR instruction shifts the CF flag into the most-significant\nbit and shifts the least-significant bit into the CF flag. For the ROL and ROR\ninstructions, the original value of the CF flag is not a part of the result,\nbut the CF flag receives a copy of the bit that was shifted from one end to\nthe other.\n\nThe OF flag is defined only for the 1-bit rotates; it is undefined in all other\ncases (except RCL and RCR instructions only: a zero-bit rotate does nothing,\nthat is affects no flags). For left rotates, the OF flag is set to the exclusive\nOR of the CF bit (after the rotate) and the most-significant bit of the result.\nFor right rotates, the OF flag is set to the exclusive OR of the two most-significant\nbits of the result.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional\nregisters (R8-R15). Use of REX.W promotes the first operand to 64 bits and causes\nthe count operand to become a 6-bit counter.\n\n\nIA-32 Architecture Compatibility:\nThe 8086 does not mask the rotation count. However, all other IA-32 processors\n(starting with the Intel 286 processor) do mask the rotation count to 5 bits,\nresulting in a maximum count of 31. This masking is done in all operating modes\n(including the virtual-8086 mode) to reduce the maximum execution time of the\ninstructions.\n\nOperation:\n\n(* RCL and RCR instructions *)\nSIZE <- OperandSize;\nCASE (determine count) OF\n  SIZE <- 8:\n  SIZE <- 16:\n  SIZE <- 32:\n  SIZE <- 64:\nESAC;\n(* RCL instruction operation *)\nWHILE (tempCOUNT != 0)\n  DO\n     tempCF <- MSB(DEST);\n     DEST <- (DEST * 2) + CF;\n     CF <- tempCF;\n     tempCOUNT <- tempCOUNT - 1;\n  OD;\nELIHW;\nIF COUNT = 1\n  THEN OF <- MSB(DEST) XOR CF;\n  ELSE OF is undefined;\nFI;\n(* RCR instruction operation *)\nIF COUNT = 1\n  THEN OF <- MSB(DEST) XOR CF;\n  ELSE OF is undefined;\nFI;\nWHILE (tempCOUNT != 0)\n  DO\n     tempCF <- LSB(SRC);\n     DEST <- (DEST / 2) + (CF * 2SIZE);\n     CF <- tempCF;\n     tempCOUNT <- tempCOUNT - 1;\n  OD;\n(* ROL and ROR instructions *)\nIF OperandSize = 64\n  THEN COUNTMASK = 3FH;\n  ELSE COUNTMASK = 1FH;\nFI;\n(* ROL instruction operation *)\ntempCOUNT <- (COUNT & COUNTMASK) MOD SIZE\nWHILE (tempCOUNT != 0)\n  DO\n     tempCF <- MSB(DEST);\n     DEST <- (DEST * 2) + tempCF;\n     tempCOUNT <- tempCOUNT - 1;\n  OD;\nELIHW;\nCF <- LSB(DEST);\nIF (COUNT & COUNTMASK) = 1\n  THEN OF <- MSB(DEST) XOR CF;\n  ELSE OF is undefined;\nFI;\n(* ROR instruction operation *)\ntempCOUNT <- (COUNT & COUNTMASK) MOD SIZE\nWHILE (tempCOUNT != 0)\n  DO\n     tempCF <- LSB(SRC);\n     DEST <- (DEST / 2) + (tempCF * 2SIZE);\n     tempCOUNT <- tempCOUNT - 1;\n  OD;\nELIHW;\nCF <- MSB(DEST);\nIF (COUNT & COUNTMASK) = 1\n  THEN OF <- MSB(DEST) XOR MSB \u2212 1(DEST);\n  ELSE OF is undefined;\nFI;\n\nFlags Affected:\nThe CF flag contains the value of the bit shifted into it. The OF flag is affected\nonly for single-bit rotates (see \u201cDescription\u201d above); it is undefined for multi-bit\nrotates. The SF, ZF, AF, and PF flags are not affected.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the source operand is located in       \n|                | a non-writable segment. If a memory       \n|                | operand effective address is outside      \n|                | the CS, DS, ES, FS, or GS segment limit.  \n|                | If the DS, ES, FS, or GS register contains\n|                | a NULL segment selector.                  \n| #SS(0)         | If a memory operand effective address     \n|                | is outside the SS segment limit.          \n| #PF(fault-code)| If a page fault occurs.                   \n| #AC(0)         | If alignment checking is enabled and      \n|                | an unaligned memory reference is made     \n|                | while the current privilege level is      \n|                | 3.                                        \n| #UD            | If the LOCK prefix is used.               \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the   \n|                | SS segment is in a non-canonical form.\n| #GP(0)         | If the source operand is located in   \n|                | a nonwritable segment. If the memory  \n|                | address is in a non-canonical form.   \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made \n|                | while the current privilege level is  \n|                | 3.                                    \n| #UD            | If the LOCK prefix is used.           \n", 
      "mnem": "RCL"
    }, 
    {
      "description": "\nRCPPS - Compute Reciprocals of Packed Single-Precision Floating-Point Values:\n| Opcode*/Instruction                        | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                  \n| 0F 53 /r RCPPS xmm1, xmm2/m128             | RM   | V/V                   | SSE               | Computes the approximate reciprocals         \n|                                            |      |                       |                   | of the packed single-precision floating-point\n|                                            |      |                       |                   | values in xmm2/m128 and stores the results   \n|                                            |      |                       |                   | in xmm1.                                     \n| VEX.128.0F.WIG 53 /r VRCPPS xmm1, xmm2/m128| RM   | V/V                   | AVX               | Computes the approximate reciprocals         \n|                                            |      |                       |                   | of packed single-precision values in         \n|                                            |      |                       |                   | xmm2/mem and stores the results in xmm1.     \n| VEX.256.0F.WIG 53 /r VRCPPS ymm1, ymm2/m256| RM   | V/V                   | AVX               | Computes the approximate reciprocals         \n|                                            |      |                       |                   | of packed single-precision values in         \n|                                            |      |                       |                   | ymm2/mem and stores the results in ymm1.     \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nPerforms a SIMD computation of the approximate reciprocals of the four packed\nsingle-precision floating-point values in the source operand (second operand)\nstores the packed single-precision floating-point results in the destination\noperand. The source operand can be an XMM register or a 128-bit memory location.\nThe destination operand is an XMM register. See Figure 10-5 in the Intel\u00ae 64\nand IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration\nof a SIMD single-precision floating-point operation.\n\nThe relative error for this approximation is:\n\n|Relative Error| \u2264 1.5 * 2\u221212\n\nThe RCPPS instruction is not affected by the rounding control bits in the MXCSR\nregister. When a source value is a 0.0, an \u221e of the sign of the source value\nis returned. A denormal source value is treated as a 0.0 (of the same sign).\nTiny results are always flushed to 0.0, with the sign of the operand. (Input\nvalues greater than or equal to |1.11111111110100000000000B*2125| are guaranteed\nto not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2126|\nare guaranteed to produce tiny results, which are in turn flushed to 0.0; and\ninput values in between this range may or may not produce tiny results, depending\non the implementation.) When a source value is an SNaN or QNaN, the SNaN is\nconverted to a QNaN or the source QNaN is returned.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed. VEX.256 encoded version:\nThe first source operand is a YMM register. The second source operand can be\na YMM register or a 256-bit memory location. The destination operand is a YMM\nregister. Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b,\notherwise instructions will #UD.\n\nOperation:\n\nRCPPS (128-bit Legacy SSE version)\nDEST[31:0] <- APPROXIMATE(1/SRC[31:0])\nDEST[63:32] <- APPROXIMATE(1/SRC[63:32])\nDEST[95:64] <- APPROXIMATE(1/SRC[95:64])\nDEST[127:96] <- APPROXIMATE(1/SRC[127:96])\nDEST[VLMAX-1:128] (Unmodified)\nVRCPPS (VEX.128 encoded version)\nDEST[31:0] <- APPROXIMATE(1/SRC[31:0])\nDEST[63:32] <- APPROXIMATE(1/SRC[63:32])\nDEST[95:64] <- APPROXIMATE(1/SRC[95:64])\nDEST[127:96] <- APPROXIMATE(1/SRC[127:96])\nDEST[VLMAX-1:128] <- 0\nVRCPPS (VEX.256 encoded version)\nDEST[31:0] <- APPROXIMATE(1/SRC[31:0])\nDEST[63:32] <- APPROXIMATE(1/SRC[63:32])\nDEST[95:64] <- APPROXIMATE(1/SRC[95:64])\nDEST[127:96] <- APPROXIMATE(1/SRC[127:96])\nDEST[159:128] <- APPROXIMATE(1/SRC[159:128])\nDEST[191:160] <- APPROXIMATE(1/SRC[191:160])\nDEST[223:192] <- APPROXIMATE(1/SRC[223:192])\nDEST[255:224] <- APPROXIMATE(1/SRC[255:224])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| RCCPS:| __m128 _mm_rcp_ps(__m128 a)     \n| RCPPS:| __m256 _mm256_rcp_ps (__m256 a);\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "RCPPS"
    }, 
    {
      "description": "\nRCPSS - Compute Reciprocal of Scalar Single-Precision Floating-Point Values:\n| Opcode*/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                  \n| F3 0F 53 /r RCPSS xmm1, xmm2/m32        | RM   | V/V                   | SSE               | Computes the approximate reciprocal          \n|                                         |      |                       |                   | of the scalar single-precision floating-point\n|                                         |      |                       |                   | value in xmm2/m32 and stores the result      \n|                                         |      |                       |                   | in xmm1.                                     \n| VEX.NDS.LIG.F3.0F.WIG 53 /r VRCPSS xmm1,| RVM  | V/V                   | AVX               | Computes the approximate reciprocal          \n| xmm2, xmm3/m32                          |      |                       |                   | of the scalar single-precision floating-point\n|                                         |      |                       |                   | value in xmm3/m32 and stores the result      \n|                                         |      |                       |                   | in xmm1. Also, upper single precision        \n|                                         |      |                       |                   | floating-point values (bits[127:32])         \n|                                         |      |                       |                   | from xmm2 are copied to xmm1[127:32].        \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nComputes of an approximate reciprocal of the low single-precision floating-point\nvalue in the source operand (second operand) and stores the single-precision\nfloating-point result in the destination operand. The source operand can be\nan XMM register or a 32-bit memory location. The destination operand is an XMM\nregister. The three high-order doublewords of the destination operand remain\nunchanged. See Figure 10-6 in the Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1, for an illustration of a scalar single-precision\nfloatingpoint operation.\n\nThe relative error for this approximation is:\n\n|Relative Error| \u2264 1.5 * 2\u221212\n\nThe RCPSS instruction is not affected by the rounding control bits in the MXCSR\nregister. When a source value is a 0.0, an \u221e of the sign of the source value\nis returned. A denormal source value is treated as a 0.0 (of the same sign).\nTiny results are always flushed to 0.0, with the sign of the operand. (Input\nvalues greater than or equal to |1.11111111110100000000000B*2125| are guaranteed\nto not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2126|\nare guaranteed to produce tiny results, which are in turn flushed to 0.0; and\ninput values in between this range may or may not produce tiny results, depending\non the implementation.) When a source value is an SNaN or QNaN, the SNaN is\nconverted to a QNaN or the source QNaN is returned.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nfirst source operand and the destination operand are the same. Bits (VLMAX1:32)\nof the corresponding YMM destination register remain unchanged. VEX.128 encoded\nversion: Bits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nOperation:\n\nRCPSS (128-bit Legacy SSE version)\nDEST[31:0] <- APPROXIMATE(1/SRC[31:0])\nDEST[VLMAX-1:32] (Unmodified)\nVRCPSS (VEX.128 encoded version)\nDEST[31:0] <- APPROXIMATE(1/SRC2[31:0])\nDEST[127:32] <- SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| RCPSS:| __m128 _mm_rcp_ss(__m128 a)\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5.\n\n", 
      "mnem": "RCPSS"
    }, 
    {
      "description": "-R:RCL", 
      "mnem": "RCR"
    }, 
    {
      "description": "\nRDFSBASE/RDGSBASE - Read FS/GS Segment Base:\n| Opcode/Instruction              | Op/En| 64/32bit Mode| CPUID Feature Flag| Description                         \n| F3 0F AE /0 RDFSBASE r32        | M    | V/I          | FSGSBASE          | Load the 32-bit destination register\n|                                 |      |              |                   | with the FS base address.           \n| REX.W + F3 0F AE /0 RDFSBASE r64| M    | V/I          | FSGSBASE          | Load the 64-bit destination register\n|                                 |      |              |                   | with the FS base address.           \n| F3 0F AE /1 RDGSBASE r32        | M    | V/I          | FSGSBASE          | Load the 32-bit destination register\n|                                 |      |              |                   | with the GS base address.           \n| REX.W + F3 0F AE /1 RDGSBASE r64| M    | V/I          | FSGSBASE          | Load the 64-bit destination register\n|                                 |      |              |                   | with the GS base address.           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nLoads the general-purpose register indicated by the modR/M:r/m field with the\nFS or GS segment base address.\n\nThe destination operand may be either a 32-bit or a 64-bit general-purpose register.\nThe REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is\nused, the operand size is 32 bits; the upper 32 bits of the source base address\n(for FS or GS) are ignored and upper 32 bits of the destination register are\ncleared. This instruction is supported only in 64-bit mode.\n\nOperation:\n\nDEST <- FS/GS segment base address;\n\nFlags Affected:\nNone\n\n\nC/C++ Compiler Intrinsic Equivalent:\n| RDFSBASE:| unsigned int _readfsbase_u32(void ); \n| RDFSBASE:| unsigned __int64 _readfsbase_u64(void\n|          | );                                   \n| RDGSBASE:| unsigned int _readgsbase_u32(void ); \n| RDGSBASE:| unsigned __int64 _readgsbase_u64(void\n|          | );                                   \n\nProtected Mode Exceptions:\n| #UD| The RDFSBASE and RDGSBASE instructions\n|    | are not recognized in protected mode. \n\nReal-Address Mode Exceptions:\n| #UD| The RDFSBASE and RDGSBASE instructions  \n|    | are not recognized in real-address mode.\n\nVirtual-8086 Mode Exceptions:\n| #UD| The RDFSBASE and RDGSBASE instructions  \n|    | are not recognized in virtual-8086 mode.\n\nCompatibility Mode Exceptions:\n| #UD| The RDFSBASE and RDGSBASE instructions\n|    | are not recognized in compatibility   \n|    | mode.                                 \n\n64-Bit Mode Exceptions:\n| #UD| If the LOCK prefix is used. If CR4.FSGSBASE[bit\n|    | 16] = 0. If CPUID.07H.0H:EBX.FSGSBASE[bit      \n|    | 0] = 0.                                        \n", 
      "mnem": "RDFSBASE"
    }, 
    {
      "description": "-R:RDFSBASE", 
      "mnem": "RDGSBASE"
    }, 
    {
      "description": "\nRDMSR - Read from Model Specific Register:\n| Opcode*| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                            \n| 0F 32  | RDMSR      | NP   | Valid      | Valid          | Read MSR specified by ECX into EDX:EAX.\nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nReads the contents of a 64-bit model specific register (MSR) specified in the\nECX register into registers EDX:EAX. (On processors that support the Intel 64\narchitecture, the high-order 32 bits of RCX are ignored.) The EDX register is\nloaded with the high-order 32 bits of the MSR and the EAX register is loaded\nwith the low-order 32 bits. (On processors that support the Intel 64 architecture,\nthe high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64\nbits are implemented in the MSR being read, the values returned to EDX:EAX in\nunimplemented bit locations are undefined.\n\nThis instruction must be executed at privilege level 0 or in real-address mode;\notherwise, a general protection exception #GP(0) will be generated. Specifying\na reserved or unimplemented MSR address in ECX will also cause a general protection\nexception.\n\nThe MSRs control functions for testability, execution tracing, performance-monitoring,\nand machine check errors. Chapter 35, \u201cModel-Specific Registers (MSRs),\u201d in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 3C,\nlists all the MSRs that can be read with this instruction and their addresses.\nNote that each processor family has its own set of MSRs.\n\nThe CPUID instruction should be used to determine whether MSRs are supported\n(CPUID.01H:EDX[5] = 1) before using this instruction.\n\n\nIA-32 Architecture Compatibility:\nThe MSRs and the ability to read them with the RDMSR instruction were introduced\ninto the IA-32 Architecture with the Pentium processor. Execution of this instruction\nby an IA-32 processor earlier than the Pentium processor results in an invalid\nopcode exception #UD.\n\nSee \u201cChanges to Instruction Behavior in VMX Non-Root Operation\u201d in Chapter 25\nof the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n3C, for more information about the behavior of this instruction in VMX non-root\noperation.\n\nOperation:\n\nEDX:EAX <- MSR[ECX];\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the current privilege level is not      \n|       | 0. If the value in ECX specifies a reserved\n|       | or unimplemented MSR address.              \n| #UD   | If the LOCK prefix is used.                \n\nReal-Address Mode Exceptions:\n| #GP| If the value in ECX specifies a reserved\n|    | or unimplemented MSR address.           \n| #UD| If the LOCK prefix is used.             \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| The RDMSR instruction is not recognized\n|       | in virtual-8086 mode.                  \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "RDMSR"
    }, 
    {
      "description": "\nRDPMC - Read Performance-Monitoring Counters:\n| Opcode*| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                        \n| 0F 33  | RDPMC      | NP   | Valid      | Valid          | Read performance-monitoring counter\n|        |            |      |            |                | specified by ECX into EDX:EAX.     \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nThe EAX register is loaded with the low-order 32 bits. The EDX register is loaded\nwith the supported high-order bits of the counter. The number of high-order\nbits loaded into EDX is implementation specific on processors that do no support\narchitectural performance monitoring. The width of fixed-function and general-purpose\nperformance counters on processors supporting architectural performance monitoring\nare reported by CPUID 0AH leaf. See below for the treatment of the EDX register\nfor \u201cfast\u201d reads.\n\nThe ECX register selects one of two type of performance counters, specifies\nthe index relative to the base of each counter type, and selects \u201cfast\u201d read\nmode if supported. The two counter types are :\n\n - General-purpose or special-purpose performance counters: The number of general-purpose\ncounters is model specific if the processor does not support architectural performance\nmonitoring, see Chapter 30 of Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3B. Special-purpose counters are available only in selected processor\nmembers, see Section 30.13, 30.14 of Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 3B. This counter type is selected if ECX[30] is clear.\n - Fixed-function performance counter. The number fixed-function performance counters\nis enumerated by CPUID 0AH leaf. See Chapter 30 of Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 3B. This counter type is selected if ECX[30]\nis set.\n\nECX[29:0] specifies the index. The width of general-purpose performance counters\nare 40-bits for processors that do not support architectural performance monitoring\ncounters.The width of special-purpose performance counters are implementation\nspecific. The width of fixed-function performance counters and general-purpose\nperformance counters on processor supporting architectural performance monitoring\nare reported by CPUID 0AH leaf.\n\nTable 4-12 lists valid indices of the general-purpose and special-purpose performance\ncounters according to the derived DisplayFamily_DisplayModel values of CPUID\nencoding for each processor family (see CPUID instruction in Chapter 3, \u201cInstruction\nSet Reference, A-M\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 2A).\n\n\nTable 4-12. Valid General and Special Purpose Performance Counter Index Range for RDPMC:\n| Processor Family                            | DisplayFamily_DisplayModel/Other Signatures| Valid PMC Index Range| General-purpose Counters\n| P6                                          | 06H_01H, 06H_03H, 06H_05H, 06H_06H,        | 0, 1                 | 0, 1                    \n|                                             | 06H_07H, 06H_08H, 06H_0AH, 06H_0BH         |                      |                         \n| Pentium\u00ae 4, Intel\u00ae Xeon processors          | 0FH_00H, 0FH_01H, 0FH_02H                  | \u2265 0 and \u2264 17         | \u2265 0 and \u2264 17            \n| Pentium 4, Intel Xeon processors            | (0FH_03H, 0FH_04H, 0FH_06H) and (L3        | \u2265 0 and \u2264 17         | \u2265 0 and \u2264 17            \n|                                             | is absent)                                 |                      |                         \n| Pentium M processors                        | 06H_09H, 06H_0DH                           | 0, 1                 | 0, 1                    \n| 64-bit Intel Xeon processors with L3        | 0FH_03H, 0FH_04H) and (L3 is present)      | \u2265 0 and \u2264 25         | \u2265 0 and \u2264 17            \n| Intel\u00ae Core\u2122 Solo and Intel\u00ae Core\u2122 Duo      | 06H_0EH Valid General and Special Purpose  | 0, 1                 | 0, 1                    \n| processors, Dual-core Intel\u00ae Xeon\u00ae processor| Performance Counter Index Range for        |                      |                         \n| LV Table 4-12.                              | RDPMC (Contd.)                             |                      |                         \n| Processor Family                            | DisplayFamily_DisplayModel/Other Signatures| Valid PMC Index Range| General-purpose Counters\n| Intel\u00ae Core\u21222 Duo processor, Intel Xeon     | 06H_0FH                                    | 0, 1                 | 0, 1                    \n| processor                                   |                                            |                      |                         \n3000, 5100, 5300, 7300 Series - general-purpose PMC\n\n| Intel Xeon processors 7100 series with       | (0FH_06H) and (L3 is present)     | \u2265 0 and \u2264 25| \u2265 0 and \u2264 17\n| L3                                           |                                   |             |             \n| Intel\u00ae Core\u21222 Duo processor family,          | 06H_17H                           | 0, 1        | 0, 1        \n| Intel Xeon processor family - general-purpose|                                   |             |             \n| PMC                                          |                                   |             |             \n| Intel Xeon processors 7400 series            | (06H_1DH)                         | \u2265 0 and \u2264 9 | 0, 1        \n| Intel\u00ae Atom\u2122 processor family                | 06H_1CH                           | 0, 1        | 0, 1        \n| Intel\u00ae Core\u2122i7 processor, Intel Xeon         | 06H_1AH, 06H_1EH, 06H_1FH, 06H_2EH| 0-3         | 0, 1, 2, 3  \n| processors 5500 series                       |                                   |             |             \nThe Pentium 4 and Intel Xeon processors also support \u201cfast\u201d (32-bit) and \u201cslow\u201d\n(40-bit) reads on the first 18 performance counters. Selected this option using\nECX[31]. If bit 31 is set, RDPMC reads only the low 32 bits of the selected\nperformance counter. If bit 31 is clear, all 40 bits are read. A 32-bit result\nis returned in EAX and EDX is set to 0. A 32-bit read executes faster on Pentium\n4 processors and Intel Xeon processors than a full 40-bit read.\n\nOn 64-bit Intel Xeon processors with L3, performance counters with indices 18-25\nare 32-bit counters. EDX is cleared after executing RDPMC for these counters.\nOn Intel Xeon processor 7100 series with L3, performance counters with indices\n18-25 are also 32-bit counters.\n\nIn Intel Core 2 processor family, Intel Xeon processor 3000, 5100, 5300 and\n7400 series, the fixed-function performance counters are 40-bits wide; they\ncan be accessed by RDMPC with ECX between from 4000_0000H and 4000_0002H.\n\nOn Intel Xeon processor 7400 series, there are eight 32-bit special-purpose\ncounters addressable with indices 2-9, ECX[30]=0.\n\nWhen in protected or virtual 8086 mode, the performance-monitoring counters\nenabled (PCE) flag in register CR4 restricts the use of the RDPMC instruction\nas follows. When the PCE flag is set, the RDPMC instruction can be executed\nat any privilege level; when the flag is clear, the instruction can only be\nexecuted at privilege level 0. (When in real-address mode, the RDPMC instruction\nis always enabled.)\n\nThe performance-monitoring counters can also be read with the RDMSR instruction,\nwhen executing at privilege level 0.\n\nThe performance-monitoring counters are event counters that can be programmed\nto count events such as the number of instructions decoded, number of interrupts\nreceived, or number of cache loads. Chapter 19, \u201cPerformance Monitoring Events,\u201d\nin the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n3B, lists the events that can be counted for various processors in the Intel\n64 and IA-32 architecture families.\n\nThe RDPMC instruction is not a serializing instruction; that is, it does not\nimply that all the events caused by the preceding instructions have been completed\nor that events caused by subsequent instructions have not begun. If an exact\nevent count is desired, software must insert a serializing instruction (such\nas the CPUID instruction) before and/or after the RDPMC instruction.\n\nIn the Pentium 4 and Intel Xeon processors, performing back-to-back fast reads\nare not guaranteed to be monotonic. To guarantee monotonicity on back-to-back\nreads, a serializing instruction must be placed between the two RDPMC instructions.\n\nThe RDPMC instruction can execute in 16-bit addressing mode or virtual-8086\nmode; however, the full contents of the ECX register are used to select the\ncounter, and the event count is stored in the full EAX and EDX registers. The\nRDPMC instruction was introduced into the IA-32 Architecture in the Pentium\nPro processor and the Pentium processor with MMX technology. The earlier Pentium\nprocessors have performance-monitoring counters, but they must be read with\nthe RDMSR instruction.\n\nOperation:\n\n(* Intel Core i7 processor family and Intel Xeon processor 3400, 5500 series*)\nMost significant counter bit (MSCB) = 47\nIF ((CR4.PCE = 1) or (CPL = 0) or (CR0.PE = 0))\n  THEN IF (ECX[30] = 1 and ECX[29:0] in valid fixed-counter range)\n     EAX <- IA32_FIXED_CTR(ECX)[30:0];\n     EDX <- IA32_FIXED_CTR(ECX)[MSCB:32];\n  ELSE IF (ECX[30] = 0 and ECX[29:0] in valid general-purpose counter range)\n     EAX <- PMC(ECX[30:0])[31:0];\n     EDX <- PMC(ECX[30:0])[MSCB:32];\n  ELSE (* ECX is not valid or CR4.PCE is 0 and CPL is 1, 2, or 3 and CR0.PE is 1 *)\n     #GP(0);\nFI;\n(* Intel Core 2 Duo processor family and Intel Xeon processor 3000, 5100, 5300, 7400 series*)\nMost significant counter bit (MSCB) = 39\nIF ((CR4.PCE = 1) or (CPL = 0) or (CR0.PE = 0))\n  THEN IF (ECX[30] = 1 and ECX[29:0] in valid fixed-counter range)\n     EAX <- IA32_FIXED_CTR(ECX)[30:0];\n     EDX <- IA32_FIXED_CTR(ECX)[MSCB:32];\n  ELSE IF (ECX[30] = 0 and ECX[29:0] in valid general-purpose counter range)\n     EAX <- PMC(ECX[30:0])[31:0];\n     EDX <- PMC(ECX[30:0])[MSCB:32];\n  ELSE IF (ECX[30] = 0 and ECX[29:0] in valid special-purpose counter range)\n     EAX <- PMC(ECX[30:0])[31:0]; (* 32-bit read *)\n  ELSE (* ECX is not valid or CR4.PCE is 0 and CPL is 1, 2, or 3 and CR0.PE is 1 *)\n     #GP(0);\nFI;\n(* P6 family processors and Pentium processor with MMX technology *)\nIF (ECX = 0 or 1) and ((CR4.PCE = 1) or (CPL = 0) or (CR0.PE = 0))\n  THEN\n     EAX <- PMC(ECX)[31:0];\n     EDX <- PMC(ECX)[39:32];\n  ELSE (* ECX is not 0 or 1 or CR4.PCE is 0 and CPL is 1, 2, or 3 and CR0.PE is 1 *)\n     #GP(0);\nFI;\n(* Processors with CPUID family 15 *)\nIF ((CR4.PCE = 1) or (CPL = 0) or (CR0.PE = 0))\n  THEN IF (ECX[30:0] = 0:17)\n     THEN IF ECX[31] = 0\n       THEN\n          EAX <- PMC(ECX[30:0])[31:0]; (* 40-bit read *)\n          EDX <- PMC(ECX[30:0])[39:32];\n     ELSE (* ECX[31] = 1*)\n       THEN\n          EAX <- PMC(ECX[30:0])[31:0]; (* 32-bit read *)\n          EDX <- 0;\n     FI;\n  ELSE IF (*64-bit Intel Xeon processor with L3 *)\n     THEN IF (ECX[30:0] = 18:25 )\n       EAX <- PMC(ECX[30:0])[31:0]; (* 32-bit read *)\n       EDX <- 0;\n     FI;\n  ELSE IF (*Intel Xeon processor 7100 series with L3 *)\n     THEN IF (ECX[30:0] = 18:25 )\n       EAX <- PMC(ECX[30:0])[31:0]; (* 32-bit read *)\n       EDX <- 0;\n     FI;\n  ELSE (* Invalid PMC index in ECX[30:0], see Table 4-15. *)\n     GP(0);\n  FI;\nELSE\n  #GP(0);\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the current privilege level is not       \n|       | 0 and the PCE flag in the CR4 register      \n|       | is clear. If an invalid performance         \n|       | counter index is specified (see Table       \n|       | 4-12). (Pentium 4 and Intel Xeon processors)\n|       | If the value in ECX[30:0] is not within     \n|       | the valid range.                            \n| #UD   | If the LOCK prefix is used.                 \n\nReal-Address Mode Exceptions:\n| #GP| If an invalid performance counter index\n|    | is specified (see Table 4-12). (Pentium\n|    | 4 and Intel Xeon processors) If the    \n|    | value in ECX[30:0] is not within the   \n|    | valid range.                           \n| #UD| If the LOCK prefix is used.            \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| If the PCE flag in the CR4 register         \n|       | is clear. If an invalid performance         \n|       | counter index is specified (see Table       \n|       | 4-12). (Pentium 4 and Intel Xeon processors)\n|       | If the value in ECX[30:0] is not within     \n|       | the valid range.                            \n| #UD   | If the LOCK prefix is used.                 \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)| If the current privilege level is not  \n|       | 0 and the PCE flag in the CR4 register \n|       | is clear. If an invalid performance    \n|       | counter index is specified in ECX[30:0]\n|       | (see Table 4-12).                      \n| #UD   | If the LOCK prefix is used.            \n", 
      "mnem": "RDPMC"
    }, 
    {
      "description": "\nRDRAND - Read Random Number:\n| Opcode*/Instruction        | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                          \n| 0F C7 /6 RDRAND r16        | M    | V/V                   | RDRAND            | Read a 16-bit random number and store\n|                            |      |                       |                   | in the destination register.         \n| 0F C7 /6 RDRAND r32        | M    | V/V                   | RDRAND            | Read a 32-bit random number and store\n|                            |      |                       |                   | in the destination register.         \n| REX.W + 0F C7 /6 RDRAND r64| M    | V/I                   | RDRAND            | Read a 64-bit random number and store\n|                            |      |                       |                   | in the destination register.         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nLoads a hardware generated random value and store it in the destination register.\nThe size of the random value is determined by the destination register size\nand operating mode. The Carry Flag indicates whether a random value is available\nat the time the instruction is executed. CF=1 indicates that the data in the\ndestination is valid. Otherwise CF=0 and the data in the destination operand\nwill be returned as zeros for the specified width. All other flags are forced\nto 0 in either situation. Software must check the state of CF=1 for determining\nif a valid random value has been returned, otherwise it is expected to loop\nand retry execution of RDRAND (see Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1, Section 7.3.17, \u201cRandom Number Generator Instruction\u201d).\nThis instruction is available at all privilege levels. In 64-bit mode, the instruction's\ndefault operation size is 32 bits. Using a REX prefix in the form of REX.B permits\naccess to additional registers (R8-R15). Using a REX prefix in the form of REX.W\npromotes operation to 64 bit operands. See the summary chart at the beginning\nof this section for encoding data and limits.\n\nOperation:\n\nIF HW_RND_GEN.ready = 1\n  THEN\n     CASE of\n       osize is 64: DEST[63:0] <- HW_RND_GEN.data;\n       osize is 32: DEST[31:0] <- HW_RND_GEN.data;\n       osize is 16: DEST[15:0] <- HW_RND_GEN.data;\n     ESAC\n     CF <- 1;\n  ELSE\n     CASE of\n       osize is 64: DEST[63:0] <- 0;\n       osize is 32: DEST[31:0] <- 0;\n       osize is 16: DEST[15:0] <- 0;\n     ESAC\n     CF <- 0;\nFI\nOF, SF, ZF, AF, PF <- 0;\n\nFlags Affected:\nThe CF flag is set according to the result (see the \u201cOperation\u201d section above).\nThe OF, SF, ZF, AF, and PF flags are set to 0.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| RDRAND:| int _rdrand16_step( unsigned short * \n|        | );                                   \n| RDRAND:| int _rdrand32_step( unsigned int * );\n| RDRAND:| int _rdrand64_step( unsigned __int64 \n|        | *);                                  \n\nProtected Mode Exceptions:\n| #UD| If the LOCK prefix is used. If the F2H            \n|    | or F3H prefix is used. If CPUID.01H:ECX.RDRAND[bit\n|    | 30] = 0.                                          \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "RDRAND"
    }, 
    {
      "description": "\nRDTSC - Read Time-Stamp Counter:\n| Opcode*| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F 31  | RDTSC      | NP   | Valid      | Valid          | Read time-stamp counter into EDX:EAX.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nLoads the current value of the processor's time-stamp counter (a 64-bit MSR)\ninto the EDX:EAX registers. The EDX register is loaded with the high-order 32\nbits of the MSR and the EAX register is loaded with the low-order 32 bits. (On\nprocessors that support the Intel 64 architecture, the high-order 32 bits of\neach of RAX and RDX are cleared.)\n\nThe processor monotonically increments the time-stamp counter MSR every clock\ncycle and resets it to 0 whenever the processor is reset. See \u201cTime Stamp Counter\u201d\nin Chapter 17 of the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3B, for specific details of the time stamp counter behavior.\n\nWhen in protected or virtual 8086 mode, the time stamp disable (TSD) flag in\nregister CR4 restricts the use of the RDTSC instruction as follows. When the\nTSD flag is clear, the RDTSC instruction can be executed at any privilege level;\nwhen the flag is set, the instruction can only be executed at privilege level\n0. (When in real-address mode, the RDTSC instruction is always enabled.)\n\nThe time-stamp counter can also be read with the RDMSR instruction, when executing\nat privilege level 0.\n\nThe RDTSC instruction is not a serializing instruction. It does not necessarily\nwait until all previous instructions have been executed before reading the counter.\nSimilarly, subsequent instructions may begin execution before the read operation\nis performed. If software requires RDTSC to be executed only after all previous\ninstructions have completed locally, it can either use RDTSCP (if the processor\nsupports that instruction) or execute the sequence LFENCE;RDTSC.\n\nThis instruction was introduced by the Pentium processor.\n\nSee \u201cChanges to Instruction Behavior in VMX Non-Root Operation\u201d in Chapter 25\nof the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n3C, for more information about the behavior of this instruction in VMX non-root\noperation.\n\nOperation:\n\nIF (CR4.TSD = 0) or (CPL = 0) or (CR0.PE = 0)\n  THEN EDX:EAX <- TimeStampCounter;\n  ELSE (* CR4.TSD = 1 and (CPL = 1, 2, or 3) and CR0.PE = 1 *)\n     #GP(0);\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the TSD flag in register CR4 is set\n|       | and the CPL is greater than 0.        \n| #UD   | If the LOCK prefix is used.           \n\nReal-Address Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| If the TSD flag in register CR4 is set.\n| #UD   | If the LOCK prefix is used.            \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "RDTSC"
    }, 
    {
      "description": "\nRDTSCP - Read Time-Stamp Counter and Processor ID:\n| Opcode* | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                              \n| 0F 01 F9| RDTSCP     | NP   | Valid      | Valid          | Read 64-bit time-stamp counter and 32-bit\n|         |            |      |            |                | IA32_TSC_AUX value into EDX:EAX and      \n|         |            |      |            |                | ECX.                                     \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nLoads the current value of the processor's time-stamp counter (a 64-bit MSR)\ninto the EDX:EAX registers and also loads the IA32_TSC_AUX MSR (address C000_0103H)\ninto the ECX register. The EDX register is loaded with the high-order 32 bits\nof the IA32_TSC MSR; the EAX register is loaded with the low-order 32 bits of\nthe IA32_TSC MSR; and the ECX register is loaded with the low-order 32-bits\nof IA32_TSC_AUX MSR. On processors that support the Intel 64 architecture, the\nhigh-order 32 bits of each of RAX, RDX, and RCX are cleared.\n\nThe processor monotonically increments the time-stamp counter MSR every clock\ncycle and resets it to 0 whenever the processor is reset. See \u201cTime Stamp Counter\u201d\nin Chapter 17 of the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3B, for specific details of the time stamp counter behavior.\n\nWhen in protected or virtual 8086 mode, the time stamp disable (TSD) flag in\nregister CR4 restricts the use of the RDTSCP instruction as follows. When the\nTSD flag is clear, the RDTSCP instruction can be executed at any privilege level;\nwhen the flag is set, the instruction can only be executed at privilege level\n0. (When in real-address mode, the RDTSCP instruction is always enabled.)\n\nThe RDTSCP instruction waits until all previous instructions have been executed\nbefore reading the counter.\n\n| However, The presence of the RDTSCP       | subsequent instructions may begin execution\n| instruction is indicated by CPUID leaf    | before the read operation is performed.    \n| 80000001H, EDX bit 27. If the bit is      |                                            \n| set to 1 then RDTSCP is present on the    |                                            \n| processor. See \u201cChanges to Instruction    |                                            \n| Behavior in VMX Non-Root Operation\u201d       |                                            \n| in Chapter 25 of the Intel\u00ae 64 and IA-32  |                                            \n| Architectures Software Developer's Manual,|                                            \n| Volume 3C, for more information about     |                                            \n| the behavior of this instruction in       |                                            \n| VMX non-root operation.                   |                                            \nOperation:\n\nIF (CR4.TSD = 0) or (CPL = 0) or (CR0.PE = 0)\n  THEN\n     EDX:EAX <- TimeStampCounter;\n     ECX <- IA32_TSC_AUX[31:0];\n  ELSE (* CR4.TSD = 1 and (CPL = 1, 2, or 3) and CR0.PE = 1 *)\n     #GP(0);\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the TSD flag in register CR4 is set                       \n|       | and the CPL is greater than 0.                               \n| #UD   | If the LOCK prefix is used. If CPUID.80000001H:EDX.RDTSCP[bit\n|       | 27] = 0.                                                     \n\nReal-Address Mode Exceptions:\n| #UD| If the LOCK prefix is used. If CPUID.80000001H:EDX.RDTSCP[bit\n|    | 27] = 0.                                                     \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| If the TSD flag in register CR4 is set.                      \n| #UD   | If the LOCK prefix is used. If CPUID.80000001H:EDX.RDTSCP[bit\n|       | 27] = 0.                                                     \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "RDTSCP"
    }, 
    {
      "description": "\nREP/REPE/REPZ/REPNE/REPNZ - Repeat String Operation Prefix:\n| Opcode     | Instruction        | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                  \n| F3 6C      | REP INS m8, DX     | NP   | Valid      | Valid          | Input (E)CX bytes from port DX into          \n|            |                    |      |            |                | ES:[(E)DI].                                  \n| F3 6C      | REP INS m8, DX     | NP   | Valid      | N.E.           | Input RCX bytes from port DX into [RDI].     \n| F3 6D      | REP INS m16, DX    | NP   | Valid      | Valid          | Input (E)CX words from port DX into          \n|            |                    |      |            |                | ES:[(E)DI.]                                  \n| F3 6D      | REP INS m32, DX    | NP   | Valid      | Valid          | Input (E)CX doublewords from port DX         \n|            |                    |      |            |                | into ES:[(E)DI].                             \n| F3 6D      | REP INS r/m32, DX  | NP   | Valid      | N.E.           | Input RCX default size from port DX          \n|            |                    |      |            |                | into [RDI].                                  \n| F3 A4      | REP MOVS m8, m8    | NP   | Valid      | Valid          | Move (E)CX bytes from DS:[(E)SI] to          \n|            |                    |      |            |                | ES:[(E)DI].                                  \n| F3 REX.W A4| REP MOVS m8, m8    | NP   | Valid      | N.E.           | Move RCX bytes from [RSI] to [RDI].          \n| F3 A5      | REP MOVS m16, m16  | NP   | Valid      | Valid          | Move (E)CX words from DS:[(E)SI] to          \n|            |                    |      |            |                | ES:[(E)DI].                                  \n| F3 A5      | REP MOVS m32, m32  | NP   | Valid      | Valid          | Move (E)CX doublewords from DS:[(E)SI]       \n|            |                    |      |            |                | to ES:[(E)DI].                               \n| F3 REX.W A5| REP MOVS m64, m64  | NP   | Valid      | N.E.           | Move RCX quadwords from [RSI] to [RDI].      \n| F3 6E      | REP OUTS DX, r/m8  | NP   | Valid      | Valid          | Output (E)CX bytes from DS:[(E)SI] to        \n|            |                    |      |            |                | port DX.                                     \n| F3 REX.W 6E| REP OUTS DX, r/m8* | NP   | Valid      | N.E.           | Output RCX bytes from [RSI] to port          \n|            |                    |      |            |                | DX.                                          \n| F3 6F      | REP OUTS DX, r/m16 | NP   | Valid      | Valid          | Output (E)CX words from DS:[(E)SI] to        \n|            |                    |      |            |                | port DX.                                     \n| F3 6F      | REP OUTS DX, r/m32 | NP   | Valid      | Valid          | Output (E)CX doublewords from DS:[(E)SI]     \n|            |                    |      |            |                | to port DX.                                  \n| F3 REX.W 6F| REP OUTS DX, r/m32 | NP   | Valid      | N.E.           | Output RCX default size from [RSI] to        \n|            |                    |      |            |                | port DX.                                     \n| F3 AC      | REP LODS AL        | NP   | Valid      | Valid          | Load (E)CX bytes from DS:[(E)SI] to          \n|            |                    |      |            |                | AL.                                          \n| F3 REX.W AC| REP LODS AL        | NP   | Valid      | N.E.           | Load RCX bytes from [RSI] to AL.             \n| F3 AD      | REP LODS AX        | NP   | Valid      | Valid          | Load (E)CX words from DS:[(E)SI] to          \n|            |                    |      |            |                | AX.                                          \n| F3 AD      | REP LODS EAX       | NP   | Valid      | Valid          | Load (E)CX doublewords from DS:[(E)SI]       \n|            |                    |      |            |                | to EAX.                                      \n| F3 REX.W AD| REP LODS RAX       | NP   | Valid      | N.E.           | Load RCX quadwords from [RSI] to RAX.        \n| F3 AA      | REP STOS m8        | NP   | Valid      | Valid          | Fill (E)CX bytes at ES:[(E)DI] with          \n|            |                    |      |            |                | AL.                                          \n| F3 REX.W AA| REP STOS m8        | NP   | Valid      | N.E.           | Fill RCX bytes at [RDI] with AL.             \n| F3 AB      | REP STOS m16       | NP   | Valid      | Valid          | Fill (E)CX words at ES:[(E)DI] with          \n|            |                    |      |            |                | AX.                                          \n| F3 AB      | REP STOS m32       | NP   | Valid      | Valid          | Fill (E)CX doublewords at ES:[(E)DI]         \n|            |                    |      |            |                | with EAX.                                    \n| F3 REX.W AB| REP STOS m64       | NP   | Valid      | N.E.           | Fill RCX quadwords at [RDI] with RAX.        \n| F3 A6      | REPE CMPS m8, m8   | NP   | Valid      | Valid          | Find nonmatching bytes in ES:[(E)DI]         \n|            |                    |      |            |                | and DS:[(E)SI].                              \n| F3 REX.W A6| REPE CMPS m8, m8   | NP   | Valid      | N.E.           | Find non-matching bytes in [RDI] and         \n|            |                    |      |            |                | [RSI].                                       \n| F3 A7      | REPE CMPS m16, m16 | NP   | Valid      | Valid          | Find nonmatching words in ES:[(E)DI]         \n|            |                    |      |            |                | and DS:[(E)SI].                              \n| F3 A7      | REPE CMPS m32, m32 | NP   | Valid      | Valid          | Find nonmatching doublewords in ES:[(E)DI]and\n|            |                    |      |            |                | DS:[(E)SI].                                  \n| F3 REX.W A7| REPE CMPS m64, m64 | NP   | Valid      | N.E.           | Find non-matching quadwords in [RDI]         \n|            |                    |      |            |                | and [RSI].                                   \n| F3 AE      | REPE SCAS m8       | NP   | Valid      | Valid          | Find non-AL byte starting at ES:[(E)DI].     \n| F3 REX.W AE| REPE SCAS m8       | NP   | Valid      | N.E.           | Find non-AL byte starting at [RDI].          \n| F3 AF      | REPE SCAS m16      | NP   | Valid      | Valid          | Find non-AX word starting at ES:[(E)DI].     \n| F3 AF      | REPE SCAS m32      | NP   | Valid      | Valid          | Find non-EAX doubleword starting at          \n|            |                    |      |            |                | ES:[(E)DI].                                  \n| Opcode     | Instruction        | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                  \n| F3 REX.W AF| REPE SCAS m64      | NP   | Valid      | N.E.           | Find non-RAX quadword starting at [RDI].     \n| F2 A6      | REPNE CMPS m8, m8  | NP   | Valid      | Valid          | Find matching bytes in ES:[(E)DI] and        \n|            |                    |      |            |                | DS:[(E)SI].                                  \n| F2 REX.W A6| REPNE CMPS m8, m8  | NP   | Valid      | N.E.           | Find matching bytes in [RDI] and [RSI].      \n| F2 A7      | REPNE CMPS m16, m16| NP   | Valid      | Valid          | Find matching words in ES:[(E)DI] and        \n|            |                    |      |            |                | DS:[(E)SI].                                  \n| F2 A7      | REPNE CMPS m32, m32| NP   | Valid      | Valid          | Find matching doublewords in ES:[(E)DI]      \n|            |                    |      |            |                | and DS:[(E)SI].                              \n| F2 REX.W A7| REPNE CMPS m64, m64| NP   | Valid      | N.E.           | Find matching doublewords in [RDI] and       \n|            |                    |      |            |                | [RSI].                                       \n| F2 AE      | REPNE SCAS m8      | NP   | Valid      | Valid          | Find AL, starting at ES:[(E)DI].             \n| F2 REX.W AE| REPNE SCAS m8      | NP   | Valid      | N.E.           | Find AL, starting at [RDI].                  \n| F2 AF      | REPNE SCAS m16     | NP   | Valid      | Valid          | Find AX, starting at ES:[(E)DI].             \n| F2 AF      | REPNE SCAS m32     | NP   | Valid      | Valid          | Find EAX, starting at ES:[(E)DI].            \n| F2 REX.W AF| REPNE SCAS m64     | NP   | Valid      | N.E.           | Find RAX, starting at [RDI].                 \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nRepeats a string instruction the number of times specified in the count register\nor until the indicated condition of the ZF flag is no longer met. The REP (repeat),\nREPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while\nzero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be\nadded to one of the string instructions. The REP prefix can be added to the\nINS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and\nREPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and\nREPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.)\nThe behavior of the REP prefix is undefined when used with non-string instructions.\n\nThe REP prefixes apply only to one string instruction at a time. To repeat a\nblock of instructions, use the LOOP instruction or another looping construct.\nAll of these repeat prefixes cause the associated instruction to be repeated\nuntil the count in register is decremented to 0. See Table 4-13.\n\n\nTable 4-13. Repeat Prefixes:\n| Repeat Prefix| Termination Condition 1*| Termination Condition 2\n| REP          | RCX or (E)CX = 0        | None                   \n| REPE/REPZ    | RCX or (E)CX = 0        | ZF = 0                 \n| REPNE/REPNZ  | RCX or (E)CX = 0        | ZF = 1                 \nNotes: * Count register is CX, ECX or RCX by default, depending on attributes\nof the operating modes.\n\nThe REPE, REPNE, REPZ, and REPNZ prefixes also check the state of the ZF flag\nafter each iteration and terminate the repeat loop if the ZF flag is not in\nthe specified state. When both termination conditions are tested, the cause\nof a repeat termination can be determined either by testing the count register\nwith a JECXZ instruction or by testing the ZF flag (with a JZ, JNZ, or JNE instruction).\n\nWhen the REPE/REPZ and REPNE/REPNZ prefixes are used, the ZF flag does not require\ninitialization because both the CMPS and SCAS instructions affect the ZF flag\naccording to the results of the comparisons they make.\n\nA repeating string operation can be suspended by an exception or interrupt.\nWhen this happens, the state of the registers is preserved to allow the string\noperation to be resumed upon a return from the exception or interrupt handler.\nThe source and destination registers point to the next string elements to be\noperated on, the EIP register points to the string instruction, and the ECX\nregister has the value it held following the last successful iteration of the\ninstruction. This mechanism allows long string operations to proceed without\naffecting the interrupt response time of the system.\n\nWhen a fault occurs during the execution of a CMPS or SCAS instruction that\nis prefixed with REPE or REPNE, the EFLAGS value is restored to the state prior\nto the execution of the instruction. Since the SCAS and CMPS instructions do\nnot use EFLAGS as an input, the processor can resume the instruction after the\npage fault handler.\n\nUse the REP INS and REP OUTS instructions with caution. Not all I/O ports can\nhandle the rate at which these instructions execute. Note that a REP STOS instruction\nis the fastest way to initialize a large block of memory.\n\nIn 64-bit mode, the operand size of the count register is associated with the\naddress size attribute. Thus the default count register is RCX; REX.W has no\neffect on the address size and the count register. In 64-bit mode, if 67H is\nused to override address size attribute, the count register is ECX and any implicit\nsource/destination operand will use the corresponding 32-bit index register.\nSee the summary chart at the beginning of this section for encoding data and\nlimits.\n\nOperation:\n\nIF AddressSize = 16\n THEN\n   Use CX for CountReg;\n   Implicit Source/Dest operand for memory use of SI/DI;\n ELSE IF AddressSize = 64\n   THEN Use RCX for CountReg;\n   Implicit Source/Dest operand for memory use of RSI/RDI;\n ELSE\n   Use ECX for CountReg;\n   Implicit Source/Dest operand for memory use of ESI/EDI;\nFI;\nWHILE CountReg != 0\n  DO\n     Service pending interrupts (if any);\n     Execute associated string instruction;\n     CountReg <- (CountReg - 1);\n     IF CountReg = 0\n       THEN exit WHILE loop; FI;\n     IF (Repeat prefix is REPZ or REPE) and (ZF = 0)\n     or (Repeat prefix is REPNZ or REPNE) and (ZF = 1)\n       THEN exit WHILE loop; FI;\n  OD;\n\nFlags Affected:\nNone; however, the CMPS and SCAS instructions do set the status flags in the\nEFLAGS register.\n\n\nExceptions (All Operating Modes):\nExceptions may be generated by an instruction associated with the prefix.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)| If the memory address is in a non-canonical\n|       | form.                                      \n", 
      "mnem": "REP"
    }, 
    {
      "description": "-R:REP", 
      "mnem": "REPE"
    }, 
    {
      "description": "-R:REP", 
      "mnem": "REPNE"
    }, 
    {
      "description": "-R:REP", 
      "mnem": "REPNZ"
    }, 
    {
      "description": "-R:REP", 
      "mnem": "REPZ"
    }, 
    {
      "description": "\nRET - Return from Procedure:\n| Opcode*| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                         \n| C3     | RET        | NP   | Valid      | Valid          | Near return to calling procedure.   \n| CB     | RET        | NP   | Valid      | Valid          | Far return to calling procedure.    \n| C2 iw  | RET imm16  | I    | Valid      | Valid          | Near return to calling procedure and\n|        |            |      |            |                | pop imm16 bytes from stack.         \n| CA iw  | RET imm16  | I    | Valid      | Valid          | Far return to calling procedure and \n|        |            |      |            |                | pop imm16 bytes from stack.         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n| I    | imm16    | NA       | NA       | NA       \n\nDescription:\nTransfers program control to a return address located on the top of the stack.\nThe address is usually placed on the stack by a CALL instruction, and the return\nis made to the instruction that follows the CALL instruction.\n\nThe optional source operand specifies the number of stack bytes to be released\nafter the return address is popped; the default is none. This operand can be\nused to release parameters from the stack that were passed to the called procedure\nand are no longer needed. It must be used when the CALL instruction used to\nswitch to a new procedure uses a call gate with a non-zero word count to access\nthe new procedure. Here, the source operand for the RET instruction must specify\nthe same number of bytes as is specified in the word count field of the call\ngate.\n\nThe RET instruction can be used to execute three different types of returns:\n\n - Near return  -  A return to a calling procedure within the current code segment\n(the segment currently pointed to by the CS register), sometimes referred to\nas an intrasegment return.\n - Far return  -  A return to a calling procedure located in a different segment\nthan the current code segment, sometimes referred to as an intersegment return.\n - Inter-privilege-level far return  -  A far return to a different privilege level\nthan that of the currently executing program or procedure.\n\nThe inter-privilege-level return type can only be executed in protected mode.\nSee the section titled \u201cCalling Procedures Using Call and RET\u201d in Chapter 6\nof the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1, for detailed information on near, far, and inter-privilege-level returns.\n\nWhen executing a near return, the processor pops the return instruction pointer\n(offset) from the top of the stack into the EIP register and begins program\nexecution at the new instruction pointer. The CS register is unchanged.\n\nWhen executing a far return, the processor pops the return instruction pointer\nfrom the top of the stack into the EIP register, then pops the segment selector\nfrom the top of the stack into the CS register. The processor then begins program\nexecution in the new code segment at the new instruction pointer.\n\nThe mechanics of an inter-privilege-level far return are similar to an intersegment\nreturn, except that the processor examines the privilege levels and access rights\nof the code and stack segments being returned to determine if the control transfer\nis allowed to be made. The DS, ES, FS, and GS segment registers are cleared\nby the RET instruction during an inter-privilege-level return if they refer\nto segments that are not allowed to be accessed at the new privilege level.\nSince a stack switch also occurs on an inter-privilege level return, the ESP\nand SS registers are loaded from the stack.\n\nIf parameters are passed to the called procedure during an inter-privilege level\ncall, the optional source operand must be used with the RET instruction to release\nthe parameters on the return. Here, the parameters are released both from the\ncalled procedure's stack and the calling procedure's stack (that is, the stack\nbeing returned to).\n\nIn 64-bit mode, the default operation size of this instruction is the stack-address\nsize, i.e. 64 bits.\n\nOperation:\n\n(* Near return *)\nIF instruction = near return\n  THEN;\n     IF OperandSize = 32\n       THEN\n          IF top 4 bytes of stack not within stack limits\n             THEN #SS(0); FI;\n          EIP <- Pop();\n       ELSE\n          IF OperandSize = 64\n             THEN\n               IF top 8 bytes of stack not within stack limits\n                  THEN #SS(0); FI;\n               RIP <- Pop();\n             ELSE (* OperandSize = 16 *)\n               IF top 2 bytes of stack not within stack limits\n                  THEN #SS(0); FI;\n               tempEIP <- Pop();\n               tempEIP <- tempEIP AND 0000FFFFH;\n               IF tempEIP not within code segment limits\n                  THEN #GP(0); FI;\n               EIP <- tempEIP;\n          FI;\n     FI;\n  IF instruction has immediate operand\n     THEN (* Release parameters from stack *)\n       IF StackAddressSize = 32\n          THEN\n             ESP <- ESP + SRC;\n          ELSE\n             IF StackAddressSize = 64\n               THEN\n                  RSP <- RSP + SRC;\n               ELSE (* StackAddressSize = 16 *)\n                  SP <- SP + SRC;\n             FI;\n       FI;\n  FI;\nFI;\n(* Real-address mode or virtual-8086 mode *)\nIF ((PE = 0) or (PE = 1 AND VM = 1)) and instruction = far return\n  THEN\n     IF OperandSize = 32\n       THEN\n          IF top 8 bytes of stack not within stack limits\n             THEN #SS(0); FI;\n          EIP <- Pop();\n          CS <- Pop(); (* 32-bit pop, high-order 16 bits discarded *)\n       ELSE (* OperandSize = 16 *)\n          IF top 4 bytes of stack not within stack limits\n             THEN #SS(0); FI;\n          tempEIP <- Pop();\n          tempEIP <- tempEIP AND 0000FFFFH;\n          IF tempEIP not within code segment limits\n             THEN #GP(0); FI;\n          EIP <- tempEIP;\n          CS <- Pop(); (* 16-bit pop *)\n     FI;\n  IF instruction has immediate operand\n     THEN (* Release parameters from stack *)\n       SP <- SP + (SRC AND FFFFH);\n  FI;\nFI;\n(* Protected mode, not virtual-8086 mode *)\nIF (PE = 1 and VM = 0 and IA32_EFER.LMA = 0) and instruction = far return\n  THEN\n     IF OperandSize = 32\n       THEN\n          IF second doubleword on stack is not within stack limits\n             THEN #SS(0); FI;\n       ELSE (* OperandSize = 16 *)\n          IF second word on stack is not within stack limits\n             THEN #SS(0); FI;\n     FI;\n  IF return code segment selector is NULL\n     THEN #GP(0); FI;\n  IF return code segment selector addresses descriptor beyond descriptor table limit\n     THEN #GP(selector); FI;\n  Obtain descriptor to which return code segment selector points from descriptor table;\n  IF return code segment descriptor is not a code segment\n     THEN #GP(selector); FI;\n  IF return code segment selector RPL < CPL\n     THEN #GP(selector); FI;\n  IF return code segment descriptor is conforming\n  and return code segment DPL > return code segment selector RPL\n     THEN #GP(selector); FI;\n  IF return code segment descriptor is non-conforming and return code\n  segment DPL != return code segment selector RPL\n     THEN #GP(selector); FI;\n  IF return code segment descriptor is not present\n     THEN #NP(selector); FI:\n  IF return code segment selector RPL > CPL\n     THEN GOTO RETURN-OUTER-PRIVILEGE-LEVEL;\n     ELSE GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL;\n  FI;\nFI;\nRETURN-SAME-PRIVILEGE-LEVEL:\n  IF the return instruction pointer is not within the return code segment limit\n     THEN #GP(0); FI;\n  IF OperandSize = 32\n     THEN\n       EIP <- Pop();\n       CS <- Pop(); (* 32-bit pop, high-order 16 bits discarded *)\n     ELSE (* OperandSize = 16 *)\n       EIP <- Pop();\n       EIP <- EIP AND 0000FFFFH;\n       CS <- Pop(); (* 16-bit pop *)\n  FI;\n  IF instruction has immediate operand\n     THEN (* Release parameters from stack *)\n       IF StackAddressSize = 32\n          THEN\n             ESP <- ESP + SRC;\n          ELSE (* StackAddressSize = 16 *)\n             SP <- SP + SRC;\n       FI;\n  FI;\nRETURN-OUTER-PRIVILEGE-LEVEL:\n  IF top (16 + SRC) bytes of stack are not within stack limits (OperandSize = 32)\n  or top (8 + SRC) bytes of stack are not within stack limits (OperandSize = 16)\n       THEN #SS(0); FI;\n  Read return segment selector;\n  IF stack segment selector is NULL\n     THEN #GP(0); FI;\n  IF return stack segment selector index is not within its descriptor table limits\n     THEN #GP(selector); FI;\n  Read segment descriptor pointed to by return segment selector;\n  IF stack segment selector RPL != RPL of the return code segment selector\n  or stack segment is not a writable data segment\n  or stack segment descriptor DPL != RPL of the return code segment selector\n       THEN #GP(selector); FI;\n  IF stack segment not present\n     THEN #SS(StackSegmentSelector); FI;\n  IF the return instruction pointer is not within the return code segment limit\n     THEN #GP(0); FI;\n  CPL <- ReturnCodeSegmentSelector(RPL);\n  IF OperandSize = 32\n     THEN\n       EIP <- Pop();\n       CS <- Pop(); (* 32-bit pop, high-order 16 bits discarded; segment descriptor loaded *)\n       CS(RPL) <- CPL;\n       IF instruction has immediate operand\n          THEN (* Release parameters from called procedure's stack *)\n             IF StackAddressSize = 32\n               THEN\n                  ESP <- ESP + SRC;\n               ELSE (* StackAddressSize = 16 *)\n                  SP <- SP + SRC;\n             FI;\n       FI;\n       tempESP <- Pop();\n       tempSS <- Pop(); (* 32-bit pop, high-order 16 bits discarded; seg. descriptor loaded *)\n       ESP <- tempESP;\n       SS <- tempSS;\n     ELSE (* OperandSize = 16 *)\n       EIP <- Pop();\n       EIP <- EIP AND 0000FFFFH;\n       CS <- Pop(); (* 16-bit pop; segment descriptor loaded *)\n       CS(RPL) <- CPL;\n       IF instruction has immediate operand\n          THEN (* Release parameters from called procedure's stack *)\n             IF StackAddressSize = 32\n               THEN\n                  ESP <- ESP + SRC;\n               ELSE (* StackAddressSize = 16 *)\n                  SP <- SP + SRC;\n             FI;\n       FI;\n       tempESP <- Pop();\n       tempSS <- Pop(); (* 16-bit pop; segment descriptor loaded *)\n       ESP <- tempESP;\n       SS <- tempSS;\n  FI;\n  FOR each of segment register (ES, FS, GS, and DS)\n     DO\n       IF segment register points to data or non-conforming code segment\n       and CPL > segment descriptor DPL (* DPL in hidden part of segment register *)\n          THEN SegmentSelector <- 0; (* Segment selector invalid *)\n       FI;\n     OD;\n  IF instruction has immediate operand\n     THEN (* Release parameters from calling procedure's stack *)\n       IF StackAddressSize = 32\n          THEN\n             ESP <- ESP + SRC;\n          ELSE (* StackAddressSize = 16 *)\n             SP <- SP + SRC;\n       FI;\n  FI;\n(* IA-32e Mode *)\n  IF (PE = 1 and VM = 0 and IA32_EFER.LMA = 1) and instruction = far return\n     THEN\n       IF OperandSize = 32\n          THEN\n             IF second doubleword on stack is not within stack limits\n               THEN #SS(0); FI;\n             IF first or second doubleword on stack is not in canonical space\n               THEN #SS(0); FI;\n          ELSE\n             IF OperandSize = 16\n               THEN\n                  IF second word on stack is not within stack limits\n                     THEN #SS(0); FI;\n                  IF first or second word on stack is not in canonical space\n                     THEN #SS(0); FI;\n               ELSE (* OperandSize = 64 *)\n                  IF first or second quadword on stack is not in canonical space\n                     THEN #SS(0); FI;\n             FI\n       FI;\n     IF return code segment selector is NULL\n       THEN GP(0); FI;\n     IF return code segment selector addresses descriptor beyond descriptor table limit\n       THEN GP(selector); FI;\n     IF return code segment selector addresses descriptor in non-canonical space\n       THEN GP(selector); FI;\n     Obtain descriptor to which return code segment selector points from descriptor table;\n     IF return code segment descriptor is not a code segment\n       THEN #GP(selector); FI;\n     IF return code segment descriptor has L-bit = 1 and D-bit = 1\n       THEN #GP(selector); FI;\n     IF return code segment selector RPL < CPL\n       THEN #GP(selector); FI;\n     IF return code segment descriptor is conforming\n     and return code segment DPL > return code segment selector RPL\n       THEN #GP(selector); FI;\n     IF return code segment descriptor is non-conforming\n     and return code segment DPL != return code segment selector RPL\n       THEN #GP(selector); FI;\n     IF return code segment descriptor is not present\n       THEN #NP(selector); FI:\n     IF return code segment selector RPL > CPL\n       THEN GOTO IA-32E-MODE-RETURN-OUTER-PRIVILEGE-LEVEL;\n       ELSE GOTO IA-32E-MODE-RETURN-SAME-PRIVILEGE-LEVEL;\n     FI;\n  FI;\nIA-32E-MODE-RETURN-SAME-PRIVILEGE-LEVEL:\nIF the return instruction pointer is not within the return code segment limit\n  THEN #GP(0); FI;\nIF the return instruction pointer is not within canonical address space\n  THEN #GP(0); FI;\nIF OperandSize = 32\n  THEN\n     EIP <- Pop();\n     CS <- Pop(); (* 32-bit pop, high-order 16 bits discarded *)\n  ELSE\n     IF OperandSize = 16\n       THEN\n          EIP <- Pop();\n          EIP <- EIP AND 0000FFFFH;\n          CS <- Pop(); (* 16-bit pop *)\n       ELSE (* OperandSize = 64 *)\n          RIP <- Pop();\n          CS <- Pop(); (* 64-bit pop, high-order 48 bits discarded *)\n     FI;\nFI;\nIF instruction has immediate operand\n  THEN (* Release parameters from stack *)\n     IF StackAddressSize = 32\n       THEN\n          ESP <- ESP + SRC;\n       ELSE\n          IF StackAddressSize = 16\n             THEN\n               SP <- SP + SRC;\n             ELSE (* StackAddressSize = 64 *)\n               RSP <- RSP + SRC;\n          FI;\n     FI;\nFI;\nIA-32E-MODE-RETURN-OUTER-PRIVILEGE-LEVEL:\nIF top (16 + SRC) bytes of stack are not within stack limits (OperandSize = 32)\nor top (8 + SRC) bytes of stack are not within stack limits (OperandSize = 16)\n  THEN #SS(0); FI;\nIF top (16 + SRC) bytes of stack are not in canonical address space (OperandSize = 32)\nor top (8 + SRC) bytes of stack are not in canonical address space (OperandSize = 16)\nor top (32 + SRC) bytes of stack are not in canonical address space (OperandSize = 64)\n  THEN #SS(0); FI;\nRead return stack segment selector;\nIF stack segment selector is NULL\n  THEN\n     IF new CS descriptor L-bit = 0\n       THEN #GP(selector);\n     IF stack segment selector RPL = 3\n       THEN #GP(selector);\nFI;\nIF return stack segment descriptor is not within descriptor table limits\n     THEN #GP(selector); FI;\nIF return stack segment descriptor is in non-canonical address space\n     THEN #GP(selector); FI;\nRead segment descriptor pointed to by return segment selector;\nIF stack segment selector RPL != RPL of the return code segment selector\nor stack segment is not a writable data segment\nor stack segment descriptor DPL != RPL of the return code segment selector\n  THEN #GP(selector); FI;\nIF stack segment not present\n  THEN #SS(StackSegmentSelector); FI;\nIF the return instruction pointer is not within the return code segment limit\n  THEN #GP(0); FI:\nIF the return instruction pointer is not within canonical address space\n  THEN #GP(0); FI;\nCPL <- ReturnCodeSegmentSelector(RPL);\nIF OperandSize = 32\n  THEN\n     EIP <- Pop();\n     CS <- Pop(); (* 32-bit pop, high-order 16 bits discarded, segment descriptor loaded *)\n     CS(RPL) <- CPL;\n     IF instruction has immediate operand\n       THEN (* Release parameters from called procedure's stack *)\n          IF StackAddressSize = 32\n             THEN\n               ESP <- ESP + SRC;\n             ELSE\n               IF StackAddressSize = 16\n                  THEN\n                     SP <- SP + SRC;\n                  ELSE (* StackAddressSize = 64 *)\n                     RSP <- RSP + SRC;\n               FI;\n          FI;\n     FI;\n     tempESP <- Pop();\n     tempSS <- Pop(); (* 32-bit pop, high-order 16 bits discarded, segment descriptor loaded *)\n     ESP <- tempESP;\n     SS <- tempSS;\n  ELSE\n     IF OperandSize = 16\n       THEN\n          EIP <- Pop();\n          EIP <- EIP AND 0000FFFFH;\n          CS <- Pop(); (* 16-bit pop; segment descriptor loaded *)\n          CS(RPL) <- CPL;\n          IF instruction has immediate operand\n             THEN (* Release parameters from called procedure's stack *)\n               IF StackAddressSize = 32\n                  THEN\n                     ESP <- ESP + SRC;\n                  ELSE\n                     IF StackAddressSize = 16\n                       THEN\n                          SP <- SP + SRC;\n                       ELSE (* StackAddressSize = 64 *)\n                          RSP <- RSP + SRC;\n                     FI;\n               FI;\n          FI;\n          tempESP <- Pop();\n          tempSS <- Pop(); (* 16-bit pop; segment descriptor loaded *)\n          ESP <- tempESP;\n          SS <- tempSS;\n       ELSE (* OperandSize = 64 *)\n          RIP <- Pop();\n          CS <- Pop(); (* 64-bit pop; high-order 48 bits discarded; seg. descriptor loaded *)\n          CS(RPL) <- CPL;\n          IF instruction has immediate operand\n             THEN (* Release parameters from called procedure's stack *)\n               RSP <- RSP + SRC;\n          FI;\n          tempESP <- Pop();\n          tempSS <- Pop(); (* 64-bit pop; high-order 48 bits discarded; seg. desc. loaded *)\n          ESP <- tempESP;\n          SS <- tempSS;\n     FI;\nFI;\nFOR each of segment register (ES, FS, GS, and DS)\n  DO\n     IF segment register points to data or non-conforming code segment\n     and CPL > segment descriptor DPL; (* DPL in hidden part of segment register *)\n       THEN SegmentSelector <- 0; (* SegmentSelector invalid *)\n     FI;\n  OD;\nIF instruction has immediate operand\n  THEN (* Release parameters from calling procedure's stack *)\n     IF StackAddressSize = 32\n       THEN\n          ESP <- ESP + SRC;\n       ELSE\n          IF StackAddressSize = 16\n             THEN\n               SP <- SP + SRC;\n             ELSE (* StackAddressSize = 64 *)\n               RSP <- RSP + SRC;\n          FI;\n     FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the return code or stack segment          \n|                | selector NULL. If the return instruction     \n|                | pointer is not within the return code        \n|                | segment limit                                \n| #GP(selector)  | If the RPL of the return code segment        \n|                | selector is less then the CPL. If the        \n|                | return code or stack segment selector        \n|                | index is not within its descriptor table     \n|                | limits. If the return code segment descriptor\n|                | does not indicate a code segment. If         \n|                | the return code segment is non-conforming    \n|                | and the segment selector's DPL is not        \n|                | equal to the RPL of the code segment's       \n|                | segment selector If the return code          \n|                | segment is conforming and the segment        \n|                | selector's DPL greater than the RPL          \n|                | of the code segment's segment selector       \n|                | If the stack segment is not a writable       \n|                | data segment. If the stack segment selector  \n|                | RPL is not equal to the RPL of the return    \n|                | code segment selector. If the stack          \n|                | segment descriptor DPL is not equal          \n|                | to the RPL of the return code segment        \n|                | selector.                                    \n| #SS(0)         | If the top bytes of stack are not within     \n|                | stack limits. If the return stack segment    \n|                | is not present.                              \n| #NP(selector)  | If the return code segment is not present.   \n| #PF(fault-code)| If a page fault occurs.                      \n| #AC(0)         | If an unaligned memory access occurs         \n|                | when the CPL is 3 and alignment checking     \n|                | is enabled.                                  \n\nReal-Address Mode Exceptions:\n| #GP| If the return instruction pointer is    \n|    | not within the return code segment limit\n| #SS| If the top bytes of stack are not within\n|    | stack limits.                           \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If the return instruction pointer is    \n|                | not within the return code segment limit\n| #SS(0)         | If the top bytes of stack are not within\n|                | stack limits.                           \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If an unaligned memory access occurs    \n|                | when alignment checking is enabled.     \n\nCompatibility Mode Exceptions:\nSame as 64-bit mode exceptions.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the return instruction pointer is        \n|                | non-canonical. If the return instruction    \n|                | pointer is not within the return code       \n|                | segment limit. If the stack segment         \n|                | selector is NULL going back to compatibility\n|                | mode. If the stack segment selector         \n|                | is NULL going back to CPL3 64-bit mode.     \n|                | If a NULL stack segment selector RPL        \n|                | is not equal to CPL going back to non-CPL3  \n|                | 64-bit mode. If the return code segment     \n|                | selector is NULL.                           \n| #GP(selector)  | If the proposed segment descriptor for      \n|                | a code segment does not indicate it         \n|                | is a code segment. If the proposed new      \n|                | code segment descriptor has both the        \n|                | D-bit and L-bit set. If the DPL for         \n|                | a nonconforming-code segment is not         \n|                | equal to the RPL of the code segment        \n|                | selector. If CPL is greater than the        \n|                | RPL of the code segment selector. If        \n|                | the DPL of a conforming-code segment        \n|                | is greater than the return code segment     \n|                | selector RPL. If a segment selector         \n|                | index is outside its descriptor table       \n|                | limits. If a segment descriptor memory      \n|                | address is non-canonical. If the stack      \n|                | segment is not a writable data segment.     \n|                | If the stack segment descriptor DPL         \n|                | is not equal to the RPL of the return       \n|                | code segment selector. If the stack         \n|                | segment selector RPL is not equal to        \n|                | the RPL of the return code segment selector.\n| #SS(0)         | If an attempt to pop a value off the        \n|                | stack violates the SS limit. If an attempt  \n|                | to pop a value off the stack causes         \n|                | a non-canonical address to be referenced.   \n| #NP(selector)  | If the return code or stack segment         \n|                | is not present.                             \n| #PF(fault-code)| If a page fault occurs.                     \n| #AC(0)         | If alignment checking is enabled and        \n|                | an unaligned memory reference is made       \n|                | while the current privilege level is        \n|                | 3.                                          \n", 
      "mnem": "RET"
    }, 
    {
      "description": "-R:RET", 
      "mnem": "RETF"
    }, 
    {
      "description": "-R:RCL", 
      "mnem": "ROL"
    }, 
    {
      "description": "-R:RCL", 
      "mnem": "ROR"
    }, 
    {
      "description": "\nRORX  -  Rotate Right Logical Without Affecting Flags:\n| Opcode/Instruction                  | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                         \n| VEX.LZ.F2.0F3A.W0 F0 /r ib RORX r32,| RMI  | V/V            | BMI2              | Rotate 32-bit r/m32 right imm8 times\n| r/m32, imm8                         |      |                |                   | without affecting arithmetic flags. \n| VEX.LZ.F2.0F3A.W1 F0 /r ib RORX r64,| RMI  | V/N.E.         | BMI2              | Rotate 64-bit r/m64 right imm8 times\n| r/m64, imm8                         |      |                |                   | without affecting arithmetic flags. \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| Imm8     | NA       \n\nDescription:\nRotates the bits of second operand right by the count value specified in imm8\nwithout affecting arithmetic flags. The RORX instruction does not read or write\nthe arithmetic flags. This instruction is not supported in real mode and virtual-8086\nmode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode\noperand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt\nto execute this instruction with VEX.L not equal to 0 will cause #UD.\n\nOperation:\n\nIF (OperandSize = 32)\n  y <- imm8 AND 1FH;\n  DEST <- (SRC >> y) | (SRC << (32-y));\nELSEIF (OperandSize = 64 )\n  y <- imm8 AND 3FH;\n  DEST <- (SRC >> y) | (SRC << (64-y));\nENDIF\n\nFlags Affected:\nNone\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nAuto-generated from high-level language.\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Section 2.5.1, \u201cException Conditions for VEX-Encoded GPR Instructions\u201d,\nTable 2-29; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "RORX"
    }, 
    {
      "description": "\nROUNDPD  -  Round Packed Double Precision Floating-Point Values:\n| Opcode*/Instruction                       | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                 \n| 66 0F 3A 09 /r ib ROUNDPD xmm1, xmm2/m128,| RMI  | V/V                   | SSE4_1            | Round packed double precision floating-point\n| imm8                                      |      |                       |                   | values in xmm2/m128 and place the result    \n|                                           |      |                       |                   | in The rounding mode is determined by       \n|                                           |      |                       |                   | imm8.                                       \n| VEX.128.66.0F3A.WIG 09 /r ib VROUNDPD     | RMI  | V/V                   | AVX               | Round packed double-precision floating-point\n| xmm1, xmm2/m128, imm8                     |      |                       |                   | values in xmm2/m128 and place the result    \n|                                           |      |                       |                   | in xmm1. The rounding mode is determined    \n|                                           |      |                       |                   | by imm8.                                    \n| VEX.256.66.0F3A.WIG 09 /r ib VROUNDPD     | RMI  | V/V                   | AVX               | Round packed double-precision floating-point\n| ymm1, ymm2/m256, imm8                     |      |                       |                   | values in ymm2/m256 and place the result    \n|                                           |      |                       |                   | in ymm1. The rounding mode is determined    \n|                                           |      |                       |                   | by imm8.                                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8     | NA       \n\nDescription:\nRound the 2 double-precision floating-point values in the source operand (second\noperand) using the rounding mode specified in the immediate operand (third operand)\nand place the results in the destination operand (first operand). The rounding\nprocess rounds each input floating-point value to an integer value and returns\nthe integer result as a single-precision floating-point value.\n\nThe immediate operand specifies control fields for the rounding operation, three\nbit fields are defined and shown in Figure 4-20. Bit 3 of the immediate byte\ncontrols processor behavior for a precision exception, bit 2 selects the source\nof rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value\n(Table 4-14 lists the encoded values for rounding-mode field).\n\nThe Precision Floating-Point Exception is signaled according to the immediate\noperand. If any source operand is an SNaN then it will be converted to a QNaN.\nIf DAZ is set to \u20181 then denormals will be converted to zero before rounding.\n128-bit Legacy SSE version: The second source can be an XMM register or 128-bit\nmemory location. The destination is not distinct from the first source XMM register\nand the upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. VEX.128 encoded version: the source operand second source operand\nor a 128-bit memory location. The destination operand is an XMM register. The\nupper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or a 256-bit memory\nlocation. The destination operand is a YMM register. Note: In VEX-encoded versions,\nVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n\n| 8| 3 2 1 0\nReserved\n\nP  -  Precision Mask; 0: normal, 1: inexact RS  -  Rounding select; 1: MXCSR.RC,\n0: Imm8.RC RC  -  Rounding mode\n\n| Figure 4-20.                                 | Bit Control Fields of Immediate Byte   \n|                                              | for ROUNDxx Instruction                \n| Table 4-14.                                  | Rounding Modes and Encoding of Rounding\n|                                              | Control (RC) Field                     \n| Description                                  | RC Field Setting                       \n| Rounded result is the closest to the         | 00B nearest (even)                     \n| infinitely precise result. If two values     |                                        \n| are equally close, the result is the         |                                        \n| even value (i.e., the integer value          |                                        \n| with the least-significant bit of zero).     |                                        \n| Rounded result is closest to but no          | 01B (toward \u2212\u221e)                        \n| greater than the infinitely precise          |                                        \n| result.                                      |                                        \n| Rounded result is closest to but no          | 10B (toward +\u221e)                        \n| less than the infinitely precise result.     |                                        \n| Rounded result is closest to but no          | 11B zero (Truncate)                    \n| greater in absolute value than the infinitely|                                        \n| precise result.                              |                                        \nOperation:\n\nIF (imm[2] = \u20181)\n  THEN\n     DEST[63:0] <- ConvertDPFPToInteger_M(SRC[63:0]);\n     DEST[127:64] <- ConvertDPFPToInteger_M(SRC[127:64]);\n  ELSE\n     DEST[63:0] <- ConvertDPFPToInteger_Imm(SRC[63:0]);\n     DEST[127:64] <- ConvertDPFPToInteger_Imm(SRC[127:64]);\nFI\nROUNDPD (128-bit Legacy SSE version)\nDEST[63:0] <- RoundToInteger(SRC[63:0]], ROUND_CONTROL)\nDEST[127:64] <- RoundToInteger(SRC[127:64]], ROUND_CONTROL)\nDEST[VLMAX-1:128] (Unmodified)\nVROUNDPD (VEX.128 encoded version)\nDEST[63:0] <- RoundToInteger(SRC[63:0]], ROUND_CONTROL)\nDEST[127:64] <- RoundToInteger(SRC[127:64]], ROUND_CONTROL)\nDEST[VLMAX-1:128] <- 0\nVROUNDPD (VEX.256 encoded version)\nDEST[63:0] <- RoundToInteger(SRC[63:0], ROUND_CONTROL)\nDEST[127:64] <- RoundToInteger(SRC[127:64]], ROUND_CONTROL)\nDEST[191:128] <- RoundToInteger(SRC[191:128]], ROUND_CONTROL)\nDEST[255:192] <- RoundToInteger(SRC[255:192] ], ROUND_CONTROL)\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n__m128 _mm_round_pd(__m128d s1, int iRoundMode);\n\n__m128 _mm_floor_pd(__m128d s1);\n\n__m128 _mm_ceil_pd(__m128d s1)\n\n__m256 _mm256_round_pd(__m256d s1, int iRoundMode);\n\n__m256 _mm256_floor_pd(__m256d s1);\n\n__m256 _mm256_ceil_pd(__m256d s1)\n\n\nSIMD Floating-Point Exceptions:\nInvalid (signaled only if SRC = SNaN) Precision (signaled only if imm[3] = \u20180;\nif imm[3] = \u20181, then the Precision Mask in the MXSCSR is ignored and precision\nexception is not signaled.) Note that Denormal is not signaled by ROUNDPD.\n\n\nOther Exceptions:\nSee Exceptions Type 2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "ROUNDPD"
    }, 
    {
      "description": "\nROUNDPS  -  Round Packed Single Precision Floating-Point Values:\n| Opcode*/Instruction                       | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                 \n| 66 0F 3A 08 /r ib ROUNDPS xmm1, xmm2/m128,| RMI  | V/V                   | SSE4_1            | Round packed single precision floating-point\n| imm8                                      |      |                       |                   | values in xmm2/m128 and place the result    \n|                                           |      |                       |                   | in The rounding mode is determined by       \n|                                           |      |                       |                   | imm8.                                       \n| VEX.128.66.0F3A.WIG 08 /r ib VROUNDPS     | RMI  | V/V                   | AVX               | Round packed single-precision floating-point\n| xmm1, xmm2/m128, imm8                     |      |                       |                   | values in xmm2/m128 and place the result    \n|                                           |      |                       |                   | in xmm1. The rounding mode is determined    \n|                                           |      |                       |                   | by imm8.                                    \n| VEX.256.66.0F3A.WIG 08 /r ib VROUNDPS     | RMI  | V/V                   | AVX               | Round packed single-precision floating-point\n| ymm1, ymm2/m256, imm8                     |      |                       |                   | values in ymm2/m256 and place the result    \n|                                           |      |                       |                   | in ymm1. The rounding mode is determined    \n|                                           |      |                       |                   | by imm8.                                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8     | NA       \n\nDescription:\nRound the 4 single-precision floating-point values in the source operand (second\noperand) using the rounding mode specified in the immediate operand (third operand)\nand place the results in the destination operand (first operand). The rounding\nprocess rounds each input floating-point value to an integer value and returns\nthe integer result as a single-precision floating-point value.\n\nThe immediate operand specifies control fields for the rounding operation, three\nbit fields are defined and shown in Figure 4-20. Bit 3 of the immediate byte\ncontrols processor behavior for a precision exception, bit 2 selects the source\nof rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value\n(Table 4-14 lists the encoded values for rounding-mode field).\n\nThe Precision Floating-Point Exception is signaled according to the immediate\noperand. If any source operand is an SNaN then it will be converted to a QNaN.\nIf DAZ is set to \u20181 then denormals will be converted to zero before rounding.\n128-bit Legacy SSE version: The second source can be an XMM register or 128-bit\nmemory location. The destination is not distinct from the first source XMM register\nand the upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. VEX.128 encoded version: the source operand second source operand\nor a 128-bit memory location. The destination operand is an XMM register. The\nupper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or a 256-bit memory\nlocation. The destination operand is a YMM register. Note: In VEX-encoded versions,\nVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n\nOperation:\n\nIF (imm[2] = \u20181)\n  THEN\n     DEST[31:0] <- ConvertSPFPToInteger_M(SRC[31:0]);\n     DEST[63:32] <- ConvertSPFPToInteger_M(SRC[63:32]);\n     DEST[95:64] <- ConvertSPFPToInteger_M(SRC[95:64]);\n     DEST[127:96] <- ConvertSPFPToInteger_M(SRC[127:96]);\n  ELSE\n     DEST[31:0] <- ConvertSPFPToInteger_Imm(SRC[31:0]);\n     DEST[63:32] <- ConvertSPFPToInteger_Imm(SRC[63:32]);\n     DEST[95:64] <- ConvertSPFPToInteger_Imm(SRC[95:64]);\n     DEST[127:96] <- ConvertSPFPToInteger_Imm(SRC[127:96]);\nFI;\nROUNDPS(128-bit Legacy SSE version)\nDEST[31:0] <- RoundToInteger(SRC[31:0], ROUND_CONTROL)\nDEST[63:32] <- RoundToInteger(SRC[63:32], ROUND_CONTROL)\nDEST[95:64] <- RoundToInteger(SRC[95:64]], ROUND_CONTROL)\nDEST[127:96] <- RoundToInteger(SRC[127:96]], ROUND_CONTROL)\nDEST[VLMAX-1:128] (Unmodified)\nVROUNDPS (VEX.128 encoded version)\nDEST[31:0] <- RoundToInteger(SRC[31:0], ROUND_CONTROL)\nDEST[63:32] <- RoundToInteger(SRC[63:32], ROUND_CONTROL)\nDEST[95:64] <- RoundToInteger(SRC[95:64]], ROUND_CONTROL)\nDEST[127:96] <- RoundToInteger(SRC[127:96]], ROUND_CONTROL)\nDEST[VLMAX-1:128] <- 0\nVROUNDPS (VEX.256 encoded version)\nDEST[31:0] <- RoundToInteger(SRC[31:0], ROUND_CONTROL)\nDEST[63:32] <- RoundToInteger(SRC[63:32], ROUND_CONTROL)\nDEST[95:64] <- RoundToInteger(SRC[95:64]], ROUND_CONTROL)\nDEST[127:96] <- RoundToInteger(SRC[127:96]], ROUND_CONTROL)\nDEST[159:128] <- RoundToInteger(SRC[159:128]], ROUND_CONTROL)\nDEST[191:160] <- RoundToInteger(SRC[191:160]], ROUND_CONTROL)\nDEST[223:192] <- RoundToInteger(SRC[223:192] ], ROUND_CONTROL)\nDEST[255:224] <- RoundToInteger(SRC[255:224] ], ROUND_CONTROL)\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n__m128 _mm_round_ps(__m128 s1, int iRoundMode);\n\n__m128 _mm_floor_ps(__m128 s1);\n\n__m128 _mm_ceil_ps(__m128 s1)\n\n__m256 _mm256_round_ps(__m256 s1, int iRoundMode);\n\n__m256 _mm256_floor_ps(__m256 s1);\n\n__m256 _mm256_ceil_ps(__m256 s1)\n\n\nSIMD Floating-Point Exceptions:\nInvalid (signaled only if SRC = SNaN) Precision (signaled only if imm[3] = \u20180;\nif imm[3] = \u20181, then the Precision Mask in the MXSCSR is ignored and precision\nexception is not signaled.) Note that Denormal is not signaled by ROUNDPS.\n\n\nOther Exceptions:\nSee Exceptions Type 2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "ROUNDPS"
    }, 
    {
      "description": "\nROUNDSD  -  Round Scalar Double Precision Floating-Point Values:\n| Opcode*/Instruction                      | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| 66 0F 3A 0B /r ib ROUNDSD xmm1, xmm2/m64,| RMI  | V/V                   | SSE4_1            | Round the low packed double precision   \n| imm8                                     |      |                       |                   | floating-point value in xmm2/m64 and    \n|                                          |      |                       |                   | place the result in xmm1. The rounding  \n|                                          |      |                       |                   | mode is determined by imm8.             \n| VEX.NDS.LIG.66.0F3A.WIG 0B /r ib VROUNDSD| RVMI | V/V                   | AVX               | Round the low packed double precision   \n| xmm1, xmm2, xmm3/m64, imm8               |      |                       |                   | floating-point value in xmm3/m64 and    \n|                                          |      |                       |                   | place the result in xmm1. The rounding  \n|                                          |      |                       |                   | mode is determined by imm8. Upper packed\n|                                          |      |                       |                   | double precision floating-point value   \n|                                          |      |                       |                   | (bits[127:64]) from xmm2 is copied to   \n|                                          |      |                       |                   | xmm1[127:64].                           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nRound the DP FP value in the lower qword of the source operand (second operand)\nusing the rounding mode specified in the immediate operand (third operand) and\nplace the result in the destination operand (first operand). The rounding process\nrounds a double-precision floating-point input to an integer value and returns\nthe integer result as a double precision floating-point value in the lowest\nposition. The upper double precision floating-point value in the destination\nis retained.\n\nThe immediate operand specifies control fields for the rounding operation, three\nbit fields are defined and shown in Figure 4-20. Bit 3 of the immediate byte\ncontrols processor behavior for a precision exception, bit 2 selects the source\nof rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value\n(Table 4-14 lists the encoded values for rounding-mode field).\n\nThe Precision Floating-Point Exception is signaled according to the immediate\noperand. If any source operand is an SNaN then it will be converted to a QNaN.\nIf DAZ is set to \u20181 then denormals will be converted to zero before rounding.\n128-bit Legacy SSE version: The first source operand and the destination operand\nare the same. Bits (VLMAX1:64) of the corresponding YMM destination register\nremain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128) of the destination\nYMM register are zeroed.\n\nOperation:\n\nIF (imm[2] = \u20181)\n  THEN\n     DEST[63:0] <- ConvertDPFPToInteger_M(SRC[63:0]);\n  ELSE\n     DEST[63:0] <- ConvertDPFPToInteger_Imm(SRC[63:0]);\nFI;\nDEST[127:63] remains unchanged ;\nROUNDSD (128-bit Legacy SSE version)\nDEST[63:0] <- RoundToInteger(SRC[63:0], ROUND_CONTROL)\nDEST[VLMAX-1:64] (Unmodified)\nVROUNDSD (VEX.128 encoded version)\nDEST[63:0] <- RoundToInteger(SRC2[63:0], ROUND_CONTROL)\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ROUNDSD:| __m128d mm_round_sd(__m128d dst, __m128d        \n|         | s1, int iRoundMode); __m128d mm_floor_sd(__m128d\n|         | dst, __m128d s1); __m128d mm_ceil_sd(__m128d    \n|         | dst, __m128d s1);                               \n\nSIMD Floating-Point Exceptions:\nInvalid (signaled only if SRC = SNaN) Precision (signaled only if imm[3] = \u20180;\nif imm[3] = \u20181, then the Precision Mask in the MXSCSR is ignored and precision\nexception is not signaled.) Note that Denormal is not signaled by ROUNDSD.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "ROUNDSD"
    }, 
    {
      "description": "\nROUNDSS  -  Round Scalar Single Precision Floating-Point Values:\n| Opcode*/Instruction                      | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| 66 0F 3A 0A /r ib ROUNDSS xmm1, xmm2/m32,| RMI  | V/V                   | SSE4_1            | Round the low packed single precision  \n| imm8                                     |      |                       |                   | floating-point value in xmm2/m32 and   \n|                                          |      |                       |                   | place The rounding mode is determined  \n|                                          |      |                       |                   | by imm8.                               \n| VEX.NDS.LIG.66.0F3A.WIG 0A /r ib VROUNDSS| RVMI | V/V                   | AVX               | Round the low packed single precision  \n| xmm1, xmm2, xmm3/m32, imm8               |      |                       |                   | floating-point value in xmm3/m32 and   \n|                                          |      |                       |                   | place the result in xmm1. The rounding \n|                                          |      |                       |                   | mode is determined by imm8. Also, upper\n|                                          |      |                       |                   | packed single precision floating-point \n|                                          |      |                       |                   | values (bits[127:32]) from xmm2 are    \n|                                          |      |                       |                   | copied to xmm1[127:32].                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nRound the single-precision floating-point value in the lowest dword of the source\noperand (second operand) using the rounding mode specified in the immediate\noperand (third operand) and place the result in the destination operand (first\noperand). The rounding process rounds a single-precision floating-point input\nto an integer value and returns the result as a single-precision floating-point\nvalue in the lowest position. The upper three single-precision floating-point\nvalues in the destination are retained.\n\nThe immediate operand specifies control fields for the rounding operation, three\nbit fields are defined and shown in Figure 4-20. Bit 3 of the immediate byte\ncontrols processor behavior for a precision exception, bit 2 selects the source\nof rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value\n(Table 4-14 lists the encoded values for rounding-mode field).\n\nThe Precision Floating-Point Exception is signaled according to the immediate\noperand. If any source operand is an SNaN then it will be converted to a QNaN.\nIf DAZ is set to \u20181 then denormals will be converted to zero before rounding.\n128-bit Legacy SSE version: The first source operand and the destination operand\nare the same. Bits (VLMAX1:32) of the corresponding YMM destination register\nremain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128) of the destination\nYMM register are zeroed.\n\nOperation:\n\nIF (imm[2] = \u20181)\n  THEN\n     DEST[31:0] <- ConvertSPFPToInteger_M(SRC[31:0]);\n  ELSE\n     DEST[31:0] <- ConvertSPFPToInteger_Imm(SRC[31:0]);\nFI;\nDEST[127:32] remains unchanged ;\nROUNDSS (128-bit Legacy SSE version)\nDEST[31:0] <- RoundToInteger(SRC[31:0], ROUND_CONTROL)\nDEST[VLMAX-1:32] (Unmodified)\nVROUNDSS (VEX.128 encoded version)\nDEST[31:0] <- RoundToInteger(SRC2[31:0], ROUND_CONTROL)\nDEST[127:32] <- SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| ROUNDSS:| __m128 mm_round_ss(__m128 dst, __m128         \n|         | s1, int iRoundMode); __m128 mm_floor_ss(__m128\n|         | dst, __m128 s1); __m128 mm_ceil_ss(__m128     \n|         | dst, __m128 s1);                              \n\nSIMD Floating-Point Exceptions:\nInvalid (signaled only if SRC = SNaN) Precision (signaled only if imm[3] = \u20180;\nif imm[3] = \u20181, then the Precision Mask in the MXSCSR is ignored and precision\nexception is not signaled.) Note that Denormal is not signaled by ROUNDSS.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "ROUNDSS"
    }, 
    {
      "description": "\nRSM - Resume from System Management Mode:\n| Opcode*| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                             \n| 0F AA  | RSM        | NP   | Invalid    | Valid          | Resume operation of interrupted program.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nReturns program control from system management mode (SMM) to the application\nprogram or operating-system procedure that was interrupted when the processor\nreceived an SMM interrupt. The processor's state is restored from the dump created\nupon entering SMM. If the processor detects invalid state information during\nstate restoration, it enters the shutdown state. The following invalid information\ncan cause a shutdown:\n\n - Any reserved bit of CR4 is set to 1.\n - Any illegal combination of bits in CR0, such as (PG=1 and PE=0) or (NW=1 and\nCD=0).\n - (Intel Pentium and Intel486\u2122 processors only.) The value stored in the state\ndump base field is not a 32-KByte aligned address.\n\nThe contents of the model-specific registers are not affected by a return from\nSMM.\n\nThe SMM state map used by RSM supports resuming processor context for non-64-bit\nmodes and 64-bit mode.\n\nSee Chapter 34, \u201cSystem Management Mode,\u201d in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 3C, for more information about SMM and the\nbehavior of the RSM instruction.\n\nOperation:\n\nReturnFromSMM;\nIF (IA-32e mode supported) or (CPUID DisplayFamily_DisplayModel = 06H_0CH )\n  THEN\n     ProcessorState <- Restore(SMMDump(IA-32e SMM STATE MAP));\n  Else\n     ProcessorState <- Restore(SMMDump(Non-32-Bit-Mode SMM STATE MAP));\nFI\n\nFlags Affected:\nAll.\n\n\nProtected Mode Exceptions:\n| #UD| If an attempt is made to execute this\n|    | instruction when the processor is not\n|    | in SMM. If the LOCK prefix is used.  \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "RSM"
    }, 
    {
      "description": "\nRSQRTPS - Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values:\n| Opcode*/Instruction                | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                       \n| 0F 52 /r RSQRTPS xmm1, xmm2/m128   | RM   | V/V                   | SSE               | Computes the approximate reciprocals              \n|                                    |      |                       |                   | of the square roots of the packed single-precision\n|                                    |      |                       |                   | floating-point values in xmm2/m128 and            \n|                                    |      |                       |                   | stores the results in xmm1.                       \n| VEX.128.0F.WIG 52 /r VRSQRTPS xmm1,| RM   | V/V                   | AVX               | Computes the approximate reciprocals              \n| xmm2/m128                          |      |                       |                   | of the square roots of packed single-precision    \n|                                    |      |                       |                   | values in xmm2/mem and stores the results         \n|                                    |      |                       |                   | in xmm1.                                          \n| VEX.256.0F.WIG 52 /r VRSQRTPS ymm1,| RM   | V/V                   | AVX               | Computes the approximate reciprocals              \n| ymm2/m256                          |      |                       |                   | of the square roots of packed single-precision    \n|                                    |      |                       |                   | values in ymm2/mem and stores the results         \n|                                    |      |                       |                   | in ymm1.                                          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nPerforms a SIMD computation of the approximate reciprocals of the square roots\nof the four packed single-precision floating-point values in the source operand\n(second operand) and stores the packed single-precision floatingpoint results\nin the destination operand. The source operand can be an XMM register or a 128-bit\nmemory location. The destination operand is an XMM register. See Figure 10-5\nin the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1, for an illustration of a SIMD single-precision floating-point operation.\n\nThe relative error for this approximation is:\n\n|Relative Error| \u2264 1.5 * 2\u221212\n\nThe RSQRTPS instruction is not affected by the rounding control bits in the\nMXCSR register. When a source value is a 0.0, an \u221e of the sign of the source\nvalue is returned. A denormal source value is treated as a 0.0 (of the same\nsign). When a source value is a negative value (other than \u22120.0), a floating-point\nindefinite is returned. When a source value is an SNaN or QNaN, the SNaN is\nconverted to a QNaN or the source QNaN is returned.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed. VEX.256 encoded version:\nThe first source operand is a YMM register. The second source operand can be\na YMM register or a 256-bit memory location. The destination operand is a YMM\nregister. Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b,\notherwise instructions will #UD.\n\nOperation:\n\nRSQRTPS (128-bit Legacy SSE version)\nDEST[31:0] <- APPROXIMATE(1/SQRT(SRC[31:0]))\nDEST[63:32] <- APPROXIMATE(1/SQRT(SRC1[63:32]))\nDEST[95:64] <- APPROXIMATE(1/SQRT(SRC1[95:64]))\nDEST[127:96] <- APPROXIMATE(1/SQRT(SRC2[127:96]))\nDEST[VLMAX-1:128] (Unmodified)\nVRSQRTPS (VEX.128 encoded version)\nDEST[31:0] <- APPROXIMATE(1/SQRT(SRC[31:0]))\nDEST[63:32] <- APPROXIMATE(1/SQRT(SRC1[63:32]))\nDEST[95:64] <- APPROXIMATE(1/SQRT(SRC1[95:64]))\nDEST[127:96] <- APPROXIMATE(1/SQRT(SRC2[127:96]))\nDEST[VLMAX-1:128] <- 0\nVRSQRTPS (VEX.256 encoded version)\nDEST[31:0] <- APPROXIMATE(1/SQRT(SRC[31:0]))\nDEST[63:32] <- APPROXIMATE(1/SQRT(SRC1[63:32]))\nDEST[95:64] <- APPROXIMATE(1/SQRT(SRC1[95:64]))\nDEST[127:96] <- APPROXIMATE(1/SQRT(SRC2[127:96]))\nDEST[159:128] <- APPROXIMATE(1/SQRT(SRC2[159:128]))\nDEST[191:160] <- APPROXIMATE(1/SQRT(SRC2[191:160]))\nDEST[223:192] <- APPROXIMATE(1/SQRT(SRC2[223:192]))\nDEST[255:224] <- APPROXIMATE(1/SQRT(SRC2[255:224]))\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| RSQRTPS:| __m128 _mm_rsqrt_ps(__m128 a)     \n| RSQRTPS:| __m256 _mm256_rsqrt_ps (__m256 a);\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "RSQRTPS"
    }, 
    {
      "description": "\nRSQRTSS - Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value:\n| Opcode*/Instruction                 | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                   \n| F3 0F 52 /r RSQRTSS xmm1, xmm2/m32  | RM   | V/V                   | SSE               | Computes the approximate reciprocal           \n|                                     |      |                       |                   | of the square root of the low single-precision\n|                                     |      |                       |                   | floating-point value in xmm2/m32 and          \n|                                     |      |                       |                   | stores the results in xmm1.                   \n| VEX.NDS.LIG.F3.0F.WIG 52 /r VRSQRTSS| RVM  | V/V                   | AVX               | Computes the approximate reciprocal           \n| xmm1, xmm2, xmm3/m32                |      |                       |                   | of the square root of the low single          \n|                                     |      |                       |                   | precision floating-point value in xmm3/m32    \n|                                     |      |                       |                   | and stores the results in xmm1. Also,         \n|                                     |      |                       |                   | upper single precision floating-point         \n|                                     |      |                       |                   | values (bits[127:32]) from xmm2 are           \n|                                     |      |                       |                   | copied to xmm1[127:32].                       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nComputes an approximate reciprocal of the square root of the low single-precision\nfloating-point value in the source operand (second operand) stores the single-precision\nfloating-point result in the destination operand. The source operand can be\nan XMM register or a 32-bit memory location. The destination operand is an XMM\nregister. The three high-order doublewords of the destination operand remain\nunchanged. See Figure 10-6 in the Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1, for an illustration of a scalar single-precision\nfloating-point operation.\n\nThe relative error for this approximation is:\n\n|Relative Error| \u2264 1.5 * 2\u221212\n\nThe RSQRTSS instruction is not affected by the rounding control bits in the\nMXCSR register. When a source value is a 0.0, an \u221e of the sign of the source\nvalue is returned. A denormal source value is treated as a 0.0 (of the same\nsign). When a source value is a negative value (other than \u22120.0), a floating-point\nindefinite is returned. When a source value is an SNaN or QNaN, the SNaN is\nconverted to a QNaN or the source QNaN is returned.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nfirst source operand and the destination operand are the same. Bits (VLMAX1:32)\nof the corresponding YMM destination register remain unchanged. VEX.128 encoded\nversion: Bits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nOperation:\n\nRSQRTSS (128-bit Legacy SSE version)\nDEST[31:0] <- APPROXIMATE(1/SQRT(SRC2[31:0]))\nDEST[VLMAX-1:32] (Unmodified)\nVRSQRTSS (VEX.128 encoded version)\nDEST[31:0] <- APPROXIMATE(1/SQRT(SRC2[31:0]))\nDEST[127:32] <- SRC1[31:0]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| RSQRTSS:| __m128 _mm_rsqrt_ss(__m128 a)\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5.\n\n", 
      "mnem": "RSQRTSS"
    }, 
    {
      "description": "\nSAHF - Store AH into Flags:\n| Opcode*| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                         \n| 9E     | SAHF       | NP   | Invalid*   | Valid          | Loads SF, ZF, AF, PF, and CF from AH\n|        |            |      |            |                | into EFLAGS register.               \nNotes: * Valid in specific steppings. See Description section.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nLoads the SF, ZF, AF, PF, and CF flags of the EFLAGS register with values from\nthe corresponding bits in the AH register (bits 7, 6, 4, 2, and 0, respectively).\nBits 1, 3, and 5 of register AH are ignored; the corresponding reserved bits\n(1, 3, and 5) in the EFLAGS register remain as shown in the \u201cOperation\u201d section\nbelow.\n\nThis instruction executes as described above in compatibility mode and legacy\nmode. It is valid in 64-bit mode only if CPUID.80000001H:ECX.LAHF-SAHF[bit 0]\n= 1.\n\nOperation:\n\nIF IA-64 Mode\n  THEN\n     IF CPUID.80000001H.ECX[0] = 1;\n       THEN\n          RFLAGS(SF:ZF:0:AF:0:PF:1:CF) <- AH;\n       ELSE\n          #UD;\n     FI\n  ELSE\n     EFLAGS(SF:ZF:0:AF:0:PF:1:CF) <- AH;\nFI;\n\nFlags Affected:\nThe SF, ZF, AF, PF, and CF flags are loaded with values from the AH register.\nBits 1, 3, and 5 of the EFLAGS register are unaffected, with the values remaining\n1, 0, and 0, respectively.\n\n\nProtected Mode Exceptions:\nNone.\n\n\nReal-Address Mode Exceptions:\nNone.\n\n\nVirtual-8086 Mode Exceptions:\nNone.\n\n\nCompatibility Mode Exceptions:\nNone.\n\n\n64-Bit Mode Exceptions:\n| #UD| If CPUID.80000001H.ECX[0] = 0. If the\n|    | LOCK prefix is used.                 \n", 
      "mnem": "SAHF"
    }, 
    {
      "description": "\nSAL/SAR/SHL/SHR - Shift:\n| Opcode***       | Instruction     | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                            \n| D0 /4           | SAL r/m8, 1     | M1   | Valid      | Valid          | Multiply r/m8 by 2, once.              \n| REX + D0 /4     | SAL r/m8**, 1   | M1   | Valid      | N.E.           | Multiply r/m8 by 2, once.              \n| D2 /4           | SAL r/m8, CL    | MC   | Valid      | Valid          | Multiply r/m8 by 2, CL times.          \n| REX + D2 /4     | SAL r/m8**, CL  | MC   | Valid      | N.E.           | Multiply r/m8 by 2, CL times.          \n| C0 /4 ib        | SAL r/m8, imm8  | MI   | Valid      | Valid          | Multiply r/m8 by 2, imm8 times.        \n| REX + C0 /4 ib  | SAL r/m8**, imm8| MI   | Valid      | N.E.           | Multiply r/m8 by 2, imm8 times.        \n| D1 /4           | SAL r/m16, 1    | M1   | Valid      | Valid          | Multiply r/m16 by 2, once.             \n| D3 /4           | SAL r/m16, CL   | MC   | Valid      | Valid          | Multiply r/m16 by 2, CL times.         \n| C1 /4 ib        | SAL r/m16, imm8 | MI   | Valid      | Valid          | Multiply r/m16 by 2, imm8 times.       \n| D1 /4           | SAL r/m32, 1    | M1   | Valid      | Valid          | Multiply r/m32 by 2, once.             \n| REX.W + D1 /4   | SAL r/m64, 1    | M1   | Valid      | N.E.           | Multiply r/m64 by 2, once.             \n| D3 /4           | SAL r/m32, CL   | MC   | Valid      | Valid          | Multiply r/m32 by 2, CL times.         \n| REX.W + D3 /4   | SAL r/m64, CL   | MC   | Valid      | N.E.           | Multiply r/m64 by 2, CL times.         \n| C1 /4 ib        | SAL r/m32, imm8 | MI   | Valid      | Valid          | Multiply r/m32 by 2, imm8 times.       \n| REX.W + C1 /4 ib| SAL r/m64, imm8 | MI   | Valid      | N.E.           | Multiply r/m64 by 2, imm8 times.       \n| D0 /7           | SAR r/m8, 1     | M1   | Valid      | Valid          | Signed divide* r/m8 by 2, once.        \n| REX + D0 /7     | SAR r/m8**, 1   | M1   | Valid      | N.E.           | Signed divide* r/m8 by 2, once.        \n| D2 /7           | SAR r/m8, CL    | MC   | Valid      | Valid          | Signed divide* r/m8 by 2, CL times.    \n| REX + D2 /7     | SAR r/m8**, CL  | MC   | Valid      | N.E.           | Signed divide* r/m8 by 2, CL times.    \n| C0 /7 ib        | SAR r/m8, imm8  | MI   | Valid      | Valid          | Signed divide* r/m8 by 2, imm8 time.   \n| REX + C0 /7 ib  | SAR r/m8**, imm8| MI   | Valid      | N.E.           | Signed divide* r/m8 by 2, imm8 times.  \n| D1 /7           | SAR r/m16,1     | M1   | Valid      | Valid          | Signed divide* r/m16 by 2, once.       \n| D3 /7           | SAR r/m16, CL   | MC   | Valid      | Valid          | Signed divide* r/m16 by 2, CL times.   \n| C1 /7 ib        | SAR r/m16, imm8 | MI   | Valid      | Valid          | Signed divide* r/m16 by 2, imm8 times. \n| D1 /7           | SAR r/m32, 1    | M1   | Valid      | Valid          | Signed divide* r/m32 by 2, once.       \n| REX.W + D1 /7   | SAR r/m64, 1    | M1   | Valid      | N.E.           | Signed divide* r/m64 by 2, once.       \n| D3 /7           | SAR r/m32, CL   | MC   | Valid      | Valid          | Signed divide* r/m32 by 2, CL times.   \n| REX.W + D3 /7   | SAR r/m64, CL   | MC   | Valid      | N.E.           | Signed divide* r/m64 by 2, CL times.   \n| C1 /7 ib        | SAR r/m32, imm8 | MI   | Valid      | Valid          | Signed divide* r/m32 by 2, imm8 times. \n| REX.W + C1 /7 ib| SAR r/m64, imm8 | MI   | Valid      | N.E.           | Signed divide* r/m64 by 2, imm8 times  \n| D0 /4           | SHL r/m8, 1     | M1   | Valid      | Valid          | Multiply r/m8 by 2, once.              \n| REX + D0 /4     | SHL r/m8**, 1   | M1   | Valid      | N.E.           | Multiply r/m8 by 2, once.              \n| D2 /4           | SHL r/m8, CL    | MC   | Valid      | Valid          | Multiply r/m8 by 2, CL times.          \n| REX + D2 /4     | SHL r/m8**, CL  | MC   | Valid      | N.E.           | Multiply r/m8 by 2, CL times.          \n| C0 /4 ib        | SHL r/m8, imm8  | MI   | Valid      | Valid          | Multiply r/m8 by 2, imm8 times.        \n| REX + C0 /4 ib  | SHL r/m8**, imm8| MI   | Valid      | N.E.           | Multiply r/m8 by 2, imm8 times.        \n| D1 /4           | SHL r/m16,1     | M1   | Valid      | Valid          | Multiply r/m16 by 2, once.             \n| D3 /4           | SHL r/m16, CL   | MC   | Valid      | Valid          | Multiply r/m16 by 2, CL times.         \n| C1 /4 ib        | SHL r/m16, imm8 | MI   | Valid      | Valid          | Multiply r/m16 by 2, imm8 times.       \n| D1 /4           | SHL r/m32,1     | M1   | Valid      | Valid          | Multiply r/m32 by 2, once.             \n| Opcode          | Instruction     | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                            \n| REX.W + D1 /4   | SHL r/m64,1     | M1   | Valid      | N.E.           | Multiply r/m64 by 2, once.             \n| D3 /4           | SHL r/m32, CL   | MC   | Valid      | Valid          | Multiply r/m32 by 2, CL times.         \n| REX.W + D3 /4   | SHL r/m64, CL   | MC   | Valid      | N.E.           | Multiply r/m64 by 2, CL times.         \n| C1 /4 ib        | SHL r/m32, imm8 | MI   | Valid      | Valid          | Multiply r/m32 by 2, imm8 times.       \n| REX.W + C1 /4 ib| SHL r/m64, imm8 | MI   | Valid      | N.E.           | Multiply r/m64 by 2, imm8 times.       \n| D0 /5           | SHR r/m8,1      | M1   | Valid      | Valid          | Unsigned divide r/m8 by 2, once.       \n| REX + D0 /5     | SHR r/m8**, 1   | M1   | Valid      | N.E.           | Unsigned divide r/m8 by 2, once.       \n| D2 /5           | SHR r/m8, CL    | MC   | Valid      | Valid          | Unsigned divide r/m8 by 2, CL times.   \n| REX + D2 /5     | SHR r/m8**, CL  | MC   | Valid      | N.E.           | Unsigned divide r/m8 by 2, CL times.   \n| C0 /5 ib        | SHR r/m8, imm8  | MI   | Valid      | Valid          | Unsigned divide r/m8 by 2, imm8 times. \n| REX + C0 /5 ib  | SHR r/m8**, imm8| MI   | Valid      | N.E.           | Unsigned divide r/m8 by 2, imm8 times. \n| D1 /5           | SHR r/m16, 1    | M1   | Valid      | Valid          | Unsigned divide r/m16 by 2, once.      \n| D3 /5           | SHR r/m16, CL   | MC   | Valid      | Valid          | Unsigned divide r/m16 by 2, CL times   \n| C1 /5 ib        | SHR r/m16, imm8 | MI   | Valid      | Valid          | Unsigned divide r/m16 by 2, imm8 times.\n| D1 /5           | SHR r/m32, 1    | M1   | Valid      | Valid          | Unsigned divide r/m32 by 2, once.      \n| REX.W + D1 /5   | SHR r/m64, 1    | M1   | Valid      | N.E.           | Unsigned divide r/m64 by 2, once.      \n| D3 /5           | SHR r/m32, CL   | MC   | Valid      | Valid          | Unsigned divide r/m32 by 2, CL times.  \n| REX.W + D3 /5   | SHR r/m64, CL   | MC   | Valid      | N.E.           | Unsigned divide r/m64 by 2, CL times.  \n| C1 /5 ib        | SHR r/m32, imm8 | MI   | Valid      | Valid          | Unsigned divide r/m32 by 2, imm8 times.\n| REX.W + C1 /5 ib| SHR r/m64, imm8 | MI   | Valid      | N.E.           | Unsigned divide r/m64 by 2, imm8 times.\nNotes: * Not the same form of division as IDIV; rounding is toward negative\ninfinity. ** In 64-bit mode, r/m8 can not be encoded to access the following\nbyte registers if a REX prefix is used: AH, BH, CH, DH. ***See IA-32 Architecture\nCompatibility section below.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2| Operand 3| Operand 4\n| M1   | ModRM:r/m (r, w)| 1        | NA       | NA       \n| MC   | ModRM:r/m (r, w)| CL       | NA       | NA       \n| MI   | ModRM:r/m (r, w)| imm8     | NA       | NA       \n\nDescription:\nShifts the bits in the first operand (destination operand) to the left or right\nby the number of bits specified in the second operand (count operand). Bits\nshifted beyond the destination operand boundary are first shifted into the CF\nflag, then discarded. At the end of the shift operation, the CF flag contains\nthe last bit shifted out of the destination operand.\n\nThe destination operand can be a register or a memory location. The count operand\ncan be an immediate value or the CL register. The count is masked to 5 bits\n(or 6 bits if in 64-bit mode and REX.W is used). The count range is limited\nto 0 to 31 (or 63 if 64-bit mode and REX.W is used). A special opcode encoding\nis provided for a count of 1.\n\nThe shift arithmetic left (SAL) and shift logical left (SHL) instructions perform\nthe same operation; they shift the bits in the destination operand to the left\n(toward more significant bit locations). For each shift count, the most significant\nbit of the destination operand is shifted into the CF flag, and the least significant\nbit is cleared (see Figure 7-7 in the Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1).\n\nThe shift arithmetic right (SAR) and shift logical right (SHR) instructions\nshift the bits of the destination operand to the right (toward less significant\nbit locations). For each shift count, the least significant bit of the destination\noperand is shifted into the CF flag, and the most significant bit is either\nset or cleared depending on the instruction type. The SHR instruction clears\nthe most significant bit (see Figure 7-8 in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1); the SAR instruction sets or clears the\nmost significant bit to correspond to the sign (most significant bit) of the\noriginal value in the destination operand. In effect, the SAR instruction fills\nthe empty bit position's shifted value with the sign of the unshifted value\n(see Figure 7-9 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 1).\n\nThe SAR and SHR instructions can be used to perform signed or unsigned division,\nrespectively, of the destination operand by powers of 2. For example, using\nthe SAR instruction to shift a signed integer 1 bit to the right divides the\nvalue by 2.\n\nUsing the SAR instruction to perform a division operation does not produce the\nsame result as the IDIV instruction. The quotient from the IDIV instruction\nis rounded toward zero, whereas the \u201cquotient\u201d of the SAR instruction is rounded\ntoward negative infinity. This difference is apparent only for negative numbers.\nFor example, when the IDIV instruction is used to divide -9 by 4, the result\nis -2 with a remainder of -1. If the SAR instruction is used to shift -9 right\nby two bits, the result is -3 and the \u201cremainder\u201d is +3; however, the SAR instruction\nstores only the most significant bit of the remainder (in the CF flag).\n\nThe OF flag is affected only on 1-bit shifts. For left shifts, the OF flag is\nset to 0 if the most-significant bit of the result is the same as the CF flag\n(that is, the top two bits of the original operand were the same); otherwise,\nit is set to 1. For the SAR instruction, the OF flag is cleared for all 1-bit\nshifts. For the SHR instruction, the OF flag is set to the most-significant\nbit of the original operand.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits and the\nmask width for CL is 5 bits. Using a REX prefix in the form of REX.R permits\naccess to additional registers (R8-R15). Using a REX prefix in the form of REX.W\npromotes operation to 64-bits and sets the mask width for CL to 6 bits. See\nthe summary chart at the beginning of this section for encoding data and limits.\n\n\nIA-32 Architecture Compatibility:\nThe 8086 does not mask the shift count. However, all other IA-32 processors\n(starting with the Intel 286 processor) do mask the shift count to 5 bits, resulting\nin a maximum count of 31. This masking is done in all operating modes (including\nthe virtual-8086 mode) to reduce the maximum execution time of the instructions.\n\nOperation:\n\nIF 64-Bit Mode and using REX.W\n  THEN\n     countMASK <- 3FH;\n  ELSE\n     countMASK <- 1FH;\nFI\ntempCOUNT <- (COUNT AND countMASK);\ntempDEST <- DEST;\nWHILE (tempCOUNT != 0)\nDO\n  IF instruction is SAL or SHL\n     THEN\n       CF <- MSB(DEST);\n     ELSE (* Instruction is SAR or SHR *)\n       CF <- LSB(DEST);\n  FI;\n  IF instruction is SAL or SHL\n     THEN\n       DEST <- DEST * 2;\n     ELSE\n       IF instruction is SAR\n          THEN\n             DEST <- DEST / 2; (* Signed divide, rounding toward negative infinity *)\n          ELSE (* Instruction is SHR *)\n             DEST <- DEST / 2 ; (* Unsigned divide *)\n       FI;\n  FI;\n  tempCOUNT <- tempCOUNT - 1;\nOD;\n(* Determine overflow for the various instructions *)\nIF (COUNT and countMASK) = 1\n  THEN\n     IF instruction is SAL or SHL\n       THEN\n          OF <- MSB(DEST) XOR CF;\n       ELSE\n          IF instruction is SAR\n             THEN\n               OF <- 0;\n             ELSE (* Instruction is SHR *)\n               OF <- MSB(tempDEST);\n          FI;\n     FI;\n  ELSE IF (COUNT AND countMASK) = 0\n     THEN\n       All flags unchanged;\n     ELSE (* COUNT not 1 or 0 *)\n       OF <- undefined;\n  FI;\nFI;\n\nFlags Affected:\nThe CF flag contains the value of the last bit shifted out of the destination\noperand; it is undefined for SHL and SHR instructions where the count is greater\nthan or equal to the size (in bits) of the destination operand. The OF flag\nis affected only for 1-bit shifts (see \u201cDescription\u201d above); otherwise, it is\nundefined. The SF, ZF, and PF flags are set according to the result. If the\ncount is 0, the flags are not affected. For a non-zero count, the AF flag is\nundefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register contains a NULL segment     \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "SAL"
    }, 
    {
      "description": "-R:SAL", 
      "mnem": "SAR"
    }, 
    {
      "description": "\nSARX/SHLX/SHRX  -  Shift Without Affecting Flags:\n| Opcode/Instruction                     | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                           \n| VEX.NDS1.LZ.F3.0F38.W0 F7 /r SARX r32a,| RMV  | V/V            | BMI2              | Shift r/m32 arithmetically right with \n| r/m32, r32b                            |      |                |                   | count specified in r32b.              \n| VEX.NDS1.LZ.66.0F38.W0 F7 /r SHLX r32a,| RMV  | V/V            | BMI2              | Shift r/m32 logically left with count \n| r/m32, r32b                            |      |                |                   | specified in r32b.                    \n| VEX.NDS1.LZ.F2.0F38.W0 F7 /r SHRX r32a,| RMV  | V/V            | BMI2              | Shift r/m32 logically right with count\n| r/m32, r32b                            |      |                |                   | specified in r32b.                    \n| VEX.NDS1.LZ.F3.0F38.W1 F7 /r SARX r64a,| RMV  | V/N.E.         | BMI2              | Shift r/m64 arithmetically right with \n| r/m64, r64b                            |      |                |                   | count specified in r64b.              \n| VEX.NDS1.LZ.66.0F38.W1 F7 /r SHLX r64a,| RMV  | V/N.E.         | BMI2              | Shift r/m64 logically left with count \n| r/m64, r64b                            |      |                |                   | specified in r64b.                    \n| VEX.NDS1.LZ.F2.0F38.W1 F7 /r SHRX r64a,| RMV  | V/N.E.         | BMI2              | Shift r/m64 logically right with count\n| r/m64, r64b                            |      |                |                   | specified in r64b.                    \nNotes: 1. ModRM:r/m is used to encode the first source operand (second operand)\nand VEX.vvvv encodes the second source operand (third operand).\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3   | Operand 4\n| RMV  | ModRM:reg (w)| ModRM:r/m (r)| VEX.vvvv (r)| NA       \n\nDescription:\nShifts the bits of the first source operand (the second operand) to the left\nor right by a COUNT value specified in the second source operand (the third\noperand). The result is written to the destination operand (the first operand).\nThe shift arithmetic right (SARX) and shift logical right (SHRX) instructions\nshift the bits of the destination operand to the right (toward less significant\nbit locations), SARX keeps and propagates the most significant bit (sign bit)\nwhile shifting. The logical shift left (SHLX) shifts the bits of the destination\noperand to the left (toward more significant bit locations). This instruction\nis not supported in real mode and virtual-8086 mode. The operand size is always\n32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1.\nVEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction\nwith VEX.L not equal to 0 will cause #UD. If the value specified in the first\nsource operand exceeds OperandSize -1, the COUNT value is masked. SARX,SHRX,\nand SHLX instructions do not update flags.\n\nOperation:\n\nTEMP <- SRC1;\nIF VEX.W1 and CS.L = 1\nTHEN\n  countMASK <-3FH;\nELSE\n  countMASK <-1FH;\nFI\nCOUNT <- (SRC2 AND countMASK)\nDEST[OperandSize -1] = TEMP[OperandSize -1];\nDO WHILE (COUNT != 0)\n  IF instruction is SHLX\n     THEN\n       DEST[] <- DEST *2;\n     ELSE IF instruction is SHRX\n       THEN\n          DEST[] <- DEST /2; //unsigned divide\n     ELSE\n          DEST[] <- DEST /2; // signed divide, round toward negative infinity\n  FI;\n  COUNT <- COUNT - 1;\nOD\n\nFlags Affected:\nNone.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nAuto-generated from high-level language.\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Section 2.5.1, \u201cException Conditions for VEX-Encoded GPR Instructions\u201d,\nTable 2-29; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "SARX"
    }, 
    {
      "description": "\nSBB - Integer Subtraction with Borrow:\n| Opcode          | Instruction     | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                              \n| 1C ib           | SBB AL, imm8    | I    | Valid      | Valid          | Subtract with borrow imm8 from AL.       \n| 1D iw           | SBB AX, imm16   | I    | Valid      | Valid          | Subtract with borrow imm16 from AX.      \n| 1D id           | SBB EAX, imm32  | I    | Valid      | Valid          | Subtract with borrow imm32 from EAX.     \n| REX.W + 1D id   | SBB RAX, imm32  | I    | Valid      | N.E.           | Subtract with borrow sign-extended imm.32\n|                 |                 |      |            |                | to 64-bits from RAX.                     \n| 80 /3 ib        | SBB r/m8, imm8  | MI   | Valid      | Valid          | Subtract with borrow imm8 from r/m8.     \n| REX + 80 /3 ib  | SBB r/m8*, imm8 | MI   | Valid      | N.E.           | Subtract with borrow imm8 from r/m8.     \n| 81 /3 iw        | SBB r/m16, imm16| MI   | Valid      | Valid          | Subtract with borrow imm16 from r/m16.   \n| 81 /3 id        | SBB r/m32, imm32| MI   | Valid      | Valid          | Subtract with borrow imm32 from r/m32.   \n| REX.W + 81 /3 id| SBB r/m64, imm32| MI   | Valid      | N.E.           | Subtract with borrow sign-extended imm32 \n|                 |                 |      |            |                | to 64-bits from r/m64.                   \n| 83 /3 ib        | SBB r/m16, imm8 | MI   | Valid      | Valid          | Subtract with borrow sign-extended imm8  \n|                 |                 |      |            |                | from r/m16.                              \n| 83 /3 ib        | SBB r/m32, imm8 | MI   | Valid      | Valid          | Subtract with borrow sign-extended imm8  \n|                 |                 |      |            |                | from r/m32.                              \n| REX.W + 83 /3 ib| SBB r/m64, imm8 | MI   | Valid      | N.E.           | Subtract with borrow sign-extended imm8  \n|                 |                 |      |            |                | from r/m64.                              \n| 18 /r           | SBB r/m8, r8    | MR   | Valid      | Valid          | Subtract with borrow r8 from r/m8.       \n| REX + 18 /r     | SBB r/m8*, r8   | MR   | Valid      | N.E.           | Subtract with borrow r8 from r/m8.       \n| 19 /r           | SBB r/m16, r16  | MR   | Valid      | Valid          | Subtract with borrow r16 from r/m16.     \n| 19 /r           | SBB r/m32, r32  | MR   | Valid      | Valid          | Subtract with borrow r32 from r/m32.     \n| REX.W + 19 /r   | SBB r/m64, r64  | MR   | Valid      | N.E.           | Subtract with borrow r64 from r/m64.     \n| 1A /r           | SBB r8, r/m8    | RM   | Valid      | Valid          | Subtract with borrow r/m8 from r8.       \n| REX + 1A /r     | SBB r8*, r/m8*  | RM   | Valid      | N.E.           | Subtract with borrow r/m8 from r8.       \n| 1B /r           | SBB r16, r/m16  | RM   | Valid      | Valid          | Subtract with borrow r/m16 from r16.     \n| 1B /r           | SBB r32, r/m32  | RM   | Valid      | Valid          | Subtract with borrow r/m32 from r32.     \n| REX.W + 1B /r   | SBB r64, r/m64  | RM   | Valid      | N.E.           | Subtract with borrow r/m64 from r64.     \nNotes: \n\n| *| In 64-bit mode, r/m8 can not be encoded\n|  | to access the following byte registers \n|  | if a REX prefix is used: AH, BH, CH,   \n|  | DH.                                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| I    | AL/AX/EAX/RAX| imm8/16/32   | NA       | NA       \n| MI   | ModRM:r/m (w)| imm8/16/32   | NA       | NA       \n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nAdds the source operand (second operand) and the carry (CF) flag, and subtracts\nthe result from the destination operand (first operand). The result of the subtraction\nis stored in the destination operand. The destination operand can be a register\nor a memory location; the source operand can be an immediate, a register, or\na memory location. (However, two memory operands cannot be used in one instruction.)\nThe state of the CF flag represents a borrow from a previous subtraction.\n\nWhen an immediate value is used as an operand, it is sign-extended to the length\nof the destination operand format.\n\nThe SBB instruction does not distinguish between signed or unsigned operands.\nInstead, the processor evaluates the result for both data types and sets the\nOF and CF flags to indicate a borrow in the signed or unsigned result, respectively.\nThe SF flag indicates the sign of the signed result.\n\nThe SBB instruction is usually executed as part of a multibyte or multiword\nsubtraction in which a SUB instruction is followed by a SBB instruction.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nOperation:\n\nDEST <- (DEST - (SRC + CF));\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| SBB:                    | extern unsigned char _subborrow_u8(unsigned \n|                         | char c_in, unsigned char src1, unsigned     \n|                         | char src2, unsigned char *diff_out);        \n| SBB: *diff_out);        | extern unsigned char _subborrow_u16(unsigned\n|                         | char c_in, unsigned short src1, unsigned    \n|                         | short src2, unsigned short                  \n| SBB:                    | extern unsigned char _subborrow_u32(unsigned\n|                         | char c_in, unsigned int src1, unsigned      \n|                         | char int, unsigned int *diff_out);          \n| SBB: __int64 *diff_out);| extern unsigned char _subborrow_u64(unsigned\n|                         | char c_in, unsigned __int64 src1, unsigned  \n|                         | __int64 src2, unsigned                      \n\nFlags Affected:\nThe OF, SF, ZF, AF, PF, and CF flags are set according to the result.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register contains a NULL segment     \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used but the destination \n|                | is not a memory operand.                       \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "SBB"
    }, 
    {
      "description": "\nSCAS/SCASB/SCASW/SCASD - Scan String:\n| Opcode    | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                            \n| AE        | SCAS m8    | NP   | Valid      | Valid          | Compare AL with byte at ES:(E)DI or    \n|           |            |      |            |                | RDI, then set status flags.*           \n| AF        | SCAS m16   | NP   | Valid      | Valid          | Compare AX with word at ES:(E)DI or    \n|           |            |      |            |                | RDI, then set status flags.*           \n| AF        | SCAS m32   | NP   | Valid      | Valid          | Compare EAX with doubleword at ES(E)DI \n|           |            |      |            |                | or RDI then set status flags.*         \n| REX.W + AF| SCAS m64   | NP   | Valid      | N.E.           | Compare RAX with quadword at RDI or    \n|           |            |      |            |                | EDI then set status flags.             \n| AE        | SCASB      | NP   | Valid      | Valid          | Compare AL with byte at ES:(E)DI or    \n|           |            |      |            |                | RDI then set status flags.*            \n| AF        | SCASW      | NP   | Valid      | Valid          | Compare AX with word at ES:(E)DI or    \n|           |            |      |            |                | RDI then set status flags.*            \n| AF        | SCASD      | NP   | Valid      | Valid          | Compare EAX with doubleword at ES:(E)DI\n|           |            |      |            |                | or RDI then set status flags.*         \n| REX.W + AF| SCASQ      | NP   | Valid      | N.E.           | Compare RAX with quadword at RDI or    \n|           |            |      |            |                | EDI then set status flags.             \nNotes: * In 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are\nsupported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes\nare supported.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nIn non-64-bit modes and in default 64-bit mode: this instruction compares a\nbyte, word, doubleword or quadword specified using a memory operand with the\nvalue in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results.\nThe memory operand address is read from ES:(E)DI register (depending on the\naddress-size attribute of the instruction and the current operational mode).\nNote that ES cannot be overridden with a segment override prefix.\n\nAt the assembly-code level, two forms of this instruction are allowed. The explicit-operand\nform and the no-operands form. The explicit-operand form (specified using the\nSCAS mnemonic) allows a memory operand to be specified explicitly. The memory\noperand must be a symbol that indicates the size and location of the operand\nvalue. The register operand is then automatically selected to match the size\nof the memory operand (AL register for byte comparisons, AX for word comparisons,\nEAX for doubleword comparisons). The explicit-operand form is provided to allow\ndocumentation. Note that the documentation provided by this form can be misleading.\nThat is, the memory operand symbol must specify the correct type (size) of the\noperand (byte, word, or doubleword) but it does not have to specify the correct\nlocation. The location is always specified by ES:(E)DI.\n\nThe no-operands form of the instruction uses a short form of SCAS. Again, ES:(E)DI\nis assumed to be the memory operand and AL, AX, or EAX is assumed to be the\nregister operand. The size of operands is selected by the mnemonic: SCASB (byte\ncomparison), SCASW (word comparison), or SCASD (doubleword comparison).\n\nAfter the comparison, the (E)DI register is incremented or decremented automatically\naccording to the setting of the DF flag in the EFLAGS register. If the DF flag\nis 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register\nis decremented. The register is incremented or decremented by 1 for byte operations,\nby 2 for word operations, and by 4 for doubleword operations.\n\nSCAS, SCASB, SCASW, SCASD, and SCASQ can be preceded by the REP prefix for block\ncomparisons of ECX bytes, words, doublewords, or quadwords. Often, however,\nthese instructions will be used in a LOOP construct that takes\n\nsome action based on the setting of status flags. See \u201cREP/REPE/REPZ /REPNE/REPNZ - Repeat\nString Operation Prefix\u201d in this chapter for a description of the REP prefix.\n\nIn 64-bit mode, the instruction's default address size is 64-bits, 32-bit address\nsize is supported using the prefix 67H. Using a REX prefix in the form of REX.W\npromotes operation on doubleword operand to 64 bits. The 64-bit nooperand mnemonic\nis SCASQ. Address of the memory operand is specified in either RDI or EDI, and\nAL/AX/EAX/RAX may be used as the register operand. After a comparison, the destination\nregister is incremented or decremented by the current operand size (depending\non the value of the DF flag). See the summary chart at the beginning of this\nsection for encoding data and limits.\n\nOperation:\n\nNon-64-bit Mode:\nIF (Byte comparison)\n  THEN\n     temp <- AL \u2212 SRC;\n     SetStatusFlags(temp);\n       THEN IF DF = 0\n          THEN (E)DI <- (E)DI + 1;\n          ELSE (E)DI <- (E)DI - 1; FI;\n  ELSE IF (Word comparison)\n     THEN\n       temp <- AX \u2212 SRC;\n       SetStatusFlags(temp);\n       IF DF = 0\n          THEN (E)DI <- (E)DI + 2;\n          ELSE (E)DI <- (E)DI - 2; FI;\n     FI;\n  ELSE IF (Doubleword comparison)\n     THEN\n       temp <- EAX - SRC;\n       SetStatusFlags(temp);\n       IF DF = 0\n          THEN (E)DI <- (E)DI + 4;\n          ELSE (E)DI <- (E)DI - 4; FI;\n     FI;\nFI;\n64-bit Mode:\nIF (Byte cmparison)\n  THEN\n     temp <- AL \u2212 SRC;\n     SetStatusFlags(temp);\n       THEN IF DF = 0\n          THEN (R|E)DI <- (R|E)DI + 1;\n          ELSE (R|E)DI <- (R|E)DI - 1; FI;\n  ELSE IF (Word comparison)\n     THEN\n       temp <- AX \u2212 SRC;\n       SetStatusFlags(temp);\n       IF DF = 0\n          THEN (R|E)DI <- (R|E)DI + 2;\n          ELSE (R|E)DI <- (R|E)DI - 2; FI;\n     FI;\n  ELSE IF (Doubleword comparison)\n     THEN\n       temp <- EAX - SRC;\n       SetStatusFlags(temp);\n       IF DF = 0\n          THEN (R|E)DI <- (R|E)DI + 4;\n          ELSE (R|E)DI <- (R|E)DI - 4; FI;\n     FI;\n  ELSE IF (Quadword comparison using REX.W )\n     THEN\n       temp <- RAX \u2212 SRC;\n       SetStatusFlags(temp);\n       IF DF = 0\n          THEN (R|E)DI <- (R|E)DI + 8;\n          ELSE (R|E)DI <- (R|E)DI - 8;\n       FI;\n  FI;\nF\n\nFlags Affected:\nThe OF, SF, ZF, AF, PF, and CF flags are set according to the temporary result\nof the comparison.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address     \n|                | is outside the limit of the ES segment.   \n|                | If the ES register contains a NULL segment\n|                | selector. If an illegal memory operand    \n|                | effective address in the ES segment       \n|                | is given.                                 \n| #PF(fault-code)| If a page fault occurs.                   \n| #AC(0)         | If alignment checking is enabled and      \n|                | an unaligned memory reference is made     \n|                | while the current privilege level is      \n|                | 3.                                        \n| #UD            | If the LOCK prefix is used.               \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "SCAS"
    }, 
    {
      "description": "-R:SCAS", 
      "mnem": "SCASB"
    }, 
    {
      "description": "-R:SCAS", 
      "mnem": "SCASD"
    }, 
    {
      "description": "-R:SCAS", 
      "mnem": "SCASW"
    }, 
    {
      "description": "\nSETcc - Set Byte on Condition:\n| Opcode     | Instruction | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| 0F 97      | SETA r/m8   | M    | Valid      | Valid          | Set byte if above (CF=0 and ZF=0).    \n| REX + 0F 97| SETA r/m8*  | M    | Valid      | N.E.           | Set byte if above (CF=0 and ZF=0).    \n| 0F 93      | SETAE r/m8  | M    | Valid      | Valid          | Set byte if above or equal (CF=0).    \n| REX + 0F 93| SETAE r/m8* | M    | Valid      | N.E.           | Set byte if above or equal (CF=0).    \n| 0F 92      | SETB r/m8   | M    | Valid      | Valid          | Set byte if below (CF=1).             \n| REX + 0F 92| SETB r/m8*  | M    | Valid      | N.E.           | Set byte if below (CF=1).             \n| 0F 96      | SETBE r/m8  | M    | Valid      | Valid          | Set byte if below or equal (CF=1 or   \n|            |             |      |            |                | ZF=1).                                \n| REX + 0F 96| SETBE r/m8* | M    | Valid      | N.E.           | Set byte if below or equal (CF=1 or   \n|            |             |      |            |                | ZF=1).                                \n| 0F 92      | SETC r/m8   | M    | Valid      | Valid          | Set byte if carry (CF=1).             \n| REX + 0F 92| SETC r/m8*  | M    | Valid      | N.E.           | Set byte if carry (CF=1).             \n| 0F 94      | SETE r/m8   | M    | Valid      | Valid          | Set byte if equal (ZF=1).             \n| REX + 0F 94| SETE r/m8*  | M    | Valid      | N.E.           | Set byte if equal (ZF=1).             \n| 0F 9F      | SETG r/m8   | M    | Valid      | Valid          | Set byte if greater (ZF=0 and SF=OF). \n| REX + 0F 9F| SETG r/m8*  | M    | Valid      | N.E.           | Set byte if greater (ZF=0 and SF=OF). \n| 0F 9D      | SETGE r/m8  | M    | Valid      | Valid          | Set byte if greater or equal (SF=OF). \n| REX + 0F 9D| SETGE r/m8* | M    | Valid      | N.E.           | Set byte if greater or equal (SF=OF). \n| 0F 9C      | SETL r/m8   | M    | Valid      | Valid          | Set byte if less (SF!= OF).            \n| REX + 0F 9C| SETL r/m8*  | M    | Valid      | N.E.           | Set byte if less (SF!= OF).            \n| 0F 9E      | SETLE r/m8  | M    | Valid      | Valid          | Set byte if less or equal (ZF=1 or SF!=\n|            |             |      |            |                | OF).                                  \n| REX + 0F 9E| SETLE r/m8* | M    | Valid      | N.E.           | Set byte if less or equal (ZF=1 or SF!=\n|            |             |      |            |                | OF).                                  \n| 0F 96      | SETNA r/m8  | M    | Valid      | Valid          | Set byte if not above (CF=1 or ZF=1). \n| REX + 0F 96| SETNA r/m8* | M    | Valid      | N.E.           | Set byte if not above (CF=1 or ZF=1). \n| 0F 92      | SETNAE r/m8 | M    | Valid      | Valid          | Set byte if not above or equal (CF=1).\n| REX + 0F 92| SETNAE r/m8*| M    | Valid      | N.E.           | Set byte if not above or equal (CF=1).\n| 0F 93      | SETNB r/m8  | M    | Valid      | Valid          | Set byte if not below (CF=0).         \n| REX + 0F 93| SETNB r/m8* | M    | Valid      | N.E.           | Set byte if not below (CF=0).         \n| 0F 97      | SETNBE r/m8 | M    | Valid      | Valid          | Set byte if not below or equal (CF=0  \n|            |             |      |            |                | and ZF=0).                            \n| REX + 0F 97| SETNBE r/m8*| M    | Valid      | N.E.           | Set byte if not below or equal (CF=0  \n|            |             |      |            |                | and ZF=0).                            \n| 0F 93      | SETNC r/m8  | M    | Valid      | Valid          | Set byte if not carry (CF=0).         \n| REX + 0F 93| SETNC r/m8* | M    | Valid      | N.E.           | Set byte if not carry (CF=0).         \n| 0F 95      | SETNE r/m8  | M    | Valid      | Valid          | Set byte if not equal (ZF=0).         \n| REX + 0F 95| SETNE r/m8* | M    | Valid      | N.E.           | Set byte if not equal (ZF=0).         \n| 0F 9E      | SETNG r/m8  | M    | Valid      | Valid          | Set byte if not greater (ZF=1 or SF!=  \n|            |             |      |            |                | OF)                                   \n| REX + 0F 9E| SETNG r/m8* | M    | Valid      | N.E.           | Set byte if not greater (ZF=1 or SF!=  \n|            |             |      |            |                | OF).                                  \n| 0F 9C      | SETNGE r/m8 | M    | Valid      | Valid          | Set byte if not greater or equal (SF!= \n|            |             |      |            |                | OF).                                  \n| REX + 0F 9C| SETNGE r/m8*| M    | Valid      | N.E.           | Set byte if not greater or equal (SF!= \n|            |             |      |            |                | OF).                                  \n| 0F 9D      | SETNL r/m8  | M    | Valid      | Valid          | Set byte if not less (SF=OF).         \n| REX + 0F 9D| SETNL r/m8* | M    | Valid      | N.E.           | Set byte if not less (SF=OF).         \n| 0F 9F      | SETNLE r/m8 | M    | Valid      | Valid          | Set byte if not less or equal (ZF=0   \n|            |             |      |            |                | and SF=OF).                           \n| Opcode     | Instruction | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| REX + 0F 9F| SETNLE r/m8*| M    | Valid      | N.E.           | Set byte if not less or equal (ZF=0   \n|            |             |      |            |                | and SF=OF).                           \n| 0F 91      | SETNO r/m8  | M    | Valid      | Valid          | Set byte if not overflow (OF=0).      \n| REX + 0F 91| SETNO r/m8* | M    | Valid      | N.E.           | Set byte if not overflow (OF=0).      \n| 0F 9B      | SETNP r/m8  | M    | Valid      | Valid          | Set byte if not parity (PF=0).        \n| REX + 0F 9B| SETNP r/m8* | M    | Valid      | N.E.           | Set byte if not parity (PF=0).        \n| 0F 99      | SETNS r/m8  | M    | Valid      | Valid          | Set byte if not sign (SF=0).          \n| REX + 0F 99| SETNS r/m8* | M    | Valid      | N.E.           | Set byte if not sign (SF=0).          \n| 0F 95      | SETNZ r/m8  | M    | Valid      | Valid          | Set byte if not zero (ZF=0).          \n| REX + 0F 95| SETNZ r/m8* | M    | Valid      | N.E.           | Set byte if not zero (ZF=0).          \n| 0F 90      | SETO r/m8   | M    | Valid      | Valid          | Set byte if overflow (OF=1)           \n| REX + 0F 90| SETO r/m8*  | M    | Valid      | N.E.           | Set byte if overflow (OF=1).          \n| 0F 9A      | SETP r/m8   | M    | Valid      | Valid          | Set byte if parity (PF=1).            \n| REX + 0F 9A| SETP r/m8*  | M    | Valid      | N.E.           | Set byte if parity (PF=1).            \n| 0F 9A      | SETPE r/m8  | M    | Valid      | Valid          | Set byte if parity even (PF=1).       \n| REX + 0F 9A| SETPE r/m8* | M    | Valid      | N.E.           | Set byte if parity even (PF=1).       \n| 0F 9B      | SETPO r/m8  | M    | Valid      | Valid          | Set byte if parity odd (PF=0).        \n| REX + 0F 9B| SETPO r/m8* | M    | Valid      | N.E.           | Set byte if parity odd (PF=0).        \n| 0F 98      | SETS r/m8   | M    | Valid      | Valid          | Set byte if sign (SF=1).              \n| REX + 0F 98| SETS r/m8*  | M    | Valid      | N.E.           | Set byte if sign (SF=1).              \n| 0F 94      | SETZ r/m8   | M    | Valid      | Valid          | Set byte if zero (ZF=1).              \n| REX + 0F 94| SETZ r/m8*  | M    | Valid      | N.E.           | Set byte if zero (ZF=1).              \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nSets the destination operand to 0 or 1 depending on the settings of the status\nflags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand\npoints to a byte register or a byte in memory. The condition code suffix (cc)\nindicates the condition being tested for.\n\nThe terms \u201cabove\u201d and \u201cbelow\u201d are associated with the CF flag and refer to the\nrelationship between two unsigned integer values. The terms \u201cgreater\u201d and \u201cless\u201d\nare associated with the SF and OF flags and refer to the relationship between\ntwo signed integer values.\n\nMany of the SETcc instruction opcodes have alternate mnemonics. For example,\nSETG (set byte if greater) and SETNLE (set if not less or equal) have the same\nopcode and test for the same condition: ZF equals 0 and SF equals OF. These\nalternate mnemonics are provided to make code more intelligible. Appendix B,\n\u201cEFLAGS Condition Codes,\u201d in the Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1, shows the alternate mnemonics for various test\nconditions.\n\nSome languages represent a logical one as an integer with all bits set. This\nrepresentation can be obtained by choosing the logically opposite condition\nfor the SETcc instruction, then decrementing the result. For example, to test\nfor overflow, use the SETNO instruction, then decrement the result.\n\nIn IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable\nuniform addressing to additional byte registers. Otherwise, this instruction's\noperation is the same as in legacy mode and compatibility mode.\n\nOperation:\n\nIF condition\n  THEN DEST <- 1;\n  ELSE DEST <- 0;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register contains a NULL segment     \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit.                       \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #UD            | If the LOCK prefix is used.          \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "SETcc"
    }, 
    {
      "description": "\nSFENCE - Store Fence:\n| Opcode* | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                 \n| 0F AE /7| SFENCE     | NP   | Valid      | Valid          | Serializes store operations.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nPerforms a serializing operation on all store-to-memory instructions that were\nissued prior the SFENCE instruction. This serializing operation guarantees that\nevery store instruction that precedes the SFENCE instruction in program order\nbecomes globally visible before any store instruction that follows the SFENCE\ninstruction. The SFENCE instruction is ordered with respect to store instructions,\nother SFENCE instructions, any LFENCE and MFENCE instructions, and any serializing\ninstructions (such as the CPUID instruction). It is not ordered with respect\nto load instructions.\n\nWeakly ordered memory types can be used to achieve higher processor performance\nthrough such techniques as out-of-order issue, write-combining, and write-collapsing.\nThe degree to which a consumer of data recognizes or knows that the data is\nweakly ordered varies among applications and may be unknown to the producer\nof this data. The SFENCE instruction provides a performance-efficient way of\nensuring store ordering between routines that produce weakly-ordered results\nand routines that consume this data.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nWait_On_Following_Stores_Until(preceding_stores_globally_visible);\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nvoid _mm_sfence(void)\n\n\nExceptions (All Operating Modes):\n| #UD| If CPUID.01H:EDX.SSE[bit 25] = 0. If\n|    | the LOCK prefix is used.            \n", 
      "mnem": "SFENCE"
    }, 
    {
      "description": "\nSGDT - Store Global Descriptor Table Register:\n| Opcode* | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description     \n| 0F 01 /0| SGDT m     | M    | Valid      | Valid          | Store GDTR to m.\nNotes: * See IA-32 Architecture Compatibility section below.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nStores the content of the global descriptor table register (GDTR) in the destination\noperand. The destination operand specifies a memory location.\n\nIn legacy or compatibility mode, the destination operand is a 6-byte memory\nlocation. If the operand-size attribute is 16 bits, the limit is stored in the\nlow 2 bytes and the 24-bit base address is stored in bytes 3-5, and byte 6 is\nzero-filled. If the operand-size attribute is 32 bits, the 16-bit limit field\nof the register is stored in the low 2 bytes of the memory location and the\n32-bit base address is stored in the high 4 bytes.\n\nIn IA-32e mode, the operand size is fixed at 8+2 bytes. The instruction stores\nan 8-byte base and a 2-byte limit.\n\nSGDT is useful only by operating-system software. However, it can be used in\napplication programs without causing an exception to be generated. See \u201cLGDT/LIDT - Load\nGlobal/Interrupt Descriptor Table Register\u201d in Chapter 3, Intel\u00ae 64 and IA-32\nArchitectures Software Developer's Manual, Volume 2A, for information on loading\nthe GDTR and IDTR.\n\n\nIA-32 Architecture Compatibility:\nThe 16-bit form of the SGDT is compatible with the Intel 286 processor if the\nupper 8 bits are not referenced. The Intel 286 processor fills these bits with\n1s; the Pentium 4, Intel Xeon, P6 processor family, Pentium, Intel486, and Intel386\u2122\nprocessors fill these bits with 0s.\n\nOperation:\n\nIF instruction is SGDT\n     IF OperandSize = 16\n       THEN\n          DEST[0:15] <- GDTR(Limit);\n          DEST[16:39] <- GDTR(Base); (* 24 bits of base address stored *)\n          DEST[40:47] <- 0;\n       ELSE IF (32-bit Operand Size)\n          DEST[0:15] <- GDTR(Limit);\n          DEST[16:47] <- GDTR(Base); (* Full 32-bit base address stored *)\n          FI;\n       ELSE (* 64-bit Operand Size *)\n          DEST[0:15] <- GDTR(Limit);\n          DEST[16:79] <- GDTR(Base); (* Full 64-bit base address stored *)\n     FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #UD            | If the destination operand is a register.      \n|                | If the LOCK prefix is used.                    \n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register is used to access           \n|                | memory and it contains a NULL segment          \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n\nReal-Address Mode Exceptions:\n| #UD| If the destination operand is a register.\n|    | If the LOCK prefix is used.              \n| #GP| If a memory operand effective address    \n|    | is outside the CS, DS, ES, FS, or GS     \n|    | segment limit.                           \n| #SS| If a memory operand effective address    \n|    | is outside the SS segment limit.         \n\nVirtual-8086 Mode Exceptions:\n| #UD            | If the destination operand is a register.\n|                | If the LOCK prefix is used.              \n| #GP(0)         | If a memory operand effective address    \n|                | is outside the CS, DS, ES, FS, or GS     \n|                | segment limit.                           \n| #SS(0)         | If a memory operand effective address    \n|                | is outside the SS segment limit.         \n| #PF(fault-code)| If a page fault occurs.                  \n| #AC(0)         | If alignment checking is enabled and     \n|                | an unaligned memory reference is made.   \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #UD            | If the destination operand is a register.  \n|                | If the LOCK prefix is used.                \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n", 
      "mnem": "SGDT"
    }, 
    {
      "description": "-R:SAL", 
      "mnem": "SHL"
    }, 
    {
      "description": "\nSHLD - Double Precision Shift Left:\n| Opcode*            | Instruction          | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                              \n| 0F A4 /r ib        | SHLD r/m16, r16, imm8| MRI  | Valid      | Valid          | Shift r/m16 to left imm8 places while    \n|                    |                      |      |            |                | shifting bits from r16 in from the right.\n| 0F A5 /r           | SHLD r/m16, r16, CL  | MRC  | Valid      | Valid          | Shift r/m16 to left CL places while      \n|                    |                      |      |            |                | shifting bits from r16 in from the right.\n| 0F A4 /r ib        | SHLD r/m32, r32, imm8| MRI  | Valid      | Valid          | Shift r/m32 to left imm8 places while    \n|                    |                      |      |            |                | shifting bits from r32 in from the right.\n| REX.W + 0F A4 /r ib| SHLD r/m64, r64, imm8| MRI  | Valid      | N.E.           | Shift r/m64 to left imm8 places while    \n|                    |                      |      |            |                | shifting bits from r64 in from the right.\n| 0F A5 /r           | SHLD r/m32, r32, CL  | MRC  | Valid      | Valid          | Shift r/m32 to left CL places while      \n|                    |                      |      |            |                | shifting bits from r32 in from the right.\n| REX.W + 0F A5 /r   | SHLD r/m64, r64, CL  | MRC  | Valid      | N.E.           | Shift r/m64 to left CL places while      \n|                    |                      |      |            |                | shifting bits from r64 in from the right.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MRI  | ModRM:r/m (w)| ModRM:reg (r)| imm8     | NA       \n| MRC  | ModRM:r/m (w)| ModRM:reg (r)| CL       | NA       \n\nDescription:\nThe SHLD instruction is used for multi-precision shifts of 64 bits or more.\n\nThe instruction shifts the first operand (destination operand) to the left the\nnumber of bits specified by the third operand (count operand). The second operand\n(source operand) provides bits to shift in from the right (starting with bit\n0 of the destination operand).\n\nThe destination operand can be a register or a memory location; the source operand\nis a register. The count operand is an unsigned integer that can be stored in\nan immediate byte or in the CL register. If the count operand is CL, the shift\ncount is the logical AND of CL and a count mask. In non-64-bit modes and default\n64-bit mode; only bits 0 through 4 of the count are used. This masks the count\nto a value between 0 and 31. If a count is greater than the operand size, the\nresult is undefined.\n\nIf the count is 1 or greater, the CF flag is filled with the last bit shifted\nout of the destination operand. For a 1-bit shift, the OF flag is set if a sign\nchange occurred; otherwise, it is cleared. If the count operand is 0, flags\nare not affected.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits (upgrading\nthe count mask to 6 bits). See the summary chart at the beginning of this section\nfor encoding data and limits.\n\nOperation:\n\nIF (In 64-Bit Mode and REX.W = 1)\n  THEN COUNT <- COUNT MOD 64;\n  ELSE COUNT <- COUNT MOD 32;\nFI\nSIZE <- OperandSize;\nIF COUNT = 0\n  THEN\n     No operation;\n  ELSE\n     IF COUNT > SIZE\n       THEN (* Bad parameters *)\n          DEST is undefined;\n          CF, OF, SF, ZF, AF, PF are undefined;\n       ELSE (* Perform the shift *)\n          CF <- BIT[DEST, SIZE - COUNT];\n          (* Last bit shifted out on exit *)\n          FOR i <- SIZE - 1 DOWN TO COUNT\n             DO\n               Bit(DEST, i) <- Bit(DEST, i - COUNT);\n             OD;\n          FOR i <- COUNT - 1 DOWN TO 0\n             DO\n               BIT[DEST, i] <- BIT[SRC, i - COUNT + SIZE];\n             OD;\n     FI;\nFI;\n\nFlags Affected:\nIf the count is 1 or greater, the CF flag is filled with the last bit shifted\nout of the destination operand and the SF, ZF, and PF flags are set according\nto the value of the result. For a 1-bit shift, the OF flag is set if a sign\nchange occurred; otherwise, it is cleared. For shifts greater than 1 bit, the\nOF flag is undefined. If a shift occurs, the AF flag is undefined. If the count\noperand is 0, the flags are not affected. If the count is greater than the operand\nsize, the flags are undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register contains a NULL segment     \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "SHLD"
    }, 
    {
      "description": "-R:SARX", 
      "mnem": "SHLX"
    }, 
    {
      "description": "-R:SAL", 
      "mnem": "SHR"
    }, 
    {
      "description": "\nSHRD - Double Precision Shift Right:\n| Opcode*            | Instruction          | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                             \n| 0F AC /r ib        | SHRD r/m16, r16, imm8| MRI  | Valid      | Valid          | Shift r/m16 to right imm8 places while  \n|                    |                      |      |            |                | shifting bits from r16 in from the left.\n| 0F AD /r           | SHRD r/m16, r16, CL  | MRC  | Valid      | Valid          | Shift r/m16 to right CL places while    \n|                    |                      |      |            |                | shifting bits from r16 in from the left.\n| 0F AC /r ib        | SHRD r/m32, r32, imm8| MRI  | Valid      | Valid          | Shift r/m32 to right imm8 places while  \n|                    |                      |      |            |                | shifting bits from r32 in from the left.\n| REX.W + 0F AC /r ib| SHRD r/m64, r64, imm8| MRI  | Valid      | N.E.           | Shift r/m64 to right imm8 places while  \n|                    |                      |      |            |                | shifting bits from r64 in from the left.\n| 0F AD /r           | SHRD r/m32, r32, CL  | MRC  | Valid      | Valid          | Shift r/m32 to right CL places while    \n|                    |                      |      |            |                | shifting bits from r32 in from the left.\n| REX.W + 0F AD /r   | SHRD r/m64, r64, CL  | MRC  | Valid      | N.E.           | Shift r/m64 to right CL places while    \n|                    |                      |      |            |                | shifting bits from r64 in from the left.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MRI  | ModRM:r/m (w)| ModRM:reg (r)| imm8     | NA       \n| MRC  | ModRM:r/m (w)| ModRM:reg (r)| CL       | NA       \n\nDescription:\nThe SHRD instruction is useful for multi-precision shifts of 64 bits or more.\n\nThe instruction shifts the first operand (destination operand) to the right\nthe number of bits specified by the third operand (count operand). The second\noperand (source operand) provides bits to shift in from the left (starting with\nthe most significant bit of the destination operand).\n\nThe destination operand can be a register or a memory location; the source operand\nis a register. The count operand is an unsigned integer that can be stored in\nan immediate byte or the CL register. If the count operand is CL, the shift\ncount is the logical AND of CL and a count mask. In non-64-bit modes and default\n64-bit mode, the width of the count mask is 5 bits. Only bits 0 through 4 of\nthe count register are used (masking the count to a value between 0 and 31).\nIf the count is greater than the operand size, the result is undefined.\n\nIf the count is 1 or greater, the CF flag is filled with the last bit shifted\nout of the destination operand. For a 1-bit shift, the OF flag is set if a sign\nchange occurred; otherwise, it is cleared. If the count operand is 0, flags\nare not affected.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits (upgrading\nthe count mask to 6 bits). See the summary chart at the beginning of this section\nfor encoding data and limits.\n\nOperation:\n\nIF (In 64-Bit Mode and REX.W = 1)\n  THEN COUNT <- COUNT MOD 64;\n  ELSE COUNT <- COUNT MOD 32;\nFI\nSIZE <- OperandSize;\nIF COUNT = 0\n  THEN\n     No operation;\n  ELSE\n     IF COUNT > SIZE\n       THEN (* Bad parameters *)\n          DEST is undefined;\n          CF, OF, SF, ZF, AF, PF are undefined;\n       ELSE (* Perform the shift *)\n          CF <- BIT[DEST, COUNT - 1]; (* Last bit shifted out on exit *)\n          FOR i <- 0 TO SIZE - 1 - COUNT\n             DO\n               BIT[DEST, i] <- BIT[DEST, i + COUNT];\n             OD;\n          FOR i <- SIZE - COUNT TO SIZE - 1\n             DO\n               BIT[DEST,i] <- BIT[SRC, i + COUNT - SIZE];\n             OD;\n     FI;\nFI;\n\nFlags Affected:\nIf the count is 1 or greater, the CF flag is filled with the last bit shifted\nout of the destination operand and the SF, ZF, and PF flags are set according\nto the value of the result. For a 1-bit shift, the OF flag is set if a sign\nchange occurred; otherwise, it is cleared. For shifts greater than 1 bit, the\nOF flag is undefined. If a shift occurs, the AF flag is undefined. If the count\noperand is 0, the flags are not affected. If the count is greater than the operand\nsize, the flags are undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register contains a NULL segment     \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "SHRD"
    }, 
    {
      "description": "-R:SARX", 
      "mnem": "SHRX"
    }, 
    {
      "description": "\nSHUFPD - Shuffle Packed Double-Precision Floating-Point Values:\n| Opcode*/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                  \n| 66 0F C6 /r ib SHUFPD xmm1, xmm2/m128,| RMI  | V/V                   | SSE2              | Shuffle packed double-precision floatingpoint\n| imm8                                  |      |                       |                   | values selected by imm8 from xmm1 and        \n|                                       |      |                       |                   | xmm2/m128 to xmm1.                           \n| VEX.NDS.128.66.0F.WIG C6 /r ib VSHUFPD| RVMI | V/V                   | AVX               | Shuffle Packed double-precision floatingpoint\n| xmm1, xmm2, xmm3/m128, imm8           |      |                       |                   | values selected by imm8 from xmm2 and        \n|                                       |      |                       |                   | xmm3/mem.                                    \n| VEX.NDS.256.66.0F.WIG C6 /r ib VSHUFPD| RVMI | V/V                   | AVX               | Shuffle Packed double-precision floatingpoint\n| ymm1, ymm2, ymm3/m256, imm8           |      |                       |                   | values selected by imm8 from ymm2 and        \n|                                       |      |                       |                   | ymm3/mem.                                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nMoves either of the two packed double-precision floating-point values from destination\noperand (first operand) into the low quadword of the destination operand; moves\neither of the two packed double-precision floating-point values from the source\noperand into to the high quadword of the destination operand (see Figure 4-21).\nThe select operand (third operand) determines which values are moved to the\ndestination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsource can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed. VEX.256 encoded version:\nThe first source operand is a YMM register. The second source operand can be\na YMM register or a 256-bit memory location. The destination operand is a YMM\nregister.\n\n| X1                      | X0 DEST     \n| Y1                      | Y0 X1 or X0 \n| SHUFPD Shuffle Operation| Figure 4-21.\nThe source operand can be an XMM register or a 128-bit memory location. The\ndestination operand is an XMM register. The select operand is an 8-bit immediate:\nbit 0 selects which value is moved from the destination operand to the result\n(where 0 selects the low quadword and 1 selects the high quadword) and bit 1\nselects which value is moved from the source operand to the result. Bits 2 through\n7 of the select operand are reserved and must be set to 0.\n\nOperation:\n\nIF SELECT[0] = 0\n  THEN DEST[63:0]\n  ELSE DEST[63:0]\nIF SELECT[1] = 0\n  THEN DEST[127:64]\n  ELSE DEST[127:64]\nSHUFPD (128-bit Legacy SSE version)\nIF IMM0[0] = 0\n  THEN DEST[63:0] <- SRC1[63:0]\n  ELSE DEST[63:0] <- SRC1[127:64] FI;\nIF IMM0[1] = 0\n  THEN DEST[127:64] <- SRC2[63:0]\n  ELSE DEST[127:64] <- SRC2[127:64] FI;\nDEST[VLMAX-1:128] (Unmodified)\nVSHUFPD (VEX.128 encoded version)\nIF IMM0[0] = 0\n  THEN DEST[63:0] <- SRC1[63:0]\n  ELSE DEST[63:0] <- SRC1[127:64] FI;\nIF IMM0[1] = 0\n  THEN DEST[127:64] <- SRC2[63:0]\n  ELSE DEST[127:64] <- SRC2[127:64] FI;\nDEST[VLMAX-1:128] <- 0\nVSHUFPD (VEX.256 encoded version)\nIF IMM0[0] = 0\n  THEN DEST[63:0] <- SRC1[63:0]\n  ELSE DEST[63:0] <- SRC1[127:64] FI;\nIF IMM0[1] = 0\n  THEN DEST[127:64] <- SRC2[63:0]\n  ELSE DEST[127:64] <- SRC2[127:64] FI;\nIF IMM0[2] = 0\n  THEN DEST[191:128] <- SRC1[191:128]\n  ELSE DEST[191:128] <- SRC1[255:192] FI;\nIF IMM0[3] = 0\n  THEN DEST[255:192] <- SRC2[191:128]\n  ELSE DEST[255:192] <- SRC2[255:192] FI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| SHUFPD: | __m128d _mm_shuffle_pd(__m128d a, __m128d\n|         | b, unsigned int imm8)                    \n| VSHUFPD:| __m256d _mm256_shuffle_pd (__m256d a,    \n|         | __m256d b, const int select);            \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "SHUFPD"
    }, 
    {
      "description": "\nSHUFPS - Shuffle Packed Single-Precision Floating-Point Values:\n| Opcode*/Instruction                | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                   \n| 0F C6 /r ib SHUFPS xmm1, xmm2/m128,| RMI  | V/V                   | SSE               | Shuffle packed single-precision floating-point\n| imm8                               |      |                       |                   | values selected by imm8 from xmm1 and         \n|                                    |      |                       |                   | xmm1/m128 to xmm1.                            \n| VEX.NDS.128.0F.WIG C6 /r ib VSHUFPS| RVMI | V/V                   | AVX               | Shuffle Packed single-precision floating-point\n| xmm1, xmm2, xmm3/m128, imm8        |      |                       |                   | values selected by imm8 from xmm2 and         \n|                                    |      |                       |                   | xmm3/mem.                                     \n| VEX.NDS.256.0F.WIG C6 /r ib VSHUFPS| RVMI | V/V                   | AVX               | Shuffle Packed single-precision floating-point\n| ymm1, ymm2, ymm3/m256, imm8        |      |                       |                   | values selected by imm8 from ymm2 and         \n|                                    |      |                       |                   | ymm3/mem.                                     \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RMI  | ModRM:reg (r, w)| ModRM:r/m (r)| imm8         | NA       \n| RVMI | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| imm8     \n\nDescription:\nMoves two of the four packed single-precision floating-point values from the\ndestination operand (first operand) into the low quadword of the destination\noperand; moves two of the four packed single-precision floating-point values\nfrom the source operand (second operand) into to the high quadword of the destination\noperand (see Figure 4-22). The select operand (third operand) determines which\nvalues are moved to the destination operand.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsource can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed. determines which values\nare moved to the destination operand.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second\nsource operand can be a YMM register or a 256-bit memory location. The destination\noperand is a YMM register.\n\n| DEST| X3                    | X2                                | X1       | X0       \n| SRC | Y3                    | Y2                                | Y1       | Y0       \n| DEST| Y3 ... Y0 Figure 4-22.| Y3 ... Y0 SHUFPS Shuffle Operation| X3 ... X0| X3 ... X0\nThe source operand can be an XMM register or a 128-bit memory location. The\ndestination operand is an XMM register. The select operand is an 8-bit immediate:\nbits 0 and 1 select the value to be moved from the destination operand to the\nlow doubleword of the result, bits 2 and 3 select the value to be moved from\nthe destination operand to the second doubleword of the result, bits 4 and 5\nselect the value to be moved from the source operand to the third doubleword\nof the result, and bits 6 and 7 select the value to be moved from the source\noperand to the high doubleword of the result.\n\nOperation:\n\nCASE (SELECT[1:0]) OF\n  0:\n  1:\n  2:\n  3:\nESAC;\nCASE (SELECT[3:2]) OF\n  0:\n  1:\n  2:\n  3:\nESAC;\nCASE (SELECT[5:4]) OF\n  0:\n  1:\n  2:\n  3:\nESAC;\nCASE (SELECT[7:6]) OF\n  0:\n  1:\n  2:\n  3:\nESAC;\nSHUFPS (128-bit Legacy SSE version)\nDEST[31:0] <- Select4(SRC1[127:0], imm8[1:0]);\nDEST[63:32] <- Select4(SRC1[127:0], imm8[3:2]);\nDEST[95:64] <- Select4(SRC2[127:0], imm8[5:4]);\nDEST[127:96] <- Select4(SRC2[127:0], imm8[7:6]);\nDEST[VLMAX-1:128] (Unmodified)\nVSHUFPS (VEX.128 encoded version)\nDEST[31:0] <- Select4(SRC1[127:0], imm8[1:0]);\nDEST[63:32] <- Select4(SRC1[127:0], imm8[3:2]);\nDEST[95:64] <- Select4(SRC2[127:0], imm8[5:4]);\nDEST[127:96] <- Select4(SRC2[127:0], imm8[7:6]);\nDEST[VLMAX-1:128] <- 0\nVSHUFPS (VEX.256 encoded version)\nDEST[31:0] <- Select4(SRC1[127:0], imm8[1:0]);\nDEST[63:32] <- Select4(SRC1[127:0], imm8[3:2]);\nDEST[95:64] <- Select4(SRC2[127:0], imm8[5:4]);\nDEST[127:96] <- Select4(SRC2[127:0], imm8[7:6]);\nDEST[159:128] <- Select4(SRC1[255:128], imm8[1:0]);\nDEST[191:160] <- Select4(SRC1[255:128], imm8[3:2]);\nDEST[223:192] <- Select4(SRC2[255:128], imm8[5:4]);\nDEST[255:224] <- Select4(SRC2[255:128], imm8[7:6]);\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| SHUFPS: | __m128 _mm_shuffle_ps(__m128 a, __m128\n|         | b, unsigned int imm8)                 \n| VSHUFPS:| __m256 _mm256_shuffle_ps (__m256 a,   \n|         | __m256 b, const int select);          \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "SHUFPS"
    }, 
    {
      "description": "\nSIDT - Store Interrupt Descriptor Table Register:\n| Opcode* | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description     \n| 0F 01 /1| SIDT m     | M    | Valid      | Valid          | Store IDTR to m.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nStores the content the interrupt descriptor table register (IDTR) in the destination\noperand. The destination operand specifies a 6-byte memory location.\n\nIn non-64-bit modes, if the operand-size attribute is 32 bits, the 16-bit limit\nfield of the register is stored in the low 2 bytes of the memory location and\nthe 32-bit base address is stored in the high 4 bytes. If the operand-size attribute\nis 16 bits, the limit is stored in the low 2 bytes and the 24-bit base address\nis stored in the third, fourth, and fifth byte, with the sixth byte filled with\n0s.\n\nIn 64-bit mode, the operand size fixed at 8+2 bytes. The instruction stores\n8-byte base and 2-byte limit values.\n\nSIDT is only useful in operating-system software; however, it can be used in\napplication programs without causing an exception to be generated. See \u201cLGDT/LIDT - Load\nGlobal/Interrupt Descriptor Table Register\u201d in Chapter 3, Intel\u00ae 64 and IA-32\nArchitectures Software Developer's Manual, Volume 2A, for information on loading\nthe GDTR and IDTR.\n\n\nIA-32 Architecture Compatibility:\nThe 16-bit form of SIDT is compatible with the Intel 286 processor if the upper\n8 bits are not referenced. The Intel 286 processor fills these bits with 1s;\nthe Pentium 4, Intel Xeon, P6 processor family, Pentium, Intel486, and Intel386\nprocessors fill these bits with 0s.\n\nOperation:\n\nIF instruction is SIDT\n  THEN\n     IF OperandSize = 16\n       THEN\n          DEST[0:15] <- IDTR(Limit);\n          DEST[16:39] <- IDTR(Base); (* 24 bits of base address stored; *)\n          DEST[40:47] <- 0;\n       ELSE IF (32-bit Operand Size)\n          DEST[0:15] <- IDTR(Limit);\n          DEST[16:47] <- IDTR(Base); FI; (* Full 32-bit base address stored *)\n       ELSE (* 64-bit Operand Size *)\n          DEST[0:15] <- IDTR(Limit);\n          DEST[16:79] <- IDTR(Base); (* Full 64-bit base address stored *)\n     FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register is used to access           \n|                | memory and it contains a NULL segment          \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #UD            | If the destination operand is a register.  \n|                | If the LOCK prefix is used.                \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n", 
      "mnem": "SIDT"
    }, 
    {
      "description": "\nSLDT - Store Local Descriptor Table Register:\n| Opcode*         | Instruction | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                         \n| 0F 00 /0        | SLDT r/m16  | M    | Valid      | Valid          | Stores segment selector from LDTR in\n|                 |             |      |            |                | r/m16.                              \n| REX.W + 0F 00 /0| SLDT r64/m16| M    | Valid      | Valid          | Stores segment selector from LDTR in\n|                 |             |      |            |                | r64/m16.                            \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nStores the segment selector from the local descriptor table register (LDTR)\nin the destination operand. The destination operand can be a general-purpose\nregister or a memory location. The segment selector stored with this instruction\npoints to the segment descriptor (located in the GDT) for the current LDT. This\ninstruction can only be executed in protected mode.\n\nOutside IA-32e mode, when the destination operand is a 32-bit register, the\n16-bit segment selector is copied into the low-order 16 bits of the register.\nThe high-order 16 bits of the register are cleared for the Pentium 4, Intel\nXeon, and P6 family processors. They are undefined for Pentium, Intel486, and\nIntel386 processors. When the destination operand is a memory location, the\nsegment selector is written to memory as a 16-bit quantity, regardless of the\noperand size.\n\nIn compatibility mode, when the destination operand is a 32-bit register, the\n16-bit segment selector is copied into the low-order 16 bits of the register.\nThe high-order 16 bits of the register are cleared. When the destination operand\nis a memory location, the segment selector is written to memory as a 16-bit\nquantity, regardless of the operand size.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional\nregisters (R8-R15). The behavior of SLDT with a 64-bit register is to zero-extend\nthe 16-bit selector and store it in the register. If the destination is memory\nand operand size is 64, SLDT will write the 16-bit selector to memory as a 16-bit\nquantity, regardless of the operand size\n\nOperation:\n\nDEST <- LDTR(SegmentSelector);\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register is used to access           \n|                | memory and it contains a NULL segment          \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #UD| The SLDT instruction is not recognized\n|    | in real-address mode.                 \nIf the LOCK prefix is used.\n\n\nVirtual-8086 Mode Exceptions:\n| #UD| The SLDT instruction is not recognized  \n|    | in virtual-8086 mode. If the LOCK prefix\n|    | is used.                                \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "SLDT"
    }, 
    {
      "description": "\nSMSW - Store Machine Status Word:\n| Opcode*         | Instruction | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| 0F 01 /4        | SMSW r/m16  | M    | Valid      | Valid          | Store machine status word to r/m16.   \n| 0F 01 /4        | SMSW r32/m16| M    | Valid      | Valid          | Store machine status word in low-order\n|                 |             |      |            |                | 16 bits of r32/m16; high-order 16 bits\n|                 |             |      |            |                | of r32 are undefined.                 \n| REX.W + 0F 01 /4| SMSW r64/m16| M    | Valid      | Valid          | Store machine status word in low-order\n|                 |             |      |            |                | 16 bits of r64/m16; high-order 16 bits\n|                 |             |      |            |                | of r32 are undefined.                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nStores the machine status word (bits 0 through 15 of control register CR0) into\nthe destination operand. The destination operand can be a general-purpose register\nor a memory location.\n\nIn non-64-bit modes, when the destination operand is a 32-bit register, the\nlow-order 16 bits of register CR0 are copied into the low-order 16 bits of the\nregister and the high-order 16 bits are undefined. When the destination operand\nis a memory location, the low-order 16 bits of register CR0 are written to memory\nas a 16-bit quantity, regardless of the operand size.\n\nIn 64-bit mode, the behavior of the SMSW instruction is defined by the following\nexamples:\n\n - SMSW r16 operand size 16, store CR0[15:0] in r16\n - SMSW r32 operand size 32, zero-extend CR0[31:0], and store in r32\n - SMSW r64 operand size 64, zero-extend CR0[63:0], and store in r64\n - SMSW m16 operand size 16, store CR0[15:0] in m16\n - SMSW m16 operand size 32, store CR0[15:0] in m16 (not m32)\n - SMSW m16 operands size 64, store CR0[15:0] in m16 (not m64)\n\nSMSW is only useful in operating-system software. However, it is not a privileged\ninstruction and can be used in application programs. The is provided for compatibility\nwith the Intel 286 processor. Programs and procedures intended to run on the\nPentium 4, Intel Xeon, P6 family, Pentium, Intel486, and Intel386 processors\nshould use the MOV (control registers) instruction to load the machine status\nword.\n\nSee \u201cChanges to Instruction Behavior in VMX Non-Root Operation\u201d in Chapter 25\nof the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n3C, for more information about the behavior of this instruction in VMX non-root\noperation.\n\nOperation:\n\nDEST <- CR0[15:0];\n(* Machine status word *)\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register is used to access           \n|                | memory and it contains a NULL segment          \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP   | If a memory operand effective address\n|       | is outside the CS, DS, ES, FS, or GS \n|       | segment limit.                       \n| #SS(0)| If a memory operand effective address\n|       | is outside the SS segment limit.     \n| #UD   | If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "SMSW"
    }, 
    {
      "description": "\nSQRTPD - Compute Square Roots of Packed Double-Precision Floating-Point Values:\n| Opcode*/Instruction                  | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                          \n| 66 0F 51 /r SQRTPD xmm1, xmm2/m128   | RM   | V/V                   | SSE2              | Computes square roots of the packed  \n|                                      |      |                       |                   | doubleprecision floating-point values\n|                                      |      |                       |                   | in xmm2/m128 and stores the results  \n|                                      |      |                       |                   | in xmm1.                             \n| VEX.128.66.0F.WIG 51 /r VSQRTPD xmm1,| RM   | V/V                   | AVX               | Computes Square Roots of the packed  \n| xmm2/m128                            |      |                       |                   | doubleprecision floating-point values\n|                                      |      |                       |                   | in xmm2/m128 and stores the result in\n|                                      |      |                       |                   | xmm1.                                \n| VEX.256.66.0F.WIG 51/r VSQRTPD ymm1, | RM   | V/V                   | AVX               | Computes Square Roots of the packed  \n| ymm2/m256                            |      |                       |                   | doubleprecision floating-point values\n|                                      |      |                       |                   | in ymm2/m256 and stores the result in\n|                                      |      |                       |                   | ymm1.                                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nPerforms a SIMD computation of the square roots of the two packed double-precision\nfloating-point values in the source operand (second operand) stores the packed\ndouble-precision floating-point results in the destination operand. The source\noperand can be an XMM register or a 128-bit memory location. The destination\noperand is an XMM register. See Figure 11-3 in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1, for an illustration of a SIMD double-precision\nfloating-point operation.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the source operand second source operand or a 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed. VEX.256 encoded version:\nThe source operand is a YMM register or a 256-bit memory location. The destination\noperand is a YMM register. Note: In VEX-encoded versions, VEX.vvvv is reserved\nand must be 1111b otherwise instructions will #UD.\n\nOperation:\n\nSQRTPD (128-bit Legacy SSE version)\nDEST[63:0] <- SQRT(SRC[63:0])\nDEST[127:64] <- SQRT(SRC[127:64])\nDEST[VLMAX-1:128] (Unmodified)\nVSQRTPD (VEX.128 encoded version)\nDEST[63:0] <- SQRT(SRC[63:0])\nDEST[127:64] <- SQRT(SRC[127:64])\nDEST[VLMAX-1:128] <- 0\nVSQRTPD (VEX.256 encoded version)\nDEST[63:0] <- SQRT(SRC[63:0])\nDEST[127:64] <- SQRT(SRC[127:64])\nDEST[191:128] <- SQRT(SRC[191:128])\nDEST[255:192] <- SQRT(SRC[255:192])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| SQRTPD:| __m128d _mm_sqrt_pd (m128d a)      \n| SQRTPD:| __m256d _mm256_sqrt_pd (__m256d a);\n\nSIMD Floating-Point Exceptions:\nInvalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "SQRTPD"
    }, 
    {
      "description": "\nSQRTPS - Compute Square Roots of Packed Single-Precision Floating-Point Values:\n| Opcode*/Instruction                         | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                          \n| 0F 51 /r SQRTPS xmm1, xmm2/m128             | RM   | V/V                   | SSE               | Computes square roots of the packed  \n|                                             |      |                       |                   | singleprecision floating-point values\n|                                             |      |                       |                   | in xmm2/m128 and stores the results  \n|                                             |      |                       |                   | in xmm1.                             \n| VEX.128.0F.WIG 51 /r VSQRTPS xmm1, xmm2/m128| RM   | V/V                   | AVX               | Computes Square Roots of the packed  \n|                                             |      |                       |                   | singleprecision floating-point values\n|                                             |      |                       |                   | in xmm2/m128 and stores the result in\n|                                             |      |                       |                   | xmm1.                                \n| VEX.256.0F.WIG 51/r VSQRTPS ymm1, ymm2/m256 | RM   | V/V                   | AVX               | Computes Square Roots of the packed  \n|                                             |      |                       |                   | singleprecision floating-point values\n|                                             |      |                       |                   | in ymm2/m256 and stores the result in\n|                                             |      |                       |                   | ymm1.                                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nPerforms a SIMD computation of the square roots of the four packed single-precision\nfloating-point values in the source operand (second operand) stores the packed\nsingle-precision floating-point results in the destination operand. The source\noperand can be an XMM register or a 128-bit memory location. The destination\noperand is an XMM register. See Figure 10-5 in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1, for an illustration of a SIMD single-precision\nfloating-point operation.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the source operand second source operand or a 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed. VEX.256 encoded version:\nThe source operand is a YMM register or a 256-bit memory location. The destination\noperand is a YMM register. Note: In VEX-encoded versions, VEX.vvvv is reserved\nand must be 1111b otherwise instructions will #UD.\n\nOperation:\n\nSQRTPS (128-bit Legacy SSE version)\nDEST[31:0] <- SQRT(SRC[31:0])\nDEST[63:32] <- SQRT(SRC[63:32])\nDEST[95:64] <- SQRT(SRC[95:64])\nDEST[127:96] <- SQRT(SRC[127:96])\nDEST[VLMAX-1:128] (Unmodified)\nVSQRTPS (VEX.128 encoded version)\nDEST[31:0] <- SQRT(SRC[31:0])\nDEST[63:32] <- SQRT(SRC[63:32])\nDEST[95:64] <- SQRT(SRC[95:64])\nDEST[127:96] <- SQRT(SRC[127:96])\nDEST[VLMAX-1:128] <- 0\nVSQRTPS (VEX.256 encoded version)\nDEST[31:0] <- SQRT(SRC[31:0])\nDEST[63:32] <- SQRT(SRC[63:32])\nDEST[95:64] <- SQRT(SRC[95:64])\nDEST[127:96] <- SQRT(SRC[127:96])\nDEST[159:128] <- SQRT(SRC[159:128])\nDEST[191:160] <- SQRT(SRC[191:160])\nDEST[223:192] <- SQRT(SRC[223:192])\nDEST[255:224] <- SQRT(SRC[255:224])\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| SQRTPS:| __m128 _mm_sqrt_ps(__m128 a)     \n| SQRTPS:| __m256 _mm256_sqrt_ps (__m256 a);\n\nSIMD Floating-Point Exceptions:\nInvalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "SQRTPS"
    }, 
    {
      "description": "\nSQRTSD - Compute Square Root of Scalar Double-Precision Floating-Point Value:\n| Opcode*/Instruction                          | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                    \n| F2 0F 51 /r SQRTSD xmm1, xmm2/m64            | RM   | V/V                   | SSE2              | Computes square root of the low doubleprecision\n|                                              |      |                       |                   | floating-point value in xmm2/m64 and           \n|                                              |      |                       |                   | stores the results in xmm1.                    \n| VEX.NDS.LIG.F2.0F.WIG 51/r VSQRTSD xmm1,xmm2,| RVM  | V/V                   | AVX               | Computes square root of the low doubleprecision\n| xmm3/m64                                     |      |                       |                   | floating point value in xmm3/m64 and           \n|                                              |      |                       |                   | stores the results in xmm2. Also, upper        \n|                                              |      |                       |                   | double precision floating-point value          \n|                                              |      |                       |                   | (bits[127:64]) from xmm2 are copied            \n|                                              |      |                       |                   | to xmm1[127:64].                               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nComputes the square root of the low double-precision floating-point value in\nthe source operand (second operand) and stores the double-precision floating-point\nresult in the destination operand. The source operand can be an XMM register\nor a 64-bit memory location. The destination operand is an XMM register. The\nhigh quadword of the destination operand remains unchanged. See Figure 11-4\nin the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1, for an illustration of a scalar double-precision floating-point operation.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nfirst source operand and the destination operand are the same. Bits (VLMAX1:64)\nof the corresponding YMM destination register remain unchanged. VEX.128 encoded\nversion: Bits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nOperation:\n\nSQRTSD (128-bit Legacy SSE version)\nDEST[63:0] <- SQRT(SRC[63:0])\nDEST[VLMAX-1:64] (Unmodified)\nVSQRTSD (VEX.128 encoded version)\nDEST[63:0] <- SQRT(SRC2[63:0])\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| SQRTSD:| __m128d _mm_sqrt_sd (m128d a, m128d\n|        | b)                                 \n\nSIMD Floating-Point Exceptions:\nInvalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "SQRTSD"
    }, 
    {
      "description": "\nSQRTSS - Compute Square Root of Scalar Single-Precision Floating-Point Value:\n| Opcode*/Instruction                     | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                    \n| F3 0F 51 /r SQRTSS xmm1, xmm2/m32       | RM   | V/V                   | SSE               | Computes square root of the low singleprecision\n|                                         |      |                       |                   | floating-point value in xmm2/m32 and           \n|                                         |      |                       |                   | stores the results in xmm1.                    \n| VEX.NDS.LIG.F3.0F.WIG 51/r VSQRTSS xmm1,| RVM  | V/V                   | AVX               | Computes square root of the low singleprecision\n| xmm2, xmm3/m32                          |      |                       |                   | floating-point value in xmm3/m32 and           \n|                                         |      |                       |                   | stores the results in xmm1. Also, upper        \n|                                         |      |                       |                   | single precision floating-point values         \n|                                         |      |                       |                   | (bits[127:32]) from xmm2 are copied            \n|                                         |      |                       |                   | to xmm1[127:32].                               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nComputes the square root of the low single-precision floating-point value in\nthe source operand (second operand) and stores the single-precision floating-point\nresult in the destination operand. The source operand can be an XMM register\nor a 32-bit memory location. The destination operand is an XMM register. The\nthree high-order doublewords of the destination operand remain unchanged. See\nFigure 10-6 in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 1, for an illustration of a scalar single-precision floating-point operation.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nfirst source operand and the destination operand are the same. Bits (VLMAX1:32)\nof the corresponding YMM destination register remain unchanged. VEX.128 encoded\nversion: Bits (VLMAX-1:128) of the destination YMM register are zeroed.\n\nOperation:\n\nSQRTSS (128-bit Legacy SSE version)\nDEST[31:0] <- SQRT(SRC2[31:0])\nDEST[VLMAX-1:32] (Unmodified)\nVSQRTSS (VEX.128 encoded version)\nDEST[31:0] <- SQRT(SRC2[31:0])\nDEST[127:32] <- SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| SQRTSS:| __m128 _mm_sqrt_ss(__m128 a)\n\nSIMD Floating-Point Exceptions:\nInvalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "SQRTSS"
    }, 
    {
      "description": "\nSTC - Set Carry Flag:\n| Opcode*| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description \n| F9     | STC        | NP   | Valid      | Valid          | Set CF flag.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nSets the CF flag in the EFLAGS register.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nCF <- 1;\n\nFlags Affected:\nThe CF flag is set. The OF, ZF, SF, AF, and PF flags are unaffected.\n\n\nExceptions (All Operating Modes):\n| #UD| If the LOCK prefix is used.\n", 
      "mnem": "STC"
    }, 
    {
      "description": "\nSTD - Set Direction Flag:\n| Opcode*| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description \n| FD     | STD        | NP   | Valid      | Valid          | Set DF flag.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nSets the DF flag in the EFLAGS register. When the DF flag is set to 1, string\noperations decrement the index registers (ESI and/or EDI).\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nDF <- 1;\n\nFlags Affected:\nThe DF flag is set. The CF, OF, ZF, SF, AF, and PF flags are unaffected.\n\n\nExceptions (All Operating Modes):\n| #UD| If the LOCK prefix is used.\n", 
      "mnem": "STD"
    }, 
    {
      "description": "\nSTI - Set Interrupt Flag:\n| Opcode*| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| FB     | STI        | NP   | Valid      | Valid          | Set interrupt flag; external, maskable\n|        |            |      |            |                | interrupts enabled at the end of the  \n|        |            |      |            |                | next instruction.                     \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nIf protected-mode virtual interrupts are not enabled, STI sets the interrupt\nflag (IF) in the EFLAGS register. After the IF flag is set, the processor begins\nresponding to external, maskable interrupts after the next instruction is executed.\nThe delayed effect of this instruction is provided to allow interrupts to be\nenabled just before returning from a procedure (or subroutine). For instance,\nif an STI instruction is followed by an RET instruction, the RET instruction\nis allowed to execute before external interrupts are recognized1. If the STI\ninstruction is followed by a CLI instruction (which clears the IF flag), the\neffect of the STI instruction is negated.\n\nThe IF flag and the STI and CLI instructions do not prohibit the generation\nof exceptions and NMI interrupts. NMI interrupts (and SMIs) may be blocked for\none macroinstruction following an STI.\n\nWhen protected-mode virtual interrupts are enabled, CPL is 3, and IOPL is less\nthan 3; STI sets the VIF flag in the EFLAGS register, leaving IF unaffected.\n\nTable 4-15 indicates the action of the STI instruction depending on the processor's\nmode of operation and the CPL/IOPL settings of the running program or procedure.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nTable 4-15. Decision Table for STI Results:\n| PE| VM| IOPL | CPL| PVI| VIP| VME| STI Result\n| 0 | X | X    | X  | X  | X  | X  | IF = 1    \n| 1 | 0 | \u2265 CPL| X  | X  | X  | X  | IF = 1    \n| 1 | 0 | < CPL| 3  | 1  | 0  | X  | VIF = 1   \n| 1 | 0 | < CPL| < 3| X  | X  | X  | GP Fault  \n| 1 | 0 | < CPL| X  | 0  | X  | X  | GP Fault  \n| 1 | 0 | < CPL| X  | X  | 1  | X  | GP Fault  \n| 1 | 1 | 3    | X  | X  | X  | X  | IF = 1    \n| 1 | 1 | < 3  | X  | X  | 0  | 1  | VIF = 1   \n| 1 | 1 | < 3  | X  | X  | 1  | X  | GP Fault  \n| 1 | 1 | < 3  | X  | X  | X  | 0  | GP Fault  \nNotes: X = This setting has no impact.\n\n| 1.| The STI instruction delays recognition      \n|   | of interrupts only if it is executed        \n|   | with EFLAGS.IF = 0. In a sequence of        \n|   | STI instructions, only the first instruction\n|   | in the sequence is guaranteed to delay      \n|   | interrupts. In the following instruction    \n|   | sequence, interrupts may be recognized      \n|   | before RET executes: STI STI RET            \nOperation:\n\nIF PE = 0\n  THEN\n     IF <- 1; (* Set Interrupt Flag *)\n  ELSE\n     IF VM = 0\n       THEN\n          IF IOPL \u2265 CPL\n             THEN\n               IF <- 1;\n          ELSE\n             IF (IOPL < CPL) and (CPL = 3) and (VIP = 0)\n               THEN\n                  VIF <- 1;\n               ELSE\n                  #GP(0);\n             FI;\n          FI;\n       ELSE\n          IF IOPL = 3\n             THEN\n               IF <- 1;\n          ELSE\n             IF ((IOPL < 3) and (VIP = 0) and (VME = 1))\n               THEN\n                  VIF <- 1;\n             ELSE\n               #GP(0); (* Trap to virtual-8086 monitor *)\n             FI;)\n          FI;\n     FI;\nFI;\n\nFlags Affected:\nThe IF flag is set to 1; or the VIF flag is set to 1.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the CPL is greater (has less privilege)\n|       | than the IOPL of the current program      \n|       | or procedure.                             \n| #UD   | If the LOCK prefix is used.               \n\nReal-Address Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "STI"
    }, 
    {
      "description": "\nSTMXCSR - Store MXCSR Register State:\n| Opcode*/Instruction             | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                        \n| 0F AE /3 STMXCSR m32            | M    | V/V                   | SSE               | Store contents of MXCSR register to\n|                                 |      |                       |                   | m32.                               \n| VEX.LZ.0F.WIG AE /3 VSTMXCSR m32| M    | V/V                   | AVX               | Store contents of MXCSR register to\n|                                 |      |                       |                   | m32.                               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nStores the contents of the MXCSR control and status register to the destination\noperand. The destination operand is a 32-bit memory location. The reserved bits\nin the MXCSR register are stored as 0s.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\nVEX.L must be 0, otherwise instructions will #UD.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise\ninstructions will #UD.\n\nOperation:\n\nm32 <- MXCSR;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n_mm_getcsr(void)\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 5; additionally\n\n| #UD| If VEX.L= 1, If VEX.vvvv != 1111B.\n", 
      "mnem": "STMXCSR"
    }, 
    {
      "description": "\nSTOS/STOSB/STOSW/STOSD/STOSQ - Store String:\n| Opcode    | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| AA        | STOS m8    | NA   | Valid      | Valid          | For legacy mode, store AL at address \n|           |            |      |            |                | ES:(E)DI; For 64-bit mode store AL at\n|           |            |      |            |                | address RDI or EDI.                  \n| AB        | STOS m16   | NA   | Valid      | Valid          | For legacy mode, store AX at address \n|           |            |      |            |                | ES:(E)DI; For 64-bit mode store AX at\n|           |            |      |            |                | address RDI or EDI.                  \n| AB        | STOS m32   | NA   | Valid      | Valid          | For legacy mode, store EAX at address\n|           |            |      |            |                | ES:(E)DI; For 64-bit mode store EAX  \n|           |            |      |            |                | at address RDI or EDI.               \n| REX.W + AB| STOS m64   | NA   | Valid      | N.E.           | Store RAX at address RDI or EDI.     \n| AA        | STOSB      | NA   | Valid      | Valid          | For legacy mode, store AL at address \n|           |            |      |            |                | ES:(E)DI; For 64-bit mode store AL at\n|           |            |      |            |                | address RDI or EDI.                  \n| AB        | STOSW      | NA   | Valid      | Valid          | For legacy mode, store AX at address \n|           |            |      |            |                | ES:(E)DI; For 64-bit mode store AX at\n|           |            |      |            |                | address RDI or EDI.                  \n| AB        | STOSD      | NA   | Valid      | Valid          | For legacy mode, store EAX at address\n|           |            |      |            |                | ES:(E)DI; For 64-bit mode store EAX  \n|           |            |      |            |                | at address RDI or EDI.               \n| REX.W + AB| STOSQ      | NA   | Valid      | N.E.           | Store RAX at address RDI or EDI.     \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NA   | NA       | NA       | NA       | NA       \n\nDescription:\nIn non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from\nthe AL, AX, or EAX register (respectively) into the destination operand. The\ndestination operand is a memory location, the address of which is read from\neither the ES:EDI or ES:DI register (depending on the address-size attribute\nof the instruction and the mode of operation). The ES segment cannot be overridden\nwith a segment override prefix.\n\nAt the assembly-code level, two forms of the instruction are allowed: the \u201cexplicit-operands\u201d\nform and the \u201cnooperands\u201d form. The explicit-operands form (specified with the\nSTOS mnemonic) allows the destination operand to be specified explicitly. Here,\nthe destination operand should be a symbol that indicates the size and location\nof the destination value. The source operand is then automatically selected\nto match the size of the destination operand (the AL register for byte operands,\nAX for word operands, EAX for doubleword operands). The explicit-operands form\nis provided to allow documentation; however, note that the documentation provided\nby this form can be misleading. That is, the destination operand symbol must\nspecify the correct type (size) of the operand (byte, word, or doubleword),\nbut it does not have to specify the correct location. The location is always\nspecified by the ES:(E)DI register. These must be loaded correctly before the\nstore string instruction is executed.\n\nThe no-operands form provides \u201cshort forms\u201d of the byte, word, doubleword, and\nquadword versions of the STOS instructions. Here also ES:(E)DI is assumed to\nbe the destination operand and AL, AX, or EAX is assumed to be the source operand.\nThe size of the destination and source operands is selected by the mnemonic:\nSTOSB (byte read from register AL), STOSW (word from AX), STOSD (doubleword\nfrom EAX).\n\nAfter the byte, word, or doubleword is transferred from the register to the\nmemory location, the (E)DI register is incremented or decremented according\nto the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the\nregister is incremented; if the DF flag is 1, the register is decremented (the\nregister is incremented or decremented by 1 for byte operations, by 2 for word\noperations, by 4 for doubleword operations).\n\n\nNOTE:\nTo improve performance, more recent processors support modifications to the\nprocessor's operation during the string store operations initiated with STOS\nand STOSB. See Section 7.3.9.3 in the Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1 for additional information on fast-string operation.\n\nIn 64-bit mode, the default address size is 64 bits, 32-bit address size is\nsupported using the prefix 67H. Using a REX prefix in the form of REX.W promotes\noperation on doubleword operand to 64 bits. The promoted no-operand mnemonic\nis STOSQ. STOSQ (and its explicit operands variant) store a quadword from the\nRAX register into the destination addressed by RDI or EDI. See the summary chart\nat the beginning of this section for encoding data and limits.\n\nThe STOS, STOSB, STOSW, STOSD, STOSQ instructions can be preceded by the REP\nprefix for block loads of ECX bytes, words, or doublewords. More often, however,\nthese instructions are used within a LOOP construct because data needs to be\nmoved into the AL, AX, or EAX register before it can be stored. See \u201cREP/REPE/REPZ\n/REPNE/REPNZ - Repeat String Operation Prefix\u201d in this chapter for a description\nof the REP prefix.\n\nOperation:\n\nNon-64-bit Mode:\nIF (Byte store)\n  THEN\n     DEST <- AL;\n       THEN IF DF = 0\n          THEN (E)DI <- (E)DI + 1;\n          ELSE (E)DI <- (E)DI - 1;\n       FI;\n  ELSE IF (Word store)\n     THEN\n       DEST <- AX;\n          THEN IF DF = 0\n             THEN (E)DI <- (E)DI + 2;\n             ELSE (E)DI <- (E)DI - 2;\n          FI;\n     FI;\n  ELSE IF (Doubleword store)\n     THEN\n       DEST <- EAX;\n          THEN IF DF = 0\n             THEN (E)DI <- (E)DI + 4;\n             ELSE (E)DI <- (E)DI - 4;\n          FI;\n     FI;\nFI;\n64-bit Mode:\nIF (Byte store)\n  THEN\n     DEST <- AL;\n       THEN IF DF = 0\n          THEN (R|E)DI <- (R|E)DI + 1;\n          ELSE (R|E)DI <- (R|E)DI - 1;\n       FI;\n  ELSE IF (Word store)\n     THEN\n       DEST <- AX;\n          THEN IF DF = 0\n             THEN (R|E)DI <- (R|E)DI + 2;\n             ELSE (R|E)DI <- (R|E)DI - 2;\n          FI;\n     FI;\n  ELSE IF (Doubleword store)\n     THEN\n       DEST <- EAX;\n          THEN IF DF = 0\n             THEN (R|E)DI <- (R|E)DI + 4;\n             ELSE (R|E)DI <- (R|E)DI - 4;\n          FI;\n     FI;\n  ELSE IF (Quadword store using REX.W )\n     THEN\n       DEST <- RAX;\n          THEN IF DF = 0\n             THEN (R|E)DI <- (R|E)DI + 8;\n             ELSE (R|E)DI <- (R|E)DI - 8;\n          FI;\n     FI;\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the limit of the            \n|                | ES segment. If the ES register contains        \n|                | a NULL segment selector.                       \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the ES segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the ES segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "STOS"
    }, 
    {
      "description": "-R:STOS", 
      "mnem": "STOSB"
    }, 
    {
      "description": "-R:STOS", 
      "mnem": "STOSD"
    }, 
    {
      "description": "-R:STOS", 
      "mnem": "STOSQ"
    }, 
    {
      "description": "-R:STOS", 
      "mnem": "STOSW"
    }, 
    {
      "description": "\nSTR - Store Task Register:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                              \n| 0F 00 /1| STR r/m16  | M    | Valid      | Valid          | Stores segment selector from TR in r/m16.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nStores the segment selector from the task register (TR) in the destination operand.\nThe destination operand can be a general-purpose register or a memory location.\nThe segment selector stored with this instruction points to the task state segment\n(TSS) for the currently running task.\n\nWhen the destination operand is a 32-bit register, the 16-bit segment selector\nis copied into the lower 16 bits of the register and the upper 16 bits of the\nregister are cleared. When the destination operand is a memory location, the\nsegment selector is written to memory as a 16-bit quantity, regardless of operand\nsize.\n\nIn 64-bit mode, operation is the same. The size of the memory operand is fixed\nat 16 bits. In register stores, the 2byte TR is zero extended if stored to a\n64-bit register.\n\nThe STR instruction is useful only in operating-system software. It can only\nbe executed in protected mode.\n\nOperation:\n\nDEST <- TR(SegmentSelector);\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is a memory operand   \n|                | that is located in a non-writable segment\n|                | or if the effective address is outside   \n|                | the CS, DS, ES, FS, or GS segment limit. \n|                | If the DS, ES, FS, or GS register is     \n|                | used to access memory and it contains    \n|                | a NULL segment selector.                 \n| #SS(0)         | If a memory operand effective address    \n|                | is outside the SS segment limit.         \n| #PF(fault-code)| If a page fault occurs.                  \n| #AC(0)         | If alignment checking is enabled and     \n|                | an unaligned memory reference is made    \n|                | while the current privilege level is     \n|                | 3.                                       \n| #UD            | If the LOCK prefix is used.              \n\nReal-Address Mode Exceptions:\n| #UD| The STR instruction is not recognized\n|    | in real-address mode.                \n\nVirtual-8086 Mode Exceptions:\n| #UD| The STR instruction is not recognized\n|    | in virtual-8086 mode.                \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #SS(U)         | If the stack address is in a non-canonical \n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "STR"
    }, 
    {
      "description": "\nSUB - Subtract:\n| Opcode          | Instruction     | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                            \n| 2C ib           | SUB AL, imm8    | I    | Valid      | Valid          | Subtract imm8 from AL.                 \n| 2D iw           | SUB AX, imm16   | I    | Valid      | Valid          | Subtract imm16 from AX.                \n| 2D id           | SUB EAX, imm32  | I    | Valid      | Valid          | Subtract imm32 from EAX.               \n| REX.W + 2D id   | SUB RAX, imm32  | I    | Valid      | N.E.           | Subtract imm32 sign-extended to 64-bits\n|                 |                 |      |            |                | from RAX.                              \n| 80 /5 ib        | SUB r/m8, imm8  | MI   | Valid      | Valid          | Subtract imm8 from r/m8.               \n| REX + 80 /5 ib  | SUB r/m8*, imm8 | MI   | Valid      | N.E.           | Subtract imm8 from r/m8.               \n| 81 /5 iw        | SUB r/m16, imm16| MI   | Valid      | Valid          | Subtract imm16 from r/m16.             \n| 81 /5 id        | SUB r/m32, imm32| MI   | Valid      | Valid          | Subtract imm32 from r/m32.             \n| REX.W + 81 /5 id| SUB r/m64, imm32| MI   | Valid      | N.E.           | Subtract imm32 sign-extended to 64-bits\n|                 |                 |      |            |                | from r/m64.                            \n| 83 /5 ib        | SUB r/m16, imm8 | MI   | Valid      | Valid          | Subtract sign-extended imm8 from r/m16.\n| 83 /5 ib        | SUB r/m32, imm8 | MI   | Valid      | Valid          | Subtract sign-extended imm8 from r/m32.\n| REX.W + 83 /5 ib| SUB r/m64, imm8 | MI   | Valid      | N.E.           | Subtract sign-extended imm8 from r/m64.\n| 28 /r           | SUB r/m8, r8    | MR   | Valid      | Valid          | Subtract r8 from r/m8.                 \n| REX + 28 /r     | SUB r/m8*, r8*  | MR   | Valid      | N.E.           | Subtract r8 from r/m8.                 \n| 29 /r           | SUB r/m16, r16  | MR   | Valid      | Valid          | Subtract r16 from r/m16.               \n| 29 /r           | SUB r/m32, r32  | MR   | Valid      | Valid          | Subtract r32 from r/m32.               \n| REX.W + 29 /r   | SUB r/m64, r64  | MR   | Valid      | N.E.           | Subtract r64 from r/m64.               \n| 2A /r           | SUB r8, r/m8    | RM   | Valid      | Valid          | Subtract r/m8 from r8.                 \n| REX + 2A /r     | SUB r8*, r/m8*  | RM   | Valid      | N.E.           | Subtract r/m8 from r8.                 \n| 2B /r           | SUB r16, r/m16  | RM   | Valid      | Valid          | Subtract r/m16 from r16.               \n| 2B /r           | SUB r32, r/m32  | RM   | Valid      | Valid          | Subtract r/m32 from r32.               \n| REX.W + 2B /r   | SUB r64, r/m64  | RM   | Valid      | N.E.           | Subtract r/m64 from r64.               \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| I    | AL/AX/EAX/RAX   | imm8/26/32   | NA       | NA       \n| MI   | ModRM:r/m (r, w)| imm8/26/32   | NA       | NA       \n| MR   | ModRM:r/m (r, w)| ModRM:reg (r)| NA       | NA       \n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nSubtracts the second operand (source operand) from the first operand (destination\noperand) and stores the result in the destination operand. The destination operand\ncan be a register or a memory location; the source operand can be an immediate,\nregister, or memory location. (However, two memory operands cannot be used in\none instruction.) When an immediate value is used as an operand, it is sign-extended\nto the length of the destination operand format.\n\nThe SUB instruction performs integer subtraction. It evaluates the result for\nboth signed and unsigned integer operands and sets the OF and CF flags to indicate\nan overflow in the signed or unsigned result, respectively. The SF flag indicates\nthe sign of the signed result.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\nOperation:\n\nDEST <- (DEST - SRC);\n\nFlags Affected:\nThe OF, SF, ZF, AF, PF, and CF flags are set according to the result.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register contains a NULL segment     \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used but the destination \n|                | is not a memory operand.                       \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "SUB"
    }, 
    {
      "description": "\nSUBPD - Subtract Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                   \n| 66 0F 5C /r SUBPD xmm1, xmm2/m128            | RM   | V/V                   | SSE2              | Subtract packed double-precision floatingpoint\n|                                              |      |                       |                   | values in xmm2/m128 from xmm1.                \n| VEX.NDS.128.66.0F.WIG 5C /r VSUBPD xmm1,xmm2,| RVM  | V/V                   | AVX               | Subtract packed double-precision floatingpoint\n| xmm3/m128                                    |      |                       |                   | values in xmm3/mem from xmm2 and stores       \n|                                              |      |                       |                   | result in xmm1.                               \n| VEX.NDS.256.66.0F.WIG 5C /r VSUBPD ymm1,     | RVM  | V/V                   | AVX               | Subtract packed double-precision floatingpoint\n| ymm2, ymm3/m256                              |      |                       |                   | values in ymm3/mem from ymm2 and stores       \n|                                              |      |                       |                   | result in ymm1.                               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD subtract of the two packed double-precision floating-point values\nin the source operand (second operand) from the two packed double-precision\nfloating-point values in the destination operand (first operand), and stores\nthe packed double-precision floating-point results in the destination operand.\nThe source operand can be an XMM register or a 128-bit memory location. The\ndestination operand is an XMM register. See Figure 11-3 in the Intel\u00ae 64 and\nIA-32 Architectures Software Developer's Manual, Volume 1, for an illustration\nof a SIMD double-precision floating-point operation.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: T second\nsource can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second\nsource operand can be a YMM register or a 256-bit memory location. The destination\noperand is a YMM register.\n\nOperation:\n\nSUBPD (128-bit Legacy SSE version)\nDEST[63:0] <- DEST[63:0] - SRC[63:0]\nDEST[127:64] <- DEST[127:64] - SRC[127:64]\nDEST[VLMAX-1:128] (Unmodified)\nVSUBPD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0] - SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] - SRC2[127:64]\nDEST[VLMAX-1:128] <- 0\nVSUBPD (VEX.256 encoded version)\nDEST[63:0] <- SRC1[63:0] - SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] - SRC2[127:64]\nDEST[191:128] <- SRC1[191:128] - SRC2[191:128]\nDEST[255:192] <- SRC1[255:192] - SRC2[255:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| SUBPD: | __m128d _mm_sub_pd (m128d a, m128d b)    \n| VSUBPD:| __m256d _mm256_sub_pd (__m256d a, __m256d\n|        | b);                                      \n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "SUBPD"
    }, 
    {
      "description": "\nSUBPS - Subtract Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                        | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                    \n| 0F 5C /r SUBPS xmm1 xmm2/m128             | RM   | V/V                   | SSE               | Subtract packed single-precision floating-point\n|                                           |      |                       |                   | values in xmm2/mem from xmm1.                  \n| VEX.NDS.128.0F.WIG 5C /r VSUBPS xmm1,xmm2,| RVM  | V/V                   | AVX               | Subtract packed single-precision floating-point\n| xmm3/m128                                 |      |                       |                   | values in xmm3/mem from xmm2 and stores        \n|                                           |      |                       |                   | result in xmm1.                                \n| VEX.NDS.256.0F.WIG 5C /r VSUBPS ymm1,     | RVM  | V/V                   | AVX               | Subtract packed single-precision floating-point\n| ymm2, ymm3/m256                           |      |                       |                   | values in ymm3/mem from ymm2 and stores        \n|                                           |      |                       |                   | result in ymm1.                                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD subtract of the four packed single-precision floating-point\nvalues in the source operand (second operand) from the four packed single-precision\nfloating-point values in the destination operand (first operand), and stores\nthe packed single-precision floating-point results in the destination operand.\nThe source operand can be an XMM register or a 128-bit memory location. The\ndestination operand is an XMM register. See Figure 10-5 in the Intel\u00ae 64 and\nIA-32 Architectures Software Developer's Manual, Volume 1, for an illustration\nof a SIMD doubleprecision floating-point operation.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed.\n\nVEX.256 encoded version: The first source operand is a YMM register. The second\nsource operand can be a YMM register or a 256-bit memory location. The destination\noperand is a YMM register.\n\nOperation:\n\nSUBPS (128-bit Legacy SSE version)\nDEST[31:0] <- SRC1[31:0] - SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] - SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] - SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] - SRC2[127:96]\nDEST[VLMAX-1:128] (Unmodified)\nVSUBPS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0] - SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] - SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] - SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] - SRC2[127:96]\nDEST[VLMAX-1:128] <- 0\nVSUBPS (VEX.256 encoded version)\nDEST[31:0] <- SRC1[31:0] - SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] - SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] - SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] - SRC2[127:96]\nDEST[159:128] <- SRC1[159:128] - SRC2[159:128]\nDEST[191:160]<- SRC1[191:160] - SRC2[191:160]\nDEST[223:192] <- SRC1[223:192] - SRC2[223:192]\nDEST[255:224] <- SRC1[255:224] - SRC2[255:224].\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| SUBPS: | __m128 _mm_sub_ps(__m128 a, __m128 b) \n| VSUBPS:| __m256 _mm256_sub_ps (__m256 a, __m256\n|        | b);                                   \n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 2.\n\n", 
      "mnem": "SUBPS"
    }, 
    {
      "description": "\nSUBSD - Subtract Scalar Double-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                     \n| F2 0F 5C /r SUBSD xmm1, xmm2/m64             | RM   | V/V                   | SSE2              | Subtracts the low double-precision floatingpoint\n|                                              |      |                       |                   | values in xmm2/mem64 from xmm1.                 \n| VEX.NDS.LIG.F2.0F.WIG 5C /r VSUBSD xmm1,xmm2,| RVM  | V/V                   | AVX               | Subtract the low double-precision floatingpoint \n| xmm3/m64                                     |      |                       |                   | value in xmm3/mem from xmm2 and store           \n|                                              |      |                       |                   | the result in xmm1.                             \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nSubtracts the low double-precision floating-point value in the source operand\n(second operand) from the low double-precision floating-point value in the destination\noperand (first operand), and stores the double-precision floating-point result\nin the destination operand. The source operand can be an XMM register or a 64-bit\nmemory location. The destination operand is an XMM register. The high quadword\nof the destination operand remains unchanged. See Figure 11-4 in the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration\nof a scalar double-precision floating-point operation.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\ndestination and first source operand are the same. Bits (VLMAX-1:64) of the\ncorresponding YMM destination register remain unchanged. VEX.128 encoded version:\nBits (127:64) of the XMM register destination are copied from corresponding\nbits in the first source operand. Bits (VLMAX-1:128) of the destination YMM\nregister are zeroed.\n\nOperation:\n\nSUBSD (128-bit Legacy SSE version)\nDEST[63:0] <- DEST[63:0] - SRC[63:0]\nDEST[VLMAX-1:64] (Unmodified)\nVSUBSD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0] - SRC2[63:0]\nDEST[127:64] <- SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| SUBSD:| __m128d _mm_sub_sd (m128d a, m128d b)\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "SUBSD"
    }, 
    {
      "description": "\nSUBSS - Subtract Scalar Single-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                    \n| F3 0F 5C /r SUBSS xmm1, xmm2/m32             | RM   | V/V                   | SSE               | Subtract the lower single-precision            \n|                                              |      |                       |                   | floatingpoint values in xmm2/m32 from          \n|                                              |      |                       |                   | xmm1.                                          \n| VEX.NDS.LIG.F3.0F.WIG 5C /r VSUBSS xmm1,xmm2,| RVM  | V/V                   | AVX               | Subtract the low single-precision floatingpoint\n| xmm3/m32                                     |      |                       |                   | value in xmm3/mem from xmm2 and store          \n|                                              |      |                       |                   | the result in xmm1.                            \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nSubtracts the low single-precision floating-point value in the source operand\n(second operand) from the low singleprecision floating-point value in the destination\noperand (first operand), and stores the single-precision floatingpoint result\nin the destination operand. The source operand can be an XMM register or a 32-bit\nmemory location. The destination operand is an XMM register. The three high-order\ndoublewords of the destination operand remain unchanged. See Figure 10-6 in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 1,\nfor an illustration of a scalar single-precision floating-point operation.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\ndestination and first source operand are the same. Bits (VLMAX-1:32) of the\ncorresponding YMM destination register remain unchanged. VEX.128 encoded version:\nBits (127:32) of the XMM register destination are copied from corresponding\nbits in the first source operand. Bits (VLMAX-1:128) of the destination YMM\nregister are zeroed.\n\nOperation:\n\nSUBSS (128-bit Legacy SSE version)\nDEST[31:0] <- DEST[31:0] - SRC[31:0]\nDEST[VLMAX-1:32] (Unmodified)\nVSUBSS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0] - SRC2[31:0]\nDEST[127:32] <- SRC1[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| SUBSS:| __m128 _mm_sub_ss(__m128 a, __m128 b)\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3.\n\n", 
      "mnem": "SUBSS"
    }, 
    {
      "description": "\nSWAPGS - Swap GS Base Register:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| 0F 01 F8| SWAPGS     | NP   | Valid      | Invalid        | Exchanges the current GS base register\n|         |            |      |            |                | value with the value contained in MSR \n|         |            |      |            |                | address C0000102H.                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nSWAPGS exchanges the current GS base register value with the value contained\nin MSR address C0000102H (IA32_KERNEL_GS_BASE). The SWAPGS instruction is a\nprivileged instruction intended for use by system software.\n\nWhen using SYSCALL to implement system calls, there is no kernel stack at the\nOS entry point. Neither is there a straightforward method to obtain a pointer\nto kernel structures from which the kernel stack pointer could be read. Thus,\nthe kernel cannot save general purpose registers or reference memory.\n\nBy design, SWAPGS does not require any general purpose registers or memory operands.\nNo registers need to be saved before using the instruction. SWAPGS exchanges\nthe CPL 0 data pointer from the IA32_KERNEL_GS_BASE MSR with the GS base register.\nThe kernel can then use the GS prefix on normal memory references to access\nkernel data structures. Similarly, when the OS kernel is entered using an interrupt\nor exception (where the kernel stack is already set up), SWAPGS can be used\nto quickly get a pointer to the kernel data structures.\n\nThe IA32_KERNEL_GS_BASE MSR itself is only accessible using RDMSR/WRMSR instructions.\nThose instructions are only accessible at privilege level 0. The WRMSR instruction\nensures that the IA32_KERNEL_GS_BASE MSR contains a canonical address.\n\nOperation:\n\nIF CS.L != 1 (* Not in 64-Bit Mode *)\n  THEN\n     #UD; FI;\nIF CPL != 0\n  THEN #GP(0); FI;\ntmp <- GS.base;\nGS.base <- IA32_KERNEL_GS_BASE;\nIA32_KERNEL_GS_BASE <- tmp;\n\nFlags Affected:\nNone\n\n\nProtected Mode Exceptions:\n| #UD| If Mode != 64-Bit.\n\nReal-Address Mode Exceptions:\n| #UD| If Mode != 64-Bit.\n\nVirtual-8086 Mode Exceptions:\n| #UD| If Mode != 64-Bit.\n\nCompatibility Mode Exceptions:\n| #UD| If Mode != 64-Bit.\n\n64-Bit Mode Exceptions:\n| #GP(0)| If CPL != 0. If the LOCK prefix is used.\n", 
      "mnem": "SWAPGS"
    }, 
    {
      "description": "\nSYSCALL - Fast System Call:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F 05 | SYSCALL    | NP   | Valid      | Invalid        | Fast call to privilege level 0 system\n|       |            |      |            |                | procedures.                          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nSYSCALL invokes an OS system-call handler at privilege level 0. It does so by\nloading RIP from the IA32_LSTAR MSR (after saving the address of the instruction\nfollowing SYSCALL into RCX). (The WRMSR instruction ensures that the IA32_LSTAR\nMSR always contain a canonical address.)\n\nSYSCALL also saves RFLAGS into R11 and then masks RFLAGS using the IA32_FMASK\nMSR (MSR address C0000084H); specifically, the processor clears in RFLAGS every\nbit corresponding to a bit that is set in the IA32_FMASK MSR.\n\nSYSCALL loads the CS and SS selectors with values derived from bits 47:32 of\nthe IA32_STAR MSR. However, the CS and SS descriptor caches are not loaded from\nthe descriptors (in GDT or LDT) referenced by those selectors. Instead, the\ndescriptor caches are loaded with fixed values. See the Operation section for\ndetails. It is the responsibility of OS software to ensure that the descriptors\n(in GDT or LDT) referenced by those selector values correspond to the fixed\nvalues loaded into the descriptor caches; the SYSCALL instruction does not ensure\nthis correspondence.\n\nThe SYSCALL instruction does not save the stack pointer (RSP). If the OS system-call\nhandler will change the stack pointer, it is the responsibility of software\nto save the previous value of the stack pointer. This might be done prior to\nexecuting SYSCALL, with software restoring the stack pointer with the instruction\nfollowing SYSCALL (which will be executed after SYSRET). Alternatively, the\nOS system-call handler may save the stack pointer and restore it before executing\nSYSRET.\n\nOperation:\n\nIF (CS.L != 1 ) or (IA32_EFER.LMA != 1) or (IA32_EFER.SCE != 1)\n(* Not in 64-Bit Mode or SYSCALL/SYSRET not enabled in IA32_EFER *)\n  THEN #UD;\nFI;\nRCX <- RIP;\nRIP <- IA32_LSTAR;\nR11 <- RFLAGS;\nRFLAGS <- RFLAGS AND NOT(IA32_FMASK);\nCS.Selector <- IA32_STAR[47:32] AND FFFCH (* Operating system provides CS; RPL forced to 0 *)\n(* Set rest of CS to a fixed value *)\nCS.Base <- 0;\nCS.Limit <- FFFFFH;\nCS.Type <- 11;\nCS.S <- 1;\nCS.DPL <- 0;\nCS.P <- 1;\nCS.L <- 1;\nCS.D <- 0;\nCS.G <- 1;\nCPL <- 0;\nSS.Selector <- IA32_STAR[47:32] + 8;\n(* Set rest of SS to a fixed value *)\nSS.Base <- 0;\nSS.Limit <- FFFFFH;\nSS.Type <- 3;\nSS.S <- 1;\nSS.DPL <- 0;\nSS.P <- 1;\nSS.B <- 1;\nSS.G <- 1;\n\nFlags Affected:\nAll.\n\n\nProtected Mode Exceptions:\n| #UD| The SYSCALL instruction is not recognized\n|    | in protected mode.                       \n\nReal-Address Mode Exceptions:\n| #UD| The SYSCALL instruction is not recognized\n|    | in real-address mode.                    \n\nVirtual-8086 Mode Exceptions:\n| #UD| The SYSCALL instruction is not recognized\n|    | in virtual-8086 mode.                    \n\nCompatibility Mode Exceptions:\n| #UD| The SYSCALL instruction is not recognized\n|    | in compatibility mode.                   \n\n64-Bit Mode Exceptions:\n| #UD| If IA32_EFER.SCE = 0. If the LOCK prefix\n|    | is used.                                \n", 
      "mnem": "SYSCALL"
    }, 
    {
      "description": "\nSYSENTER - Fast System Call:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F 34 | SYSENTER   | NP   | Valid      | Valid          | Fast call to privilege level 0 system\n|       |            |      |            |                | procedures.                          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nExecutes a fast call to a level 0 system procedure or routine. SYSENTER is a\ncompanion instruction to SYSEXIT. The instruction is optimized to provide the\nmaximum performance for system calls from user code running at privilege level\n3 to operating system or executive procedures running at privilege level 0.\n\nWhen executed in IA-32e mode, the SYSENTER instruction transitions the logical\nprocessor to 64-bit mode; otherwise, the logical processor remains in protected\nmode.\n\nPrior to executing the SYSENTER instruction, software must specify the privilege\nlevel 0 code segment and code entry point, and the privilege level 0 stack segment\nand stack pointer by writing values to the following MSRs:\n\n - IA32_SYSENTER_CS (MSR address 174H)  -  The lower 16 bits of this MSR are the\nsegment selector for the privilege level 0 code segment. This value is also\nused to determine the segment selector of the privilege level 0 stack segment\n(see the Operation section). This value cannot indicate a null selector.\n - IA32_SYSENTER_EIP (MSR address 175H)  -  The value of this MSR is loaded into\nRIP (thus, this value references the first instruction of the selected operating\nprocedure or routine). In protected mode, only bits 31:0 are loaded.\n - IA32_SYSENTER_ESP (MSR address 176H)  -  The value of this MSR is loaded into\nRSP (thus, this value contains the stack pointer for the privilege level 0 stack).\nThis value cannot represent a non-canonical address. In protected mode, only\nbits 31:0 are loaded.\n\nThese MSRs can be read from and written to using RDMSR/WRMSR. The WRMSR instruction\nensures that the IA32_SYSENTER_EIP and IA32_SYSENTER_ESP MSRs always contain\ncanonical addresses.\n\nWhile SYSENTER loads the CS and SS selectors with values derived from the IA32_SYSENTER_CS\nMSR, the CS and SS descriptor caches are not loaded from the descriptors (in\nGDT or LDT) referenced by those selectors. Instead, the descriptor caches are\nloaded with fixed values. See the Operation section for details. It is the responsibility\nof OS software to ensure that the descriptors (in GDT or LDT) referenced by\nthose selector values correspond to the fixed values loaded into the descriptor\ncaches; the SYSENTER instruction does not ensure this correspondence.\n\nThe SYSENTER instruction can be invoked from all operating modes except real-address\nmode.\n\nThe SYSENTER and SYSEXIT instructions are companion instructions, but they do\nnot constitute a call/return pair. When executing a SYSENTER instruction, the\nprocessor does not save state information for the user code (e.g., the instruction\npointer), and neither the SYSENTER nor the SYSEXIT instruction supports passing\nparameters on the stack.\n\nTo use the SYSENTER and SYSEXIT instructions as companion instructions for transitions\nbetween privilege level 3 code and privilege level 0 operating system procedures,\nthe following conventions must be followed:\n\n - The segment descriptors for the privilege level 0 code and stack segments and\nfor the privilege level 3 code and stack segments must be contiguous in a descriptor\ntable. This convention allows the processor to compute the segment selectors\nfrom the value entered in the SYSENTER_CS_MSR MSR.\n - The fast system call \u201cstub\u201d routines executed by user code (typically in shared\nlibraries or DLLs) must save the required return IP and processor state information\nif a return to the calling procedure is required. Likewise, the operating system\nor executive procedures called with SYSENTER instructions must have access to\nand use this saved return and state information when returning to the user code.\n\nThe SYSENTER and SYSEXIT instructions were introduced into the IA-32 architecture\nin the Pentium II processor. The availability of these instructions on a processor\nis indicated with the SYSENTER/SYSEXIT present (SEP) feature flag returned to\nthe EDX register by the CPUID instruction. An operating system that qualifies\nthe SEP flag must also qualify the processor family and model to ensure that\nthe SYSENTER/SYSEXIT instructions are actually present. For example:\n\nIF CPUID SEP bit is set THEN IF (Family = 6) and (Model < 3) and (Stepping <\n3) THEN SYSENTER/SYSEXIT_Not_Supported; FI; ELSE SYSENTER/SYSEXIT_Supported;\nFI; FI;\n\nWhen the CPUID instruction is executed on the Pentium Pro processor (model 1),\nthe processor returns a the SEP flag as set, but does not support the SYSENTER/SYSEXIT\ninstructions.\n\nOperation:\n\nIF CR0.PE = 0 OR IA32_SYSENTER_CS[15:2] = 0 THEN #GP(0); FI;\nRFLAGS.VM <- 0;\nRFLAGS.IF <- 0;\nIF in IA-32e mode\n  THEN\n     RSP <- IA32_SYSENTER_ESP;\n     RIP <- IA32_SYSENTER_EIP;\nELSE\n     ESP <- IA32_SYSENTER_ESP[31:0];\n     EIP <- IA32_SYSENTER_EIP[31:0];\nFI;\nCS.Selector <- IA32_SYSENTER_CS[15:0] AND FFFCH;\n                          (* Operating system provides CS; RPL forced to 0 *)\n(* Set rest of CS to a fixed value *)\nCS.Base <- 0;\nCS.Limit <- FFFFFH;\nCS.Type <- 11;\nCS.S <- 1;\nCS.DPL <- 0;\nCS.P <- 1;\nIF in IA-32e mode\n  THEN\n     CS.L <- 1;\n     CS.D <- 0;\n  ELSE\n     CS.L <- 0;\n     CS.D <- 1;\nFI;\nCS.G <- 1;\nCPL <- 0;\nSS.Selector <- CS.Selector + 8;\n(* Set rest of SS to a fixed value *)\nSS.Base <- 0;\nSS.Limit <- FFFFFH;\nSS.Type <- 3;\nSS.S <- 1;\nSS.DPL <- 0;\nSS.P <- 1;\nSS.B <- 1;\nSS.G <- 1;\n\nFlags Affected:\nVM, IF (see Operation above)\n\n\nProtected Mode Exceptions:\n| #GP(0)| If IA32_SYSENTER_CS[15:2] = 0.\n| #UD   | If the LOCK prefix is used.   \n\nReal-Address Mode Exceptions:\n| #GP| The SYSENTER instruction is not recognized\n|    | in real-address mode.                     \n| #UD| If the LOCK prefix is used.               \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "SYSENTER"
    }, 
    {
      "description": "\nSYSEXIT - Fast Return from Fast System Call:\n| Opcode       | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F 35        | SYSEXIT    | NP   | Valid      | Valid          | Fast return to privilege level 3 user\n|              |            |      |            |                | code.                                \n| REX.W + 0F 35| SYSEXIT    | NP   | Valid      | Valid          | Fast return to 64-bit mode privilege \n|              |            |      |            |                | level 3 user code.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nExecutes a fast return to privilege level 3 user code. SYSEXIT is a companion\ninstruction to the SYSENTER instruction. The instruction is optimized to provide\nthe maximum performance for returns from system procedures executing at protections\nlevels 0 to user procedures executing at protection level 3. It must be executed\nfrom code executing at privilege level 0.\n\nWith a 64-bit operand size, SYSEXIT remains in 64-bit mode; otherwise, it either\nenters compatibility mode (if the logical processor is in IA-32e mode) or remains\nin protected mode (if it is not).\n\nPrior to executing SYSEXIT, software must specify the privilege level 3 code\nsegment and code entry point, and the privilege level 3 stack segment and stack\npointer by writing values into the following MSR and general-purpose registers:\n\n - IA32_SYSENTER_CS (MSR address 174H)  -  Contains a 32-bit value that is used to\ndetermine the segment selectors for the privilege level 3 code and stack segments\n(see the Operation section)\n - RDX  -  The canonical address in this register is loaded into RIP (thus, this\nvalue references the first instruction to be executed in the user code). If\nthe return is not to 64-bit mode, only bits 31:0 are loaded.\n - ECX  -  The canonical address in this register is loaded into RSP (thus, this\nvalue contains the stack pointer for the privilege level 3 stack). If the return\nis not to 64-bit mode, only bits 31:0 are loaded.\n\nThe IA32_SYSENTER_CS MSR can be read from and written to using RDMSR and WRMSR.\n\nWhile SYSEXIT loads the CS and SS selectors with values derived from the IA32_SYSENTER_CS\nMSR, the CS and SS descriptor caches are not loaded from the descriptors (in\nGDT or LDT) referenced by those selectors. Instead, the descriptor caches are\nloaded with fixed values. See the Operation section for details. It is the responsibility\nof OS software to ensure that the descriptors (in GDT or LDT) referenced by\nthose selector values correspond to the fixed values loaded into the descriptor\ncaches; the SYSEXIT instruction does not ensure this correspondence.\n\nThe SYSEXIT instruction can be invoked from all operating modes except real-address\nmode and virtual-8086 mode.\n\nThe SYSENTER and SYSEXIT instructions were introduced into the IA-32 architecture\nin the Pentium II processor. The availability of these instructions on a processor\nis indicated with the SYSENTER/SYSEXIT present (SEP) feature flag returned to\nthe EDX register by the CPUID instruction. An operating system that qualifies\nthe SEP flag must also qualify the processor family and model to ensure that\nthe SYSENTER/SYSEXIT instructions are actually present. For example:\n\nIF CPUID SEP bit is set THEN IF (Family = 6) and (Model < 3) and (Stepping <\n3) THEN SYSENTER/SYSEXIT_Not_Supported; FI; ELSE SYSENTER/SYSEXIT_Supported;\nFI; FI;\n\nWhen the CPUID instruction is executed on the Pentium Pro processor (model 1),\nthe processor returns a the SEP flag as set, but does not support the SYSENTER/SYSEXIT\ninstructions.\n\nOperation:\n\nIF IA32_SYSENTER_CS[15:2] = 0 OR CR0.PE = 0 OR CPL != 0 THEN #GP(0); FI;\nIF operand size is 64-bit\n  THEN\n     RSP <- RCX;\n     RIP <- RDX;\n  ELSE\n     RSP <- ECX;\n     RIP <- EDX;\nFI;\nIF operand size is 64-bit\n  THEN CS.Selector <- IA32_SYSENTER_CS[15:0] + 32;\n  ELSE CS.Selector <- IA32_SYSENTER_CS[15:0] + 16;\nFI;\nCS.Selector <- CS.Selector OR 3;\n(* Set rest of CS to a fixed value *)\nCS.Base <- 0;\nCS.Limit <- FFFFFH;\nCS.Type <- 11;\nCS.S <- 1;\nCS.DPL <- 3;\nCS.P <- 1;\nIF operand size is 64-bit\n  THEN\n     CS.L <- 1;\n     CS.D <- 0;\n  ELSE\n     CS.L <- 0;\n     CS.D <- 1;\nFI;\nCS.G <- 1;\nCPL <- 3;\nSS.Selector <- CS.Selector + 8;\n(* Set rest of SS to a fixed value *)\nSS.Base <- 0;\nSS.Limit <- FFFFFH;\nSS.Type <- 3;\nSS.S <- 1;\nSS.DPL <- 3;\nSS.P <- 1;\nSS.B <- 1;\nSS.G <- 1;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If IA32_SYSENTER_CS[15:2] = 0. If CPL\n|       | != 0.                                 \n| #UD   | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| The SYSEXIT instruction is not recognized\n|    | in real-address mode.                    \n| #UD| If the LOCK prefix is used.              \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| The SYSEXIT instruction is not recognized\n|       | in virtual-8086 mode.                    \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)| If IA32_SYSENTER_CS = 0. If CPL != 0.  \n|       | If RCX or RDX contains a non-canonical\n|       | address.                              \n| #UD   | If the LOCK prefix is used.           \n", 
      "mnem": "SYSEXIT"
    }, 
    {
      "description": "\nSYSRET - Return From Fast System Call:\n| Opcode       | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                           \n| 0F 07        | SYSRET     | NP   | Valid      | Invalid        | Return to compatibility mode from fast\n|              |            |      |            |                | system call                           \n| REX.W + 0F 07| SYSRET     | NP   | Valid      | Invalid        | Return to 64-bit mode from fast system\n|              |            |      |            |                | call                                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nSYSRET is a companion instruction to the SYSCALL instruction. It returns from\nan OS system-call handler to user code at privilege level 3. It does so by loading\nRIP from RCX and loading RFLAGS from R11.1 With a 64-bit operand size, SYSRET\nremains in 64-bit mode; otherwise, it enters compatibility mode and only the\nlow 32 bits of the registers are loaded.\n\nSYSRET loads the CS and SS selectors with values derived from bits 63:48 of\nthe IA32_STAR MSR. However, the CS and SS descriptor caches are not loaded from\nthe descriptors (in GDT or LDT) referenced by those selectors. Instead, the\ndescriptor caches are loaded with fixed values. See the Operation section for\ndetails. It is the responsibility of OS software to ensure that the descriptors\n(in GDT or LDT) referenced by those selector values correspond to the fixed\nvalues loaded into the descriptor caches; the SYSRET instruction does not ensure\nthis correspondence.\n\nThe SYSRET instruction does not modify the stack pointer (ESP or RSP). For that\nreason, it is necessary for software to switch to the user stack. The OS may\nload the user stack pointer (if it was saved after SYSCALL) before executing\nSYSRET; alternatively, user code may load the stack pointer (if it was saved\nbefore SYSCALL) after receiving control from SYSRET.\n\nIf the OS loads the stack pointer before executing SYSRET, it must ensure that\nthe handler of any interrupt or exception delivered between restoring the stack\npointer and successful execution of SYSRET is not invoked with the user stack.\nIt can do so using approaches such as the following:\n\n - External interrupts. The OS can prevent an external interrupt from being delivered\nby clearing EFLAGS.IF before loading the user stack pointer.\n - Nonmaskable interrupts (NMIs). The OS can ensure that the NMI handler is invoked\nwith the correct stack by using the interrupt stack table (IST) mechanism for\ngate 2 (NMI) in the IDT (see Section 6.14.5, \u201cInterrupt Stack Table,\u201d in Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 3A).\n - General-protection exceptions (#GP). The SYSRET instruction generates #GP(0)\nif the value of RCX is not canonical. The OS can address this possibility using\none or more of the following approaches:  - Confirming that the value of RCX is\ncanonical before executing SYSRET.  - Using paging to ensure that the SYSCALL\ninstruction will never save a non-canonical value into RCX.  - Using the IST mechanism\nfor gate 13 (#GP) in the IDT.\n\nOperation:\n\nIF (CS.L != 1 ) or (IA32_EFER.LMA != 1) or (IA32_EFER.SCE != 1)\n(* Not in 64-Bit Mode or SYSCALL/SYSRET not enabled in IA32_EFER *)\n  THEN #UD; FI;\nIF (CPL != 0) OR (RCX is not canonical) THEN #GP(0); FI;\n1.\n  in RFLAGS retain the fixed values.\nIF (operand size is 64-bit)\n  THEN (* Return to 64-Bit Mode *)\n     RIP <- RCX;\n  ELSE (* Return to Compatibility Mode *)\n     RIP <- ECX;\nFI;\nRFLAGS <- (R11 & 3C7FD7H) | 2;\nIF (operand size is 64-bit)\n  THEN CS.Selector <- IA32_STAR[63:48]+16;\n  ELSE CS.Selector <- IA32_STAR[63:48];\nFI;\nCS.Selector <- CS.Selector OR 3;\n(* Set rest of CS to a fixed value *)\nCS.Base <- 0;\nCS.Limit <- FFFFFH;\nCS.Type <- 11;\nCS.S <- 1;\nCS.DPL <- 3;\nCS.P <- 1;\nIF (operand size is 64-bit)\n  THEN (* Return to 64-Bit Mode *)\n     CS.L <- 1;\n     CS.D <- 0;\n  ELSE (* Return to Compatibility Mode *)\n     CS.L <- 0;\n     CS.D <- 1;\nFI;\nCS.G <- 1;\nCPL <- 0;\nSS.Selector <- (IA32_STAR[63:48]+8) OR 3;\n(* Set rest of SS to a fixed value *)\nSS.Base <- 0;\nSS.Limit <- FFFFFH;\nSS.Type <- 3;\nSS.S <- 1;\nSS.DPL <- 3;\nSS.P <- 1;\nSS.B <- 1;\nSS.G <- 1;\n\nFlags Affected:\nAll.\n\n\nProtected Mode Exceptions:\n| #UD| The SYSRET instruction is not recognized\n|    | in protected mode.                      \n\nReal-Address Mode Exceptions:\n| #UD| The SYSRET instruction is not recognized\n|    | in real-address mode.                   \n\nVirtual-8086 Mode Exceptions:\n| #UD| The SYSRET instruction is not recognized\n|    | in virtual-8086 mode.                   \n\nCompatibility Mode Exceptions:\n| #UD| The SYSRET instruction is not recognized\n|    | in compatibility mode.                  \n\n64-Bit Mode Exceptions:\n| #UD   | If IA32_EFER.SCE = 0. If the LOCK prefix   \n|       | is used.                                   \n| #GP(0)| If CPL != 0. If RCX contains a non-canonical\n|       | address.                                   \n", 
      "mnem": "SYSRET"
    }, 
    {
      "description": "\nTEST - Logical Compare:\n| Opcode          | Instruction      | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                 \n| A8 ib           | TEST AL, imm8    | I    | Valid      | Valid          | AND imm8 with AL; set SF, ZF, PF according  \n|                 |                  |      |            |                | to result.                                  \n| A9 iw           | TEST AX, imm16   | I    | Valid      | Valid          | AND imm16 with AX; set SF, ZF, PF according \n|                 |                  |      |            |                | to result.                                  \n| A9 id           | TEST EAX, imm32  | I    | Valid      | Valid          | AND imm32 with EAX; set SF, ZF, PF according\n|                 |                  |      |            |                | to result.                                  \n| REX.W + A9 id   | TEST RAX, imm32  | I    | Valid      | N.E.           | AND imm32 sign-extended to 64-bits with     \n|                 |                  |      |            |                | RAX; set SF, ZF, PF according to result.    \n| F6 /0 ib        | TEST r/m8, imm8  | MI   | Valid      | Valid          | AND imm8 with r/m8; set SF, ZF, PF according\n|                 |                  |      |            |                | to result.                                  \n| REX + F6 /0 ib  | TEST r/m8*, imm8 | MI   | Valid      | N.E.           | AND imm8 with r/m8; set SF, ZF, PF according\n|                 |                  |      |            |                | to result.                                  \n| F7 /0 iw        | TEST r/m16, imm16| MI   | Valid      | Valid          | AND imm16 with r/m16; set SF, ZF, PF        \n|                 |                  |      |            |                | according to result.                        \n| F7 /0 id        | TEST r/m32, imm32| MI   | Valid      | Valid          | AND imm32 with r/m32; set SF, ZF, PF        \n|                 |                  |      |            |                | according to result.                        \n| REX.W + F7 /0 id| TEST r/m64, imm32| MI   | Valid      | N.E.           | AND imm32 sign-extended to 64-bits with     \n|                 |                  |      |            |                | r/m64; set SF, ZF, PF according to result.  \n| 84 /r           | TEST r/m8, r8    | MR   | Valid      | Valid          | AND r8 with r/m8; set SF, ZF, PF according  \n|                 |                  |      |            |                | to result.                                  \n| REX + 84 /r     | TEST r/m8*, r8*  | MR   | Valid      | N.E.           | AND r8 with r/m8; set SF, ZF, PF according  \n|                 |                  |      |            |                | to result.                                  \n| 85 /r           | TEST r/m16, r16  | MR   | Valid      | Valid          | AND r16 with r/m16; set SF, ZF, PF according\n|                 |                  |      |            |                | to result.                                  \n| 85 /r           | TEST r/m32, r32  | MR   | Valid      | Valid          | AND r32 with r/m32; set SF, ZF, PF according\n|                 |                  |      |            |                | to result.                                  \n| REX.W + 85 /r   | TEST r/m64, r64  | MR   | Valid      | N.E.           | AND r64 with r/m64; set SF, ZF, PF according\n|                 |                  |      |            |                | to result.                                  \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| I    | AL/AX/EAX/RAX| imm8/16/32   | NA       | NA       \n| MI   | ModRM:r/m (r)| imm8/16/32   | NA       | NA       \n| MR   | ModRM:r/m (r)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nComputes the bit-wise logical AND of first operand (source 1 operand) and the\nsecond operand (source 2 operand) and sets the SF, ZF, and PF status flags according\nto the result. The result is then discarded.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional\nregisters (R8-R15). Using a REX prefix in the form of REX.W promotes operation\nto 64 bits. See the summary chart at the beginning of this section for encoding\ndata and limits.\n\nOperation:\n\nTEMP <- SRC1 AND SRC2;\nSF <- MSB(TEMP);\nIF TEMP = 0\n  THEN ZF <- 1;\n  ELSE ZF <- 0;\nFI:\nPF <- BitwiseXNOR(TEMP[0:7]);\nCF <- 0;\nOF <- 0;\n(* AF is undefined *)\n\nFlags Affected:\nThe OF and CF flags are set to 0. The SF, ZF, and PF flags are set according\nto the result (see the \u201cOperation\u201d section above). The state of the AF flag\nis undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #AC(0)         | If alignment checking is enabled and \n|                | an unaligned memory reference is made\n|                | while the current privilege level is \n|                | 3.                                   \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address \n|                | is outside the CS, DS, ES, FS, or GS  \n|                | segment limit.                        \n| #SS(0)         | If a memory operand effective address \n|                | is outside the SS segment limit.      \n| #PF(fault-code)| If a page fault occurs.               \n| #AC(0)         | If alignment checking is enabled and  \n|                | an unaligned memory reference is made.\n| #UD            | If the LOCK prefix is used.           \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "TEST"
    }, 
    {
      "description": "\nTZCNT  -  Count the Number of Trailing Zero Bits:\n| Opcode/Instruction                  | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                           \n| F3 0F BC /r TZCNT r16, r/m16        | RM   | V/V            | BMI1              | Count the number of trailing zero bits\n|                                     |      |                |                   | in r/m16, return result in r16.       \n| F3 0F BC /r TZCNT r32, r/m32        | RM   | V/V            | BMI1              | Count the number of trailing zero bits\n|                                     |      |                |                   | in r/m32, return result in r32.       \n| REX.W + F3 0F BC /r TZCNT r64, r/m64| RM   | V/N.E.         | BMI1              | Count the number of trailing zero bits\n|                                     |      |                |                   | in r/m64, return result in r64.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| A    | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nTZCNT counts the number of trailing least significant zero bits in source operand\n(second operand) and returns the result in destination operand (first operand).\nTZCNT is an extension of the BSF instruction. The key difference between TZCNT\nand BSF instruction is that TZCNT provides operand size as output when source\noperand is zero while in the case of BSF instruction, if source operand is zero,\nthe content of destination operand are undefined. On processors that do not\nsupport TZCNT, the instruction byte encoding is executed as BSF.\n\nOperation:\n\ntemp <- 0\nDEST <- 0\nDO WHILE ( (temp < OperandSize) and (SRC[ temp] = 0) )\n  temp <- temp +1\n  DEST <- DEST+ 1\nOD\nIF DEST = OperandSize\n  CF <- 1\nELSE\n  CF <- 0\nFI\nIF DEST = 0\n  ZF <- 1\nELSE\n  ZF <- 0\nFI\n\nFlags Affected:\nZF is set to 1 in case of zero output (least significant bit of the source is\nset), and to 0 otherwise, CF is set to 1 if the input was zero and cleared otherwise.\nOF, SF, PF and AF flags are undefined.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| TZCNT:| unsigned __int32 _tzcnt_u32(unsigned\n|       | __int32 src);                       \n| TZCNT:| unsigned __int64 _tzcnt_u64(unsigned\n|       | __int64 src);                       \n\nProtected Mode Exceptions:\n| #GP(0)          | For an illegal memory operand effective    \n|                 | address in the CS, DS, ES, FS or GS        \n|                 | segments. If the DS, ES, FS, or GS register\n|                 | is used to access memory and it contains   \n|                 | a null segment selector.                   \n| #SS(0)          | For an illegal address in the SS segment.  \n| #PF (fault-code)| For a page fault.                          \n| #AC(0)          | If alignment checking is enabled and       \n|                 | an unaligned memory reference is made      \n|                 | while the current privilege level is       \n|                 | 3.                                         \n\nReal-Address Mode Exceptions:\n| #GP(0)| If any part of the operand lies outside  \n|       | of the effective address space from      \n|       | 0 to 0FFFFH.                             \n| #SS(0)| For an illegal address in the SS segment.\n\nVirtual 8086 Mode Exceptions:\n| #GP(0)          | If any part of the operand lies outside  \n|                 | of the effective address space from      \n|                 | 0 to 0FFFFH.                             \n| #SS(0)          | For an illegal address in the SS segment.\n| #PF (fault-code)| For a page fault.                        \n| #AC(0)          | If alignment checking is enabled and     \n|                 | an unaligned memory reference is made    \n|                 | while the current privilege level is     \n|                 | 3.                                       \n\nCompatibility Mode Exceptions:\nSame exceptions as in Protected Mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)          | If the memory address is in a non-canonical\n|                 | form.                                      \n| #SS(0)          | If a memory address referencing the        \n|                 | SS segment is in a non-canonical form.     \n| #PF (fault-code)| For a page fault.                          \n| #AC(0)          | If alignment checking is enabled and       \n|                 | an unaligned memory reference is made      \n|                 | while the current privilege level is       \n|                 | 3.                                         \n", 
      "mnem": "TZCNT"
    }, 
    {
      "description": "\nUCOMISD - Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                 \n| 66 0F 2E /r UCOMISD xmm1, xmm2/m64    | RM   | V/V                   | SSE2              | Compares (unordered) the low doubleprecision\n|                                       |      |                       |                   | floating-point values in xmm1 and xmm2/m64  \n|                                       |      |                       |                   | and set the EFLAGS accordingly.             \n| VEX.LIG.66.0F.WIG 2E /r VUCOMISD xmm1,| RM   | V/V                   | AVX               | Compare low double precision floating-point \n| xmm2/m64                              |      |                       |                   | values in xmm1 and xmm2/mem64 and set       \n|                                       |      |                       |                   | the EFLAGS flags accordingly.               \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nPerforms an unordered compare of the double-precision floating-point values\nin the low quadwords of source operand 1 (first operand) and source operand\n2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register\naccording to the result (unordered, greater than, less than, or equal). The\nOF, SF and AF flags in the EFLAGS register are set to 0. The unordered result\nis returned if either source operand is a NaN (QNaN or SNaN). The sign of zero\nis ignored for comparisons, so that -0.0 is equal to +0.0.\n\nSource operand 1 is an XMM register; source operand 2 can be an XMM register\nor a 64 bit memory location.\n\nThe UCOMISD instruction differs from the COMISD instruction in that it signals\na SIMD floating-point invalid operation exception (#I) only when a source operand\nis an SNaN. The COMISD instruction signals an invalid operation exception if\na source operand is either a QNaN or an SNaN.\n\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception\nis generated.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). Note: In VEX-encoded versions,\nVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n\nOperation:\n\nRESULT <- UnorderedCompare(SRC1[63:0] < > SRC2[63:0]) {\n(* Set EFLAGS *)\nCASE (RESULT) OF\n  UNORDERED:\n  GREATER_THAN:\n  LESS_THAN:\n  EQUAL:\nESAC;\nOF, AF, SF <- 0;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nint _mm_ucomieq_sd(__m128d a, __m128d b) int _mm_ucomilt_sd(__m128d a, __m128d\nb) int _mm_ucomile_sd(__m128d a, __m128d b) int _mm_ucomigt_sd(__m128d a, __m128d\nb) int _mm_ucomige_sd(__m128d a, __m128d b) int _mm_ucomineq_sd(__m128d a, __m128d\nb)\n\n\nSIMD Floating-Point Exceptions:\nInvalid (if SNaN operands), Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "UCOMISD"
    }, 
    {
      "description": "\nUCOMISS - Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS:\n| Opcode/Instruction                 | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                      \n| 0F 2E /r UCOMISS xmm1, xmm2/m32    | RM   | V/V                   | SSE               | Compare lower single-precision floating-point    \n|                                    |      |                       |                   | value in xmm1 register with lower singleprecision\n|                                    |      |                       |                   | floating-point value in xmm2/mem and             \n|                                    |      |                       |                   | set the status flags accordingly.                \n| VEX.LIG.0F.WIG 2E /r VUCOMISS xmm1,| RM   | V/V                   | AVX               | Compare low single precision floating-point      \n| xmm2/m32                           |      |                       |                   | values in xmm1 and xmm2/mem32 and set            \n|                                    |      |                       |                   | the EFLAGS flags accordingly.                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nPerforms an unordered compare of the single-precision floating-point values\nin the low doublewords of the source operand 1 (first operand) and the source\noperand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS\nregister according to the result (unordered, greater than, less than, or equal).\nThe OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result\nis returned if either source operand is a NaN (QNaN or SNaN). The sign of zero\nis ignored for comparisons, so that -0.0 is equal to +0.0.\n\nSource operand 1 is an XMM register; source operand 2 can be an XMM register\nor a 32 bit memory location.\n\nThe UCOMISS instruction differs from the COMISS instruction in that it signals\na SIMD floating-point invalid operation exception (#I) only when a source operand\nis an SNaN. The COMISS instruction signals an invalid operation exception if\na source operand is either a QNaN or an SNaN.\n\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception\nis generated.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). Note: In VEX-encoded versions,\nVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\n\nOperation:\n\nRESULT <- UnorderedCompare(SRC1[31:0] <> SRC2[31:0]) {\n(* Set EFLAGS *)\nCASE (RESULT) OF\n  UNORDERED:\n  GREATER_THAN:\n  LESS_THAN:\n  EQUAL:\nESAC;\nOF,AF,SF <- 0;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nint _mm_ucomieq_ss(__m128 a, __m128 b) int _mm_ucomilt_ss(__m128 a, __m128 b)\nint _mm_ucomile_ss(__m128 a, __m128 b) int _mm_ucomigt_ss(__m128 a, __m128 b)\nint _mm_ucomige_ss(__m128 a, __m128 b)\n\nint _mm_ucomineq_ss(__m128 a, __m128 b)\n\n\nSIMD Floating-Point Exceptions:\nInvalid (if SNaN operands), Denormal.\n\n\nOther Exceptions:\nSee Exceptions Type 3; additionally\n\n| #UD| If VEX.vvvv != 1111B.\n", 
      "mnem": "UCOMISS"
    }, 
    {
      "description": "\nUD2 - Undefined Instruction:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                    \n| 0F 0B | UD2        | NP   | Valid      | Valid          | Raise invalid opcode exception.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nGenerates an invalid opcode exception. This instruction is provided for software\ntesting to explicitly generate an invalid opcode exception. The opcode for this\ninstruction is reserved for this purpose.\n\nOther than raising the invalid opcode exception, this instruction has no effect\non processor state or memory.\n\nEven though it is the execution of the UD2 instruction that causes the invalid\nopcode exception, the instruction pointer saved by delivery of the exception\nreferences the UD2 instruction (and not the following instruction).\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\n#UD (* Generates invalid opcode exception *);\n\nFlags Affected:\nNone.\n\n\nExceptions (All Operating Modes):\n| #UD| Raises an invalid opcode exception in\n|    | all operating modes.                 \n", 
      "mnem": "UD2"
    }, 
    {
      "description": "\nUNPCKHPD - Unpack and Interleave High Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| 66 0F 15 /r UNPCKHPD xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Unpacks and Interleaves double-precision \n|                                      |      |                       |                   | floating-point values from high quadwords\n|                                      |      |                       |                   | of xmm1 and xmm2/m128.                   \n| VEX.NDS.128.66.0F.WIG 15 /r VUNPCKHPD| RVM  | V/V                   | AVX               | Unpacks and Interleaves double precision \n| xmm1,xmm2, xmm3/m128                 |      |                       |                   | floating-point values from high quadwords\n|                                      |      |                       |                   | of xmm2 and xmm3/m128.                   \n| VEX.NDS.256.66.0F.WIG 15 /r VUNPCKHPD| RVM  | V/V                   | AVX               | Unpacks and Interleaves double precision \n| ymm1,ymm2, ymm3/m256                 |      |                       |                   | floating-point values from high quadwords\n|                                      |      |                       |                   | of ymm2 and ymm3/m256.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an interleaved unpack of the high double-precision floating-point values\nfrom the source operand (second operand) and the destination operand (first\noperand). See Figure 4-23.\n\n| DEST| X1                                 | X0             \n| SRC | Y1                                 | Y0             \n| DEST| Y1 UNPCKHPD Instruction High Unpack| X1 Figure 4-23.\n|     | and Interleave Operation           |                \nWhen unpacking from a memory operand, an implementation may fetch only the appropriate\n64 bits; however, alignment to 16-byte boundary and normal segment checking\nwill still be enforced.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15).\n\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit\nmemory location. The destination is not distinct from the first source XMM register\nand the upper bits (VLMAX-1:128) of the corresponding YMM register destination\nare unmodified. VEX.128 encoded version: the first source operand is an XMM\nregister or 128-bit memory location. The destination operand is an XMM register.\nThe upper bits (VLMAX-1:128) of the corresponding YMM register destination are\nzeroed.\n\nOperation:\n\nUNPCKHPD (128-bit Legacy SSE version)\nDEST[63:0] <- SRC1[127:64]\nDEST[127:64] <- SRC2[127:64]\nDEST[VLMAX-1:128] (Unmodified)\nVUNPCKHPD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[127:64]\nDEST[127:64] <- SRC2[127:64]\nDEST[VLMAX-1:128] <- 0\nVUNPCKHPD (VEX.256 encoded version)\nDEST[63:0] <- SRC1[127:64]\nDEST[127:64] <- SRC2[127:64]\nDEST[191:128]<-SRC1[255:192]\nDEST[255:192]<-SRC2[255:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| UNPCKHPD:| __m128d _mm_unpackhi_pd(__m128d a, __m128d\n|          | b)                                        \n| UNPCKHPD:| __m256d _mm256_unpackhi_pd(__m256d a,     \n|          | __m256d b)                                \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "UNPCKHPD"
    }, 
    {
      "description": "\nUNPCKHPS - Unpack and Interleave High Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| 0F 15 /r UNPCKHPS xmm1, xmm2/m128                     | RM   | V/V                   | SSE               | Unpacks and Interleaves single-precision \n|                                                       |      |                       |                   | floating-point values from high quadwords\n|                                                       |      |                       |                   | of xmm1 and xmm2/mem into xmm1.          \n| VEX.NDS.128.0F.WIG 15 /r VUNPCKHPS xmm1,xmm2,         | RVM  | V/V                   | AVX               | Unpacks and Interleaves single-precision \n| xmm3/m128                                             |      |                       |                   | floating-point values from high quadwords\n|                                                       |      |                       |                   | of xmm2 and xmm3/m128.                   \n| VEX.NDS.256.0F.WIG 15 /r VUNPCKHPS ymm1,ymm2,ymm3/m256| RVM  | V/V                   | AVX               | Unpacks and Interleaves single-precision \n|                                                       |      |                       |                   | floating-point values from high quadwords\n|                                                       |      |                       |                   | of ymm2 and ymm3/m256.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an interleaved unpack of the high-order single-precision floating-point\nvalues from the source operand (second operand) and the destination operand\n(first operand). See Figure 4-24. The source operand can be an XMM register\nor a 128-bit memory location; the destination operand is an XMM register.\n\n| DEST| X3                                 | X2| X1| X0             \n| SRC | Y3                                 | Y2| Y1| Y0             \n| DEST| Y3 UNPCKHPS Instruction High Unpack| X3| Y2| X2 Figure 4-24.\n|     | and Interleave Operation           |   |   |                \nWhen unpacking from a memory operand, an implementation may fetch only the appropriate\n64 bits; however, alignment to 16-byte boundary and normal segment checking\nwill still be enforced.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: T second\nsource can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed.\n\nOperation:\n\nUNPCKHPS (128-bit Legacy SSE version)\nDEST[31:0] <- SRC1[95:64]\nDEST[63:32] <- SRC2[95:64]\nDEST[95:64] <- SRC1[127:96]\nDEST[127:96] <- SRC2[127:96]\nDEST[VLMAX-1:128] (Unmodified)\nVUNPCKHPS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[95:64]\nDEST[63:32] <- SRC2[95:64]\nDEST[95:64] <- SRC1[127:96]\nDEST[127:96] <- SRC2[127:96]\nDEST[VLMAX-1:128] <- 0\nVUNPCKHPS (VEX.256 encoded version)\nDEST[31:0] <- SRC1[95:64]\nDEST[63:32] <- SRC2[95:64]\nDEST[95:64] <- SRC1[127:96]\nDEST[127:96] <- SRC2[127:96]\nDEST[159:128] <- SRC1[223:192]\nDEST[191:160] <- SRC2[223:192]\nDEST[223:192] <- SRC1[255:224]\nDEST[255:224] <- SRC2[255:224]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| UNPCKHPS:| __m128 _mm_unpackhi_ps(__m128 a, __m128\n|          | b)                                     \n| UNPCKHPS:| __m256 _mm256_unpackhi_ps (__m256 a,   \n|          | __m256 b);                             \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "UNPCKHPS"
    }, 
    {
      "description": "\nUNPCKLPD - Unpack and Interleave Low Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                   | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| 66 0F 14 /r UNPCKLPD xmm1, xmm2/m128 | RM   | V/V                   | SSE2              | Unpacks and Interleaves double-precision\n|                                      |      |                       |                   | floating-point values from low quadwords\n|                                      |      |                       |                   | of xmm1 and xmm2/m128.                  \n| VEX.NDS.128.66.0F.WIG 14 /r VUNPCKLPD| RVM  | V/V                   | AVX               | Unpacks and Interleaves double precision\n| xmm1,xmm2, xmm3/m128                 |      |                       |                   | floating-point values low high quadwords\n|                                      |      |                       |                   | of xmm2 and xmm3/m128.                  \n| VEX.NDS.256.66.0F.WIG 14 /r VUNPCKLPD| RVM  | V/V                   | AVX               | Unpacks and Interleaves double precision\n| ymm1,ymm2, ymm3/m256                 |      |                       |                   | floating-point values low high quadwords\n|                                      |      |                       |                   | of ymm2 and ymm3/m256.                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an interleaved unpack of the low double-precision floating-point values\nfrom the source operand (second operand) and the destination operand (first\noperand). See Figure 4-25. The source operand can be an XMM register or a 128-bit\nmemory location; the destination operand is an XMM register.\n\n| DEST| X1                                    | X0             \n| SRC | Y1                                    | Y0             \n| DEST| Y0 UNPCKLPD Instruction Low Unpack and| X0 Figure 4-25.\n|     | Interleave Operation                  |                \nWhen unpacking from a memory operand, an implementation may fetch only the appropriate\n64 bits; however, alignment to 16-byte boundary and normal segment checking\nwill still be enforced.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: T second\nsource can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed.\n\nOperation:\n\nUNPCKLPD (128-bit Legacy SSE version)\nDEST[63:0] <- SRC1[63:0]\nDEST[127:64] <- SRC2[63:0]\nDEST[VLMAX-1:128] (Unmodified)\nVUNPCKLPD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0]\nDEST[127:64] <- SRC2[63:0]\nDEST[VLMAX-1:128] <- 0\nVUNPCKLPD (VEX.256 encoded version)\nDEST[63:0] <- SRC1[63:0]\nDEST[127:64] <- SRC2[63:0]\nDEST[191:128] <- SRC1[191:128]\nDEST[255:192] <- SRC2[191:128]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| UNPCKHPD:| __m128d _mm_unpacklo_pd(__m128d a, __m128d\n|          | b)                                        \n| UNPCKLPD:| __m256d _mm256_unpacklo_pd(__m256d a,     \n|          | __m256d b)                                \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "UNPCKLPD"
    }, 
    {
      "description": "\nUNPCKLPS - Unpack and Interleave Low Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| 0F 14 /r UNPCKLPS xmm1, xmm2/m128                     | RM   | V/V                   | SSE               | Unpacks and Interleaves single-precision\n|                                                       |      |                       |                   | floating-point values from low quadwords\n|                                                       |      |                       |                   | of xmm1 and xmm2/mem into xmm1.         \n| VEX.NDS.128.0F.WIG 14 /r VUNPCKLPS xmm1,xmm2,         | RVM  | V/V                   | AVX               | Unpacks and Interleaves single-precision\n| xmm3/m128                                             |      |                       |                   | floating-point values from low quadwords\n|                                                       |      |                       |                   | of xmm2 and xmm3/m128.                  \n| VEX.NDS.256.0F.WIG 14 /r VUNPCKLPS ymm1,ymm2,ymm3/m256| RVM  | V/V                   | AVX               | Unpacks and Interleaves single-precision\n|                                                       |      |                       |                   | floating-point values from low quadwords\n|                                                       |      |                       |                   | of ymm2 and ymm3/m256.                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an interleaved unpack of the low-order single-precision floating-point\nvalues from the source operand (second operand) and the destination operand\n(first operand). See Figure 4-26. The source operand can be an XMM register\nor a 128-bit memory location; the destination operand is an XMM register.\n\n| DEST| X3                                    | X2| X1| X0             \n| SRC | Y3                                    | Y2| Y1| Y0             \n| DEST| Y1 UNPCKLPS Instruction Low Unpack and| X1| Y0| X0 Figure 4-26.\n|     | Interleave Operation                  |   |   |                \nWhen unpacking from a memory operand, an implementation may fetch only the appropriate\n64 bits; however, alignment to 16-byte boundary and normal segment checking\nwill still be enforced.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: The first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed.\n\nOperation:\n\nUNPCKLPS (128-bit Legacy SSE version)\nDEST[31:0] <- SRC1[31:0]\nDEST[63:32] <- SRC2[31:0]\nDEST[95:64] <- SRC1[63:32]\nDEST[127:96] <- SRC2[63:32]\nDEST[VLMAX-1:128] (Unmodified)\nVUNPCKLPS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0]\nDEST[63:32] <- SRC2[31:0]\nDEST[95:64] <- SRC1[63:32]\nDEST[127:96] <- SRC2[63:32]\nDEST[VLMAX-1:128] <- 0\nUNPCKLPS (VEX.256 encoded version)\nDEST[31:0] <- SRC1[31:0]\nDEST[63:32] <- SRC2[31:0]\nDEST[95:64] <- SRC1[63:32]\nDEST[127:96] <- SRC2[63:32]\nDEST[159:128] <- SRC1[159:128]\nDEST[191:160] <- SRC2[159:128]\nDEST[223:192] <- SRC1[191:160]\nDEST[255:224] <- SRC2[191:160]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| UNPCKLPS:| __m128 _mm_unpacklo_ps(__m128 a, __m128\n|          | b)                                     \n| UNPCKLPS:| __m256 _mm256_unpacklo_ps (__m256 a,   \n|          | __m256 b);                             \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "UNPCKLPS"
    }, 
    {
      "description": "\nVBROADCAST - Broadcast Floating-Point Data:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                     \n| VEX.128.66.0F38.W0 18 /r VBROADCASTSS  | RM   | V/V           | AVX               | Broadcast single-precision floating-point       \n| xmm1, m32                              |      |               |                   | element in mem to four locations in             \n|                                        |      |               |                   | xmm1.                                           \n| VEX.256.66.0F38.W0 18 /r VBROADCASTSS  | RM   | V/V           | AVX               | Broadcast single-precision floating-point       \n| ymm1, m32                              |      |               |                   | element in mem to eight locations in            \n|                                        |      |               |                   | ymm1.                                           \n| VEX.256.66.0F38.W0 19 /r VBROADCASTSD  | RM   | V/V           | AVX               | Broadcast double-precision floating-point       \n| ymm1, m64                              |      |               |                   | element in mem to four locations in             \n|                                        |      |               |                   | ymm1.                                           \n| VEX.256.66.0F38.W0 1A /r VBROADCASTF128| RM   | V/V           | AVX               | Broadcast 128 bits of floating-point            \n| ymm1, m128                             |      |               |                   | data in mem to low and high 128-bits            \n|                                        |      |               |                   | in ymm1.                                        \n| VEX.128.66.0F38.W0 18/r VBROADCASTSS   | RM   | V/V           | AVX2              | Broadcast the low single-precision floatingpoint\n| xmm1, xmm2                             |      |               |                   | element in the source operand to four           \n|                                        |      |               |                   | locations in xmm1.                              \n| VEX.256.66.0F38.W0 18 /r VBROADCASTSS  | RM   | V/V           | AVX2              | Broadcast low single-precision floating-point   \n| ymm1, xmm2                             |      |               |                   | element in the source operand to eight          \n|                                        |      |               |                   | locations in ymm1.                              \n| VEX.256.66.0F38.W0 19 /r VBROADCASTSD  | RM   | V/V           | AVX2              | Broadcast low double-precision floating-point   \n| ymm1, xmm2                             |      |               |                   | element in the source operand to four           \n|                                        |      |               |                   | locations in ymm1.                              \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nLoad floating point values from the source operand (second operand) and broadcast\nto all elements of the destination operand (first operand). VBROADCASTSD and\nVBROADCASTF128 are only supported as 256-bit wide versions. VBROADCASTSS is\nsupported in both 128-bit and 256-bit wide versions. Memory and register source\noperand syntax support of 256-bit instructions depend on the processor's enumeration\nof the following conditions with respect to CPUID.1:ECX.AVX[bit 28] and CPUID.(EAX=07H,\nECX=0H):EBX.AVX2[bit 5]:\n\n - If CPUID.1:ECX.AVX = 1 and CPUID.(EAX=07H, ECX=0H):EBX.AVX2 = 0: the destination\noperand is a YMM register. The source operand support can be either a 32-bit,\n64-bit, or 128-bit memory location. Register source encodings are reserved and\nwill #UD.\n - If CPUID.1:ECX.AVX = 1 and CPUID.(EAX=07H, ECX=0H):EBX.AVX2 = 1: the destination\noperand is a YMM register. The source operand support can be a register or memory\nlocation.\n\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise\ninstructions will #UD. An attempt to execute VBROADCASTSD or VBROADCASTF128\nencoded with VEX.L= 0 will cause an #UD exception. Attempts to execute any VBROADCAST*\ninstruction with VEX.W = 1 will cause #UD.\n\n| m32                                     | X0                \n| X0                                      | X0                \n| VBROADCASTSS Operation (VEX.256 encoded | Figure 4-27. X0   \n| version)                                |                   \n| X0                                      | X0                \n| VBROADCASTSS Operation (128-bit version)| Figure 4-28.      \n| X0                                      | m64               \n| X0                                      | X0                \n| VBROADCASTSD Operation                  | Figure 4-29. X0 X0\n| VBROADCASTF128 Operation                | Figure 4-30.      \nOperation:\n\nVBROADCASTSS (128 bit version)\ntemp <- SRC[31:0]\nDEST[31:0] <- temp\nDEST[63:32] <- temp\nDEST[95:64] <- temp\nDEST[127:96] <- temp\nDEST[VLMAX-1:128] <- 0\nVBROADCASTSS (VEX.256 encoded version)\ntemp <- SRC[31:0]\nDEST[31:0] <- temp\nDEST[63:32] <- temp\nDEST[95:64] <- temp\nDEST[127:96] <- temp\nDEST[159:128] <- temp\nDEST[191:160] <- temp\nDEST[223:192] <- temp\nDEST[255:224] <- temp\nVBROADCASTSD (VEX.256 encoded version)\ntemp <- SRC[63:0]\nDEST[63:0] <- temp\nDEST[127:64] <- temp\nDEST[191:128] <- temp\nDEST[255:192] <- temp\nVBROADCASTF128\ntemp <- SRC[127:0]\nDEST[127:0] <- temp\nDEST[VLMAX-1:128] <- temp\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| VBROADCASTSS:  | __m128 _mm_broadcast_ss(float *a);     \n| VBROADCASTSS:  | __m256 _mm256_broadcast_ss(float *a);  \n| VBROADCASTSD:  | __m256d _mm256_broadcast_sd(double *a);\n| VBROADCASTF128:| __m256 _mm256_broadcast_ps(__m128 *    \n|                | a);                                    \n| VBROADCASTF128:| __m256d _mm256_broadcast_pd(__m128d    \n|                | * a);                                  \n\nFlags Affected:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 6; additionally\n\n| #UD| If VEX.L = 0 for VBROADCASTSD, If VEX.L\n|    | = 0 for VBROADCASTF128, If VEX.W = 1.  \n", 
      "mnem": "VBROADCAST"
    }, 
    {
      "description": "\nVCVTPH2PS - Convert 16-bit FP Values to Single-Precision FP Values:\n| Opcode/Instruction                      | Op/En| 64/32bit Mode| CPUID Feature Flag| Description                                \n| VEX.256.66.0F38.W0 13 /r VCVTPH2PS ymm1,| RM   | V/V          | F16C              | Convert eight packed half precision        \n| xmm2/m128                               |      |              |                   | (16-bit) floating-point values in xmm2/m128\n|                                         |      |              |                   | to packed single-precision floating-point  \n|                                         |      |              |                   | value in ymm1.                             \n| VEX.128.66.0F38.W0 13 /r VCVTPH2PS xmm1,| RM   | V/V          | F16C              | Convert four packed half precision (16-bit)\n| xmm2/m64                                |      |              |                   | floating-point values in xmm2/m64 to       \n|                                         |      |              |                   | packed single-precision floating-point     \n|                                         |      |              |                   | value in xmm1.                             \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nConverts four/eight packed half precision (16-bits) floating-point values in\nthe low-order 64/128 bits of an XMM/YMM register or 64/128-bit memory location\nto four/eight packed single-precision floating-point values and writes the converted\nvalues into the destination XMM/YMM register. If case of a denormal operand,\nthe correct normal result is returned. MXCSR.DAZ is ignored and is treated as\nif it 0. No denormal exception is reported on MXCSR. 128-bit version: The source\noperand is a XMM register or 64-bit memory location. The destination operand\nis a XMM register. The upper bits (VLMAX-1:128) of the corresponding destination\nYMM register are zeroed. 256-bit version: The source operand is a XMM register\nor 128-bit memory location. The destination operand is a YMM register. The diagram\nbelow illustrates how data is converted from four packed half precision (in\n64 bits) to four single precision (in 128 bits) FP values. Note: VEX.vvvv is\nreserved (must be 1111b).\n\n| VCVTPH2PS xmm1, xmm2/mem64, 95 convert| imm8 0 xmm2/mem64 convert convert\n| 95 VS2                                | 0 xmm1                           \n| Figure 4-31.                          | VCVTPH2PS (128-bit Version)      \nOperation:\n\nvCvt_h2s(SRC1[15:0])\n{\nRETURN Cvt_Half_Precision_To_Single_Precision(SRC1[15:0]);\n}\nVCVTPH2PS (VEX.256 encoded version)\nDEST[31:0] <-vCvt_h2s(SRC1[15:0]);\nDEST[63:32] <-vCvt_h2s(SRC1[31:16]);\nDEST[95:64] <-vCvt_h2s(SRC1[47:32]);\nDEST[127:96] <-vCvt_h2s(SRC1[63:48]);\nDEST[159:128] <-vCvt_h2s(SRC1[79:64]);\nDEST[191:160] <-vCvt_h2s(SRC1[95:80]);\nDEST[223:192] <-vCvt_h2s(SRC1[111:96]);\nDEST[255:224] <-vCvt_h2s(SRC1[127:112]);\nVCVTPH2PS (VEX.128 encoded version)\nDEST[31:0] <-vCvt_h2s(SRC1[15:0]);\nDEST[63:32] <-vCvt_h2s(SRC1[31:16]);\nDEST[95:64] <-vCvt_h2s(SRC1[47:32]);\nDEST[127:96] <-vCvt_h2s(SRC1[63:48]);\nDEST[VLMAX-1:128] <-0\n\nFlags Affected:\nNone\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n__m128 _mm_cvtph_ps ( __m128i m1);\n\n__m256 _mm256_cvtph_ps ( __m128i m1)\n\n\nSIMD Floating-Point Exceptions:\nInvalid\n\n\nOther Exceptions:\nExceptions Type 11 (do not report #AC); additionally\n\n| #UD| If VEX.W=1.\n", 
      "mnem": "VCVTPH2PS"
    }, 
    {
      "description": "\nVCVTPS2PH - Convert Single-Precision FP value to 16-bit FP value:\n| Opcode/Instruction                   | Op/En  | 64/32bit Mode| CPUID Feature Flag| Description                              \n| VEX.256.66.0F3A.W0 1D /r ib VCVTPS2PH| MR imm8| V/V          | F16C              | Convert eight packed single-precision    \n| xmm1/m128, ymm2,                     |        |              |                   | floating-point value in ymm2 to packed   \n|                                      |        |              |                   | half-precision (16-bit) floating-point   \n|                                      |        |              |                   | value in xmm1/mem. Imm8 provides rounding\n|                                      |        |              |                   | controls.                                \n| VEX.128.66.0F3A.W0.1D /r ib VCVTPS2PH| MR imm8| V/V          | F16C              | Convert four packed single-precision     \n| xmm1/m64, xmm2,                      |        |              |                   | floating-point value in xmm2 to packed   \n|                                      |        |              |                   | halfprecision (16-bit) floating-point    \n|                                      |        |              |                   | value in xmm1/mem. Imm8 provides rounding\n|                                      |        |              |                   | controls.                                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nConvert four or eight packed single-precision floating values in first source\noperand to four or eight packed halfprecision (16-bit) floating-point values.\nThe rounding mode is specified using the immediate field (imm8). Underflow results\n(i.e. tiny results) are converted to denormals. MXCSR.FTZ is ignored. If a source\nelement is denormal relative to input format with MXCSR.DAZ not set, DM masked\nand at least one of PM or UM unmasked; a SIMD exception will be raised with\nDE, UE and PE set. 128-bit version: The source operand is a XMM register. The\ndestination operand is a XMM register or 64-bit memory location. The upper-bits\nvector register zeroing behavior of VEX prefix encoding still applies if the\ndestination operand is a xmm register. So the upper bits (255:64) of corresponding\nYMM register are zeroed. 256-bit version: The source operand is a YMM register.\nThe destination operand is a XMM register or 128-bit memory location. The upper-bits\nvector register zeroing behavior of VEX prefix encoding still applies if the\ndestination operand is a xmm register. So the upper bits (255:128) of the corresponding\nYMM register are zeroed. Note: VEX.vvvv is reserved (must be 1111b). The diagram\nbelow illustrates how data is converted from four packed single precision (in\n128 bits) to four half precision (in 64 bits) FP values.\n\n| VCVTPS2PH xmm1/mem64, xmm2, 95 VS2| imm8 0 xmm2                \n| convert                           | convert convert            \n| 95                                | 0 xmm1/mem64               \n| Figure 4-32.                      | VCVTPS2PH (128-bit Version)\nThe immediate byte defines several bit fields that controls rounding operation.\nThe effect and encoding of RC field are listed in Table 4-16.\n\n\nTable 4-16. Immediate Byte Encoding for 16-bit Floating-Point Conversion Instructions:\n| Bits          | Field Name/value           | Description                           | Comment        \n| Imm[1:0]      | RC=00B RC=01B RC=10B RC=11B| Round to nearest even Round down Round| If Imm[2] = 0  \n|               |                            | up Truncate                           |                \n| Imm[2]Imm[7:3]| MS1=0 MS1=1 Ignored        | Use imm[1:0] for rounding Use MXCSR.RC| Ignore MXCSR.RC\n|               |                            | for rounding Ignored by processor     |                \nOperation:\n\nvCvt_s2h(SRC1[31:0])\n{\nIF Imm[2] = 0\nTHEN // using Imm[1:0] for rounding control, see Table 4-16\n     RETURN Cvt_Single_Precision_To_Half_Precision_FP_Imm(SRC1[31:0]);\nELSE // using MXCSR.RC for rounding control\n     RETURN Cvt_Single_Precision_To_Half_Precision_FP_Mxcsr(SRC1[31:0]);\nFI;\n}\nVCVTPS2PH (VEX.256 encoded version)\nDEST[15:0] <- vCvt_s2h(SRC1[31:0]);\nDEST[31:16] <- vCvt_s2h(SRC1[63:32]);\nDEST[47:32] <- vCvt_s2h(SRC1[95:64]);\nDEST[63:48] <- vCvt_s2h(SRC1[127:96]);\nDEST[79:64] <- vCvt_s2h(SRC1[159:128]);\nDEST[95:80] <- vCvt_s2h(SRC1[191:160]);\nDEST[111:96] <- vCvt_s2h(SRC1[223:192]);\nDEST[127:112] <- vCvt_s2h(SRC1[255:224]);\nDEST[255:128] <- 0; // if DEST is a register\nVCVTPS2PH (VEX.128 encoded version)\nDEST[15:0] <- vCvt_s2h(SRC1[31:0]);\nDEST[31:16] <- vCvt_s2h(SRC1[63:32]);\nDEST[47:32] <- vCvt_s2h(SRC1[95:64]);\nDEST[63:48] <- vCvt_s2h(SRC1[127:96]);\nDEST[VLMAX-1:64] <-0; // if DEST is a register\n\nFlags Affected:\nNone\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n__m128i _mm_cvtps_ph ( __m128 m1, const int imm);\n\n__m128i _mm256_cvtps_ph(__m256 m1, const int imm);\n\n\nSIMD Floating-Point Exceptions:\nInvalid, Underflow, Overflow, Precision, Denormal (if MXCSR.DAZ=0);\n\n\nOther Exceptions:\nExceptions Type 11 (do not report #AC); additionally\n\n| #UD| If VEX.W=1.\n", 
      "mnem": "VCVTPS2PH"
    }, 
    {
      "description": "\nVERR/VERW - Verify a Segment for Reading or Writing:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                             \n| 0F 00 /4| VERR r/m16 | M    | Valid      | Valid          | Set ZF=1 if segment specified with r/m16\n|         |            |      |            |                | can be read.                            \n| 0F 00 /5| VERW r/m16 | M    | Valid      | Valid          | Set ZF=1 if segment specified with r/m16\n|         |            |      |            |                | can be written.                         \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nVerifies whether the code or data segment specified with the source operand\nis readable (VERR) or writable (VERW) from the current privilege level (CPL).\nThe source operand is a 16-bit register or a memory location that contains the\nsegment selector for the segment to be verified. If the segment is accessible\nand readable (VERR) or writable (VERW), the ZF flag is set; otherwise, the ZF\nflag is cleared. Code segments are never verified as writable. This check cannot\nbe performed on system segments.\n\nTo set the ZF flag, the following conditions must be met:\n\n - The segment selector is not NULL.\n - The selector must denote a descriptor within the bounds of the descriptor table\n(GDT or LDT).\n - The selector must denote the descriptor of a code or data segment (not that\nof a system segment or gate).\n - For the VERR instruction, the segment must be readable.\n - For the VERW instruction, the segment must be a writable data segment.\n - If the segment is not a conforming code segment, the segment's DPL must be greater\nthan or equal to (have less or the same privilege as) both the CPL and the segment\nselector's RPL.\n\nThe validation performed is the same as is performed when a segment selector\nis loaded into the DS, ES, FS, or GS register, and the indicated access (read\nor write) is performed. The segment selector's value cannot result in a protection\nexception, enabling the software to anticipate possible segment access problems.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\nThe operand size is fixed at 16 bits.\n\nOperation:\n\nIF SRC(Offset) > (GDTR(Limit) or (LDTR(Limit))\n  THEN ZF <- 0; FI;\nRead segment descriptor;\nIF SegmentDescriptor(DescriptorType) = 0 (* System segment *)\nor (SegmentDescriptor(Type) != conforming code segment)\nand (CPL > DPL) or (RPL > DPL)\n  THEN\n     ZF <- 0;\n  ELSE\n     IF ((Instruction = VERR) and (Segment readable))\n     or ((Instruction = VERW) and (Segment writable))\n       THEN\n          ZF <- 1;\n     FI;\nFI;\n\nFlags Affected:\nThe ZF flag is set to 1 if the segment is accessible and readable (VERR) or\nwritable (VERW); otherwise, it is set to 0.\n\n\nProtected Mode Exceptions:\nThe only exceptions generated for these instructions are those related to illegal\naddressing of the source operand.\n\n| #GP(0)         | If a memory operand effective address   \n|                | is outside the CS, DS, ES, FS, or GS    \n|                | segment limit. If the DS, ES, FS, or    \n|                | GS register is used to access memory    \n|                | and it contains a NULL segment selector.\n| #SS(0)         | If a memory operand effective address   \n|                | is outside the SS segment limit.        \n| #PF(fault-code)| If a page fault occurs.                 \n| #AC(0)         | If alignment checking is enabled and    \n|                | an unaligned memory reference is made   \n|                | while the current privilege level is    \n|                | 3.                                      \n| #UD            | If the LOCK prefix is used.             \n\nReal-Address Mode Exceptions:\n| #UD| The VERR and VERW instructions are not\n|    | recognized in real-address mode. If   \n|    | the LOCK prefix is used.              \n\nVirtual-8086 Mode Exceptions:\n| #UD| The VERR and VERW instructions are not\n|    | recognized in virtual-8086 mode. If   \n|    | the LOCK prefix is used.              \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #AC(0)         | If alignment checking is enabled and       \n|                | an unaligned memory reference is made      \n|                | while the current privilege level is       \n|                | 3.                                         \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "VERR"
    }, 
    {
      "description": "-R:VERR", 
      "mnem": "VERW"
    }, 
    {
      "description": "\nVEXTRACTF128  -  Extract Packed Floating-Point Values:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                              \n| VEX.256.66.0F3A.W0 19 /r ib VEXTRACTF128| MR   | V/V           | AVX               | Extract 128 bits of packed floating-point\n| xmm1/m128, ymm2, imm8                   |      |               |                   | values from ymm2 and store results in    \n|                                         |      |               |                   | xmm1/mem.                                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (w)| ModRM:reg (r)| NA       | NA       \n\nDescription:\nExtracts 128-bits of packed floating-point values from the source operand (second\noperand) at an 128-bit offset from imm8[0] into the destination operand (first\noperand). The destination may be either an XMM register or an 128-bit memory\nlocation. VEX.vvvv is reserved and must be 1111b otherwise instructions will\n#UD. The high 7 bits of the immediate are ignored. If VEXTRACTF128 is encoded\nwith VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will\ncause an #UD exception.\n\nOperation:\n\nVEXTRACTF128 (memory destination form)\nCASE (imm8[0]) OF\n  0: DEST[127:0] <- SRC1[127:0]\n  1: DEST[127:0] <- SRC1[255:128]\nESAC.\nVEXTRACTF128 (register destination form)\nCASE (imm8[0]) OF\n  0: DEST[127:0] <- SRC1[127:0]\n  1: DEST[127:0] <- SRC1[255:128]\nESAC.\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| VEXTRACTF128:| __m128 _mm256_extractf128_ps (__m256   \n|              | a, int offset);                        \n| VEXTRACTF128:| __m128d _mm256_extractf128_pd (__m256d \n|              | a, int offset);                        \n| VEXTRACTF128:| __m128i_mm256_extractf128_si256(__m256i\n|              | a, int offset);                        \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 6; additionally\n\n| #UD| If VEX.L= 0 If VEX.W=1.\n", 
      "mnem": "VEXTRACTF128"
    }, 
    {
      "description": "\nVEXTRACTI128  -  Extract packed Integer Values:\n| Opcode/Instruction                      | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                          \n| VEX.256.66.0F3A.W0 39 /r ib VEXTRACTI128| RMI  | V/V           | AVX2              | Extract 128 bits of integer data from\n| xmm1/m128, ymm2, imm8                   |      |               |                   | ymm2 and store results in xmm1/mem.  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RMI  | ModRM:r/m (w)| ModRM:reg (r)| Imm8     | NA       \n\nDescription:\nExtracts 128-bits of packed integer values from the source operand (second operand)\nat a 128-bit offset from imm8[0] into the destination operand (first operand).\nThe destination may be either an XMM register or a 128-bit memory location.\nVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD. The\nhigh 7 bits of the immediate are ignored. An attempt to execute VEXTRACTI128\nencoded with VEX.L= 0 will cause an #UD exception.\n\nOperation:\n\nVEXTRACTI128 (memory destination form)\nCASE (imm8[0]) OF\n  0: DEST[127:0] <- SRC1[127:0]\n  1: DEST[127:0] <- SRC1[255:128]\nESAC.\nVEXTRACTI128 (register destination form)\nCASE (imm8[0]) OF\n  0: DEST[127:0] <- SRC1[127:0]\n  1: DEST[127:0] <- SRC1[255:128]\nESAC.\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| VEXTRACTI128:| __m128i _mm256_extracti128_si256(__m256i\n|              | a, int offset);                         \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 6; additionally\n\n| #UD| IF VEX.L = 0, If VEX.W = 1.\n", 
      "mnem": "VEXTRACTI128"
    }, 
    {
      "description": "\nVFMADD132PD/VFMADD213PD/VFMADD231PD  -  Fused Multiply-Add of Packed DoublePrecision Floating-Point Values:\n| Opcode/Instruction                      | Op/En| 64/32bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.128.66.0F38.W1 98 /r VFMADD132PD| A    | V/V          | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                   |      |              |                   | values from xmm0 and xmm2/mem, add to          \n|                                         |      |              |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.128.66.0F38.W1 A8 /r VFMADD213PD| A    | V/V          | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                   |      |              |                   | values from xmm0 and xmm1, add to xmm2/mem     \n|                                         |      |              |                   | and put result in xmm0.                        \n| VEX.DDS.128.66.0F38.W1 B8 /r VFMADD231PD| A    | V/V          | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                   |      |              |                   | values from xmm1 and xmm2/mem, add to          \n|                                         |      |              |                   | xmm0 and put result in xmm0.                   \n| VEX.DDS.256.66.0F38.W1 98 /r VFMADD132PD| A    | V/V          | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                   |      |              |                   | values from ymm0 and ymm2/mem, add to          \n|                                         |      |              |                   | ymm1 and put result in ymm0.                   \n| VEX.DDS.256.66.0F38.W1 A8 /r VFMADD213PD| A    | V/V          | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                   |      |              |                   | values from ymm0 and ymm1, add to ymm2/mem     \n|                                         |      |              |                   | and put result in ymm0.                        \n| VEX.DDS.256.66.0F38.W1 B8 /r VFMADD231PD| A    | V/V          | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                   |      |              |                   | values from ymm1 and ymm2/mem, add to          \n|                                         |      |              |                   | ymm0 and put result in ymm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a set of SIMD multiply-add computation on packed double-precision floating-point\nvalues using three source operands and writes the multiply-add results in the\ndestination operand. The destination operand is also the first source operand.\nThe second operand must be a SIMD register. The third source operand can be\na SIMD register or a memory location. VFMADD132PD: Multiplies the two or four\npacked double-precision floating-point values from the first source operand\nto the two or four packed double-precision floating-point values in the third\nsource operand, adds the infinite precision intermediate result to the two or\nfour packed double-precision floating-point values in the second source operand,\nperforms rounding and stores the resulting two or four packed double-precision\nfloating-point values to the destination operand (first source operand). VFMADD213PD:\nMultiplies the two or four packed double-precision floating-point values from\nthe second source operand to the two or four packed double-precision floating-point\nvalues in the first source operand, adds the infinite precision intermediate\nresult to the two or four packed double-precision floating-point values in the\nthird source operand, performs rounding and stores the resulting two or four\npacked double-precision floating-point values to the destination operand (first\nsource operand). VFMADD231PD: Multiplies the two or four packed double-precision\nfloating-point values from the second source to the two or four packed double-precision\nfloating-point values in the third source operand, adds the infinite precision\nintermediate result to the two or four packed double-precision floating-point\nvalues in the first source operand, performs rounding and stores the resulting\ntwo or four packed double-precision floating-point values to the destination\noperand (first source operand). VEX.128 encoded version: The destination operand\n(also first source operand) is a XMM register and encoded in reg_field. The\nsecond source operand is a XMM register and encoded in VEX.vvvv. The third source\noperand is a XMM register or a 128-bit memory location and encoded in rm_field.\nThe upper 128 bits of the YMM destination register are zeroed.\n\nVEX.256 encoded version: The destination operand (also first source operand)\nis a YMM register and encoded in reg_field. The second source operand is a YMM\nregister and encoded in VEX.vvvv. The third source operand is a YMM register\nor a 256-bit memory location and encoded in rm_field. Compiler tools may optionally\nsupport a complementary mnemonic for each instruction mnemonic listed in the\nopcode/instruction column of the summary table. The behavior of the complementary\nmnemonic in situations involving NANs are governed by the definition of the\ninstruction mnemonic defined in the opcode/instruction column. See also Section\n14.5.1, \u201cFMA Instruction Operand Order and Arithmetic Behavior\u201d in the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFMADD132PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL-1 {\n  n = 64*i;\n  DEST[n+63:n] <- RoundFPControl_MXCSR(DEST[n+63:n]*SRC3[n+63:n] + SRC2[n+63:n])\n}\nIF (VEX.128) THEN\nDEST[VLMAX-1:128] <- 0\nFI\nVFMADD213PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL-1 {\n  n = 64*i;\n  DEST[n+63:n] <- RoundFPControl_MXCSR(SRC2[n+63:n]*DEST[n+63:n] + SRC3[n+63:n])\n}\nIF (VEX.128) THEN\nDEST[VLMAX-1:128] <- 0\nFI\nVFMADD231PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL-1 {\n  n = 64*i;\n  DEST[n+63:n] <- RoundFPControl_MXCSR(SRC2[n+63:n]*SRC3[n+63:n] + DEST[n+63:n])\n}\nIF (VEX.128) THEN\nDEST[VLMAX-1:128] <- 0\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFMADD132PD: __m128d _mm_fmadd_pd (__m128d a, __m128d b, __m128d c);\n\nVFMADD213PD: __m128d _mm_fmadd_pd (__m128d a, __m128d b, __m128d c);\n\nVFMADD231PD: __m128d _mm_fmadd_pd (__m128d a, __m128d b, __m128d c);\n\nVFMADD132PD: __m256d _mm256_fmadd_pd (__m256d a, __m256d b, __m256d c);\n\nVFMADD213PD: __m256d _mm256_fmadd_pd (__m256d a, __m256d b, __m256d c);\n\nVFMADD231PD: __m256d _mm256_fmadd_pd (__m256d a, __m256d b, __m256d c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "VFMADD132PD"
    }, 
    {
      "description": "\nVFMADD132PS/VFMADD213PS/VFMADD231PS  -  Fused Multiply-Add of Packed SinglePrecision Floating-Point Values:\n| Opcode/Instruction                      | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.128.66.0F38.W0 98 /r VFMADD132PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                   |      |                |                   | values from xmm0 and xmm2/mem, add to          \n|                                         |      |                |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.128.66.0F38.W0 A8 /r VFMADD213PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                   |      |                |                   | values from xmm0 and xmm1, add to xmm2/mem     \n|                                         |      |                |                   | and put result in xmm0.                        \n| VEX.DDS.128.66.0F38.W0 B8 /r VFMADD231PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                   |      |                |                   | values from xmm1 and xmm2/mem, add to          \n|                                         |      |                |                   | xmm0 and put result in xmm0.                   \n| VEX.DDS.256.66.0F38.W0 98 /r VFMADD132PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                   |      |                |                   | values from ymm0 and ymm2/mem, add to          \n|                                         |      |                |                   | ymm1 and put result in ymm0.                   \n| VEX.DDS.256.66.0F38.W0 A8 /r VFMADD213PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                   |      |                |                   | values from ymm0 and ymm1, add to ymm2/mem     \n|                                         |      |                |                   | and put result in ymm0.                        \n| VEX.DDS.256.66.0F38.W0 B8 /r VFMADD231PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                   |      |                |                   | values from ymm1 and ymm2/mem, add to          \n|                                         |      |                |                   | ymm0 and put result in ymm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a set of SIMD multiply-add computation on packed single-precision floating-point\nvalues using three source operands and writes the multiply-add results in the\ndestination operand. The destination operand is also the first source operand.\nThe second operand must be a SIMD register. The third source operand can be\na SIMD register or a memory location. VFMADD132PS: Multiplies the four or eight\npacked single-precision floating-point values from the first source operand\nto the four or eight packed single-precision floating-point values in the third\nsource operand, adds the infinite precision intermediate result to the four\nor eight packed single-precision floating-point values in the second source\noperand, performs rounding and stores the resulting four or eight packed single-precision\nfloating-point values to the destination operand (first source operand). VFMADD213PS:\nMultiplies the four or eight packed single-precision floating-point values from\nthe second source operand to the four or eight packed single-precision floating-point\nvalues in the first source operand, adds the infinite precision intermediate\nresult to the four or eight packed single-precision floating-point values in\nthe third source operand, performs rounding and stores the resulting the four\nor eight packed single-precision floating-point values to the destination operand\n(first source operand). VFMADD231PS: Multiplies the four or eight packed single-precision\nfloating-point values from the second source operand to the four or eight packed\nsingle-precision floating-point values in the third source operand, adds the\ninfinite precision intermediate result to the four or eight packed single-precision\nfloating-point values in the first source operand, performs rounding and stores\nthe resulting four or eight packed single-precision floating-point values to\nthe destination operand (first source operand). VEX.128 encoded version: The\ndestination operand (also first source operand) is a XMM register and encoded\nin reg_field. The second source operand is a XMM register and encoded in VEX.vvvv.\nThe third source operand is a XMM register or a 128-bit memory location and\nencoded in rm_field. The upper 128 bits of the YMM destination register are\nzeroed.\n\nVEX.256 encoded version: The destination operand (also first source operand)\nis a YMM register and encoded in reg_field. The second source operand is a YMM\nregister and encoded in VEX.vvvv. The third source operand is a YMM register\nor a 256-bit memory location and encoded in rm_field. Compiler tools may optionally\nsupport a complementary mnemonic for each instruction mnemonic listed in the\nopcode/instruction column of the summary table. The behavior of the complementary\nmnemonic in situations involving NANs are governed by the definition of the\ninstruction mnemonic defined in the opcode/instruction column. See also Section\n14.5.1, \u201cFMA Instruction Operand Order and Arithmetic Behavior\u201d in the \u201cIntel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1\u201d.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFMADD132PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =4\nELSEIF (VEX.256)\n  MAXVL = 8\nFI\nFor i = 0 to MAXVL-1 {\n  n = 32*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(DEST[n+31:n]*SRC3[n+31:n] + SRC2[n+31:n])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\nVFMADD213PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =4\nELSEIF (VEX.256)\n  MAXVL = 8\nFI\nFor i = 0 to MAXVL-1 {\n  n = 32*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(SRC2[n+31:n]*DEST[n+31:n] + SRC3[n+31:n])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\nVFMADD231PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =4\nELSEIF (VEX.256)\n  MAXVL = 8\nFI\nFor i = 0 to MAXVL-1 {\n  n = 32*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(SRC2[n+31:n]*SRC3[n+31:n] + DEST[n+31:n])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFMADD132PS: __m128 _mm_fmadd_ps (__m128 a, __m128 b, __m128 c);\n\nVFMADD213PS: __m128 _mm_fmadd_ps (__m128 a, __m128 b, __m128 c);\n\nVFMADD231PS: __m128 _mm_fmadd_ps (__m128 a, __m128 b, __m128 c);\n\nVFMADD132PS: __m256 _mm256_fmadd_ps (__m256 a, __m256 b, __m256 c);\n\nVFMADD213PS: __m256 _mm256_fmadd_ps (__m256 a, __m256 b, __m256 c);\n\nVFMADD231PS: __m256 _mm256_fmadd_ps (__m256 a, __m256 b, __m256 c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "VFMADD132PS"
    }, 
    {
      "description": "\nVFMADD132SD/VFMADD213SD/VFMADD231SD  -  Fused Multiply-Add of Scalar DoublePrecision Floating-Point Values:\n| Opcode/Instruction                          | Op/En| 64/32bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.LIG.128.66.0F38.W1 99 /r VFMADD132SD| A    | V/V          | FMA               | Multiply scalar double-precision floating-point\n| xmm0, xmm1, xmm2/m64                        |      |              |                   | value from xmm0 and xmm2/mem, add to           \n|                                             |      |              |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.LIG.128.66.0F38.W1 A9 /r VFMADD213SD| A    | V/V          | FMA               | Multiply scalar double-precision floating-point\n| xmm0, xmm1, xmm2/m64                        |      |              |                   | value from xmm0 and xmm1, add to xmm2/mem      \n|                                             |      |              |                   | and put result in xmm0.                        \n| VEX.DDS.LIG.128.66.0F38.W1 B9 /r VFMADD231SD| A    | V/V          | FMA               | Multiply scalar double-precision floating-point\n| xmm0, xmm1, xmm2/m64                        |      |              |                   | value from xmm1 and xmm2/mem, add to           \n|                                             |      |              |                   | xmm0 and put result in xmm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD multiply-add computation on the low packed double-precision\nfloating-point values using three source operands and writes the multiply-add\nresult in the destination operand. The destination operand is also the first\nsource operand. The second operand must be a SIMD register. The third source\noperand can be a SIMD register or a memory location. VFMADD132SD: Multiplies\nthe low packed double-precision floating-point value from the first source operand\nto the low packed double-precision floating-point value in the third source\noperand, adds the infinite precision intermediate result to the low packed double-precision\nfloating-point values in the second source operand, performs rounding and stores\nthe resulting packed double-precision floating-point value to the destination\noperand (first source operand). VFMADD213SD: Multiplies the low packed double-precision\nfloating-point value from the second source operand to the low packed double-precision\nfloating-point value in the first source operand, adds the infinite precision\nintermediate result to the low packed double-precision floating-point value\nin the third source operand, performs rounding and stores the resulting packed\ndouble-precision floating-point value to the destination operand (first source\noperand). VFMADD231SD: Multiplies the low packed double-precision floating-point\nvalue from the second source to the low packed double-precision floating-point\nvalue in the third source operand, adds the infinite precision intermediate\nresult to the low packed double-precision floating-point value in the first\nsource operand, performs rounding and stores the resulting packed double-precision\nfloating-point value to the destination operand (first source operand). VEX.128\nencoded version: The destination operand (also first source operand) is a XMM\nregister and encoded in reg_field. The second source operand is a XMM register\nand encoded in VEX.vvvv. The third source operand is a XMM register or a 64-bit\nmemory location and encoded in rm_field. The upper bits ([VLMAX-1:128]) of the\nYMM destination register are zeroed. Compiler tools may optionally support a\ncomplementary mnemonic for each instruction mnemonic listed in the opcode/instruction\ncolumn of the summary table. The behavior of the complementary mnemonic in situations\ninvolving NANs are governed by the definition of the instruction mnemonic defined\nin the opcode/instruction column. See also Section 14.5.1, \u201cFMA Instruction\nOperand Order and Arithmetic Behavior\u201d in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFMADD132SD DEST, SRC2, SRC3\nDEST[63:0] <- RoundFPControl_MXCSR(DEST[63:0]*SRC3[63:0] + SRC2[63:0])\nDEST[127:64] <- DEST[127:64]\nDEST[VLMAX-1:128] <- 0\nVFMADD213SD DEST, SRC2, SRC3\nDEST[63:0] <- RoundFPControl_MXCSR(SRC2[63:0]*DEST[63:0] + SRC3[63:0])\nDEST[127:64] <- DEST[127:64]\nDEST[VLMAX-1:128] <- 0\nVFMADD231SD DEST, SRC2, SRC3\nDEST[63:0] <- RoundFPControl_MXCSR(SRC2[63:0]*SRC3[63:0] + DEST[63:0])\nDEST[127:64] <- DEST[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFMADD132SD: __m128d _mm_fmadd_sd (__m128d a, __m128d b, __m128d c);\n\nVFMADD213SD: __m128d _mm_fmadd_sd (__m128d a, __m128d b, __m128d c);\n\nVFMADD231SD: __m128d _mm_fmadd_sd (__m128d a, __m128d b, __m128d c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 3\n\n", 
      "mnem": "VFMADD132SD"
    }, 
    {
      "description": "\nVFMADD132SS/VFMADD213SS/VFMADD231SS  -  Fused Multiply-Add of Scalar Single-Precision Floating-Point Values:\n| Opcode/Instruction                          | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.LIG.128.66.0F38.W0 99 /r VFMADD132SS| A    | V/V            | FMA               | Multiply scalar single-precision floating-point\n| xmm0, xmm1, xmm2/m32                        |      |                |                   | value from xmm0 and xmm2/mem, add to           \n|                                             |      |                |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.LIG.128.66.0F38.W0 A9 /r VFMADD213SS| A    | V/V            | FMA               | Multiply scalar single-precision floating-point\n| xmm0, xmm1, xmm2/m32                        |      |                |                   | value from xmm0 and xmm1, add to xmm2/mem      \n|                                             |      |                |                   | and put result in xmm0.                        \n| VEX.DDS.LIG.128.66.0F38.W0 B9 /r VFMADD231SS| A    | V/V            | FMA               | Multiply scalar single-precision floating-point\n| xmm0, xmm1, xmm2/m32                        |      |                |                   | value from xmm1 and xmm2/mem, add to           \n|                                             |      |                |                   | xmm0 and put result in xmm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD multiply-add computation on packed single-precision floating-point\nvalues using three source operands and writes the multiply-add results in the\ndestination operand. The destination operand is also the first source operand.\nThe second operand must be a SIMD register. The third source operand can be\na SIMD register or a memory location. VFMADD132SS: Multiplies the low packed\nsingle-precision floating-point value from the first source operand to the low\npacked single-precision floating-point value in the third source operand, adds\nthe infinite precision intermediate result to the low packed single-precision\nfloating-point value in the second source operand, performs rounding and stores\nthe resulting packed single-precision floating-point value to the destination\noperand (first source operand). VFMADD213SS: Multiplies the low packed single-precision\nfloating-point value from the second source operand to the low packed single-precision\nfloating-point value in the first source operand, adds the infinite precision\nintermediate result to the low packed single-precision floating-point value\nin the third source operand, performs rounding and stores the resulting packed\nsingle-precision floating-point value to the destination operand (first source\noperand). VFMADD231SS: Multiplies the low packed single-precision floating-point\nvalue from the second source operand to the low packed single-precision floating-point\nvalue in the third source operand, adds the infinite precision intermediate\nresult to the low packed single-precision floating-point value in the first\nsource operand, performs rounding and stores the resulting packed single-precision\nfloating-point value to the destination operand (first source operand). VEX.128\nencoded version: The destination operand (also first source operand) is a XMM\nregister and encoded in reg_field. The second source operand is a XMM register\nand encoded in VEX.vvvv. The third source operand is a XMM register or a 32-bit\nmemory location and encoded in rm_field. The upper bits ([VLMAX-1:128]) of the\nYMM destination register are zeroed. Compiler tools may optionally support a\ncomplementary mnemonic for each instruction mnemonic listed in the opcode/instruction\ncolumn of the summary table. The behavior of the complementary mnemonic in situations\ninvolving NANs are governed by the definition of the instruction mnemonic defined\nin the opcode/instruction column. See also Section 14.5.1, \u201cFMA Instruction\nOperand Order and Arithmetic Behavior\u201d in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFMADD132SS DEST, SRC2, SRC3\nDEST[31:0] <- RoundFPControl_MXCSR(DEST[31:0]*SRC3[31:0] + SRC2[31:0])\nDEST[127:32] <- DEST[127:32]\nDEST[VLMAX-1:128] <- 0\nVFMADD213SS DEST, SRC2, SRC3\nDEST[31:0] <- RoundFPControl_MXCSR(SRC2[31:0]*DEST[31:0] + SRC3[31:0])\nDEST[127:32] <- DEST[127:32]\nDEST[VLMAX-1:128] <- 0\nVFMADD231SS DEST, SRC2, SRC3\nDEST[31:0] <- RoundFPControl_MXCSR(SRC2[31:0]*SRC3[63:0] + DEST[31:0])\nDEST[127:32] <- DEST[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFMADD132SS: __m128 _mm_fmadd_ss (__m128 a, __m128 b, __m128 c);\n\nVFMADD213SS: __m128 _mm_fmadd_ss (__m128 a, __m128 b, __m128 c);\n\nVFMADD231SS: __m128 _mm_fmadd_ss (__m128 a, __m128 b, __m128 c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 3\n\n", 
      "mnem": "VFMADD132SS"
    }, 
    {
      "description": "-R:VFMADD132PD", 
      "mnem": "VFMADD213PD"
    }, 
    {
      "description": "-R:VFMADD132PS", 
      "mnem": "VFMADD213PS"
    }, 
    {
      "description": "-R:VFMADD132SD", 
      "mnem": "VFMADD213SD"
    }, 
    {
      "description": "-R:VFMADD132SS", 
      "mnem": "VFMADD213SS"
    }, 
    {
      "description": "-R:VFMADD132PD", 
      "mnem": "VFMADD231PD"
    }, 
    {
      "description": "-R:VFMADD132PS", 
      "mnem": "VFMADD231PS"
    }, 
    {
      "description": "-R:VFMADD132SD", 
      "mnem": "VFMADD231SD"
    }, 
    {
      "description": "-R:VFMADD132SS", 
      "mnem": "VFMADD231SS"
    }, 
    {
      "description": "\nVFMADDSUB132PD/VFMADDSUB213PD/VFMADDSUB231PD  -  Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                         | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.128.66.0F38.W1 96 /r VFMADDSUB132PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                      |      |                |                   | values from xmm0 and xmm2/mem, add/subtract    \n|                                            |      |                |                   | elements in xmm1 and put result in xmm0.       \n| VEX.DDS.128.66.0F38.W1 A6 /r VFMADDSUB213PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                      |      |                |                   | values from xmm0 and xmm1, add/subtract        \n|                                            |      |                |                   | elements in xmm2/mem and put result            \n|                                            |      |                |                   | in xmm0.                                       \n| VEX.DDS.128.66.0F38.W1 B6 /r VFMADDSUB231PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                      |      |                |                   | values from xmm1 and xmm2/mem, add/subtract    \n|                                            |      |                |                   | elements in xmm0 and put result in xmm0.       \n| VEX.DDS.256.66.0F38.W1 96 /r VFMADDSUB132PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                      |      |                |                   | values from ymm0 and ymm2/mem, add/subtract    \n|                                            |      |                |                   | elements in ymm1 and put result in ymm0.       \n| VEX.DDS.256.66.0F38.W1 A6 /r VFMADDSUB213PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                      |      |                |                   | values from ymm0 and ymm1, add/subtract        \n|                                            |      |                |                   | elements in ymm2/mem and put result            \n|                                            |      |                |                   | in ymm0.                                       \n| VEX.DDS.256.66.0F38.W1 B6 /r VFMADDSUB231PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                      |      |                |                   | values from ymm1 and ymm2/mem, add/subtract    \n|                                            |      |                |                   | elements in ymm0 and put result in ymm0.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nVFMADDSUB132PD: Multiplies the two or four packed double-precision floating-point\nvalues from the first source operand to the two or four packed double-precision\nfloating-point values in the third source operand. From the infinite precision\nintermediate result, adds the odd double-precision floating-point elements and\nsubtracts the even double-precision floating-point values in the second source\noperand, performs rounding and stores the resulting two or four packed double-precision\nfloating-point values to the destination operand (first source operand). VFMADDSUB213PD:\nMultiplies the two or four packed double-precision floating-point values from\nthe second source operand to the two or four packed double-precision floating-point\nvalues in the first source operand. From the infinite precision intermediate\nresult, adds the odd double-precision floating-point elements and subtracts\nthe even double-precision floating-point values in the third source operand,\nperforms rounding and stores the resulting two or four packed double-precision\nfloating-point values to the destination operand (first source operand). VFMADDSUB231PD:\nMultiplies the two or four packed double-precision floating-point values from\nthe second source operand to the two or four packed double-precision floating-point\nvalues in the third source operand. From the infinite precision intermediate\nresult, adds the odd double-precision floating-point elements and subtracts\nthe even double-precision floating-point values in the first source operand,\nperforms rounding and stores the resulting two or four packed double-precision\nfloating-point values to the destination operand (first source operand). VEX.128\nencoded version: The destination operand (also first source operand) is a XMM\nregister and encoded in reg_field. The second source operand is a XMM register\nand encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit\nmemory location and encoded in rm_field. The upper 128 bits of the YMM destination\nregister are zeroed.\n\nVEX.256 encoded version: The destination operand (also first source operand)\nis a YMM register and encoded in reg_field. The second source operand is a YMM\nregister and encoded in VEX.vvvv. The third source operand is a YMM register\nor a 256-bit memory location and encoded in rm_field.\n\nCompiler tools may optionally support a complementary mnemonic for each instruction\nmnemonic listed in the opcode/instruction column of the summary table. The behavior\nof the complementary mnemonic in situations involving NANs are governed by the\ndefinition of the instruction mnemonic defined in the opcode/instruction column.\nSee also Section 14.5.1, \u201cFMA Instruction Operand Order and Arithmetic Behavior\u201d\nin the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFMADDSUB132PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  DEST[63:0] <- RoundFPControl_MXCSR(DEST[63:0]*SRC3[63:0] - SRC2[63:0])\n  DEST[127:64] <- RoundFPControl_MXCSR(DEST[127:64]*SRC3[127:64] + SRC2[127:64])\n  DEST[VLMAX-1:128] <- 0\nELSEIF (VEX.256)\n  DEST[63:0] <- RoundFPControl_MXCSR(DEST[63:0]*SRC3[63:0] - SRC2[63:0])\n  DEST[127:64] <- RoundFPControl_MXCSR(DEST[127:64]*SRC3[127:64] + SRC2[127:64])\n  DEST[191:128] <- RoundFPControl_MXCSR(DEST[191:128]*SRC3[191:128] - SRC2[191:128])\n  DEST[255:192] <- RoundFPControl_MXCSR(DEST[255:192]*SRC3[255:192] + SRC2[255:192]\nFI\nVFMADDSUB213PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  DEST[63:0] <- RoundFPControl_MXCSR(SRC2[63:0]*DEST[63:0] - SRC3[63:0])\n  DEST[127:64] <- RoundFPControl_MXCSR(SRC2[127:64]*DEST[127:64] + SRC3[127:64])\n  DEST[VLMAX-1:128] <- 0\nELSEIF (VEX.256)\n  DEST[63:0] <- RoundFPControl_MXCSR(SRC2[63:0]*DEST[63:0] - SRC3[63:0])\n  DEST[127:64] <- RoundFPControl_MXCSR(SRC2[127:64]*DEST[127:64] + SRC3[127:64])\n  DEST[191:128] <- RoundFPControl_MXCSR(SRC2[191:128]*DEST[191:128] - SRC3[191:128])\n  DEST[255:192] <- RoundFPControl_MXCSR(SRC2[255:192]*DEST[255:192] + SRC3[255:192]\nFI\nVFMADDSUB231PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  DEST[63:0] <- RoundFPControl_MXCSR(SRC2[63:0]*SRC3[63:0] - DEST[63:0])\n  DEST[127:64] <- RoundFPControl_MXCSR(SRC2[127:64]*SRC3[127:64] + DEST[127:64])\n  DEST[VLMAX-1:128] <- 0\nELSEIF (VEX.256)\n  DEST[63:0] <- RoundFPControl_MXCSR(SRC2[63:0]*SRC3[63:0] - DEST[63:0])\n  DEST[127:64] <- RoundFPControl_MXCSR(SRC2[127:64]*SRC3[127:64] + DEST[127:64])\n  DEST[191:128] <- RoundFPControl_MXCSR(SRC2[191:128]*SRC3[191:128] - DEST[191:128])\n  DEST[255:192] <- RoundFPControl_MXCSR(SRC2[255:192]*SRC3[255:192] + DEST[255:192]\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFMADDSUB132PD: __m128d _mm_fmaddsub_pd (__m128d a, __m128d b, __m128d c);\n\nVFMADDSUB213PD: __m128d _mm_fmaddsub_pd (__m128d a, __m128d b, __m128d c);\n\nVFMADDSUB231PD: __m128d _mm_fmaddsub_pd (__m128d a, __m128d b, __m128d c);\n\nVFMADDSUB132PD: __m256d _mm256_fmaddsub_pd (__m256d a, __m256d b, __m256d c);\n\nVFMADDSUB213PD: __m256d _mm256_fmaddsub_pd (__m256d a, __m256d b, __m256d c);\n\nVFMADDSUB231PD: __m256d _mm256_fmaddsub_pd (__m256d a, __m256d b, __m256d c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "VFMADDSUB132PD"
    }, 
    {
      "description": "\nVFMADDSUB132PS/VFMADDSUB213PS/VFMADDSUB231PS  -  Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                         | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.128.66.0F38.W0 96 /r VFMADDSUB132PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                      |      |                |                   | values from xmm0 and xmm2/mem, add/subtract    \n|                                            |      |                |                   | elements in xmm1 and put result in xmm0.       \n| VEX.DDS.128.66.0F38.W0 A6 /r VFMADDSUB213PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                      |      |                |                   | values from xmm0 and xmm1, add/subtract        \n|                                            |      |                |                   | elements in xmm2/mem and put result            \n|                                            |      |                |                   | in xmm0.                                       \n| VEX.DDS.128.66.0F38.W0 B6 /r VFMADDSUB231PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                      |      |                |                   | values from xmm1 and xmm2/mem, add/subtract    \n|                                            |      |                |                   | elements in xmm0 and put result in xmm0.       \n| VEX.DDS.256.66.0F38.W0 96 /r VFMADDSUB132PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                      |      |                |                   | values from ymm0 and ymm2/mem, add/subtract    \n|                                            |      |                |                   | elements in ymm1 and put result in ymm0.       \n| VEX.DDS.256.66.0F38.W0 A6 /r VFMADDSUB213PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                      |      |                |                   | values from ymm0 and ymm1, add/subtract        \n|                                            |      |                |                   | elements in ymm2/mem and put result            \n|                                            |      |                |                   | in ymm0.                                       \n| VEX.DDS.256.66.0F38.W0 B6 /r VFMADDSUB231PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                      |      |                |                   | values from ymm1 and ymm2/mem, add/subtract    \n|                                            |      |                |                   | elements in ymm0 and put result in ymm0.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nVFMADDSUB132PS: Multiplies the four or eight packed single-precision floating-point\nvalues from the first source operand to the four or eight packed single-precision\nfloating-point values in the third source operand. From the infinite precision\nintermediate result, adds the odd single-precision floating-point elements and\nsubtracts the even single-precision floating-point values in the second source\noperand, performs rounding and stores the resulting four or eight packed single-precision\nfloating-point values to the destination operand (first source operand). VFMADDSUB213PS:\nMultiplies the four or eight packed single-precision floating-point values from\nthe second source operand to the four or eight packed single-precision floating-point\nvalues in the first source operand. From the infinite precision intermediate\nresult, adds the odd single-precision floating-point elements and subtracts\nthe even single-precision floating-point values in the third source operand,\nperforms rounding and stores the resulting four or eight packed single-precision\nfloating-point values to the destination operand (first source operand). VFMADDSUB231PS:\nMultiplies the four or eight packed single-precision floating-point values from\nthe second source operand to the four or eight packed single-precision floating-point\nvalues in the third source operand. From the infinite precision intermediate\nresult, adds the odd single-precision floating-point elements and subtracts\nthe even single-precision floating-point values in the first source operand,\nperforms rounding and stores the resulting four or eight packed single-precision\nfloating-point values to the destination operand (first source operand). VEX.128\nencoded version: The destination operand (also first source operand) is a XMM\nregister and encoded in reg_field. The second source operand is a XMM register\nand encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit\nmemory location and encoded in rm_field. The upper 128 bits of the YMM destination\nregister are zeroed.\n\nVEX.256 encoded version: The destination operand (also first source operand)\nis a YMM register and encoded in reg_field. The second source operand is a YMM\nregister and encoded in VEX.vvvv. The third source operand is a YMM register\nor a 256-bit memory location and encoded in rm_field.\n\nCompiler tools may optionally support a complementary mnemonic for each instruction\nmnemonic listed in the opcode/instruction column of the summary table. The behavior\nof the complementary mnemonic in situations involving NANs are governed by the\ndefinition of the instruction mnemonic defined in the opcode/instruction column.\nSee also Section 14.5.1, \u201cFMA Instruction Operand Order and Arithmetic Behavior\u201d\nin the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFMADDSUB132PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL -1{\n  n = 64*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(DEST[n+31:n]*SRC3[n+31:n] - SRC2[n+31:n])\n  DEST[n+63:n+32] <- RoundFPControl_MXCSR(DEST[n+63:n+32]*SRC3[n+63:n+32] + SRC2[n+63:n+32])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\nVFMADDSUB213PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL -1{\n  n = 64*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(SRC2[n+31:n]*DEST[n+31:n] - SRC3[n+31:n])\n  DEST[n+63:n+32] <- RoundFPControl_MXCSR(SRC2[n+63:n+32]*DEST[n+63:n+32] + SRC3[n+63:n+32])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\nVFMADDSUB231PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL -1{\n  n = 64*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(SRC2[n+31:n]*SRC3[n+31:n] - DEST[n+31:n])\n  DEST[n+63:n+32] <- RoundFPControl_MXCSR(SRC2[n+63:n+32]*SRC3[n+63:n+32] + DEST[n+63:n+32])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFMADDSUB132PS: __m128 _mm_fmaddsub_ps (__m128 a, __m128 b, __m128 c);\n\nVFMADDSUB213PS: __m128 _mm_fmaddsub_ps (__m128 a, __m128 b, __m128 c);\n\nVFMADDSUB231PS: __m128 _mm_fmaddsub_ps (__m128 a, __m128 b, __m128 c);\n\nVFMADDSUB132PS: __m256 _mm256_fmaddsub_ps (__m256 a, __m256 b, __m256 c);\n\nVFMADDSUB213PS: __m256 _mm256_fmaddsub_ps (__m256 a, __m256 b, __m256 c);\n\nVFMADDSUB231PS: __m256 _mm256_fmaddsub_ps (__m256 a, __m256 b, __m256 c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "VFMADDSUB132PS"
    }, 
    {
      "description": "-R:VFMADDSUB132PD", 
      "mnem": "VFMADDSUB213PD"
    }, 
    {
      "description": "-R:VFMADDSUB132PS", 
      "mnem": "VFMADDSUB213PS"
    }, 
    {
      "description": "-R:VFMADDSUB132PD", 
      "mnem": "VFMADDSUB231PD"
    }, 
    {
      "description": "-R:VFMADDSUB132PS", 
      "mnem": "VFMADDSUB231PS"
    }, 
    {
      "description": "\nVFMSUB132PD/VFMSUB213PD/VFMSUB231PD  -  Fused Multiply-Subtract of Packed DoublePrecision Floating-Point Values:\n| Opcode/Instruction                      | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.128.66.0F38.W1 9A /r VFMSUB132PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                   |      |                |                   | values from xmm0 and xmm2/mem, subtract        \n|                                         |      |                |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.128.66.0F38.W1 AA /r VFMSUB213PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                   |      |                |                   | values from xmm0 and xmm1, subtract            \n|                                         |      |                |                   | xmm2/mem and put result in xmm0.               \n| VEX.DDS.128.66.0F38.W1 BA /r VFMSUB231PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                   |      |                |                   | values from xmm1 and xmm2/mem, subtract        \n|                                         |      |                |                   | xmm0 and put result in xmm0.                   \n| VEX.DDS.256.66.0F38.W1 9A /r VFMSUB132PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                   |      |                |                   | values from ymm0 and ymm2/mem, subtract        \n|                                         |      |                |                   | ymm1 and put result in ymm0.                   \n| VEX.DDS.256.66.0F38.W1 AA /r VFMSUB213PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                   |      |                |                   | values from ymm0 and ymm1, subtract            \n|                                         |      |                |                   | ymm2/mem and put result in ymm0.               \n| VEX.DDS.256.66.0F38.W1 BA /r VFMSUB231PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                   |      |                |                   | values from ymm1 and ymm2/mem, subtract        \n|                                         |      |                |                   | ymm0 and put result in ymm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a set of SIMD multiply-subtract computation on packed double-precision\nfloating-point values using three source operands and writes the multiply-subtract\nresults in the destination operand. The destination operand is also the first\nsource operand. The second operand must be a SIMD register. The third source\noperand can be a SIMD register or a memory location. VFMSUB132PD: Multiplies\nthe two or four packed double-precision floating-point values from the first\nsource operand to the two or four packed double-precision floating-point values\nin the third source operand. From the infinite precision intermediate result,\nsubtracts the two or four packed double-precision floating-point values in the\nsecond source operand, performs rounding and stores the resulting two or four\npacked double-precision floatingpoint values to the destination operand (first\nsource operand). VFMSUB213PD: Multiplies the two or four packed double-precision\nfloating-point values from the second source operand to the two or four packed\ndouble-precision floating-point values in the first source operand. From the\ninfinite precision intermediate result, subtracts the two or four packed double-precision\nfloating-point values in the third source operand, performs rounding and stores\nthe resulting two or four packed double-precision floatingpoint values to the\ndestination operand (first source operand). VFMSUB231PD: Multiplies the two\nor four packed double-precision floating-point values from the second source\nto the two or four packed double-precision floating-point values in the third\nsource operand. From the infinite precision intermediate result, subtracts the\ntwo or four packed double-precision floating-point values in the first source\noperand, performs rounding and stores the resulting two or four packed double-precision\nfloating-point values to the destination operand (first source operand).\n\nVEX.128 encoded version: The destination operand (also first source operand)\nis a XMM register and encoded in reg_field. The second source operand is a XMM\nregister and encoded in VEX.vvvv. The third source operand is a XMM register\nor a 128-bit memory location and encoded in rm_field. The upper 128 bits of\nthe YMM destination register are zeroed.\n\nVEX.256 encoded version: The destination operand (also first source operand)\nis a YMM register and encoded in reg_field. The second source operand is a YMM\nregister and encoded in VEX.vvvv. The third source operand is a YMM register\nor a 256-bit memory location and encoded in rm_field. Compiler tools may optionally\nsupport a complementary mnemonic for each instruction mnemonic listed in the\nopcode/instruction column of the summary table. The behavior of the complementary\nmnemonic in situations involving NANs are governed by the definition of the\ninstruction mnemonic defined in the opcode/instruction column. See also Section\n14.5.1, \u201cFMA Instruction Operand Order and Arithmetic Behavior\u201d in the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFMSUB132PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL-1 {\n  n = 64*i;\n  DEST[n+63:n] <- RoundFPControl_MXCSR(DEST[n+63:n]*SRC3[n+63:n] - SRC2[n+63:n])\n}\nIF (VEX.128) THEN\nDEST[VLMAX-1:128] <- 0\nFI\nVFMSUB213PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL-1 {\n  n = 64*i;\n  DEST[n+63:n] <- RoundFPControl_MXCSR(SRC2[n+63:n]*DEST[n+63:n] - SRC3[n+63:n])\n}\nIF (VEX.128) THEN\nDEST[VLMAX-1:128] <- 0\nFI\nVFMSUB231PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL-1 {\n  n = 64*i;\n  DEST[n+63:n] <- RoundFPControl_MXCSR(SRC2[n+63:n]*SRC3[n+63:n] - DEST[n+63:n])\n}\nIF (VEX.128) THEN\nDEST[VLMAX-1:128] <- 0\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFMSUB132PD: __m128d _mm_fmsub_pd (__m128d a, __m128d b, __m128d c);\n\nVFMSUB213PD: __m128d _mm_fmsub_pd (__m128d a, __m128d b, __m128d c);\n\nVFMSUB231PD: __m128d _mm_fmsub_pd (__m128d a, __m128d b, __m128d c);\n\nVFMSUB132PD: __m256d _mm256_fmsub_pd (__m256d a, __m256d b, __m256d c);\n\nVFMSUB213PD: __m256d _mm256_fmsub_pd (__m256d a, __m256d b, __m256d c);\n\nVFMSUB231PD: __m256d _mm256_fmsub_pd (__m256d a, __m256d b, __m256d c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "VFMSUB132PD"
    }, 
    {
      "description": "\nVFMSUB132PS/VFMSUB213PS/VFMSUB231PS  -  Fused Multiply-Subtract of Packed SinglePrecision Floating-Point Values:\n| Opcode/Instruction                      | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.128.66.0F38.W0 9A /r VFMSUB132PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                   |      |                |                   | values from xmm0 and xmm2/mem, subtract        \n|                                         |      |                |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.128.66.0F38.W0 AA /r VFMSUB213PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                   |      |                |                   | values from xmm0 and xmm1, subtract            \n|                                         |      |                |                   | xmm2/mem and put result in xmm0.               \n| VEX.DDS.128.66.0F38.W0 BA /r VFMSUB231PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                   |      |                |                   | values from xmm1 and xmm2/mem, subtract        \n|                                         |      |                |                   | xmm0 and put result in xmm0.                   \n| VEX.DDS.256.66.0F38.W0 9A /r VFMSUB132PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                   |      |                |                   | values from ymm0 and ymm2/mem, subtract        \n|                                         |      |                |                   | ymm1 and put result in ymm0.                   \n| VEX.DDS.256.66.0F38.W0 AA /r VFMSUB213PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                   |      |                |                   | values from ymm0 and ymm1, subtract            \n|                                         |      |                |                   | ymm2/mem and put result in ymm0.               \n| VEX.DDS.256.66.0F38.0 BA /r VFMSUB231PS | A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                   |      |                |                   | values from ymm1 and ymm2/mem, subtract        \n|                                         |      |                |                   | ymm0 and put result in ymm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a set of SIMD multiply-subtract computation on packed single-precision\nfloating-point values using three source operands and writes the multiply-subtract\nresults in the destination operand. The destination operand is also the first\nsource operand. The second operand must be a SIMD register. The third source\noperand can be a SIMD register or a memory location. VFMSUB132PS: Multiplies\nthe four or eight packed single-precision floating-point values from the first\nsource operand to the four or eight packed single-precision floating-point values\nin the third source operand. From the infinite precision intermediate result,\nsubtracts the four or eight packed single-precision floating-point values in\nthe second source operand, performs rounding and stores the resulting four or\neight packed single-precision floatingpoint values to the destination operand\n(first source operand). VFMSUB213PS: Multiplies the four or eight packed single-precision\nfloating-point values from the second source operand to the four or eight packed\nsingle-precision floating-point values in the first source operand. From the\ninfinite precision intermediate result, subtracts the four or eight packed single-precision\nfloating-point values in the third source operand, performs rounding and stores\nthe resulting four or eight packed single-precision floatingpoint values to\nthe destination operand (first source operand). VFMSUB231PS: Multiplies the\nfour or eight packed single-precision floating-point values from the second\nsource to the four or eight packed single-precision floating-point values in\nthe third source operand. From the infinite precision intermediate result, subtracts\nthe four or eight packed single-precision floating-point values in the first\nsource operand, performs rounding and stores the resulting four or eight packed\nsingle-precision floating-point values to the destination operand (first source\noperand). VEX.128 encoded version: The destination operand (also first source\noperand) is a XMM register and encoded in reg_field. The second source operand\nis a XMM register and encoded in VEX.vvvv. The third source operand is a XMM\nregister or a 128-bit memory location and encoded in rm_field. The upper 128\nbits of the YMM destination register are zeroed.\n\nVEX.256 encoded version: The destination operand (also first source operand)\nis a YMM register and encoded in reg_field. The second source operand is a YMM\nregister and encoded in VEX.vvvv. The third source operand is a YMM register\nor a 256-bit memory location and encoded in rm_field. Compiler tools may optionally\nsupport a complementary mnemonic for each instruction mnemonic listed in the\nopcode/instruction column of the summary table. The behavior of the complementary\nmnemonic in situations involving NANs are governed by the definition of the\ninstruction mnemonic defined in the opcode/instruction column. See also Section\n14.5.1, \u201cFMA Instruction Operand Order and Arithmetic Behavior\u201d in the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFMSUB132PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =4\nELSEIF (VEX.256)\n  MAXVL = 8\nFI\nFor i = 0 to MAXVL-1 {\n  n = 32*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(DEST[n+31:n]*SRC3[n+31:n] - SRC2[n+31:n])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\nVFMSUB213PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =4\nELSEIF (VEX.256)\n  MAXVL = 8\nFI\nFor i = 0 to MAXVL-1 {\n  n = 32*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(SRC2[n+31:n]*DEST[n+31:n] - SRC3[n+31:n])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\nVFMSUB231PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =4\nELSEIF (VEX.256)\n  MAXVL = 8\nFI\nFor i = 0 to MAXVL-1 {\n  n = 32*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(SRC2[n+31:n]*SRC3[n+31:n] - DEST[n+31:n])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFMSUB132PS: __m128 _mm_fmsub_ps (__m128 a, __m128 b, __m128 c);\n\nVFMSUB213PS: __m128 _mm_fmsub_ps (__m128 a, __m128 b, __m128 c);\n\nVFMSUB231PS: __m128 _mm_fmsub_ps (__m128 a, __m128 b, __m128 c);\n\nVFMSUB132PS: __m256 _mm256_fmsub_ps (__m256 a, __m256 b, __m256 c);\n\nVFMSUB213PS: __m256 _mm256_fmsub_ps (__m256 a, __m256 b, __m256 c);\n\nVFMSUB231PS: __m256 _mm256_fmsub_ps (__m256 a, __m256 b, __m256 c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "VFMSUB132PS"
    }, 
    {
      "description": "\nVFMSUB132SD/VFMSUB213SD/VFMSUB231SD  -  Fused Multiply-Subtract of Scalar DoublePrecision Floating-Point Values:\n| Opcode/Instruction                          | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.LIG.128.66.0F38.W1 9B /r VFMSUB132SD| A    | V/V            | FMA               | Multiply scalar double-precision floating-point\n| xmm0, xmm1, xmm2/m64                        |      |                |                   | value from xmm0 and xmm2/mem, subtract         \n|                                             |      |                |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.LIG.128.66.0F38.W1 AB /r VFMSUB213SD| A    | V/V            | FMA               | Multiply scalar double-precision floating-point\n| xmm0, xmm1, xmm2/m64                        |      |                |                   | value from xmm0 and xmm1, subtract xmm2/mem    \n|                                             |      |                |                   | and put result in xmm0.                        \n| VEX.DDS.LIG.128.66.0F38.W1 BB /r VFMSUB231SD| A    | V/V            | FMA               | Multiply scalar double-precision floating-point\n| xmm0, xmm1, xmm2/m64                        |      |                |                   | value from xmm1 and xmm2/mem, subtract         \n|                                             |      |                |                   | xmm0 and put result in xmm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD multiply-subtract computation on the low packed double-precision\nfloating-point values using three source operands and writes the multiply-add\nresult in the destination operand. The destination operand is also the first\nsource operand. The second operand must be a SIMD register. The third source\noperand can be a SIMD register or a memory location. VFMSUB132SD: Multiplies\nthe low packed double-precision floating-point value from the first source operand\nto the low packed double-precision floating-point value in the third source\noperand. From the infinite precision intermediate result, subtracts the low\npacked double-precision floating-point values in the second source operand,\nperforms rounding and stores the resulting packed double-precision floating-point\nvalue to the destination operand (first source operand). VFMSUB213SD: Multiplies\nthe low packed double-precision floating-point value from the second source\noperand to the low packed double-precision floating-point value in the first\nsource operand. From the infinite precision intermediate result, subtracts the\nlow packed double-precision floating-point value in the third source operand,\nperforms rounding and stores the resulting packed double-precision floating-point\nvalue to the destination operand (first source operand). VFMSUB231SD: Multiplies\nthe low packed double-precision floating-point value from the second source\nto the low packed double-precision floating-point value in the third source\noperand. From the infinite precision intermediate result, subtracts the low\npacked double-precision floating-point value in the first source operand, performs\nrounding and stores the resulting packed double-precision floating-point value\nto the destination operand (first source operand). VEX.128 encoded version:\nThe destination operand (also first source operand) is a XMM register and encoded\nin reg_field. The second source operand is a XMM register and encoded in VEX.vvvv.\nThe third source operand is a XMM register or a 64-bit memory location and encoded\nin rm_field. The upper bits ([VLMAX-1:128]) of the YMM destination register\nare zeroed. Compiler tools may optionally support a complementary mnemonic for\neach instruction mnemonic listed in the opcode/instruction column of the summary\ntable. The behavior of the complementary mnemonic in situations involving NANs\nare governed by the definition of the instruction mnemonic defined in the opcode/instruction\ncolumn. See also Section 14.5.1, \u201cFMA Instruction Operand Order and Arithmetic\nBehavior\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFMSUB132SD DEST, SRC2, SRC3\nDEST[63:0] <- RoundFPControl_MXCSR(DEST[63:0]*SRC3[63:0] - SRC2[63:0])\nDEST[127:64] <- DEST[127:64]\nDEST[VLMAX-1:128] <- 0\nVFMSUB213SD DEST, SRC2, SRC3\nDEST[63:0] <- RoundFPControl_MXCSR(SRC2[63:0]*DEST[63:0] - SRC3[63:0])\nDEST[127:64] <- DEST[127:64]\nDEST[VLMAX-1:128] <- 0\nVFMSUB231SD DEST, SRC2, SRC3\nDEST[63:0] <- RoundFPControl_MXCSR(SRC2[63:0]*SRC3[63:0] - DEST[63:0])\nDEST[127:64] <- DEST[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFMSUB132SD: __m128d _mm_fmsub_sd (__m128d a, __m128d b, __m128d c);\n\nVFMSUB213SD: __m128d _mm_fmsub_sd (__m128d a, __m128d b, __m128d c);\n\nVFMSUB231SD: __m128d _mm_fmsub_sd (__m128d a, __m128d b, __m128d c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 3\n\n", 
      "mnem": "VFMSUB132SD"
    }, 
    {
      "description": "\nVFMSUB132SS/VFMSUB213SS/VFMSUB231SS  -  Fused Multiply-Subtract of Scalar SinglePrecision Floating-Point Values:\n| Opcode/Instruction                          | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.LIG.128.66.0F38.W0 9B /r VFMSUB132SS| A    | V/V            | FMA               | Multiply scalar single-precision floating-point\n| xmm0, xmm1, xmm2/m32                        |      |                |                   | value from xmm0 and xmm2/mem, subtract         \n|                                             |      |                |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.LIG.128.66.0F38.W0 AB /r VFMSUB213SS| A    | V/V            | FMA               | Multiply scalar single-precision floating-point\n| xmm0, xmm1, xmm2/m32                        |      |                |                   | value from xmm0 and xmm1, subtract xmm2/mem    \n|                                             |      |                |                   | and put result in xmm0.                        \n| VEX.DDS.LIG.128.66.0F38.W0 BB /r VFMSUB231SS| A    | V/V            | FMA               | Multiply scalar single-precision floating-point\n| xmm0, xmm1, xmm2/m32                        |      |                |                   | value from xmm1 and xmm2/mem, subtract         \n|                                             |      |                |                   | xmm0 and put result in xmm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a SIMD multiply-subtract computation on the low packed single-precision\nfloating-point values using three source operands and writes the multiply-add\nresult in the destination operand. The destination operand is also the first\nsource operand. The second operand must be a SIMD register. The third source\noperand can be a SIMD register or a memory location. VFMSUB132SS: Multiplies\nthe low packed single-precision floating-point value from the first source operand\nto the low packed single-precision floating-point value in the third source\noperand. From the infinite precision intermediate result, subtracts the low\npacked single-precision floating-point values in the second source operand,\nperforms rounding and stores the resulting packed single-precision floating-point\nvalue to the destination operand (first source operand). VFMSUB213SS: Multiplies\nthe low packed single-precision floating-point value from the second source\noperand to the low packed single-precision floating-point value in the first\nsource operand. From the infinite precision intermediate result, subtracts the\nlow packed single-precision floating-point value in the third source operand,\nperforms rounding and stores the resulting packed single-precision floating-point\nvalue to the destination operand (first source operand). VFMSUB231SS: Multiplies\nthe low packed single-precision floating-point value from the second source\nto the low packed single-precision floating-point value in the third source\noperand. From the infinite precision intermediate result, subtracts the low\npacked single-precision floating-point value in the first source operand, performs\nrounding and stores the resulting packed single-precision floating-point value\nto the destination operand (first source operand). VEX.128 encoded version:\nThe destination operand (also first source operand) is a XMM register and encoded\nin reg_field. The second source operand is a XMM register and encoded in VEX.vvvv.\nThe third source operand is a XMM register or a 32-bit memory location and encoded\nin rm_field. The upper bits ([VLMAX-1:128]) of the YMM destination register\nare zeroed. Compiler tools may optionally support a complementary mnemonic for\neach instruction mnemonic listed in the opcode/instruction column of the summary\ntable. The behavior of the complementary mnemonic in situations involving NANs\nare governed by the definition of the instruction mnemonic defined in the opcode/instruction\ncolumn. See also Section 14.5.1, \u201cFMA Instruction Operand Order and Arithmetic\nBehavior\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFMSUB132SS DEST, SRC2, SRC3\nDEST[31:0] <- RoundFPControl_MXCSR(DEST[31:0]*SRC3[31:0] - SRC2[31:0])\nDEST[127:32] <- DEST[127:32]\nDEST[VLMAX-1:128] <- 0\nVFMSUB213SS DEST, SRC2, SRC3\nDEST[31:0] <- RoundFPControl_MXCSR(SRC2[31:0]*DEST[31:0] - SRC3[31:0])\nDEST[127:32] <- DEST[127:32]\nDEST[VLMAX-1:128] <- 0\nVFMSUB231SS DEST, SRC2, SRC3\nDEST[31:0] <- RoundFPControl_MXCSR(SRC2[31:0]*SRC3[63:0] - DEST[31:0])\nDEST[127:32] <- DEST[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFMSUB132SS: __m128 _mm_fmsub_ss (__m128 a, __m128 b, __m128 c);\n\nVFMSUB213SS: __m128 _mm_fmsub_ss (__m128 a, __m128 b, __m128 c);\n\nVFMSUB231SS: __m128 _mm_fmsub_ss (__m128 a, __m128 b, __m128 c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 3\n\n", 
      "mnem": "VFMSUB132SS"
    }, 
    {
      "description": "-R:VFMSUB132PD", 
      "mnem": "VFMSUB213PD"
    }, 
    {
      "description": "-R:VFMSUB132PS", 
      "mnem": "VFMSUB213PS"
    }, 
    {
      "description": "-R:VFMSUB132SD", 
      "mnem": "VFMSUB213SD"
    }, 
    {
      "description": "-R:VFMSUB132SS", 
      "mnem": "VFMSUB213SS"
    }, 
    {
      "description": "-R:VFMSUB132PD", 
      "mnem": "VFMSUB231PD"
    }, 
    {
      "description": "-R:VFMSUB132PS", 
      "mnem": "VFMSUB231PS"
    }, 
    {
      "description": "-R:VFMSUB132SD", 
      "mnem": "VFMSUB231SD"
    }, 
    {
      "description": "-R:VFMSUB132SS", 
      "mnem": "VFMSUB231SS"
    }, 
    {
      "description": "\nVFMSUBADD132PD/VFMSUBADD213PD/VFMSUBADD231PD  -  Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                         | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.128.66.0F38.W1 97 /r VFMSUBADD132PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                      |      |                |                   | values from xmm0 and xmm2/mem, subtract/add    \n|                                            |      |                |                   | elements in xmm1 and put result in xmm0.       \n| VEX.DDS.128.66.0F38.W1 A7 /r VFMSUBADD213PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                      |      |                |                   | values from xmm0 and xmm1, subtract/add        \n|                                            |      |                |                   | elements in xmm2/mem and put result            \n|                                            |      |                |                   | in xmm0.                                       \n| VEX.DDS.128.66.0F38.W1 B7 /r VFMSUBADD231PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                      |      |                |                   | values from xmm1 and xmm2/mem, subtract/add    \n|                                            |      |                |                   | elements in xmm0 and put result in xmm0.       \n| VEX.DDS.256.66.0F38.W1 97 /r VFMSUBADD132PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                      |      |                |                   | values from ymm0 and ymm2/mem, subtract/add    \n|                                            |      |                |                   | elements in ymm1 and put result in ymm0.       \n| VEX.DDS.256.66.0F38.W1 A7 /r VFMSUBADD213PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                      |      |                |                   | values from ymm0 and ymm1, subtract/add        \n|                                            |      |                |                   | elements in ymm2/mem and put result            \n|                                            |      |                |                   | in ymm0.                                       \n| VEX.DDS.256.66.0F38.W1 B7 /r VFMSUBADD231PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                      |      |                |                   | values from ymm1 and ymm2/mem, subtract/add    \n|                                            |      |                |                   | elements in ymm0 and put result in ymm0.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nVFMSUBADD132PD: Multiplies the two or four packed double-precision floating-point\nvalues from the first source operand to the two or four packed double-precision\nfloating-point values in the third source operand. From the infinite precision\nintermediate result, subtracts the odd double-precision floating-point elements\nand adds the even double-precision floating-point values in the second source\noperand, performs rounding and stores the resulting two or four packed double-precision\nfloating-point values to the destination operand (first source operand). VFMSUBADD213PD:\nMultiplies the two or four packed double-precision floating-point values from\nthe second source operand to the two or four packed double-precision floating-point\nvalues in the first source operand. From the infinite precision intermediate\nresult, subtracts the odd double-precision floating-point elements and adds\nthe even double-precision floating-point values in the third source operand,\nperforms rounding and stores the resulting two or four packed double-precision\nfloating-point values to the destination operand (first source operand). VFMSUBADD231PD:\nMultiplies the two or four packed double-precision floating-point values from\nthe second source operand to the two or four packed double-precision floating-point\nvalues in the third source operand. From the infinite precision intermediate\nresult, subtracts the odd double-precision floating-point elements and adds\nthe even double-precision floating-point values in the first source operand,\nperforms rounding and stores the resulting two or four packed double-precision\nfloating-point values to the destination operand (first source operand). VEX.128\nencoded version: The destination operand (also first source operand) is a XMM\nregister and encoded in reg_field. The second source operand is a XMM register\nand encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit\nmemory location and encoded in rm_field. The upper 128 bits of the YMM destination\nregister are zeroed.\n\nVEX.256 encoded version: The destination operand (also first source operand)\nis a YMM register and encoded in reg_field. The second source operand is a YMM\nregister and encoded in VEX.vvvv. The third source operand is a YMM register\nor a 256-bit memory location and encoded in rm_field.\n\nCompiler tools may optionally support a complementary mnemonic for each instruction\nmnemonic listed in the opcode/instruction column of the summary table. The behavior\nof the complementary mnemonic in situations involving NANs are governed by the\ndefinition of the instruction mnemonic defined in the opcode/instruction column.\nSee also Section 14.5.1, \u201cFMA Instruction Operand Order and Arithmetic Behavior\u201d\nin the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFMSUBADD132PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  DEST[63:0] <- RoundFPControl_MXCSR(DEST[63:0]*SRC3[63:0] + SRC2[63:0])\n  DEST[127:64] <- RoundFPControl_MXCSR(DEST[127:64]*SRC3[127:64] - SRC2[127:64])\n  DEST[VLMAX-1:128] <- 0\nELSEIF (VEX.256)\n  DEST[63:0] <- RoundFPControl_MXCSR(DEST[63:0]*SRC3[63:0] + SRC2[63:0])\n  DEST[127:64] <- RoundFPControl_MXCSR(DEST[127:64]*SRC3[127:64] - SRC2[127:64])\n  DEST[191:128] <- RoundFPControl_MXCSR(DEST[191:128]*SRC3[191:128] + SRC2[191:128])\n  DEST[255:192] <- RoundFPControl_MXCSR(DEST[255:192]*SRC3[255:192] - SRC2[255:192]\nFI\nVFMSUBADD213PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  DEST[63:0] <- RoundFPControl_MXCSR(SRC2[63:0]*DEST[63:0] + SRC3[63:0])\n  DEST[127:64] <- RoundFPControl_MXCSR(SRC2[127:64]*DEST[127:64] - SRC3[127:64])\n  DEST[VLMAX-1:128] <- 0\nELSEIF (VEX.256)\n  DEST[63:0] <- RoundFPControl_MXCSR(SRC2[63:0]*DEST[63:0] + SRC3[63:0])\n  DEST[127:64] <- RoundFPControl_MXCSR(SRC2[127:64]*DEST[127:64] - SRC3[127:64])\n  DEST[191:128] <- RoundFPControl_MXCSR(SRC2[191:128]*DEST[191:128] + SRC3[191:128])\n  DEST[255:192] <- RoundFPControl_MXCSR(SRC2[255:192]*DEST[255:192] - SRC3[255:192]\nFI\nVFMSUBADD231PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  DEST[63:0] <- RoundFPControl_MXCSR(SRC2[63:0]*SRC3[63:0] + DEST[63:0])\n  DEST[127:64] <- RoundFPControl_MXCSR(SRC2[127:64]*SRC3[127:64] - DEST[127:64])\n  DEST[VLMAX-1:128] <- 0\nELSEIF (VEX.256)\n  DEST[63:0] <- RoundFPControl_MXCSR(SRC2[63:0]*SRC3[63:0] + DEST[63:0])\n  DEST[127:64] <- RoundFPControl_MXCSR(SRC2[127:64]*SRC3[127:64] - DEST[127:64])\n  DEST[191:128] <- RoundFPControl_MXCSR(SRC2[191:128]*SRC3[191:128] + DEST[191:128])\n  DEST[255:192] <- RoundFPControl_MXCSR(SRC2[255:192]*SRC3[255:192] - DEST[255:192]\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFMSUBADD132PD: __m128d _mm_fmsubadd_pd (__m128d a, __m128d b, __m128d c);\n\nVFMSUBADD213PD: __m128d _mm_fmsubadd_pd (__m128d a, __m128d b, __m128d c);\n\nVFMSUBADD231PD: __m128d _mm_fmsubadd_pd (__m128d a, __m128d b, __m128d c);\n\nVFMSUBADD132PD: __m256d _mm256_fmsubadd_pd (__m256d a, __m256d b, __m256d c);\n\nVFMSUBADD213PD: __m256d _mm256_fmsubadd_pd (__m256d a, __m256d b, __m256d c);\n\nVFMSUBADD231PD: __m256d _mm256_fmsubadd_pd (__m256d a, __m256d b, __m256d c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "VFMSUBADD132PD"
    }, 
    {
      "description": "\nVFMSUBADD132PS/VFMSUBADD213PS/VFMSUBADD231PS  -  Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                         | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.128.66.0F38.W0 97 /r VFMSUBADD132PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                      |      |                |                   | values from xmm0 and xmm2/mem, subtract/add    \n|                                            |      |                |                   | elements in xmm1 and put result in xmm0.       \n| VEX.DDS.128.66.0F38.W0 A7 /r VFMSUBADD213PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                      |      |                |                   | values from xmm0 and xmm1, subtract/add        \n|                                            |      |                |                   | elements in xmm2/mem and put result            \n|                                            |      |                |                   | in xmm0.                                       \n| VEX.DDS.128.66.0F38.W0 B7 /r VFMSUBADD231PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                      |      |                |                   | values from xmm1 and xmm2/mem, subtract/add    \n|                                            |      |                |                   | elements in xmm0 and put result in xmm0.       \n| VEX.DDS.256.66.0F38.W0 97 /r VFMSUBADD132PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                      |      |                |                   | values from ymm0 and ymm2/mem, subtract/add    \n|                                            |      |                |                   | elements in ymm1 and put result in ymm0.       \n| VEX.DDS.256.66.0F38.W0 A7 /r VFMSUBADD213PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                      |      |                |                   | values from ymm0 and ymm1, subtract/add        \n|                                            |      |                |                   | elements in ymm2/mem and put result            \n|                                            |      |                |                   | in ymm0.                                       \n| VEX.DDS.256.66.0F38.W0 B7 /r VFMSUBADD231PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                      |      |                |                   | values from ymm1 and ymm2/mem, subtract/add    \n|                                            |      |                |                   | elements in ymm0 and put result in ymm0.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nVFMSUBADD132PS: Multiplies the four or eight packed single-precision floating-point\nvalues from the first source operand to the four or eight packed single-precision\nfloating-point values in the third source operand. From the infinite precision\nintermediate result, subtracts the odd single-precision floating-point elements\nand adds the even single-precision floating-point values in the second source\noperand, performs rounding and stores the resulting four or eight packed single-precision\nfloating-point values to the destination operand (first source operand). VFMSUBADD213PS:\nMultiplies the four or eight packed single-precision floating-point values from\nthe second source operand to the four or eight packed single-precision floating-point\nvalues in the first source operand. From the infinite precision intermediate\nresult, subtracts the odd single-precision floating-point elements and adds\nthe even single-precision floating-point values in the third source operand,\nperforms rounding and stores the resulting four or eight packed single-precision\nfloating-point values to the destination operand (first source operand). VFMSUBADD231PS:\nMultiplies the four or eight packed single-precision floating-point values from\nthe second source operand to the four or eight packed single-precision floating-point\nvalues in the third source operand. From the infinite precision intermediate\nresult, subtracts the odd single-precision floating-point elements and adds\nthe even single-precision floating-point values in the first source operand,\nperforms rounding and stores the resulting four or eight packed single-precision\nfloating-point values to the destination operand (first source operand). VEX.128\nencoded version: The destination operand (also first source operand) is a XMM\nregister and encoded in reg_field. The second source operand is a XMM register\nand encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit\nmemory location and encoded in rm_field. The upper 128 bits of the YMM destination\nregister are zeroed.\n\nVEX.256 encoded version: The destination operand (also first source operand)\nis a YMM register and encoded in reg_field. The second source operand is a YMM\nregister and encoded in VEX.vvvv. The third source operand is a YMM register\nor a 256-bit memory location and encoded in rm_field.\n\nCompiler tools may optionally support a complementary mnemonic for each instruction\nmnemonic listed in the opcode/instruction column of the summary table. The behavior\nof the complementary mnemonic in situations involving NANs are governed by the\ndefinition of the instruction mnemonic defined in the opcode/instruction column.\nSee also Section 14.5.1, \u201cFMA Instruction Operand Order and Arithmetic Behavior\u201d\nin the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFMSUBADD132PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL -1{\n  n = 64*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(DEST[n+31:n]*SRC3[n+31:n] + SRC2[n+31:n])\n  DEST[n+63:n+32] <- RoundFPControl_MXCSR(DEST[n+63:n+32]*SRC3[n+63:n+32] -SRC2[n+63:n+32])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\nVFMSUBADD213PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL -1{\n  n = 64*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(SRC2[n+31:n]*DEST[n+31:n] +SRC3[n+31:n])\n  DEST[n+63:n+32] <- RoundFPControl_MXCSR(SRC2[n+63:n+32]*DEST[n+63:n+32] -SRC3[n+63:n+32])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\nVFMSUBADD231PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL -1{\n  n = 64*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(SRC2[n+31:n]*SRC3[n+31:n] + DEST[n+31:n])\n  DEST[n+63:n+32] <- RoundFPControl_MXCSR(SRC2[n+63:n+32]*SRC3[n+63:n+32] -DEST[n+63:n+32])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFMSUBADD132PS: __m128 _mm_fmsubadd_ps (__m128 a, __m128 b, __m128 c);\n\nVFMSUBADD213PS: __m128 _mm_fmsubadd_ps (__m128 a, __m128 b, __m128 c);\n\nVFMSUBADD231PS: __m128 _mm_fmsubadd_ps (__m128 a, __m128 b, __m128 c);\n\nVFMSUBADD132PS: __m256 _mm256_fmsubadd_ps (__m256 a, __m256 b, __m256 c);\n\nVFMSUBADD213PS: __m256 _mm256_fmsubadd_ps (__m256 a, __m256 b, __m256 c);\n\nVFMSUBADD231PS: __m256 _mm256_fmsubadd_ps (__m256 a, __m256 b, __m256 c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "VFMSUBADD132PS"
    }, 
    {
      "description": "-R:VFMSUBADD132PD", 
      "mnem": "VFMSUBADD213PD"
    }, 
    {
      "description": "-R:VFMSUBADD132PS", 
      "mnem": "VFMSUBADD213PS"
    }, 
    {
      "description": "-R:VFMSUBADD132PD", 
      "mnem": "VFMSUBADD231PD"
    }, 
    {
      "description": "-R:VFMSUBADD132PS", 
      "mnem": "VFMSUBADD231PS"
    }, 
    {
      "description": "\nVFNMADD132PD/VFNMADD213PD/VFNMADD231PD  -  Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                       | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.128.66.0F38.W1 9C /r VFNMADD132PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                    |      |                |                   | values from xmm0 and xmm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and add to           \n|                                          |      |                |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.128.66.0F38.W1 AC /r VFNMADD213PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                    |      |                |                   | values from xmm0 and xmm1, negate the          \n|                                          |      |                |                   | multiplication result and add to xmm2/mem      \n|                                          |      |                |                   | and put result in xmm0.                        \n| VEX.DDS.128.66.0F38.W1 BC /r VFNMADD231PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                    |      |                |                   | values from xmm1 and xmm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and add to           \n|                                          |      |                |                   | xmm0 and put result in xmm0.                   \n| VEX.DDS.256.66.0F38.W1 9C /r VFNMADD132PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                    |      |                |                   | values from ymm0 and ymm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and add to           \n|                                          |      |                |                   | ymm1 and put result in ymm0.                   \n| VEX.DDS.256.66.0F38.W1 AC /r VFNMADD213PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                    |      |                |                   | values from ymm0 and ymm1, negate the          \n|                                          |      |                |                   | multiplication result and add to ymm2/mem      \n|                                          |      |                |                   | and put result in ymm0.                        \n| VEX.DDS.256.66.0F38.W1 BC /r VFNMADD231PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                    |      |                |                   | values from ymm1 and ymm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and add to           \n|                                          |      |                |                   | ymm0 and put result in ymm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nVFNMADD132PD: Multiplies the two or four packed double-precision floating-point\nvalues from the first source operand to the two or four packed double-precision\nfloating-point values in the third source operand, adds the negated infinite\nprecision intermediate result to the two or four packed double-precision floating-point\nvalues in the second source operand, performs rounding and stores the resulting\ntwo or four packed double-precision floatingpoint values to the destination\noperand (first source operand). VFNMADD213PD: Multiplies the two or four packed\ndouble-precision floating-point values from the second source operand to the\ntwo or four packed double-precision floating-point values in the first source\noperand, adds the negated infinite precision intermediate result to the two\nor four packed double-precision floating-point values in the third source operand,\nperforms rounding and stores the resulting two or four packed double-precision\nfloatingpoint values to the destination operand (first source operand). VFNMADD231PD:\nMultiplies the two or four packed double-precision floating-point values from\nthe second source to the two or four packed double-precision floating-point\nvalues in the third source operand, adds the negated infinite precision intermediate\nresult to the two or four packed double-precision floating-point values in the\nfirst source operand, performs rounding and stores the resulting two or four\npacked double-precision floating-point values to the destination operand (first\nsource operand). VEX.128 encoded version: The destination operand (also first\nsource operand) is a XMM register and encoded in reg_field. The second source\noperand is a XMM register and encoded in VEX.vvvv. The third source operand\nis a\n\nXMM register or a 128-bit memory location and encoded in rm_field. The upper\n128 bits of the YMM destination register are zeroed.\n\nVEX.256 encoded version: The destination operand (also first source operand)\nis a YMM register and encoded in reg_field. The second source operand is a YMM\nregister and encoded in VEX.vvvv. The third source operand is a YMM register\nor a 256-bit memory location and encoded in rm_field. Compiler tools may optionally\nsupport a complementary mnemonic for each instruction mnemonic listed in the\nopcode/instruction column of the summary table. The behavior of the complementary\nmnemonic in situations involving NANs are governed by the definition of the\ninstruction mnemonic defined in the opcode/instruction column. See also Section\n14.5.1, \u201cFMA Instruction Operand Order and Arithmetic Behavior\u201d in the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFNMADD132PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL-1 {\n  n = 64*i;\n  DEST[n+63:n] <- RoundFPControl_MXCSR(-(DEST[n+63:n]*SRC3[n+63:n]) + SRC2[n+63:n])\n}\nIF (VEX.128) THEN\nDEST[VLMAX-1:128] <- 0\nFI\nVFNMADD213PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL-1 {\n  n = 64*i;\n  DEST[n+63:n] <- RoundFPControl_MXCSR(-(SRC2[n+63:n]*DEST[n+63:n]) + SRC3[n+63:n])\n}\nIF (VEX.128) THEN\nDEST[VLMAX-1:128] <- 0\nFI\nVFNMADD231PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL-1 {\n  n = 64*i;\n  DEST[n+63:n] <- RoundFPControl_MXCSR(-(SRC2[n+63:n]*SRC3[n+63:n]) + DEST[n+63:n])\n}\nIF (VEX.128) THEN\nDEST[VLMAX-1:128] <- 0\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFNMADD132PD: __m128d _mm_fnmadd_pd (__m128d a, __m128d b, __m128d c);\n\nVFNMADD213PD: __m128d _mm_fnmadd_pd (__m128d a, __m128d b, __m128d c);\n\nVFNMADD231PD: __m128d _mm_fnmadd_pd (__m128d a, __m128d b, __m128d c);\n\nVFNMADD132PD: __m256d _mm256_fnmadd_pd (__m256d a, __m256d b, __m256d c);\n\nVFNMADD213PD: __m256d _mm256_fnmadd_pd (__m256d a, __m256d b, __m256d c);\n\nVFNMADD231PD: __m256d _mm256_fnmadd_pd (__m256d a, __m256d b, __m256d c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "VFNMADD132PD"
    }, 
    {
      "description": "\nVFNMADD132PS/VFNMADD213PS/VFNMADD231PS  -  Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                       | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.128.66.0F38.W0 9C /r VFNMADD132PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                    |      |                |                   | values from xmm0 and xmm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and add to           \n|                                          |      |                |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.128.66.0F38.W0 AC /r VFNMADD213PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                    |      |                |                   | values from xmm0 and xmm1, negate the          \n|                                          |      |                |                   | multiplication result and add to xmm2/mem      \n|                                          |      |                |                   | and put result in xmm0.                        \n| VEX.DDS.128.66.0F38.W0 BC /r VFNMADD231PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                    |      |                |                   | values from xmm1 and xmm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and add to           \n|                                          |      |                |                   | xmm0 and put result in xmm0.                   \n| VEX.DDS.256.66.0F38.W0 9C /r VFNMADD132PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                    |      |                |                   | values from ymm0 and ymm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and add to           \n|                                          |      |                |                   | ymm1 and put result in ymm0.                   \n| VEX.DDS.256.66.0F38.W0 AC /r VFNMADD213PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                    |      |                |                   | values from ymm0 and ymm1, negate the          \n|                                          |      |                |                   | multiplication result and add to ymm2/mem      \n|                                          |      |                |                   | and put result in ymm0.                        \n| VEX.DDS.256.66.0F38.0 BC /r VFNMADD231PS | A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                    |      |                |                   | values from ymm1 and ymm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and add to           \n|                                          |      |                |                   | ymm0 and put result in ymm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nVFNMADD132PS: Multiplies the four or eight packed single-precision floating-point\nvalues from the first source operand to the four or eight packed single-precision\nfloating-point values in the third source operand, adds the negated infinite\nprecision intermediate result to the four or eight packed single-precision floating-point\nvalues in the second source operand, performs rounding and stores the resulting\nfour or eight packed single-precision floating-point values to the destination\noperand (first source operand). VFNMADD213PS: Multiplies the four or eight packed\nsingle-precision floating-point values from the second source operand to the\nfour or eight packed single-precision floating-point values in the first source\noperand, adds the negated infinite precision intermediate result to the four\nor eight packed single-precision floating-point values in the third source operand,\nperforms rounding and stores the resulting the four or eight packed single-precision\nfloating-point values to the destination operand (first source operand). VFNMADD231PS:\nMultiplies the four or eight packed single-precision floating-point values from\nthe second source operand to the four or eight packed single-precision floating-point\nvalues in the third source operand, adds the negated infinite precision intermediate\nresult to the four or eight packed single-precision floating-point values in\nthe first source operand, performs rounding and stores the resulting four or\neight packed single-precision floatingpoint values to the destination operand\n(first source operand). VEX.256 encoded version: The destination operand (also\nfirst source operand) is a YMM register and encoded in reg_field. The second\nsource operand is a YMM register and encoded in VEX.vvvv. The third source operand\nis a YMM register or a 256-bit memory location and encoded in rm_field.\n\nVEX.128 encoded version: The destination operand (also first source operand)\nis a XMM register and encoded in reg_field. The second source operand is a XMM\nregister and encoded in VEX.vvvv. The third source operand is a XMM register\nor a 128-bit memory location and encoded in rm_field. The upper 128 bits of\nthe YMM destination register are zeroed. Compiler tools may optionally support\na complementary mnemonic for each instruction mnemonic listed in the opcode/instruction\ncolumn of the summary table. The behavior of the complementary mnemonic in situations\ninvolving NANs are governed by the definition of the instruction mnemonic defined\nin the opcode/instruction column. See also Section 14.5.1, \u201cFMA Instruction\nOperand Order and Arithmetic Behavior\u201d in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFNMADD132PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =4\nELSEIF (VEX.256)\n  MAXVL = 8\nFI\nFor i = 0 to MAXVL-1 {\n  n = 32*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(- (DEST[n+31:n]*SRC3[n+31:n]) + SRC2[n+31:n])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\nVFNMADD213PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =4\nELSEIF (VEX.256)\n  MAXVL = 8\nFI\nFor i = 0 to MAXVL-1 {\n  n = 32*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(- (SRC2[n+31:n]*DEST[n+31:n]) + SRC3[n+31:n])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\nVFNMADD231PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =4\nELSEIF (VEX.256)\n  MAXVL = 8\nFI\nFor i = 0 to MAXVL-1 {\n  n = 32*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR(- (SRC2[n+31:n]*SRC3[n+31:n]) + DEST[n+31:n])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFNMADD132PS: __m128 _mm_fnmadd_ps (__m128 a, __m128 b, __m128 c);\n\nVFNMADD213PS: __m128 _mm_fnmadd_ps (__m128 a, __m128 b, __m128 c);\n\nVFNMADD231PS: __m128 _mm_fnmadd_ps (__m128 a, __m128 b, __m128 c);\n\nVFNMADD132PS: __m256 _mm256_fnmadd_ps (__m256 a, __m256 b, __m256 c);\n\nVFNMADD213PS: __m256 _mm256_fnmadd_ps (__m256 a, __m256 b, __m256 c);\n\nVFNMADD231PS: __m256 _mm256_fnmadd_ps (__m256 a, __m256 b, __m256 c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "VFNMADD132PS"
    }, 
    {
      "description": "\nVFNMADD132SD/VFNMADD213SD/VFNMADD231SD  -  Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.LIG.128.66.0F38.W1 9D /r VFNMADD132SD| A    | V/V            | FMA               | Multiply scalar double-precision floating-point\n| xmm0, xmm1, xmm2/m64                         |      |                |                   | value from xmm0 and xmm2/mem, negate           \n|                                              |      |                |                   | the multiplication result and add to           \n|                                              |      |                |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.LIG.128.66.0F38.W1 AD /r VFNMADD213SD| A    | V/V            | FMA               | Multiply scalar double-precision floating-point\n| xmm0, xmm1, xmm2/m64                         |      |                |                   | value from xmm0 and xmm1, negate the           \n|                                              |      |                |                   | multiplication result and add to xmm2/mem      \n|                                              |      |                |                   | and put result in xmm0.                        \n| VEX.DDS.LIG.128.66.0F38.W1 BD /r VFNMADD231SD| A    | V/V            | FMA               | Multiply scalar double-precision floating-point\n| xmm0, xmm1, xmm2/m64                         |      |                |                   | value from xmm1 and xmm2/mem, negate           \n|                                              |      |                |                   | the multiplication result and add to           \n|                                              |      |                |                   | xmm0 and put result in xmm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nVFNMADD132SD: Multiplies the low packed double-precision floating-point value\nfrom the first source operand to the low packed double-precision floating-point\nvalue in the third source operand, adds the negated infinite precision intermediate\nresult to the low packed double-precision floating-point values in the second\nsource operand, performs rounding and stores the resulting packed double-precision\nfloating-point value to the destination operand (first source operand). VFNMADD213SD:\nMultiplies the low packed double-precision floating-point value from the second\nsource operand to the low packed double-precision floating-point value in the\nfirst source operand, adds the negated infinite precision intermediate result\nto the low packed double-precision floating-point value in the third source\noperand, performs rounding and stores the resulting packed double-precision\nfloating-point value to the destination operand (first source operand). VFNMADD231SD:\nMultiplies the low packed double-precision floating-point value from the second\nsource to the low packed double-precision floating-point value in the third\nsource operand, adds the negated infinite precision intermediate result to the\nlow packed double-precision floating-point value in the first source operand,\nperforms rounding and stores the resulting packed double-precision floating-point\nvalue to the destination operand (first source operand). VEX.128 encoded version:\nThe destination operand (also first source operand) is a XMM register and encoded\nin reg_field. The second source operand is a XMM register and encoded in VEX.vvvv.\nThe third source operand is a XMM register or a 64-bit memory location and encoded\nin rm_field. The upper bits ([VLMAX-1:128]) of the YMM destination register\nare zeroed. Compiler tools may optionally support a complementary mnemonic for\neach instruction mnemonic listed in the opcode/instruction column of the summary\ntable. The behavior of the complementary mnemonic in situations involving NANs\nare governed by the definition of the instruction mnemonic defined in the opcode/instruction\ncolumn. See also Section 14.5.1, \u201cFMA Instruction Operand Order and Arithmetic\nBehavior\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFNMADD132SD DEST, SRC2, SRC3\nDEST[63:0] <- RoundFPControl_MXCSR(- (DEST[63:0]*SRC3[63:0]) + SRC2[63:0])\nDEST[127:64] <- DEST[127:64]\nDEST[VLMAX-1:128] <- 0\nVFNMADD213SD DEST, SRC2, SRC3\nDEST[63:0] <- RoundFPControl_MXCSR(- (SRC2[63:0]*DEST[63:0]) + SRC3[63:0])\nDEST[127:64] <- DEST[127:64]\nDEST[VLMAX-1:128] <- 0\nVFNMADD231SD DEST, SRC2, SRC3\nDEST[63:0] <- RoundFPControl_MXCSR(- (SRC2[63:0]*SRC3[63:0]) + DEST[63:0])\nDEST[127:64] <- DEST[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFNMADD132SD: __m128d _mm_fnmadd_sd (__m128d a, __m128d b, __m128d c);\n\nVFNMADD213SD: __m128d _mm_fnmadd_sd (__m128d a, __m128d b, __m128d c);\n\nVFNMADD231SD: __m128d _mm_fnmadd_sd (__m128d a, __m128d b, __m128d c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 3\n\n", 
      "mnem": "VFNMADD132SD"
    }, 
    {
      "description": "\nVFNMADD132SS/VFNMADD213SS/VFNMADD231SS  -  Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.LIG.128.66.0F38.W0 9D /r VFNMADD132SS| A    | V/V            | FMA               | Multiply scalar single-precision floating-point\n| xmm0, xmm1, xmm2/m32                         |      |                |                   | value from xmm0 and xmm2/mem, negate           \n|                                              |      |                |                   | the multiplication result and add to           \n|                                              |      |                |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.LIG.128.66.0F38.W0 AD /r VFNMADD213SS| A    | V/V            | FMA               | Multiply scalar single-precision floating-point\n| xmm0, xmm1, xmm2/m32                         |      |                |                   | value from xmm0 and xmm1, negate the           \n|                                              |      |                |                   | multiplication result and add to xmm2/mem      \n|                                              |      |                |                   | and put result in xmm0.                        \n| VEX.DDS.LIG.128.66.0F38.W0 BD /r VFNMADD231SS| A    | V/V            | FMA               | Multiply scalar single-precision floating-point\n| xmm0, xmm1, xmm2/m32                         |      |                |                   | value from xmm1 and xmm2/mem, negate           \n|                                              |      |                |                   | the multiplication result and add to           \n|                                              |      |                |                   | xmm0 and put result in xmm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nVFNMADD132SS: Multiplies the low packed single-precision floating-point value\nfrom the first source operand to the low packed single-precision floating-point\nvalue in the third source operand, adds the negated infinite precision intermediate\nresult to the low packed single-precision floating-point value in the second\nsource operand, performs rounding and stores the resulting packed single-precision\nfloating-point value to the destination operand (first source operand). VFNMADD213SS:\nMultiplies the low packed single-precision floating-point value from the second\nsource operand to the low packed single-precision floating-point value in the\nfirst source operand, adds the negated infinite precision intermediate result\nto the low packed single-precision floating-point value in the third source\noperand, performs rounding and stores the resulting packed single-precision\nfloating-point value to the destination operand (first source operand). VFNMADD231SS:\nMultiplies the low packed single-precision floating-point value from the second\nsource operand to the low packed single-precision floating-point value in the\nthird source operand, adds the negated infinite precision intermediate result\nto the low packed single-precision floating-point value in the first source\noperand, performs rounding and stores the resulting packed single-precision\nfloating-point value to the destination operand (first source operand). VEX.128\nencoded version: The destination operand (also first source operand) is a XMM\nregister and encoded in reg_field. The second source operand is a XMM register\nand encoded in VEX.vvvv. The third source operand is a XMM register or a 32-bit\nmemory location and encoded in rm_field. The upper bits ([VLMAX-1:128]) of the\nYMM destination register are zeroed. Compiler tools may optionally support a\ncomplementary mnemonic for each instruction mnemonic listed in the opcode/instruction\ncolumn of the summary table. The behavior of the complementary mnemonic in situations\ninvolving NANs are governed by the definition of the instruction mnemonic defined\nin the opcode/instruction column. See also Section 14.5.1, \u201cFMA Instruction\nOperand Order and Arithmetic Behavior\u201d in the Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFNMADD132SS DEST, SRC2, SRC3\nDEST[31:0] <- RoundFPControl_MXCSR(- (DEST[31:0]*SRC3[31:0]) + SRC2[31:0])\nDEST[127:32] <- DEST[127:32]\nDEST[VLMAX-1:128] <- 0\nVFNMADD213SS DEST, SRC2, SRC3\nDEST[31:0] <- RoundFPControl_MXCSR(- (SRC2[31:0]*DEST[31:0]) + SRC3[31:0])\nDEST[127:32] <- DEST[127:32]\nDEST[VLMAX-1:128] <- 0\nVFNMADD231SS DEST, SRC2, SRC3\nDEST[31:0] <- RoundFPControl_MXCSR(- (SRC2[31:0]*SRC3[63:0]) + DEST[31:0])\nDEST[127:32] <- DEST[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFNMADD132SS: __m128 _mm_fnmadd_ss (__m128 a, __m128 b, __m128 c);\n\nVFNMADD213SS: __m128 _mm_fnmadd_ss (__m128 a, __m128 b, __m128 c);\n\nVFNMADD231SS: __m128 _mm_fnmadd_ss (__m128 a, __m128 b, __m128 c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 3\n\n", 
      "mnem": "VFNMADD132SS"
    }, 
    {
      "description": "-R:VFNMADD132PD", 
      "mnem": "VFNMADD213PD"
    }, 
    {
      "description": "-R:VFNMADD132PS", 
      "mnem": "VFNMADD213PS"
    }, 
    {
      "description": "-R:VFNMADD132SD", 
      "mnem": "VFNMADD213SD"
    }, 
    {
      "description": "-R:VFNMADD132SS", 
      "mnem": "VFNMADD213SS"
    }, 
    {
      "description": "-R:VFNMADD132PD", 
      "mnem": "VFNMADD231PD"
    }, 
    {
      "description": "-R:VFNMADD132PS", 
      "mnem": "VFNMADD231PS"
    }, 
    {
      "description": "-R:VFNMADD132SD", 
      "mnem": "VFNMADD231SD"
    }, 
    {
      "description": "-R:VFNMADD132SS", 
      "mnem": "VFNMADD231SS"
    }, 
    {
      "description": "\nVFNMSUB132PD/VFNMSUB213PD/VFNMSUB231PD  -  Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values:\n| Opcode/Instruction                       | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.128.66.0F38.W1 9E /r VFNMSUB132PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                    |      |                |                   | values from xmm0 and xmm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and subtract         \n|                                          |      |                |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.128.66.0F38.W1 AE /r VFNMSUB213PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                    |      |                |                   | values from xmm0 and xmm1, negate the          \n|                                          |      |                |                   | multiplication result and subtract xmm2/mem    \n|                                          |      |                |                   | and put result in xmm0.                        \n| VEX.DDS.128.66.0F38.W1 BE /r VFNMSUB231PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| xmm0, xmm1, xmm2/m128                    |      |                |                   | values from xmm1 and xmm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and subtract         \n|                                          |      |                |                   | xmm0 and put result in xmm0.                   \n| VEX.DDS.256.66.0F38.W1 9E /r VFNMSUB132PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                    |      |                |                   | values from ymm0 and ymm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and subtract         \n|                                          |      |                |                   | ymm1 and put result in ymm0.                   \n| VEX.DDS.256.66.0F38.W1 AE /r VFNMSUB213PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                    |      |                |                   | values from ymm0 and ymm1, negate the          \n|                                          |      |                |                   | multiplication result and subtract ymm2/mem    \n|                                          |      |                |                   | and put result in ymm0.                        \n| VEX.DDS.256.66.0F38.W1 BE /r VFNMSUB231PD| A    | V/V            | FMA               | Multiply packed double-precision floating-point\n| ymm0, ymm1, ymm2/m256                    |      |                |                   | values from ymm1 and ymm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and subtract         \n|                                          |      |                |                   | ymm0 and put result in ymm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nVFNMSUB132PD: Multiplies the two or four packed double-precision floating-point\nvalues from the first source operand to the two or four packed double-precision\nfloating-point values in the third source operand. From negated infinite precision\nintermediate results, subtracts the two or four packed double-precision floating-point\nvalues in the second source operand, performs rounding and stores the resulting\ntwo or four packed double-precision floating-point values to the destination\noperand (first source operand). VFMSUB213PD: Multiplies the two or four packed\ndouble-precision floating-point values from the second source operand to the\ntwo or four packed double-precision floating-point values in the first source\noperand. From negated infinite precision intermediate results, subtracts the\ntwo or four packed double-precision floating-point values in the third source\noperand, performs rounding and stores the resulting two or four packed double-precision\nfloatingpoint values to the destination operand (first source operand). VFMSUB231PD:\nMultiplies the two or four packed double-precision floating-point values from\nthe second source to the two or four packed double-precision floating-point\nvalues in the third source operand. From negated infinite precision intermediate\nresults, subtracts the two or four packed double-precision floating-point values\nin the first source operand, performs rounding and stores the resulting two\nor four packed double-precision floating-point values to the destination operand\n(first source operand).\n\nVEX.128 encoded version: The destination operand (also first source operand)\nis a XMM register and encoded in reg_field. The second source operand is a XMM\nregister and encoded in VEX.vvvv. The third source operand is a\n\nXMM register or a 128-bit memory location and encoded in rm_field. The upper\n128 bits of the YMM destination register are zeroed.\n\nVEX.256 encoded version: The destination operand (also first source operand)\nis a YMM register and encoded in reg_field. The second source operand is a YMM\nregister and encoded in VEX.vvvv. The third source operand is a YMM register\nor a 256-bit memory location and encoded in rm_field. Compiler tools may optionally\nsupport a complementary mnemonic for each instruction mnemonic listed in the\nopcode/instruction column of the summary table. The behavior of the complementary\nmnemonic in situations involving NANs are governed by the definition of the\ninstruction mnemonic defined in the opcode/instruction column. See also Section\n14.5.1, \u201cFMA Instruction Operand Order and Arithmetic Behavior\u201d in the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFNMSUB132PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL-1 {\n  n = 64*i;\n  DEST[n+63:n] <- RoundFPControl_MXCSR( - (DEST[n+63:n]*SRC3[n+63:n]) - SRC2[n+63:n])\n}\nIF (VEX.128) THEN\nDEST[VLMAX-1:128] <- 0\nFI\nVFNMSUB213PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL-1 {\n  n = 64*i;\n  DEST[n+63:n] <- RoundFPControl_MXCSR( - (SRC2[n+63:n]*DEST[n+63:n]) - SRC3[n+63:n])\n}\nIF (VEX.128) THEN\nDEST[VLMAX-1:128] <- 0\nFI\nVFNMSUB231PD DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =2\nELSEIF (VEX.256)\n  MAXVL = 4\nFI\nFor i = 0 to MAXVL-1 {\n  n = 64*i;\n  DEST[n+63:n] <- RoundFPControl_MXCSR( - (SRC2[n+63:n]*SRC3[n+63:n]) - DEST[n+63:n])\n}\nIF (VEX.128) THEN\nDEST[VLMAX-1:128] <- 0\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFNMSUB132PD: __m128d _mm_fnmsub_pd (__m128d a, __m128d b, __m128d c);\n\nVFNMSUB213PD: __m128d _mm_fnmsub_pd (__m128d a, __m128d b, __m128d c);\n\nVFNMSUB231PD: __m128d _mm_fnmsub_pd (__m128d a, __m128d b, __m128d c);\n\nVFNMSUB132PD: __m256d _mm256_fnmsub_pd (__m256d a, __m256d b, __m256d c);\n\nVFNMSUB213PD: __m256d _mm256_fnmsub_pd (__m256d a, __m256d b, __m256d c);\n\nVFNMSUB231PD: __m256d _mm256_fnmsub_pd (__m256d a, __m256d b, __m256d c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "VFNMSUB132PD"
    }, 
    {
      "description": "\nVFNMSUB132PS/VFNMSUB213PS/VFNMSUB231PS  -  Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values:\n| Opcode/Instruction                       | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.128.66.0F38.W0 9E /r VFNMSUB132PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                    |      |                |                   | values from xmm0 and xmm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and subtract         \n|                                          |      |                |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.128.66.0F38.W0 AE /r VFNMSUB213PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                    |      |                |                   | values from xmm0 and xmm1, negate the          \n|                                          |      |                |                   | multiplication result and subtract xmm2/mem    \n|                                          |      |                |                   | and put result in xmm0.                        \n| VEX.DDS.128.66.0F38.W0 BE /r VFNMSUB231PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| xmm0, xmm1, xmm2/m128                    |      |                |                   | values from xmm1 and xmm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and subtract         \n|                                          |      |                |                   | xmm0 and put result in xmm0.                   \n| VEX.DDS.256.66.0F38.W0 9E /r VFNMSUB132PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                    |      |                |                   | values from ymm0 and ymm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and subtract         \n|                                          |      |                |                   | ymm1 and put result in ymm0.                   \n| VEX.DDS.256.66.0F38.W0 AE /r VFNMSUB213PS| A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                    |      |                |                   | values from ymm0 and ymm1, negate the          \n|                                          |      |                |                   | multiplication result and subtract ymm2/mem    \n|                                          |      |                |                   | and put result in ymm0.                        \n| VEX.DDS.256.66.0F38.0 BE /r VFNMSUB231PS | A    | V/V            | FMA               | Multiply packed single-precision floating-point\n| ymm0, ymm1, ymm2/m256                    |      |                |                   | values from ymm1 and ymm2/mem, negate          \n|                                          |      |                |                   | the multiplication result and subtract         \n|                                          |      |                |                   | ymm0 and put result in ymm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nVFNMSUB132PS: Multiplies the four or eight packed single-precision floating-point\nvalues from the first source operand to the four or eight packed single-precision\nfloating-point values in the third source operand. From negated infinite precision\nintermediate results, subtracts the four or eight packed single-precision floating-point\nvalues in the second source operand, performs rounding and stores the resulting\nfour or eight packed single-precision floating-point values to the destination\noperand (first source operand). VFNMSUB213PS: Multiplies the four or eight packed\nsingle-precision floating-point values from the second source operand to the\nfour or eight packed single-precision floating-point values in the first source\noperand. From negated infinite precision intermediate results, subtracts the\nfour or eight packed single-precision floating-point values in the third source\noperand, performs rounding and stores the resulting four or eight packed single-precision\nfloatingpoint values to the destination operand (first source operand). VFNMSUB231PS:\nMultiplies the four or eight packed single-precision floating-point values from\nthe second source to the four or eight packed single-precision floating-point\nvalues in the third source operand. From negated infinite precision intermediate\nresults, subtracts the four or eight packed single-precision floating-point\nvalues in the first source operand, performs rounding and stores the resulting\nfour or eight packed single-precision floating-point values to the destination\noperand (first source operand). VEX.128 encoded version: The destination operand\n(also first source operand) is a XMM register and encoded in reg_field. The\nsecond source operand is a XMM register and encoded in VEX.vvvv. The third source\noperand is a\n\nXMM register or a 128-bit memory location and encoded in rm_field. The upper\n128 bits of the YMM destination register are zeroed.\n\nVEX.256 encoded version: The destination operand (also first source operand)\nis a YMM register and encoded in reg_field. The second source operand is a YMM\nregister and encoded in VEX.vvvv. The third source operand is a YMM register\nor a 256-bit memory location and encoded in rm_field. Compiler tools may optionally\nsupport a complementary mnemonic for each instruction mnemonic listed in the\nopcode/instruction column of the summary table. The behavior of the complementary\nmnemonic in situations involving NANs are governed by the definition of the\ninstruction mnemonic defined in the opcode/instruction column. See also Section\n14.5.1, \u201cFMA Instruction Operand Order and Arithmetic Behavior\u201d in the Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFNMSUB132PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =4\nELSEIF (VEX.256)\n  MAXVL = 8\nFI\nFor i = 0 to MAXVL-1 {\n  n = 32*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR( - (DEST[n+31:n]*SRC3[n+31:n]) - SRC2[n+31:n])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\nVFNMSUB213PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =4\nELSEIF (VEX.256)\n  MAXVL = 8\nFI\nFor i = 0 to MAXVL-1 {\n  n = 32*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR( - (SRC2[n+31:n]*DEST[n+31:n]) - SRC3[n+31:n])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\nVFNMSUB231PS DEST, SRC2, SRC3\nIF (VEX.128) THEN\n  MAXVL =4\nELSEIF (VEX.256)\n  MAXVL = 8\nFI\nFor i = 0 to MAXVL-1 {\n  n = 32*i;\n  DEST[n+31:n] <- RoundFPControl_MXCSR( - (SRC2[n+31:n]*SRC3[n+31:n]) - DEST[n+31:n])\n}\nIF (VEX.128) THEN\n  DEST[VLMAX-1:128] <- 0\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFNMSUB132PS: __m128 _mm_fnmsub_ps (__m128 a, __m128 b, __m128 c);\n\nVFNMSUB213PS: __m128 _mm_fnmsub_ps (__m128 a, __m128 b, __m128 c);\n\nVFNMSUB231PS: __m128 _mm_fnmsub_ps (__m128 a, __m128 b, __m128 c);\n\nVFNMSUB132PS: __m256 _mm256_fnmsub_ps (__m256 a, __m256 b, __m256 c);\n\nVFNMSUB213PS: __m256 _mm256_fnmsub_ps (__m256 a, __m256 b, __m256 c);\n\nVFNMSUB231PS: __m256 _mm256_fnmsub_ps (__m256 a, __m256 b, __m256 c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 2\n\n", 
      "mnem": "VFNMSUB132PS"
    }, 
    {
      "description": "\nVFNMSUB132SD/VFNMSUB213SD/VFNMSUB231SD  -  Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.LIG.128.66.0F38.W1 9F /r VFNMSUB132SD| A    | V/V          | FMA               | Multiply scalar double-precision floating-point\n| xmm0, xmm1, xmm2/m64                         |      |              |                   | value from xmm0 and xmm2/mem, negate           \n|                                              |      |              |                   | the multiplication result and subtract         \n|                                              |      |              |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.LIG.128.66.0F38.W1 AF /r VFNMSUB213SD| A    | V/V          | FMA               | Multiply scalar double-precision floating-point\n| xmm0, xmm1, xmm2/m64                         |      |              |                   | value from xmm0 and xmm1, negate the           \n|                                              |      |              |                   | multiplication result and subtract xmm2/mem    \n|                                              |      |              |                   | and put result in xmm0.                        \n| VEX.DDS.LIG.128.66.0F38.W1 BF /r VFNMSUB231SD| A    | V/V          | FMA               | Multiply scalar double-precision floating-point\n| xmm0, xmm1, xmm2/m64                         |      |              |                   | value from xmm1 and xmm2/mem, negate           \n|                                              |      |              |                   | the multiplication result and subtract         \n|                                              |      |              |                   | xmm0 and put result in xmm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nVFNMSUB132SD: Multiplies the low packed double-precision floating-point value\nfrom the first source operand to the low packed double-precision floating-point\nvalue in the third source operand. From negated infinite precision intermediate\nresult, subtracts the low double-precision floating-point value in the second\nsource operand, performs rounding and stores the resulting packed double-precision\nfloating-point value to the destination operand (first source operand). VFNMSUB213SD:\nMultiplies the low packed double-precision floating-point value from the second\nsource operand to the low packed double-precision floating-point value in the\nfirst source operand. From negated infinite precision intermediate result, subtracts\nthe low double-precision floating-point value in the third source operand, performs\nrounding and stores the resulting packed double-precision floating-point value\nto the destination operand (first source operand). VFNMSUB231SD: Multiplies\nthe low packed double-precision floating-point value from the second source\nto the low packed double-precision floating-point value in the third source\noperand. From negated infinite precision intermediate result, subtracts the\nlow double-precision floating-point value in the first source operand, performs\nrounding and stores the resulting packed double-precision floating-point value\nto the destination operand (first source operand). VEX.128 encoded version:\nThe destination operand (also first source operand) is a XMM register and encoded\nin reg_field. The second source operand is a XMM register and encoded in VEX.vvvv.\nThe third source operand is a XMM register or a 64-bit memory location and encoded\nin rm_field. The upper bits ([VLMAX-1:128]) of the YMM destination register\nare zeroed. Compiler tools may optionally support a complementary mnemonic for\neach instruction mnemonic listed in the opcode/instruction column of the summary\ntable. The behavior of the complementary mnemonic in situations involving NANs\nare governed by the definition of the instruction mnemonic defined in the opcode/instruction\ncolumn. See also Section 14.5.1, \u201cFMA Instruction Operand Order and Arithmetic\nBehavior\u201d in the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFNMSUB132SD DEST, SRC2, SRC3\nDEST[63:0] <- RoundFPControl_MXCSR(- (DEST[63:0]*SRC3[63:0]) - SRC2[63:0])\nDEST[127:64] <- DEST[127:64]\nDEST[VLMAX-1:128] <- 0\nVFNMSUB213SD DEST, SRC2, SRC3\nDEST[63:0] <- RoundFPControl_MXCSR(- (SRC2[63:0]*DEST[63:0]) - SRC3[63:0])\nDEST[127:64] <- DEST[127:64]\nDEST[VLMAX-1:128] <- 0\nVFNMSUB231SD DEST, SRC2, SRC3\nDEST[63:0] <- RoundFPControl_MXCSR(- (SRC2[63:0]*SRC3[63:0]) - DEST[63:0])\nDEST[127:64] <- DEST[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFNMSUB132SD: __m128d _mm_fnmsub_sd (__m128d a, __m128d b, __m128d c);\n\nVFNMSUB213SD: __m128d _mm_fnmsub_sd (__m128d a, __m128d b, __m128d c);\n\nVFNMSUB231SD: __m128d _mm_fnmsub_sd (__m128d a, __m128d b, __m128d c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 3\n\n", 
      "mnem": "VFNMSUB132SD"
    }, 
    {
      "description": "\nVFNMSUB132SS/VFNMSUB213SS/VFNMSUB231SS  -  Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                    \n| VEX.DDS.LIG.128.66.0F38.W0 9F /r VFNMSUB132SS| A    | V/V            | FMA               | Multiply scalar single-precision floating-point\n| xmm0, xmm1, xmm2/m32                         |      |                |                   | value from xmm0 and xmm2/mem, negate           \n|                                              |      |                |                   | the multiplication result and subtract         \n|                                              |      |                |                   | xmm1 and put result in xmm0.                   \n| VEX.DDS.LIG.128.66.0F38.W0 AF /r VFNMSUB213SS| A    | V/V            | FMA               | Multiply scalar single-precision floating-point\n| xmm0, xmm1, xmm2/m32                         |      |                |                   | value from xmm0 and xmm1, negate the           \n|                                              |      |                |                   | multiplication result and subtract xmm2/mem    \n|                                              |      |                |                   | and put result in xmm0.                        \n| VEX.DDS.LIG.128.66.0F38.W0 BF /r VFNMSUB231SS| A    | V/V            | FMA               | Multiply scalar single-precision floating-point\n| xmm0, xmm1, xmm2/m32                         |      |                |                   | value from xmm1 and xmm2/mem, negate           \n|                                              |      |                |                   | the multiplication result and subtract         \n|                                              |      |                |                   | xmm0 and put result in xmm0.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2   | Operand 3    | Operand 4\n| A    | ModRM:reg (r, w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nVFNMSUB132SS: Multiplies the low packed single-precision floating-point value\nfrom the first source operand to the low packed single-precision floating-point\nvalue in the third source operand. From negated infinite precision intermediate\nresult, the low single-precision floating-point value in the second source operand,\nperforms rounding and stores the resulting packed single-precision floating-point\nvalue to the destination operand (first source operand). VFNMSUB213SS: Multiplies\nthe low packed single-precision floating-point value from the second source\noperand to the low packed single-precision floating-point value in the first\nsource operand. From negated infinite precision intermediate result, the low\nsingle-precision floating-point value in the third source operand, performs\nrounding and stores the resulting packed single-precision floating-point value\nto the destination operand (first source operand). VFNMSUB231SS: Multiplies\nthe low packed single-precision floating-point value from the second source\nto the low packed single-precision floating-point value in the third source\noperand. From negated infinite precision intermediate result, the low single-precision\nfloating-point value in the first source operand, performs rounding and stores\nthe resulting packed single-precision floating-point value to the destination\noperand (first source operand). VEX.128 encoded version: The destination operand\n(also first source operand) is a XMM register and encoded in reg_field. The\nsecond source operand is a XMM register and encoded in VEX.vvvv. The third source\noperand is a XMM register or a 32-bit memory location and encoded in rm_field.\nThe upper bits ([VLMAX-1:128]) of the YMM destination register are zeroed. Compiler\ntools may optionally support a complementary mnemonic for each instruction mnemonic\nlisted in the opcode/instruction column of the summary table. The behavior of\nthe complementary mnemonic in situations involving NANs are governed by the\ndefinition of the instruction mnemonic defined in the opcode/instruction column.\nSee also Section 14.5.1, \u201cFMA Instruction Operand Order and Arithmetic Behavior\u201d\nin the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume\n1.\n\nOperation:\n\nIn the operations below, \"+\", \"-\", and \"*\" symbols represent addition, subtraction, and multiplication operations\nwith infinite precision inputs and outputs (no rounding).\nVFNMSUB132SS DEST, SRC2, SRC3\nDEST[31:0] <- RoundFPControl_MXCSR(- (DEST[31:0]*SRC3[31:0]) - SRC2[31:0])\nDEST[127:32] <- DEST[127:32]\nDEST[VLMAX-1:128] <- 0\nVFNMSUB213SS DEST, SRC2, SRC3\nDEST[31:0] <- RoundFPControl_MXCSR(- (SRC2[31:0]*DEST[31:0]) - SRC3[31:0])\nDEST[127:32] <- DEST[127:32]\nDEST[VLMAX-1:128] <- 0\nVFNMSUB231SS DEST, SRC2, SRC3\nDEST[31:0] <- RoundFPControl_MXCSR(- (SRC2[31:0]*SRC3[63:0]) - DEST[31:0])\nDEST[127:32] <- DEST[127:32]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVFNMSUB132SS: __m128 _mm_fnmsub_ss (__m128 a, __m128 b, __m128 c);\n\nVFNMSUB213SS: __m128 _mm_fnmsub_ss (__m128 a, __m128 b, __m128 c);\n\nVFNMSUB231SS: __m128 _mm_fnmsub_ss (__m128 a, __m128 b, __m128 c);\n\n\nSIMD Floating-Point Exceptions:\nOverflow, Underflow, Invalid, Precision, Denormal\n\n\nOther Exceptions:\nSee Exceptions Type 3\n\n", 
      "mnem": "VFNMSUB132SS"
    }, 
    {
      "description": "-R:VFNMSUB132PD", 
      "mnem": "VFNMSUB213PD"
    }, 
    {
      "description": "-R:VFNMSUB132PS", 
      "mnem": "VFNMSUB213PS"
    }, 
    {
      "description": "-R:VFNMSUB132SD", 
      "mnem": "VFNMSUB213SD"
    }, 
    {
      "description": "-R:VFNMSUB132SS", 
      "mnem": "VFNMSUB213SS"
    }, 
    {
      "description": "-R:VFNMSUB132PD", 
      "mnem": "VFNMSUB231PD"
    }, 
    {
      "description": "-R:VFNMSUB132PS", 
      "mnem": "VFNMSUB231PS"
    }, 
    {
      "description": "-R:VFNMSUB132SD", 
      "mnem": "VFNMSUB231SD"
    }, 
    {
      "description": "-R:VFNMSUB132SS", 
      "mnem": "VFNMSUB231SS"
    }, 
    {
      "description": "\nVGATHERDPD/VGATHERQPD  -  Gather Packed DP FP Values Using Signed Dword/Qword Indices:\n| Opcode/Instruction                     | Op/En| 64/3 2-bit Mode| CPUID Feature Flag| Description                             \n| VEX.DDS.128.66.0F38.W1 92 /r VGATHERDPD| RMV  | V/V            | AVX2              | Using dword indices specified in vm32x, \n| xmm1, vm32x, xmm2                      |      |                |                   | gather double-precision FP values from  \n|                                        |      |                |                   | memory conditioned on mask specified    \n|                                        |      |                |                   | by xmm2. Conditionally gathered elements\n|                                        |      |                |                   | are merged into xmm1.                   \n| VEX.DDS.128.66.0F38.W1 93 /r VGATHERQPD| RMV  | V/V            | AVX2              | Using qword indices specified in vm64x, \n| xmm1, vm64x, xmm2                      |      |                |                   | gather double-precision FP values from  \n|                                        |      |                |                   | memory conditioned on mask specified    \n|                                        |      |                |                   | by xmm2. Conditionally gathered elements\n|                                        |      |                |                   | are merged into xmm1.                   \n| VEX.DDS.256.66.0F38.W1 92 /r VGATHERDPD| RMV  | V/V            | AVX2              | Using dword indices specified in vm32x, \n| ymm1, vm32x, ymm2                      |      |                |                   | gather double-precision FP values from  \n|                                        |      |                |                   | memory conditioned on mask specified    \n|                                        |      |                |                   | by ymm2. Conditionally gathered elements\n|                                        |      |                |                   | are merged into ymm1.                   \n| VEX.DDS.256.66.0F38.W1 93 /r VGATHERQPD| RMV  | V/V            | AVX2              | Using qword indices specified in vm64y, \n| ymm1, vm64y, ymm2                      |      |                |                   | gather double-precision FP values from  \n|                                        |      |                |                   | memory conditioned on mask specified    \n|                                        |      |                |                   | by ymm2. Conditionally gathered elements\n|                                        |      |                |                   | are merged into ymm1.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1      | Operand 2                            | Operand 3      | Operand 4\n| RMV  | ModRM:reg (r,w)| BaseReg (R): VSIB:base, VectorReg(R):| VEX.vvvv (r, w)| NA       \n|      |                | VSIB:index                           |                |          \n\nDescription:\nThe instruction conditionally loads up to 2 or 4 double-precision floating-point\nvalues from memory addresses specified by the memory operand (the second operand)\nand using qword indices. The memory operand uses the VSIB form of the SIB byte\nto specify a general purpose register operand as the common base, a vector register\nfor an array of indices relative to the base and a constant scale factor. The\nmask operand (the third operand) specifies the conditional load operation from\neach memory address and the corresponding update of each data element of the\ndestination operand (the first operand). Conditionality is specified by the\nmost significant bit of each data element of the mask register. If an element's\nmask bit is not set, the corresponding element of the destination register is\nleft unchanged. The width of data element in the destination register and mask\nregister are identical. The entire mask register will be set to zero by this\ninstruction unless the instruction causes an exception. Using dword indices\nin the lower half of the mask register, the instruction conditionally loads\nup to 2 or 4 doubleprecision floating-point values from the VSIB addressing\nmemory operand, and updates the destination register. This instruction can be\nsuspended by an exception if at least one element is already gathered (i.e.,\nif the exception\n\n| is triggered by an element other than       | When this happens, the destination If \n| the rightmost one with its mask bit         | any traps or interrupts are pending   \n| set). register and the mask operand         | from already gathIt may do this to one\n| are partially updated; those elements       | or both                               \n| that have been gathered are placed into     |                                       \n| the destination register and have their     |                                       \n| mask bits set to zero. ered elements,       |                                       \n| they will be delivered in lieu of the       |                                       \n| exception; in this case, EFLAG.RF is        |                                       \n| set to one so an instruction breakpoint     |                                       \n| is not re-triggered when the instruction    |                                       \n| is continued. If the data size and index    |                                       \n| size are different, part of the destination |                                       \n| register and part of the mask register      |                                       \n| do not correspond to any elements being     |                                       \n| gathered. of those registers even if        |                                       \n| the instruction triggers an exception,      |                                       \n| and even if the instruction triggers        |                                       \n| the exception before gathering any elements.|                                       \n| VEX.128 version: The instruction will       | For dword indices, only the           \n| gather two double-precision floating-point  |                                       \n| values.                                     |                                       \nlower two indices in the vector index register are used.\n\n| VEX.256 version: The instruction will        | For dword indices, only If any pair         \n| gather four double-precision floating-point  | of the index, mask, or destination registers\n| values. the lower four indices in the        | are the same, this instruction results      \n| vector index register are used. Note         | a #UD fault.                                \n| that: \u2022                                      |                                             \n| \u202264 memory-ordering model. \u2022                 | Memory ordering with other instructions     \n|                                              | follows the IntelThat is, if a fault        \n|                                              | is triggered by an element and delivered,   \n|                                              | all                                         \n| elements closer to the LSB of the destination| Individual elements closer If a given       \n| will be completed (and non-faulting).        | element triggers multiple faults, they      \n| to the MSB may or may not be completed.      | are delivered in the Elements may be        \n| conventional order. \u2022                        | gathered in any order, but faults must      \n|                                              | be delivered in a right-to-left order;      \n|                                              | thus, elements to                           \n| the left of a faulting one may be gathered   | A given implementation of this This         \n| before the fault is delivered. instruction   | instruction does not perform AC checks,     \n| is repeatable - given the same input         | and so will never deliver an AC fault.      \n| values and architectural state, the          |                                             \n| same set of elements to the left of          |                                             \n| the faulting one will be gathered. \u2022         |                                             \n| \u2022                                            | This instruction will cause a #UD if        \n|                                              | the address size attribute is 16-bit.       \n| \u2022                                            | This instruction will cause a #UD if        \n|                                              | the memory operand is encoded without       \n|                                              | the SIB byte.                               \n| \u2022is implementation specific, and some        | This instruction should not be used         \n| implementations may use loads larger         | to access memory mapped I/O as the ordering \n| than the data element size or load elements  | of the individual loads it does The         \n| an indeterminate number of times. \u2022          | scaled index may require more bits to       \n|                                              | represent than the address bits used        \n|                                              | by the processor (e.g., in 32-              \n| bit mode, if the scale is greater than       | In this case, the most significant bits     \n| one). bits are ignored.                      | beyond the number of address                \nOperation:\n\nDEST <- SRC1;\nBASE_ADDR: base register encoded in VSIB addressing;\nVINDEX: the vector index register encoded by VSIB addressing;\nSCALE: scale factor encoded by SIB:[7:6];\nDISP: optional 1, 4 byte displacement;\nMASK <- SRC3;\nVGATHERDPD (VEX.128 version)\nFOR j<- 0 to 1\n  i <- j * 64;\n  IF MASK[63+i] THEN\n     MASK[i +63:i] <- 0xFFFFFFFF_FFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +63:i] <- 0;\n  FI;\nENDFOR\nFOR j<- 0 to 1\n  k <- j * 32;\n  i <- j * 64;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX[k+31:k])*SCALE + DISP;\n  IF MASK[63+i] THEN\n     DEST[i +63:i] <- FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +63: i] <- 0;\nENDFOR\nMASK[VLMAX-1:128] <- 0;\nDEST[VLMAX-1:128] <- 0;\n(non-masked elements of the mask register have the content of respective element\nVGATHERQPD (VEX.128 version)\nFOR j<- 0 to 1\n  i <- j * 64;\n  IF MASK[63+i] THEN\n     MASK[i +63:i] <- 0xFFFFFFFF_FFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +63:i] <- 0;\n  FI;\nENDFOR\nFOR j<- 0 to 1\n  i <- j * 64;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX1[i+63:i])*SCALE + DISP;\n  IF MASK[63+i] THEN\n     DEST[i +63:i] <- FETCH_64BITS(DATA_ADDR); // a fault exits this instruction\n  FI;\n  MASK[i +63: i] <- 0;\nENDFOR\nMASK[VLMAX-1:128] <- 0;\nDEST[VLMAX-1:128] <- 0;\n(non-masked elements of the mask register have the content of respective element\nVGATHERQPD (VEX.256 version)\nFOR j<- 0 to 3\n  i <- j * 64;\n  IF MASK[63+i] THEN\n     MASK[i +63:i] <- 0xFFFFFFFF_FFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +63:i] <- 0;\n  FI;\nENDFOR\nFOR j<- 0 to 3\n  i <- j * 64;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX1[i+63:i])*SCALE + DISP;\n  IF MASK[63+i] THEN\n     DEST[i +63:i] <- FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +63: i] <- 0;\nENDFOR\n(non-masked elements of the mask register have the content of respective element\nVGATHERDPD (VEX.256 version)\nFOR j<- 0 to 3\n  i <- j * 64;\n  IF MASK[63+i] THEN\n     MASK[i +63:i] <- 0xFFFFFFFF_FFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +63:i] <- 0;\n  FI;\nENDFOR\nFOR j<- 0 to 3\n  k <- j * 32;\n  i <- j * 64;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX1[k+31:k])*SCALE + DISP;\n  IF MASK[63+i] THEN\n     DEST[i +63:i] <- FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +63:i] <- 0;\nENDFOR\n(non-masked elements of the mask register have the content of respective element\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVGATHERDPD: __m128d _mm_i32gather_pd (double const * base, __m128i index, const\nint scale);\n\nVGATHERDPD: __m128d _mm_mask_i32gather_pd (__m128d src, double const * base,\n__m128i index, __m128d mask, const int scale);\n\nVGATHERDPD: __m256d _mm256_i32gather_pd (double const * base, __m128i index,\nconst int scale);\n\nVGATHERDPD: __m256d _mm256_mask_i32gather_pd (__m256d src, double const * base,\n__m128i index, __m256d mask, const int scale);\n\nVGATHERQPD: __m128d _mm_i64gather_pd (double const * base, __m128i index, const\nint scale);\n\nVGATHERQPD: __m128d _mm_mask_i64gather_pd (__m128d src, double const * base,\n__m128i index, __m128d mask, const int scale);\n\nVGATHERQPD: __m256d _mm256_i64gather_pd (double const * base, __m256i index,\nconst int scale);\n\nVGATHERQPD: __m256d _mm256_mask_i64gather_pd (__m256d src, double const * base,\n__m256i index, __m256d mask, const int scale);\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 12\n\n", 
      "mnem": "VGATHERDPD"
    }, 
    {
      "description": "\nVGATHERDPS/VGATHERQPS  -  Gather Packed SP FP values Using Signed Dword/Qword Indices:\n| Opcode/Instruction                     | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                             \n| VEX.DDS.128.66.0F38.W0 92 /r VGATHERDPS| RMV  | V/V            | AVX2              | Using dword indices specified in vm32x, \n| xmm1, vm32x, xmm2                      |      |                |                   | gather single-precision FP values from  \n|                                        |      |                |                   | memory conditioned on mask specified    \n|                                        |      |                |                   | by xmm2. Conditionally gathered elements\n|                                        |      |                |                   | are merged into xmm1.                   \n| VEX.DDS.128.66.0F38.W0 93 /r VGATHERQPS| RMV  | V/V            | AVX2              | Using qword indices specified in vm64x, \n| xmm1, vm64x, xmm2                      |      |                |                   | gather single-precision FP values from  \n|                                        |      |                |                   | memory conditioned on mask specified    \n|                                        |      |                |                   | by xmm2. Conditionally gathered elements\n|                                        |      |                |                   | are merged into xmm1.                   \n| VEX.DDS.256.66.0F38.W0 92 /r VGATHERDPS| RMV  | V/V            | AVX2              | Using dword indices specified in vm32y, \n| ymm1, vm32y, ymm2                      |      |                |                   | gather single-precision FP values from  \n|                                        |      |                |                   | memory conditioned on mask specified    \n|                                        |      |                |                   | by ymm2. Conditionally gathered elements\n|                                        |      |                |                   | are merged into ymm1.                   \n| VEX.DDS.256.66.0F38.W0 93 /r VGATHERQPS| RMV  | V/V            | AVX2              | Using qword indices specified in vm64y, \n| xmm1, vm64y, xmm2                      |      |                |                   | gather single-precision FP values from  \n|                                        |      |                |                   | memory conditioned on mask specified    \n|                                        |      |                |                   | by xmm2. Conditionally gathered elements\n|                                        |      |                |                   | are merged into xmm1.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1      | Operand 2                            | Operand 3      | Operand 4\n| A    | ModRM:reg (r,w)| BaseReg (R): VSIB:base, VectorReg(R):| VEX.vvvv (r, w)| NA       \n|      |                | VSIB:index                           |                |          \n\nDescription:\nThe instruction conditionally loads up to 4 or 8 single-precision floating-point\nvalues from memory addresses specified by the memory operand (the second operand)\nand using dword indices. The memory operand uses the VSIB form of the SIB byte\nto specify a general purpose register operand as the common base, a vector register\nfor an array of indices relative to the base and a constant scale factor. The\nmask operand (the third operand) specifies the conditional load operation from\neach memory address and the corresponding update of each data element of the\ndestination operand (the first operand). Conditionality is specified by the\nmost significant bit of each data element of the mask register. If an element's\nmask bit is not set, the corresponding element of the destination register is\nleft unchanged. The width of data element in the destination register and mask\nregister are identical. The entire mask register will be set to zero by this\ninstruction unless the instruction causes an exception. Using qword indices,\nthe instruction conditionally loads up to 2 or 4 single-precision floating-point\nvalues from the VSIB addressing memory operand, and updates the lower half of\nthe destination register. The upper 128 or 256 bits of the destination register\nare zero'ed with qword indices. This instruction can be suspended by an exception\nif at least one element is already gathered (i.e., if the exception\n\n| is triggered by an element other than            | When this happens, the destination If \n| the rightmost one with its mask bit              | any traps or interrupts are pending   \n| set). register and the mask operand              | from already gathIt may do this to one\n| are partially updated; those elements            | or both                               \n| that have been gathered are placed into          |                                       \n| the destination register and have their          |                                       \n| mask bits set to zero. ered elements,            |                                       \n| they will be delivered in lieu of the            |                                       \n| exception; in this case, EFLAG.RF is             |                                       \n| set to one so an instruction breakpoint          |                                       \n| is not re-triggered when the instruction         |                                       \n| is continued. If the data size and index         |                                       \n| size are different, part of the destination      |                                       \n| register and part of the mask register           |                                       \n| do not correspond to any elements being          |                                       \n| gathered. of those registers even if             |                                       \n| the instruction triggers an exception,           |                                       \n| and even if the instruction triggers             |                                       \n| the exception before gathering any elements.     |                                       \n| VEX.128 version: For dword indices,              | For                                   \n| the instruction will gather four single-precision|                                       \n| floating-point values.                           |                                       \nqword indices, the instruction will gather two values and zeroes the upper 64\nbits of the destination.\n\n| VEX.256 version: For dword indices,               | For If any pair of the index, mask,        \n| the instruction will gather eight single-precision| or destination registers are the same,     \n| floating-point values. qword indices,             | this instruction results a UD fault.       \n| the instruction will gather four values           |                                            \n| and zeroes the upper 128 bits of the              |                                            \n| destination. Note that: \u2022                         |                                            \n| \u202264 memory-ordering model. \u2022                      | Memory ordering with other instructions    \n|                                                   | follows the IntelThat is, if a fault       \n|                                                   | is triggered by an element and delivered,  \n|                                                   | all                                        \n| elements closer to the LSB of the destination     | Individual elements closer If a given      \n| will be completed (and non-faulting).             | element triggers multiple faults, they     \n| to the MSB may or may not be completed.           | are delivered in the Elements may be       \n| conventional order. \u2022                             | gathered in any order, but faults must     \n|                                                   | be delivered in a right-to-left order;     \n|                                                   | thus, elements to                          \n| the left of a faulting one may be gathered        | A given implementation of this This        \n| before the fault is delivered. instruction        | instruction does not perform AC checks,    \n| is repeatable - given the same input              | and so will never deliver an AC fault.     \n| values and architectural state, the               |                                            \n| same set of elements to the left of               |                                            \n| the faulting one will be gathered. \u2022              |                                            \n| \u2022                                                 | This instruction will cause a #UD if       \n|                                                   | the address size attribute is 16-bit.      \n| \u2022                                                 | This instruction will cause a #UD if       \n|                                                   | the memory operand is encoded without      \n|                                                   | the SIB byte.                              \n| \u2022is implementation specific, and some             | This instruction should not be used        \n| implementations may use loads larger              | to access memory mapped I/O as the ordering\n| than the data element size or load elements       | of the individual loads it does The        \n| an indeterminate number of times. \u2022               | scaled index may require more bits to      \n|                                                   | represent than the address bits used       \n|                                                   | by the processor (e.g., in 32-             \n| bit mode, if the scale is greater than            | In this case, the most significant bits    \n| one). bits are ignored.                           | beyond the number of address               \nOperation:\n\nDEST <- SRC1;\nBASE_ADDR: base register encoded in VSIB addressing;\nVINDEX: the vector index register encoded by VSIB addressing;\nSCALE: scale factor encoded by SIB:[7:6];\nDISP: optional 1, 4 byte displacement;\nMASK <- SRC3;\nVGATHERDPS (VEX.128 version)\nFOR j<- 0 to 3\n  i <- j * 32;\n  IF MASK[31+i] THEN\n     MASK[i +31:i] <- 0xFFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +31:i] <- 0;\n  FI;\nENDFOR\nMASK[VLMAX-1:128] <- 0;\nFOR j<- 0 to 3\n  i <- j * 32;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX[i+31:i])*SCALE + DISP;\n  IF MASK[31+i] THEN\n     DEST[i +31:i] <- FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +31:i] <- 0;\nENDFOR\nDEST[VLMAX-1:128] <- 0;\n(non-masked elements of the mask register have the content of respective element\nVGATHERQPS (VEX.128 version)\nFOR j<- 0 to 3\n  i <- j * 32;\n  IF MASK[31+i] THEN\n     MASK[i +31:i] <- 0xFFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +31:i] <- 0;\n  FI;\nENDFOR\nMASK[VLMAX-1:128] <- 0;\nFOR j<- 0 to 1\n  k <- j * 64;\n  i <- j * 32;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX1[k+63:k])*SCALE + DISP;\n  IF MASK[31+i] THEN\n     DEST[i +31:i] <- FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +31:i] <- 0;\nENDFOR\nMASK[127:64] <- 0;\nDEST[VLMAX-1:64] <- 0;\n(non-masked elements of the mask register have the content of respective element\nVGATHERDPS (VEX.256 version)\nFOR j<- 0 to 7\n  i <- j * 32;\n  IF MASK[31+i] THEN\n     MASK[i +31:i] <- 0xFFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +31:i] <- 0;\n  FI;\nENDFOR\nFOR j<- 0 to 7\n  i <- j * 32;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX1[i+31:i])*SCALE + DISP;\n  IF MASK[31+i] THEN\n     DEST[i +31:i] <- FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +31:i] <- 0;\nENDFOR\n(non-masked elements of the mask register have the content of respective element\nVGATHERQPS (VEX.256 version)\nFOR j<- 0 to 7\n  i <- j * 32;\n  IF MASK[31+i] THEN\n     MASK[i +31:i] <- 0xFFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +31:i] <- 0;\n  FI;\nENDFOR\nFOR j<- 0 to 3\n  k <- j * 64;\n  i <- j * 32;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX1[k+63:k])*SCALE + DISP;\n  IF MASK[31+i] THEN\n     DEST[i +31:i] <- FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +31:i] <- 0;\nENDFOR\nMASK[VLMAX-1:128] <- 0;\nDEST[VLMAX-1:128] <- 0;\n(non-masked elements of the mask register have the content of respective element\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| VGATHERDPS:        | __m128 _mm_i32gather_ps (float const    \n|                    | * base, __m128i index, const int scale);\n| VGATHERDPS:        | __m128 _mm_mask_i32gather_ps (__m128    \n|                    | src, float const * base, __m128i index, \n|                    | __m128 mask, const int scale);          \n| VGATHERDPS:        | __m256 _mm256_i32gather_ps (float const \n|                    | * base, __m256i index, const int scale);\n| VGATHERDPS: scale);| __m256 _mm256_mask_i32gather_ps (__m256 \n|                    | src, float const * base, __m256i index, \n|                    | __m256 mask, const int                  \n| VGATHERQPS:        | __m128 _mm_i64gather_ps (float const    \n|                    | * base, __m128i index, const int scale);\n| VGATHERQPS:        | __m128 _mm_mask_i64gather_ps (__m128    \n|                    | src, float const * base, __m128i index, \n|                    | __m128 mask, const int scale);          \n| VGATHERQPS:        | __m128 _mm256_i64gather_ps (float const \n|                    | * base, __m256i index, const int scale);\n| VGATHERQPS: scale);| __m128 _mm256_mask_i64gather_ps (__m128 \n|                    | src, float const * base, __m256i index, \n|                    | __m128 mask, const int                  \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 12\n\n", 
      "mnem": "VGATHERDPS"
    }, 
    {
      "description": "-R:VGATHERDPD", 
      "mnem": "VGATHERQPD"
    }, 
    {
      "description": "-R:VGATHERDPS", 
      "mnem": "VGATHERQPS"
    }, 
    {
      "description": "\nVINSERTF128  -  Insert Packed Floating-Point Values:\n| Opcode/Instruction                         | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                              \n| VEX.NDS.256.66.0F3A.W0 18 /r ib VINSERTF128| RVM  | V/V           | AVX               | Insert a single precision floating-point \n| ymm1, ymm2, xmm3/m128, imm8                |      |               |                   | value selected by imm8 from xmm3/m128    \n|                                            |      |               |                   | into ymm2 at the specified destination   \n|                                            |      |               |                   | element specified by imm8 and zero out   \n|                                            |      |               |                   | destination elements in ymm1 as indicated\n|                                            |      |               |                   | in imm8.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2   | Operand 3    | Operand 4\n| RVM  | ModRM:reg (w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n\nDescription:\nPerforms an insertion of 128-bits of packed floating-point values from the second\nsource operand (third operand) into an the destination operand (first operand)\nat an 128-bit offset from imm8[0]. The remaining portions of the destination\nare written by the corresponding fields of the first source operand (second\noperand). The second source operand can be either an XMM register or a 128-bit\nmemory location. The high 7 bits of the immediate are ignored.\n\nOperation:\n\nTEMP[255:0] <- SRC1[255:0]\nCASE (imm8[0]) OF\n  0: TEMP[127:0] <- SRC2[127:0]\n  1: TEMP[255:128] <- SRC2[127:0]\nESAC\nDEST <-TEMP\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| INSERTF128:| __m256 _mm256_insertf128_ps (__m256     \n|            | a, __m128 b, int offset);               \n| INSERTF128:| __m256d _mm256_insertf128_pd (__m256d   \n|            | a, __m128d b, int offset);              \n| INSERTF128:| __m256i _mm256_insertf128_si256 (__m256i\n|            | a, __m128i b, int offset);              \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 6; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "VINSERTF128"
    }, 
    {
      "description": "\nVINSERTI128  -  Insert Packed Integer Values:\n| Opcode/Instruction                         | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                           \n| VEX.NDS.256.66.0F3A.W0 38 /r ib VINSERTI128| RVMI | V/V            | AVX2              | Insert 128-bits of integer data from  \n| ymm1, ymm2, xmm3/m128, imm8                |      |                |                   | xmm3/mem and the remaining values from\n|                                            |      |                |                   | ymm2 into ymm1.                       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3    | Operand 4\n| RVMI | ModRM:reg (w)| VEX.vvvv | ModRM:r/m (r)| Imm8     \n\nDescription:\nPerforms an insertion of 128-bits of packed integer data from the second source\noperand (third operand) into an the destination operand (first operand) at a\n128-bit offset from imm8[0]. The remaining portions of the destination are written\nby the corresponding fields of the first source operand (second operand). The\nsecond source operand can be either an XMM register or a 128-bit memory location.\nThe high 7 bits of the immediate are ignored. VEX.L must be 1; an attempt to\nexecute this instruction with VEX.L=0 will cause #UD.\n\nOperation:\n\nVINSERTI128\nTEMP[255:0] <- SRC1[255:0]\nCASE (imm8[0]) OF\n  0: TEMP[127:0] <-SRC2[127:0]\n  1: TEMP[255:128] <- SRC2[127:0]\nESAC\nDEST <-TEMP\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVINSERTI128: __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, int offset);\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 6; additionally\n\n| #UD| If VEX.L = 0, If VEX.W = 1.\n", 
      "mnem": "VINSERTI128"
    }, 
    {
      "description": "\nVMASKMOV - Conditional SIMD Packed Loads and Stores:\n| Opcode/Instruction                     | Op/En| 64/32-bit Mode| CPUID Feature Flag| Description                                \n| VEX.NDS.128.66.0F38.W0 2C /r VMASKMOVPS| RVM  | V/V           | AVX               | Conditionally load packed single-precision \n| xmm1, xmm2, m128                       |      |               |                   | values from m128 using mask in xmm2        \n|                                        |      |               |                   | and store in xmm1.                         \n| VEX.NDS.256.66.0F38.W0 2C /r VMASKMOVPS| RVM  | V/V           | AVX               | Conditionally load packed single-precision \n| ymm1, ymm2, m256                       |      |               |                   | values from m256 using mask in ymm2        \n|                                        |      |               |                   | and store in ymm1.                         \n| VEX.NDS.128.66.0F38.W0 2D /r VMASKMOVPD| RVM  | V/V           | AVX               | Conditionally load packed double-precision \n| xmm1, xmm2, m128                       |      |               |                   | values from m128 using mask in xmm2        \n|                                        |      |               |                   | and store in xmm1.                         \n| VEX.NDS.256.66.0F38.W0 2D /r VMASKMOVPD| RVM  | V/V           | AVX               | Conditionally load packed double-precision \n| ymm1, ymm2, m256                       |      |               |                   | values from m256 using mask in ymm2        \n|                                        |      |               |                   | and store in ymm1.                         \n| VEX.NDS.128.66.0F38.W0 2E /r VMASKMOVPS| MVR  | V/V           | AVX               | Conditionally store packed single-precision\n| m128, xmm1, xmm2                       |      |               |                   | values from xmm2 using mask in xmm1.       \n| VEX.NDS.256.66.0F38.W0 2E /r VMASKMOVPS| MVR  | V/V           | AVX               | Conditionally store packed single-precision\n| m256, ymm1, ymm2                       |      |               |                   | values from ymm2 using mask in ymm1.       \n| VEX.NDS.128.66.0F38.W0 2F /r VMASKMOVPD| MVR  | V/V           | AVX               | Conditionally store packed double-precision\n| m128, xmm1, xmm2                       |      |               |                   | values from xmm2 using mask in xmm1.       \n| VEX.NDS.256.66.0F38.W0 2F /r VMASKMOVPD| MVR  | V/V           | AVX               | Conditionally store packed double-precision\n| m256, ymm1, ymm2                       |      |               |                   | values from ymm2 using mask in ymm1.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2   | Operand 3    | Operand 4\n| RVM  | ModRM:reg (w)| VEX.vvvv (r)| ModRM:r/m (r)| NA       \n| MVR  | ModRM:r/m (w)| VEX.vvvv (r)| ModRM:reg (r)| NA       \n\nDescription:\nConditionally moves packed data elements from the second source operand into\nthe corresponding data element of the destination operand, depending on the\nmask bits associated with each data element. The mask bits are specified in\nthe first source operand. The mask bit for each data element is the most significant\nbit of that element in the first source operand. If a mask is 1, the corresponding\ndata element is copied from the second source operand to the destination operand.\nIf the mask is 0, the corresponding data element is set to zero in the load\nform of these instructions, and unmodified in the store form. The second source\noperand is a memory address for the load form of these instruction. The destination\noperand is a memory address for the store form of these instructions. The other\noperands are both XMM registers (for VEX.128 version) or YMM registers (for\nVEX.256 version). Faults occur only due to mask-bit required memory accesses\nthat caused the faults. Faults will not occur due to referencing any memory\nlocation if the corresponding mask bit for that memory location is 0. For example,\nno faults will be detected if the mask bits are all zero. Unlike previous MASKMOV\ninstructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to\nthese instructions. Instruction behavior on alignment check reporting with mask\nbits of less than all 1s are the same as with mask bits of all 1s. VMASKMOV\nshould not be used to access memory mapped I/O and un-cached memory as the access\nand the ordering of the individual loads or stores it does is implementation\nspecific.\n\nIn cases where mask bits indicate data should not be loaded or stored paging\nA and D bits will be set in an implementation dependent way. However, A and\nD bits are always set for pages where data is actually loaded/stored. Note:\nfor load forms, the first source (the mask) is encoded in VEX.vvvv; the second\nsource is encoded in rm_field, and the destination register is encoded in reg_field.\nNote: for store forms, the first source (the mask) is encoded in VEX.vvvv; the\nsecond source register is encoded in reg_field, and the destination memory location\nis encoded in rm_field.\n\nOperation:\n\nVMASKMOVPS -128-bit load\nDEST[31:0] <- IF (SRC1[31]) Load_32(mem) ELSE 0\nDEST[63:32] <- IF (SRC1[63]) Load_32(mem + 4) ELSE 0\nDEST[95:64] <- IF (SRC1[95]) Load_32(mem + 8) ELSE 0\nDEST[127:97] <- IF (SRC1[127]) Load_32(mem + 12) ELSE 0\nDEST[VLMAX-1:128] <- 0\nDEST[31:0] <- IF (SRC1[31]) Load_32(mem) ELSE 0\nDEST[63:32] <- IF (SRC1[63]) Load_32(mem + 4) ELSE 0\nDEST[95:64] <- IF (SRC1[95]) Load_32(mem + 8) ELSE 0\nDEST[127:96] <- IF (SRC1[127]) Load_32(mem + 12) ELSE 0\nDEST[159:128] <- IF (SRC1[159]) Load_32(mem + 16) ELSE 0\nDEST[191:160] <- IF (SRC1[191]) Load_32(mem + 20) ELSE 0\nDEST[223:192] <- IF (SRC1[223]) Load_32(mem + 24) ELSE 0\nDEST[255:224] <- IF (SRC1[255]) Load_32(mem + 28) ELSE 0\nVMASKMOVPD - 128-bit load\nDEST[63:0] <- IF (SRC1[63]) Load_64(mem) ELSE 0\nDEST[127:64] <- IF (SRC1[127]) Load_64(mem + 16) ELSE 0\nDEST[VLMAX-1:128] <- 0\nVMASKMOVPD - 256-bit load\nDEST[63:0] <- IF (SRC1[63]) Load_64(mem) ELSE 0\nDEST[127:64] <- IF (SRC1[127]) Load_64(mem + 8) ELSE 0\nDEST[195:128] <- IF (SRC1[191]) Load_64(mem + 16) ELSE 0\nDEST[255:196] <- IF (SRC1[255]) Load_64(mem + 24) ELSE 0\nVMASKMOVPS - 128-bit store\nIF (SRC1[31]) DEST[31:0] <- SRC2[31:0]\nIF (SRC1[63]) DEST[63:32] <- SRC2[63:32]\nIF (SRC1[95]) DEST[95:64] <- SRC2[95:64]\nIF (SRC1[127]) DEST[127:96] <- SRC2[127:96]\nVMASKMOVPS - 256-bit store\nIF (SRC1[31]) DEST[31:0] <- SRC2[31:0]\nIF (SRC1[63]) DEST[63:32] <- SRC2[63:32]\nIF (SRC1[95]) DEST[95:64] <- SRC2[95:64]\nIF (SRC1[127]) DEST[127:96] <- SRC2[127:96]\nIF (SRC1[159]) DEST[159:128] <-SRC2[159:128]\nIF (SRC1[191]) DEST[191:160] <- SRC2[191:160]\nIF (SRC1[223]) DEST[223:192] <- SRC2[223:192]\nIF (SRC1[255]) DEST[255:224] <- SRC2[255:224]\nVMASKMOVPD - 128-bit store\nIF (SRC1[63]) DEST[63:0] <- SRC2[63:0]\nIF (SRC1[127]) DEST[127:64] <-SRC2[127:64]\nVMASKMOVPD - 256-bit store\nIF (SRC1[63]) DEST[63:0] <- SRC2[63:0]\nIF (SRC1[127]) DEST[127:64] <-SRC2[127:64]\nVMASKMOVPS - 256-bit load\nIF (SRC1[191]) DEST[191:128] <- SRC2[191:128]\nIF (SRC1[255]) DEST[255:192] <- SRC2[255:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| __m256                                | _mm256_maskload_ps(float const *a, __m256i\n|                                       | mask)                                     \n| void __m256d _mm256_maskload_pd(double| _mm256_maskstore_ps(float *a, __m256i     \n| *a, __m256i mask);                    | mask, __m256 b)                           \n| void __m128 _mm128_maskload_ps(float  | _mm256_maskstore_pd(double *a, __m256i    \n| const *a, __m128i mask)               | mask, __m256d b);                         \n| void __m128d _mm128_maskload_pd(double| _mm128_maskstore_ps(float *a, __m128i     \n| *a, __m128i mask);                    | mask, __m128 b)                           \n| void                                  | _mm128_maskstore_pd(double *a, __m128i    \n|                                       | mask, __m128d b);                         \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 6 (No AC# reported for any mask bit combinations); additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "VMASKMOV"
    }, 
    {
      "description": "\nVPBLENDD  -  Blend Packed Dwords:\n| Opcode/Instruction                      | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                          \n| VEX.NDS.128.66.0F3A.W0 02 /r ib VPBLENDD| RVMI | V/V            | AVX2              | Select dwords from xmm2 and xmm3/m128\n| xmm1, xmm2, xmm3/m128, imm8             |      |                |                   | from mask specified in imm8 and store\n|                                         |      |                |                   | the values into xmm1.                \n| VEX.NDS.256.66.0F3A.W0 02 /r ib VPBLENDD| RVMI | V/V            | AVX2              | Select dwords from ymm2 and ymm3/m256\n| ymm1, ymm2, ymm3/m256, imm8             |      |                |                   | from mask specified in imm8 and store\n|                                         |      |                |                   | the values into ymm1.                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3    | Operand 4\n| RVMI | ModRM:reg (w)| VEX.vvvv | ModRM:r/m (r)| Imm8     \n\nDescription:\nDword elements from the source operand (second operand) are conditionally written\nto the destination operand (first operand) depending on bits in the immediate\noperand (third operand). The immediate bits (bits 7:0) form a mask that determines\nwhether the corresponding word in the destination is copied from the source.\nIf a bit in the mask, corresponding to a word, is \u201c1\", then the word is copied,\nelse the word is unchanged. VEX.128 encoded version: The second source operand\ncan be an XMM register or a 128-bit memory location. The first source and destination\noperands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register\nare zeroed. VEX.256 encoded version: The first source operand is a YMM register.\nThe second source operand is a YMM register or a 256-bit memory location. The\ndestination operand is a YMM register.\n\nOperation:\n\nVPBLENDD (VEX.256 encoded version)\nIF (imm8[0] == 1) THEN DEST[31:0] <- SRC2[31:0]\nELSE DEST[31:0] <- SRC1[31:0]\nIF (imm8[1] == 1) THEN DEST[63:32] <- SRC2[63:32]\nELSE DEST[63:32] <- SRC1[63:32]\nIF (imm8[2] == 1) THEN DEST[95:64] <- SRC2[95:64]\nELSE DEST[95:64] <- SRC1[95:64]\nIF (imm8[3] == 1) THEN DEST[127:96] <- SRC2[127:96]\nELSE DEST[127:96] <- SRC1[127:96]\nIF (imm8[4] == 1) THEN DEST[159:128] <- SRC2[159:128]\nELSE DEST[159:128] <- SRC1[159:128]\nIF (imm8[5] == 1) THEN DEST[191:160] <- SRC2[191:160]\nELSE DEST[191:160] <- SRC1[191:160]\nIF (imm8[6] == 1) THEN DEST[223:192] <- SRC2[223:192]\nELSE DEST[223:192] <- SRC1[223:192]\nIF (imm8[7] == 1) THEN DEST[255:224] <- SRC2[255:224]\nELSE DEST[255:224] <- SRC1[255:224]\nVPBLENDD (VEX.128 encoded version)\nIF (imm8[0] == 1) THEN DEST[31:0] <- SRC2[31:0]\nELSE DEST[31:0] <- SRC1[31:0]\nIF (imm8[1] == 1) THEN DEST[63:32] <- SRC2[63:32]\nELSE DEST[63:32] <- SRC1[63:32]\nIF (imm8[2] == 1) THEN DEST[95:64] <- SRC2[95:64]\nELSE DEST[95:64] <- SRC1[95:64]\nIF (imm8[3] == 1) THEN DEST[127:96] <- SRC2[127:96]\nELSE DEST[127:96] <- SRC1[127:96]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| VPBLENDD:| __m128i _mm_blend_epi32 (__m128i v1,\n|          | __m128i v2, const int mask)         \n| VPBLENDD:| __m256i _mm256_blend_epi32 (__m256i \n|          | v1, __m256i v2, const int mask)     \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "VPBLENDD"
    }, 
    {
      "description": "\nVPBROADCAST - Broadcast Integer Data:\n| Opcode/Instruction                     | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                            \n| VEX.128.66.0F38.W0 78 /r VPBROADCASTB  | RM   | V/V            | AVX2              | Broadcast a byte integer in the source \n| xmm1, xmm2/m8                          |      |                |                   | operand to sixteen locations in xmm1.  \n| VEX.256.66.0F38.W0 78 /r VPBROADCASTB  | RM   | V/V            | AVX2              | Broadcast a byte integer in the source \n| ymm1, xmm2/m8                          |      |                |                   | operand to thirtytwo locations in ymm1.\n| VEX.128.66.0F38.W0 79 /r VPBROADCASTW  | RM   | V/V            | AVX2              | Broadcast a word integer in the source \n| xmm1, xmm2/m16                         |      |                |                   | operand to eight locations in xmm1.    \n| VEX.256.66.0F38.W0 79 /r VPBROADCASTW  | RM   | V/V            | AVX2              | Broadcast a word integer in the source \n| ymm1, xmm2/m16                         |      |                |                   | operand to sixteen locations in ymm1.  \n| VEX.128.66.0F38.W0 58 /r VPBROADCASTD  | RM   | V/V            | AVX2              | Broadcast a dword integer in the source\n| xmm1, xmm2/m32                         |      |                |                   | operand to four locations in xmm1.     \n| VEX.256.66.0F38.W0 58 /r VPBROADCASTD  | RM   | V/V            | AVX2              | Broadcast a dword integer in the source\n| ymm1, xmm2/m32                         |      |                |                   | operand to eight locations in ymm1.    \n| VEX.128.66.0F38.W0 59 /r VPBROADCASTQ  | RM   | V/V            | AVX2              | Broadcast a qword element in mem to    \n| xmm1, xmm2/m64                         |      |                |                   | two locations in xmm1.                 \n| VEX.256.66.0F38.W0 59 /r VPBROADCASTQ  | RM   | V/V            | AVX2              | Broadcast a qword element in mem to    \n| ymm1, xmm2/m64                         |      |                |                   | four locations in ymm1.                \n| VEX.256.66.0F38.W0 5A /r VBROADCASTI128| RM   | V/V            | AVX2              | Broadcast 128 bits of integer data in  \n| ymm1, m128                             |      |                |                   | mem to low and high 128-bits in ymm1.  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nLoad integer data from the source operand (second operand) and broadcast to\nall elements of the destination operand (first operand). The destination operand\nis a YMM register. The source operand is 8-bit, 16-bit 32-bit, 64-bit memory\nlocation or the low 8-bit, 16-bit 32-bit, 64-bit data in an XMM register. VPBROADCASTB/D/W/Q\nalso support XMM register as the source operand. VBROADCASTI128: The destination\noperand is a YMM register. The source operand is 128-bit memory location. Register\nsource encodings for VBROADCASTI128 are reserved and will #UD. VPBROADCASTB/W/D/Q\nis supported in both 128-bit and 256-bit wide versions.\n\nVBROADCASTI128 is only supported as a 256-bit wide version. Note: In VEX-encoded\nversions, VEX.vvvv is reserved and must be 1111b otherwise instructions will\n#UD. Attempts to execute any VPBROADCAST* instruction with VEX.W = 1 will cause\n#UD. If VBROADCASTI128 is encoded with VEX.L= 0, an attempt to execute the instruction\nencoded with VEX.L= 0 will cause an #UD exception.\n\n| m32                                     | X0                \n| X0                                      | X0                \n| VPBROADCASTD Operation (VEX.256 encoded | Figure 4-33.      \n| version)                                |                   \n| m32                                     | X0                \n| X0                                      | X0                \n| VPBROADCASTD Operation (128-bit version)| Figure 4-34. X0 X0\n| VPBROADCASTQ Operation                  | Figure 4-35. X0 X0\n| VBROADCASTI128 Operation                | Figure 4-36.      \nOperation:\n\nVPBROADCASTB (VEX.128 encoded version)\ntemp <- SRC[7:0]\nFOR j <- 0 TO 15\nDEST[7+j*8: j*8] <- temp\nENDFOR\nDEST[VLMAX-1:128] <- 0\nVPBROADCASTB (VEX.256 encoded version)\ntemp <- SRC[7:0]\nFOR j <- 0 TO 31\nDEST[7+j*8: j*8] <- temp\nENDFOR\nVPBROADCASTW (VEX.128 encoded version)\ntemp <- SRC[15:0]\nFOR j <- 0 TO 7\nDEST[15+j*16: j*16] <- temp\nENDFOR\nDEST[VLMAX-1:128] <- 0\nVPBROADCASTW (VEX.256 encoded version)\ntemp <- SRC[15:0]\nFOR j <- 0 TO 15\nDEST[15+j*16: j*16] <- temp\nENDFOR\nVPBROADCASTD (128 bit version)\ntemp <- SRC[31:0]\nFOR j <- 0 TO 3\nDEST[31+j*32: j*32] <- temp\nENDFOR\nDEST[VLMAX-1:128] <- 0\nVPBROADCASTD (VEX.256 encoded version)\ntemp <- SRC[31:0]\nFOR j <- 0 TO 7\nDEST[31+j*32: j*32] <- temp\nENDFOR\nVPBROADCASTQ (VEX.128 encoded version)\ntemp <- SRC[63:0]\nDEST[63:0] <- temp\nDEST[127:64] <- temp\nDEST[VLMAX-1:128] <- 0\nVPBROADCASTQ (VEX.256 encoded version)\ntemp <- SRC[63:0]\nDEST[63:0] <- temp\nDEST[127:64] <- temp\nDEST[191:128] <- temp\nDEST[255:192] <- temp\nVBROADCASTI128\ntemp <- SRC[127:0]\nDEST[127:0] <- temp\nDEST[VLMAX-1:128] <- temp\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| VPBROADCASTB:  | __m256i _mm256_broadcastb_epi8(__m128i     \n|                | );                                         \n| VPBROADCASTW:  | __m256i _mm256_broadcastw_epi16(__m128i    \n|                | );                                         \n| VPBROADCASTD:  | __m256i _mm256_broadcastd_epi32(__m128i    \n|                | );                                         \n| VPBROADCASTQ:  | __m256i _mm256_broadcastq_epi64(__m128i    \n|                | );                                         \n| VPBROADCASTB:  | __m128i _mm_broadcastb_epi8(__m128i        \n|                | );                                         \n| VPBROADCASTW:  | __m128i _mm_broadcastw_epi16(__m128i       \n|                | );                                         \n| VPBROADCASTD:  | __m128i _mm_broadcastd_epi32(__m128i       \n|                | );                                         \n| VPBROADCASTQ:  | __m128i _mm_broadcastq_epi64(__m128i       \n|                | );                                         \n| VBROADCASTI128:| __m256i _mm256_broadcastsi128_si256(__m128i\n|                | );                                         \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 6; additionally\n\n| #UD| If VEX.W = 1, If VEX.L = 0 for VBROADCASTI128.\n", 
      "mnem": "VPBROADCAST"
    }, 
    {
      "description": "\nVPERM2F128  -  Permute Floating-Point Values:\n| Opcode/Instruction                        | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                          \n| VEX.NDS.256.66.0F3A.W0 06 /r ib VPERM2F128| RVMI | V/V                   | AVX               | Permute 128-bit floating-point fields\n| ymm1, ymm2, ymm3/m256, imm8               |      |                       |                   | in ymm2 and ymm3/mem using controls  \n|                                           |      |                       |                   | from imm8 and store result in ymm1.  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2   | Operand 3    | Operand 4\n| RVMI | ModRM:reg (w)| VEX.vvvv (r)| ModRM:r/m (r)| imm8     \n\nDescription:\nPermute 128 bit floating-point-containing fields from the first source operand\n(second operand) and second source operand (third operand) using bits in the\n8-bit immediate and store results in the destination operand (first operand).\nThe first source operand is a YMM register, the second source operand is a YMM\nregister or a 256-bit memory location, and the destination operand is a YMM\nregister.\n\n| SRC2| Y1                            | Y0                                    \n| SRC1| X1                            | X0                                    \n| DEST| X0, X1, Y0, or Y1 Figure 4-42.| X0, X1, Y0, or Y1 VPERM2F128 Operation\nImm8[1:0] select the source for the first destination 128-bit field, imm8[5:4]\nselect the source for the second destination field. If imm8[3] is set, the low\n128-bit field is zeroed. If imm8[7] is set, the high 128-bit field is zeroed.\nVEX.L must be 1, otherwise the instruction will #UD.\n\nOperation:\n\nVPERM2F128\nCASE IMM8[1:0] of\n0: DEST[127:0] <- SRC1[127:0]\n1: DEST[127:0] <- SRC1[255:128]\n2: DEST[127:0] <- SRC2[127:0]\n3: DEST[127:0] <- SRC2[255:128]\nESAC\nCASE IMM8[5:4] of\n0: DEST[255:128] <- SRC1[127:0]\n1: DEST[255:128] <- SRC1[255:128]\n2: DEST[255:128] <- SRC2[127:0]\n3: DEST[255:128] <- SRC2[255:128]\nESAC\nIF (imm8[3])\nDEST[127:0] <- 0\nFI\nIF (imm8[7])\nDEST[VLMAX-1:128] <- 0\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| VPERM2F128:| __m256 _mm256_permute2f128_ps (__m256     \n|            | a, __m256 b, int control)                 \n| VPERM2F128:| __m256d _mm256_permute2f128_pd (__m256d   \n|            | a, __m256d b, int control)                \n| VPERM2F128:| __m256i _mm256_permute2f128_si256 (__m256i\n|            | a, __m256i b, int control)                \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 6; additionally\n\n| #UD| If VEX.L = 0 If VEX.W = 1.\n", 
      "mnem": "VPERM2F128"
    }, 
    {
      "description": "\nVPERM2I128  -  Permute Integer Values:\n| Opcode/Instruction                        | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                          \n| VEX.NDS.256.66.0F3A.W0 46 /r ib VPERM2I128| RVMI | V/V            | AVX2              | Permute 128-bit integer data in ymm2 \n| ymm1, ymm2, ymm3/m256, imm8               |      |                |                   | and ymm3/mem using controls from imm8\n|                                           |      |                |                   | and store result in ymm1.            \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3    | Operand 4\n| RVMI | ModRM:reg (w)| VEX.vvvv | ModRM:r/m (r)| Imm8     \n\nDescription:\nPermute 128 bit integer data from the first source operand (second operand)\nand second source operand (third operand) using bits in the 8-bit immediate\nand store results in the destination operand (first operand). The first source\noperand is a YMM register, the second source operand is a YMM register or a\n256-bit memory location, and the destination operand is a YMM register.\n\n| SRC2| Y1                            | Y0                                    \n| SRC1| X1                            | X0                                    \n| DEST| X0, X1, Y0, or Y1 Figure 4-37.| X0, X1, Y0, or Y1 VPERM2I128 Operation\nImm8[1:0] select the source for the first destination 128-bit field, imm8[5:4]\nselect the source for the second destination field. If imm8[3] is set, the low\n128-bit field is zeroed. If imm8[7] is set, the high 128-bit field is zeroed.\nVEX.L must be 1, otherwise the instruction will #UD.\n\nOperation:\n\nVPERM2I128\nCASE IMM8[1:0] of\n0: DEST[127:0] <- SRC1[127:0]\n1: DEST[127:0] <- SRC1[255:128]\n2: DEST[127:0] <- SRC2[127:0]\n3: DEST[127:0] <- SRC2[255:128]\nESAC\nCASE IMM8[5:4] of\n0: DEST[255:128] <- SRC1[127:0]\n1: DEST[255:128] <- SRC1[255:128]\n2: DEST[255:128] <- SRC2[127:0]\n3: DEST[255:128] <- SRC2[255:128]\nESAC\nIF (imm8[3])\nDEST[127:0] <- 0\nFI\nIF (imm8[7])\nDEST[255:128] <- 0\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVPERM2I128: __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, int control)\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 6; additionally\n\n| #UD| If VEX.L = 0, If VEX.W = 1.\n", 
      "mnem": "VPERM2I128"
    }, 
    {
      "description": "\nVPERMD  -  Full Doublewords Element Permutation:\n| Opcode/Instruction                 | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                           \n| VEX.NDS.256.66.0F38.W0 36 /r VPERMD| RVM  | V/V            | AVX2              | Permute doublewords in ymm3/m256 using\n| ymm1, ymm2, ymm3/m256              |      |                |                   | indexes in ymm2 and store the result  \n|                                    |      |                |                   | in ymm1.                              \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3    | Operand 4\n| RVM  | ModRM:reg (w)| VEX.vvvv | ModRM:r/m (r)| NA       \n\nDescription:\nUse the index values in each dword element of the first source operand (the\nsecond operand) to select a dword element in the second source operand (the\nthird operand), the resultant dword value from the second source operand is\ncopied to the destination operand (the first operand) in the corresponding position\nof the index element. Note that this instruction permits a doubleword in the\nsource operand to be copied to more than one doubleword location in the destination\noperand. An attempt to execute VPERMD encoded with VEX.L= 0 will cause an #UD\nexception.\n\nOperation:\n\nVPERMD (VEX.256 encoded version)\nDEST[31:0] <- (SRC2[255:0] >> (SRC1[2:0] * 32))[31:0];\nDEST[63:32] <- (SRC2[255:0] >> (SRC1[34:32] * 32))[31:0];\nDEST[95:64] <- (SRC2[255:0] >> (SRC1[66:64] * 32))[31:0];\nDEST[127:96] <- (SRC2[255:0] >> (SRC1[98:96] * 32))[31:0];\nDEST[159:128] <- (SRC2[255:0] >> (SRC1[130:128] * 32))[31:0];\nDEST[191:160] <- (SRC2[255:0] >> (SRC1[162:160] * 32))[31:0];\nDEST[223:192] <- (SRC2[255:0] >> (SRC1[194:192] * 32))[31:0];\nDEST[255:224] <- (SRC2[255:0] >> (SRC1[226:224] * 32))[31:0];\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVPERMD: __m256i _mm256_permutevar8x32_epi32(__m256i a, __m256i offsets);\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 0 for VPERMD, If VEX.W =\n|    | 1.                                 \n", 
      "mnem": "VPERMD"
    }, 
    {
      "description": "\nVPERMILPD  -  Permute Double-Precision Floating-Point Values:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| VEX.NDS.128.66.0F38.W0 0D /r VPERMILPD| RVM  | V/V                   | AVX               | Permute double-precision floating-point    \n| xmm1, xmm2, xmm3/m128                 |      |                       |                   | values in xmm2 using controls from xmm3/mem\n|                                       |      |                       |                   | and store result in xmm1.                  \n| VEX.NDS.256.66.0F38.W0 0D /r VPERMILPD| RVM  | V/V                   | AVX               | Permute double-precision floating-point    \n| ymm1, ymm2, ymm3/m256                 |      |                       |                   | values in ymm2 using controls from ymm3/mem\n|                                       |      |                       |                   | and store result in ymm1.                  \n| VEX.128.66.0F3A.W0 05 /r ib VPERMILPD | RMI  | V/V                   | AVX               | Permute double-precision floating-point    \n| xmm1, xmm2/m128, imm8                 |      |                       |                   | values in xmm2/mem using controls from     \n|                                       |      |                       |                   | imm8.                                      \n| VEX.256.66.0F3A.W0 05 /r ib VPERMILPD | RMI  | V/V                   | AVX               | Permute double-precision floating-point    \n| ymm1, ymm2/m256, imm8                 |      |                       |                   | values in ymm2/mem using controls from     \n|                                       |      |                       |                   | imm8.                                      \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8         | NA       \n\nDescription:\nPermute double-precision floating-point values in the first source operand (second\noperand) using 8-bit control fields in the low bytes of the second source operand\n(third operand) and store results in the destination operand (first operand).\nThe first source operand is a YMM register, the second source operand is a YMM\nregister or a 256bit memory location, and the destination operand is a YMM register.\n\n| SRC1| X3                 | X2                        | X1    | X0    \n| DEST| X2..X3 Figure 4-38.| X2..X3 VPERMILPD operation| X0..X1| X0..X1\nThere is one control byte per destination double-precision element. Each control\nbyte is aligned with the low 8 bits of the corresponding double-precision destination\nelement. Each control byte contains a 1-bit select field (see Figure 4-39) that\ndetermines which of the source elements are selected. Source elements are restricted\nto lie in the same source 128-bit region as the destination.\n\nBit\n\n| 255| 194 193 sel Control Field 4 Figure 4-39.| 127 VPERMILPD Shuffle Control| 66 ignored Control Field 2| 65 sel| 63| 2 ignored Control Field1| 1 sel\n(immediate control version) Permute double-precision floating-point values in\nthe first source operand (second operand) using two, 1-bit control fields in\nthe low 2 bits of the 8-bit immediate and store results in the destination operand\n(first operand). The source operand is a YMM register or 256-bit memory location\nand the destination operand is a YMM register. Note: For the VEX.128.66.0F3A\n05 instruction version, VEX.vvvv is reserved and must be 1111b otherwise instruction\nwill #UD. Note: For the VEX.256.66.0F3A 05 instruction version, VEX.vvvv is\nreserved and must be 1111b otherwise instruction will #UD.\n\nOperation:\n\nVPERMILPD (256-bit immediate version)\nIF (imm8[0] = 0) THEN DEST[63:0]<-SRC1[63:0]\nIF (imm8[0] = 1) THEN DEST[63:0]<-SRC1[127:64]\nIF (imm8[1] = 0) THEN DEST[127:64]<-SRC1[63:0]\nIF (imm8[1] = 1) THEN DEST[127:64]<-SRC1[127:64]\nIF (imm8[2] = 0) THEN DEST[191:128]<-SRC1[191:128]\nIF (imm8[2] = 1) THEN DEST[191:128]<-SRC1[255:192]\nIF (imm8[3] = 0) THEN DEST[255:192]<-SRC1[191:128]\nIF (imm8[3] = 1) THEN DEST[255:192]<-SRC1[255:192]\nVPERMILPD (128-bit immediate version)\nIF (imm8[0] = 0) THEN DEST[63:0]<-SRC1[63:0]\nIF (imm8[0] = 1) THEN DEST[63:0]<-SRC1[127:64]\nIF (imm8[1] = 0) THEN DEST[127:64]<-SRC1[63:0]\nIF (imm8[1] = 1) THEN DEST[127:64]<-SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\nVPERMILPD (256-bit variable version)\nIF (SRC2[1] = 0) THEN DEST[63:0]<-SRC1[63:0]\nIF (SRC2[1] = 1) THEN DEST[63:0]<-SRC1[127:64]\nIF (SRC2[65] = 0) THEN DEST[127:64]<-SRC1[63:0]\nIF (SRC2[65] = 1) THEN DEST[127:64]<-SRC1[127:64]\nIF (SRC2[129] = 0) THEN DEST[191:128]<-SRC1[191:128]\nIF (SRC2[129] = 1) THEN DEST[191:128]<-SRC1[255:192]\nIF (SRC2[193] = 0) THEN DEST[255:192]<-SRC1[191:128]\nIF (SRC2[193] = 1) THEN DEST[255:192]<-SRC1[255:192]\nVPERMILPD (128-bit variable version)\nIF (SRC2[1] = 0) THEN DEST[63:0]<-SRC1[63:0]\nIF (SRC2[1] = 1) THEN DEST[63:0]<-SRC1[127:64]\nIF (SRC2[65] = 0) THEN DEST[127:64]<-SRC1[63:0]\nIF (SRC2[65] = 1) THEN DEST[127:64]<-SRC1[127:64]\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| VPERMILPD:| __m128d _mm_permute_pd (__m128d a, int\n|           | control)                              \n| VPERMILPD:| __m256d _mm256_permute_pd (__m256d a, \n|           | int control)                          \n| VPERMILPD:| __m128d _mm_permutevar_pd (__m128d a, \n|           | __m128i control);                     \n| VPERMILPD:| __m256d _mm256_permutevar_pd (__m256d \n|           | a, __m256i control);                  \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 6; additionally\n\n| #UD| If VEX.W = 1\n", 
      "mnem": "VPERMILPD"
    }, 
    {
      "description": "\nVPERMILPS  -  Permute Single-Precision Floating-Point Values:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                                \n| VEX.NDS.128.66.0F38.W0 0C /r VPERMILPS| RVM  | V/V                   | AVX               | Permute single-precision floating-point    \n| xmm1, xmm2, xmm3/m128                 |      |                       |                   | values in xmm2 using controls from xmm3/mem\n|                                       |      |                       |                   | and store result in xmm1.                  \n| VEX.128.66.0F3A.W0 04 /r ib VPERMILPS | RMI  | V/V                   | AVX               | Permute single-precision floating-point    \n| xmm1, xmm2/m128, imm8                 |      |                       |                   | values in xmm2/mem using controls from     \n|                                       |      |                       |                   | imm8 and store result in xmm1.             \n| VEX.NDS.256.66.0F38.W0 0C /r VPERMILPS| RVM  | V/V                   | AVX               | Permute single-precision floating-point    \n| ymm1, ymm2, ymm3/m256                 |      |                       |                   | values in ymm2 using controls from ymm3/mem\n|                                       |      |                       |                   | and store result in ymm1.                  \n| VEX.256.66.0F3A.W0 04 /r ib VPERMILPS | RMI  | V/V                   | AVX               | Permute single-precision floating-point    \n| ymm1, ymm2/m256, imm8                 |      |                       |                   | values in ymm2/mem using controls from     \n|                                       |      |                       |                   | imm8 and store result in ymm1.             \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3    | Operand 4\n| RVM  | ModRM:reg (w)| VEX.vvvv (r) | ModRM:r/m (r)| NA       \n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| imm8         | NA       \n\nDescription:\n(variable control version) Permute single-precision floating-point values in\nthe first source operand (second operand) using 8-bit control fields in the\nlow bytes of corresponding elements the shuffle control (third operand) and\nstore results in the destination operand (first operand). The first source operand\nis a YMM register, the second source operand is a YMM register or a 256-bit\nmemory location, and the destination operand is a YMM register.\n\n| SRC1| X7      | X6      | X5                   | X4      | X3                         | X2     | X1      | X0      \n| DEST| X7 .. X4| X7 .. X4| X7 .. X4 Figure 4-40.| X7 .. X4| X3 ..X0 VPERMILPS Operation| X3 ..X0| X3 .. X0| X3 .. X0\nThere is one control byte per destination single-precision element. Each control\nbyte is aligned with the low 8 bits of the corresponding single-precision destination\nelement. Each control byte contains a 2-bit select field (see Figure 4-41) that\ndetermines which of the source elements are selected. Source elements are restricted\nto lie in the same source 128-bit region as the destination.\n\nBit\n\n| 255 ignored| 226 Control Field 7| 225 224 sel Figure 4-41.| 63 ignored VPERMILPS Shuffle Control| 34 Control Field 2| 33 32 sel| 31 ignored Control Field 1| 1 sel| 0\n(immediate control version) Permute single-precision floating-point values in\nthe first source operand (second operand) using four 2-bit control fields in\nthe 8-bit immediate and store results in the destination operand (first operand).\nThe source operand is a YMM register or 256-bit memory location and the destination\noperand is a YMM register. This is similar to a wider version of PSHUFD, just\noperating on single-precision floating-point values. Note: For the VEX.128.66.0F3A\n04 instruction version, VEX.vvvv is reserved and must be 1111b otherwise instruction\nwill #UD. Note: For the VEX.256.66.0F3A 04 instruction version, VEX.vvvv is\nreserved and must be 1111b otherwise instruction will #UD.\n\nOperation:\n\nSelect4(SRC, control) {\nCASE (control[1:0]) OF\n  0:\n  1:\n  2:\n  3:\nESAC;\nRETURN TMP\n}\nVPERMILPS (256-bit immediate version)\nDEST[31:0] <- Select4(SRC1[127:0], imm8[1:0]);\nDEST[63:32] <- Select4(SRC1[127:0], imm8[3:2]);\nDEST[95:64] <- Select4(SRC1[127:0], imm8[5:4]);\nDEST[127:96] <- Select4(SRC1[127:0], imm8[7:6]);\nDEST[159:128] <- Select4(SRC1[255:128], imm8[1:0]);\nDEST[191:160] <- Select4(SRC1[255:128], imm8[3:2]);\nDEST[223:192] <- Select4(SRC1[255:128], imm8[5:4]);\nDEST[255:224] <- Select4(SRC1[255:128], imm8[7:6]);\nVPERMILPS (128-bit immediate version)\nDEST[31:0] <- Select4(SRC1[127:0], imm8[1:0]);\nDEST[63:32] <- Select4(SRC1[127:0], imm8[3:2]);\nDEST[95:64] <- Select4(SRC1[127:0], imm8[5:4]);\nDEST[127:96] <- Select4(SRC1[127:0], imm8[7:6]);\nDEST[VLMAX-1:128] <- 0\nVPERMILPS (256-bit variable version)\nDEST[31:0] <- Select4(SRC1[127:0], SRC2[1:0]);\nDEST[63:32] <- Select4(SRC1[127:0], SRC2[33:32]);\nDEST[95:64] <- Select4(SRC1[127:0], SRC2[65:64]);\nDEST[127:96] <- Select4(SRC1[127:0], SRC2[97:96]);\nDEST[159:128] <- Select4(SRC1[255:128], SRC2[129:128]);\nDEST[191:160] <- Select4(SRC1[255:128], SRC2[161:160]);\nDEST[223:192] <- Select4(SRC1[255:128], SRC2[193:192]);\nDEST[255:224] <- Select4(SRC1[255:128], SRC2[225:224]);\nVPERMILPS (128-bit variable version)\nDEST[31:0] <- Select4(SRC1[127:0], SRC2[1:0]);\nDEST[63:32] <- Select4(SRC1[127:0], SRC2[33:32]);\nDEST[95:64] <- Select4(SRC1[127:0], SRC2[65:64]);\nDEST[127:96] <- Select4(SRC1[127:0], SRC2[97:96]);\nDEST[VLMAX-1:128] <- 0\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| VPERM1LPS:| __m128 _mm_permute_ps (__m128 a, int\n|           | control);                           \n| VPERM1LPS:| __m256 _mm256_permute_ps (__m256 a, \n|           | int control);                       \n| VPERM1LPS:| __m128 _mm_permutevar_ps (__m128 a, \n|           | __m128i control);                   \n| VPERM1LPS:| __m256 _mm256_permutevar_ps (__m256 \n|           | a, __m256i control);                \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 6; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "VPERMILPS"
    }, 
    {
      "description": "\nVPERMPD  -  Permute Double-Precision Floating-Point Elements:\n| Opcode/Instruction                 | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                            \n| VEX.256.66.0F3A.W1 01 /r ib VPERMPD| RMI  | V/V            | AVX2              | Permute double-precision floating-point\n| ymm1, ymm2/m256, imm8              |      |                |                   | elements in ymm2/m256 using indexes    \n|                                    |      |                |                   | in imm8 and store the result in ymm1.  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| Imm8     | NA       \n\nDescription:\nUse two-bit index values in the immediate byte to select a double-precision\nfloating-point element in the source operand; the resultant data from the source\noperand is copied to the corresponding element of the destination operand in\nthe order of the index field. Note that this instruction permits a qword in\nthe source operand to be copied to multiple location in the destination operand.\nAn attempt to execute VPERMPD encoded with VEX.L= 0 will cause an #UD exception.\n\nOperation:\n\nVPERMPD (VEX.256 encoded version)\nDEST[63:0] <- (SRC[255:0] >> (IMM8[1:0] * 64))[63:0];\nDEST[127:64] <- (SRC[255:0] >> (IMM8[3:2] * 64))[63:0];\nDEST[191:128] <- (SRC[255:0] >> (IMM8[5:4] * 64))[63:0];\nDEST[255:192] <- (SRC[255:0] >> (IMM8[7:6] * 64))[63:0];\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVPERMPD: __m256d _mm256_permute4x64_pd(__m256d a, int control) ;\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 0.\n", 
      "mnem": "VPERMPD"
    }, 
    {
      "description": "\nVPERMPS  -  Permute Single-Precision Floating-Point Elements:\n| Opcode/Instruction                  | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                            \n| VEX.NDS.256.66.0F38.W0 16 /r VPERMPS| RVM  | V/V            | AVX2              | Permute single-precision floating-point\n| ymm1, ymm2, ymm3/m256               |      |                |                   | elements in ymm3/m256 using indexes    \n|                                     |      |                |                   | in ymm2 and store the result in ymm1.  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3    | Operand 4\n| RVM  | ModRM:reg (w)| VEX.vvvv | ModRM:r/m (r)| NA       \n\nDescription:\nUse the index values in each dword element of the first source operand (the\nsecond operand) to select a singleprecision floating-point element in the second\nsource operand (the third operand), the resultant data from the second source\noperand is copied to the destination operand (the first operand) in the corresponding\nposition of the index element. Note that this instruction permits a doubleword\nin the source operand to be copied to more than one doubleword location in the\ndestination operand. An attempt to execute VPERMPS encoded with VEX.L= 0 will\ncause an #UD exception.\n\nOperation:\n\nVPERMPS (VEX.256 encoded version)\nDEST[31:0] <- (SRC2[255:0] >> (SRC1[2:0] * 32))[31:0];\nDEST[63:32] <- (SRC2[255:0] >> (SRC1[34:32] * 32))[31:0];\nDEST[95:64] <- (SRC2[255:0] >> (SRC1[66:64] * 32))[31:0];\nDEST[127:96] <- (SRC2[255:0] >> (SRC1[98:96] * 32))[31:0];\nDEST[159:128] <- (SRC2[255:0] >> (SRC1[130:128] * 32))[31:0];\nDEST[191:160] <- (SRC2[255:0] >> (SRC1[162:160] * 32))[31:0];\nDEST[223:192] <- (SRC2[255:0] >> (SRC1[194:192] * 32))[31:0];\nDEST[255:224] <- (SRC2[255:0] >> (SRC1[226:224] * 32))[31:0];\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVPERMPS: __m256i _mm256_permutevar8x32_ps(__m256 a, __m256i offsets)\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 0, If VEX.W = 1.\n", 
      "mnem": "VPERMPS"
    }, 
    {
      "description": "\nVPERMQ  -  Qwords Element Permutation:\n| Opcode/Instruction                      | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                              \n| VEX.256.66.0F3A.W1 00 /r ib VPERMQ ymm1,| RMI  | V/V            | AVX2              | Permute qwords in ymm2/m256 using indexes\n| ymm2/m256, imm8                         |      |                |                   | in imm8 and store the result in ymm1.    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RMI  | ModRM:reg (w)| ModRM:r/m (r)| Imm8     | NA       \n\nDescription:\nUse two-bit index values in the immediate byte to select a qword element in\nthe source operand, the resultant qword value from the source operand is copied\nto the corresponding element of the destination operand in the order of the\nindex field. Note that this instruction permits a qword in the source operand\nto be copied to multiple locations in the destination operand. An attempt to\nexecute VPERMQ encoded with VEX.L= 0 will cause an #UD exception.\n\nOperation:\n\nVPERMQ (VEX.256 encoded version)\nDEST[63:0] <- (SRC[255:0] >> (IMM8[1:0] * 64))[63:0];\nDEST[127:64] <- (SRC[255:0] >> (IMM8[3:2] * 64))[63:0];\nDEST[191:128] <- (SRC[255:0] >> (IMM8[5:4] * 64))[63:0];\nDEST[255:192] <- (SRC[255:0] >> (IMM8[7:6] * 64))[63:0];\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVPERMQ: __m256i _mm256_permute4x64_epi64(__m256i a, int control)\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.L = 0.\n", 
      "mnem": "VPERMQ"
    }, 
    {
      "description": "\nVPGATHERDD/VPGATHERQD  -  Gather Packed Dword Values Using Signed Dword/Qword Indices:\n| Opcode/Instruction                     | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                \n| VEX.DDS.128.66.0F38.W0 90 /r VPGATHERDD| RMV  | V/V            | AVX2              | Using dword indices specified in vm32x,    \n| xmm1, vm32x, xmm2                      |      |                |                   | gather dword values from memory conditioned\n|                                        |      |                |                   | on mask specified by xmm2. Conditionally   \n|                                        |      |                |                   | gathered elements are merged into xmm1.    \n| VEX.DDS.128.66.0F38.W0 91 /r VPGATHERQD| RMV  | V/V            | AVX2              | Using qword indices specified in vm64x,    \n| xmm1, vm64x, xmm2                      |      |                |                   | gather dword values from memory conditioned\n|                                        |      |                |                   | on mask specified by xmm2. Conditionally   \n|                                        |      |                |                   | gathered elements are merged into xmm1.    \n| VEX.DDS.256.66.0F38.W0 90 /r VPGATHERDD| RMV  | V/V            | AVX2              | Using dword indices specified in vm32y,    \n| ymm1, vm32y, ymm2                      |      |                |                   | gather dword from memory conditioned       \n|                                        |      |                |                   | on mask specified by ymm2. Conditionally   \n|                                        |      |                |                   | gathered elements are merged into ymm1.    \n| VEX.DDS.256.66.0F38.W0 91 /r VPGATHERQD| RMV  | V/V            | AVX2              | Using qword indices specified in vm64y,    \n| xmm1, vm64y, xmm2                      |      |                |                   | gather dword values from memory conditioned\n|                                        |      |                |                   | on mask specified by xmm2. Conditionally   \n|                                        |      |                |                   | gathered elements are merged into xmm1.    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1      | Operand 2                            | Operand 3      | Operand 4\n| RMV  | ModRM:reg (r,w)| BaseReg (R): VSIB:base, VectorReg(R):| VEX.vvvv (r, w)| NA       \n|      |                | VSIB:index                           |                |          \n\nDescription:\nThe instruction conditionally loads up to 4 or 8 dword values from memory addresses\nspecified by the memory operand (the second operand) and using dword indices.\nThe memory operand uses the VSIB form of the SIB byte to specify a general purpose\nregister operand as the common base, a vector register for an array of indices\nrelative to the base and a constant scale factor. The mask operand (the third\noperand) specifies the conditional load operation from each memory address and\nthe corresponding update of each data element of the destination operand (the\nfirst operand). Conditionality is specified by the most significant bit of each\ndata element of the mask register. If an element's mask bit is not set, the\ncorresponding element of the destination register is left unchanged. The width\nof data element in the destination register and mask register are identical.\nThe entire mask register will be set to zero by this instruction unless the\ninstruction causes an exception. Using qword indices, the instruction conditionally\nloads up to 2 or 4 dword values from the VSIB addressing memory operand, and\nupdates the lower half of the destination register. The upper 128 or 256 bits\nof the destination register are zero'ed with qword indices. This instruction\ncan be suspended by an exception if at least one element is already gathered\n(i.e., if the exception\n\n| is triggered by an element other than       | When this happens, the destination If \n| the rightmost one with its mask bit         | any traps or interrupts are pending   \n| set). register and the mask operand         | from already gathIt may do this to one\n| are partially updated; those elements       | or both                               \n| that have been gathered are placed into     |                                       \n| the destination register and have their     |                                       \n| mask bits set to zero. ered elements,       |                                       \n| they will be delivered in lieu of the       |                                       \n| exception; in this case, EFLAG.RF is        |                                       \n| set to one so an instruction breakpoint     |                                       \n| is not re-triggered when the instruction    |                                       \n| is continued. If the data size and index    |                                       \n| size are different, part of the destination |                                       \n| register and part of the mask register      |                                       \n| do not correspond to any elements being     |                                       \n| gathered. of those registers even if        |                                       \n| the instruction triggers an exception,      |                                       \n| and even if the instruction triggers        |                                       \n| the exception before gathering any elements.|                                       \n| VEX.128 version: For dword indices,         | For qword indices, the instruc-       \n| the instruction will gather four dword      |                                       \n| values. tion will gather two values         |                                       \n| and zeroes the upper 64 bits of the         |                                       \n| destination.                                |                                       \n| VEX.256 version: For dword indices,         | For qword indices, the instruc-       \n| the instruction will gather eight dword     |                                       \n| values.                                     |                                       \ntion will gather four values and zeroes the upper 128 bits of the destination.\nNote that:\n\n - If any pair of the index, mask, or destination registers are the same, this\ninstruction results a UD fault.\n - The values may be read from memory in any order. Memory ordering with other\ninstructions follows the Intel64 memory-ordering model.\n - Faults are delivered in a right-to-left manner. That is, if a fault is triggered\nby an element and delivered, all elements closer to the LSB of the destination\nwill be completed (and non-faulting). Individual elements closer to the MSB\nmay or may not be completed. If a given element triggers multiple faults, they\nare delivered in the conventional order.\n - Elements may be gathered in any order, but faults must be delivered in a right-to-left\norder; thus, elements to the left of a faulting one may be gathered before the\nfault is delivered. A given implementation of this instruction is repeatable\n- given the same input values and architectural state, the same set of elements\nto the left of the faulting one will be gathered.\n - This instruction does not perform AC checks, and so will never deliver an AC\nfault.\n - This instruction will cause a #UD if the address size attribute is 16-bit.\n - This instruction will cause a #UD if the memory operand is encoded without the\nSIB byte.\n - This instruction should not be used to access memory mapped I/O as the ordering\nof the individual loads it does is implementation specific, and some implementations\nmay use loads larger than the data element size or load elements an indeterminate\nnumber of times.\n - The scaled index may require more bits to represent than the address bits used\nby the processor (e.g., in 32bit mode, if the scale is greater than one). In\nthis case, the most significant bits beyond the number of address bits are ignored.\n\nOperation:\n\nDEST <- SRC1;\nBASE_ADDR: base register encoded in VSIB addressing;\nVINDEX: the vector index register encoded by VSIB addressing;\nSCALE: scale factor encoded by SIB:[7:6];\nDISP: optional 1, 4 byte displacement;\nMASK <- SRC3;\nVPGATHERDD (VEX.128 version)\nFOR j<- 0 to 3\n  i <- j * 32;\n  IF MASK[31+i] THEN\n     MASK[i +31:i] <- 0xFFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +31:i] <- 0;\n  FI;\nENDFOR\nMASK[VLMAX-1:128] <- 0;\nFOR j<- 0 to 3\n  i <- j * 32;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX[i+31:i])*SCALE + DISP;\n  IF MASK[31+i] THEN\n     DEST[i +31:i] <- FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +31:i] <- 0;\nENDFOR\nDEST[VLMAX-1:128] <- 0;\n(non-masked elements of the mask register have the content of respective element\nVPGATHERQD (VEX.128 version)\nFOR j<- 0 to 3\n  i <- j * 32;\n  IF MASK[31+i] THEN\n     MASK[i +31:i] <- 0xFFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +31:i] <- 0;\n  FI;\nENDFOR\nMASK[VLMAX-1:128] <- 0;\nFOR j<- 0 to 1\n  k <- j * 64;\n  i <- j * 32;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX1[k+63:k])*SCALE + DISP;\n  IF MASK[31+i] THEN\n     DEST[i +31:i] <- FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +31:i] <- 0;\nENDFOR\nMASK[127:64] <- 0;\nDEST[VLMAX-1:64] <- 0;\n(non-masked elements of the mask register have the content of respective element\nVPGATHERDD (VEX.256 version)\nFOR j<- 0 to 7\n  i <- j * 32;\n  IF MASK[31+i] THEN\n     MASK[i +31:i] <- 0xFFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +31:i] <- 0;\n  FI;\nENDFOR\nFOR j<- 0 to 7\n  i <- j * 32;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX1[i+31:i])*SCALE + DISP;\n  IF MASK[31+i] THEN\n     DEST[i +31:i] <- FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +31:i] <- 0;\nENDFOR\n(non-masked elements of the mask register have the content of respective element\nVPGATHERQD (VEX.256 version)\nFOR j<- 0 to 7\n  i <- j * 32;\n  IF MASK[31+i] THEN\n     MASK[i +31:i] <- 0xFFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +31:i] <- 0;\n  FI;\nENDFOR\nFOR j<- 0 to 3\n  k <- j * 64;\n  i <- j * 32;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX1[k+63:k])*SCALE + DISP;\n  IF MASK[31+i] THEN\n     DEST[i +31:i] <- FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +31:i] <- 0;\nENDFOR\nMASK[VLMAX-1:128] <- 0;\nDEST[VLMAX-1:128] <- 0;\n(non-masked elements of the mask register have the content of respective element\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVPGATHERDD: __m128i _mm_i32gather_epi32 (int const * base, __m128i index, const\nint scale);\n\nVPGATHERDD: __m128i _mm_mask_i32gather_epi32 (__m128i src, int const * base,\n__m128i index, __m128i mask, const int scale);\n\nVPGATHERDD: __m256i _mm256_i32gather_epi32 ( int const * base, __m256i index,\nconst int scale);\n\nVPGATHERDD: __m256i _mm256_mask_i32gather_epi32 (__m256i src, int const * base,\n__m256i index, __m256i mask, const int scale);\n\nVPGATHERQD: __m128i _mm_i64gather_epi32 (int const * base, __m128i index, const\nint scale);\n\nVPGATHERQD: __m128i _mm_mask_i64gather_epi32 (__m128i src, int const * base,\n__m128i index, __m128i mask, const int scale);\n\nVPGATHERQD: __m128i _mm256_i64gather_epi32 (int const * base, __m256i index,\nconst int scale);\n\nVPGATHERQD: __m128i _mm256_mask_i64gather_epi32 (__m128i src, int const * base,\n__m256i index, __m128i mask, const int scale);\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 12\n\n", 
      "mnem": "VPGATHERDD"
    }, 
    {
      "description": "\nVPGATHERDQ/VPGATHERQQ  -  Gather Packed Qword Values Using Signed Dword/Qword Indices:\n| Opcode/Instruction                     | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                                \n| VEX.DDS.128.66.0F38.W1 90 /r VPGATHERDQ| RMV  | V/V            | AVX2              | Using dword indices specified in vm32x,    \n| xmm1, vm32x, xmm2                      |      |                |                   | gather qword values from memory conditioned\n|                                        |      |                |                   | on mask specified by xmm2. Conditionally   \n|                                        |      |                |                   | gathered elements are merged into xmm1.    \n| VEX.DDS.128.66.0F38.W1 91 /r VPGATHERQQ| RMV  | V/V            | AVX2              | Using qword indices specified in vm64x,    \n| xmm1, vm64x, xmm2                      |      |                |                   | gather qword values from memory conditioned\n|                                        |      |                |                   | on mask specified by xmm2. Conditionally   \n|                                        |      |                |                   | gathered elements are merged into xmm1.    \n| VEX.DDS.256.66.0F38.W1 90 /r VPGATHERDQ| RMV  | V/V            | AVX2              | Using dword indices specified in vm32x,    \n| ymm1, vm32x, ymm2                      |      |                |                   | gather qword values from memory conditioned\n|                                        |      |                |                   | on mask specified by ymm2. Conditionally   \n|                                        |      |                |                   | gathered elements are merged into ymm1.    \n| VEX.DDS.256.66.0F38.W1 91 /r VPGATHERQQ| RMV  | V/V            | AVX2              | Using qword indices specified in vm64y,    \n| ymm1, vm64y, ymm2                      |      |                |                   | gather qword values from memory conditioned\n|                                        |      |                |                   | on mask specified by ymm2. Conditionally   \n|                                        |      |                |                   | gathered elements are merged into ymm1.    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1      | Operand 2                            | Operand 3      | Operand 4\n| A    | ModRM:reg (r,w)| BaseReg (R): VSIB:base, VectorReg(R):| VEX.vvvv (r, w)| NA       \n|      |                | VSIB:index                           |                |          \n\nDescription:\nThe instruction conditionally loads up to 2 or 4 qword values from memory addresses\nspecified by the memory operand (the second operand) and using qword indices.\nThe memory operand uses the VSIB form of the SIB byte to specify a general purpose\nregister operand as the common base, a vector register for an array of indices\nrelative to the base and a constant scale factor. The mask operand (the third\noperand) specifies the conditional load operation from each memory address and\nthe corresponding update of each data element of the destination operand (the\nfirst operand). Conditionality is specified by the most significant bit of each\ndata element of the mask register. If an element's mask bit is not set, the\ncorresponding element of the destination register is left unchanged. The width\nof data element in the destination register and mask register are identical.\nThe entire mask register will be set to zero by this instruction unless the\ninstruction causes an exception. Using dword indices in the lower half of the\nmask register, the instruction conditionally loads up to 2 or 4 qword values\nfrom the VSIB addressing memory operand, and updates the destination register.\nThis instruction can be suspended by an exception if at least one element is\nalready gathered (i.e., if the exception\n\n| is triggered by an element other than       | When this happens, the destination If \n| the rightmost one with its mask bit         | any traps or interrupts are pending   \n| set). register and the mask operand         | from already gathIt may do this to one\n| are partially updated; those elements       | or both                               \n| that have been gathered are placed into     |                                       \n| the destination register and have their     |                                       \n| mask bits set to zero. ered elements,       |                                       \n| they will be delivered in lieu of the       |                                       \n| exception; in this case, EFLAG.RF is        |                                       \n| set to one so an instruction breakpoint     |                                       \n| is not re-triggered when the instruction    |                                       \n| is continued. If the data size and index    |                                       \n| size are different, part of the destination |                                       \n| register and part of the mask register      |                                       \n| do not correspond to any elements being     |                                       \n| gathered. of those registers even if        |                                       \n| the instruction triggers an exception,      |                                       \n| and even if the instruction triggers        |                                       \n| the exception before gathering any elements.|                                       \n| VEX.128 version: The instruction will       | For dword indices, only the lower two \n| gather two qword values. vector index       | indices in the                        \n| register are used.                          |                                       \n| VEX.256 version: The instruction will       | For dword indices, only the lower four\n| gather four qword values.                   | indices in                            \nthe vector index register are used. Note that:\n\n - If any pair of the index, mask, or destination registers are the same, this\ninstruction results a UD fault.\n - The values may be read from memory in any order. Memory ordering with other\ninstructions follows the Intel64 memory-ordering model.\n - Faults are delivered in a right-to-left manner. That is, if a fault is triggered\nby an element and delivered, all elements closer to the LSB of the destination\nwill be completed (and non-faulting). Individual elements closer to the MSB\nmay or may not be completed. If a given element triggers multiple faults, they\nare delivered in the conventional order.\n - Elements may be gathered in any order, but faults must be delivered in a right-to-left\norder; thus, elements to the left of a faulting one may be gathered before the\nfault is delivered. A given implementation of this instruction is repeatable\n- given the same input values and architectural state, the same set of elements\nto the left of the faulting one will be gathered.\n - This instruction does not perform AC checks, and so will never deliver an AC\nfault.\n - This instruction will cause a #UD if the address size attribute is 16-bit.\n - This instruction will cause a #UD if the memory operand is encoded without the\nSIB byte.\n - This instruction should not be used to access memory mapped I/O as the ordering\nof the individual loads it does is implementation specific, and some implementations\nmay use loads larger than the data element size or load elements an indeterminate\nnumber of times.\n - The scaled index may require more bits to represent than the address bits used\nby the processor (e.g., in 32bit mode, if the scale is greater than one). In\nthis case, the most significant bits beyond the number of address bits are ignored.\n\nOperation:\n\nDEST <- SRC1;\nBASE_ADDR: base register encoded in VSIB addressing;\nVINDEX: the vector index register encoded by VSIB addressing;\nSCALE: scale factor encoded by SIB:[7:6];\nDISP: optional 1, 4 byte displacement;\nMASK <- SRC3;\nVPGATHERDQ (VEX.128 version)\nFOR j<- 0 to 1\n  i <- j * 64;\n  IF MASK[63+i] THEN\n     MASK[i +63:i] <- 0xFFFFFFFF_FFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +63:i] <- 0;\n  FI;\nENDFOR\nFOR j<- 0 to 1\n  k <- j * 32;\n  i <- j * 64;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX[k+31:k])*SCALE + DISP;\n  IF MASK[63+i] THEN\n     DEST[i +63:i] <- FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +63:i] <- 0;\nENDFOR\nMASK[VLMAX-1:128] <- 0;\nDEST[VLMAX-1:128] <- 0;\n(non-masked elements of the mask register have the content of respective element\nVPGATHERQQ (VEX.128 version)\nFOR j<- 0 to 1\n  i <- j * 64;\n  IF MASK[63+i] THEN\n     MASK[i +63:i] <- 0xFFFFFFFF_FFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +63:i] <- 0;\n  FI;\nENDFOR\nFOR j<- 0 to 1\n  i <-j * 64;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX1[i+63:i])*SCALE + DISP;\n  IF MASK[63+i] THEN\n     DEST[i +63:i] <- FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +63:i] <- 0;\nENDFOR\nMASK[VLMAX-1:128] <- 0;\nDEST[VLMAX-1:128] <- 0;\n(non-masked elements of the mask register have the content of respective element\nVPGATHERQQ (VEX.256 version)\nFOR j<- 0 to 3\n  i <- j * 64;\n  IF MASK[63+i] THEN\n     MASK[i +63:i] <- 0xFFFFFFFF_FFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +63:i] <- 0;\n  FI;\nENDFOR\nFOR j<- 0 to 3\n  i <- j * 64;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX1[i+63:i])*SCALE + DISP;\n  IF MASK[63+i] THEN\n     DEST[i +63:i] <- FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +63:i] <- 0;\nENDFOR\n(non-masked elements of the mask register have the content of respective element\nVPGATHERDQ (VEX.256 version)\nFOR j<- 0 to 3\n  i <- j * 64;\n  IF MASK[63+i] THEN\n     MASK[i +63:i] <- 0xFFFFFFFF_FFFFFFFF; // extend from most significant bit\n  ELSE\n     MASK[i +63:i] <- 0;\n  FI;\nENDFOR\nFOR j<- 0 to 3\n  k <- j * 32;\n  i <- j * 64;\n  DATA_ADDR <- BASE_ADDR + (SignExtend(VINDEX1[k+31:k])*SCALE + DISP;\n  IF MASK[63+i] THEN\n     DEST[i +63:i] <- FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n  FI;\n  MASK[i +63:i] <- 0;\nENDFOR\n(non-masked elements of the mask register have the content of respective element\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVPGATHERDQ: __m128i _mm_i32gather_epi64 (int64 const * base, __m128i index,\nconst int scale);\n\nVPGATHERDQ: __m128i _mm_mask_i32gather_epi64 (__m128i src, int64 const * base,\n__m128i index, __m128i mask, const int scale);\n\nVPGATHERDQ: __m256i _mm256_i32gather_epi64 ( int64 const * base, __m128i index,\nconst int scale);\n\nVPGATHERDQ: __m256i _mm256_mask_i32gather_epi64 (__m256i src, int64 const *\nbase, __m128i index, __m256i mask, const int scale);\n\nVPGATHERQQ: __m128i _mm_i64gather_epi64 (int64 const * base, __m128i index,\nconst int scale);\n\nVPGATHERQQ: __m128i _mm_mask_i64gather_epi64 (__m128i src, int64 const * base,\n__m128i index, __m128i mask, const int scale);\n\nVPGATHERQQ: __m256i _mm256_i64gather_epi64 (int64 const * base, __m256i index,\nconst int scale);\n\nVPGATHERQQ: __m256i _mm256_mask_i64gather_epi64 (__m256i src, int64 const *\nbase, __m256i index, __m256i mask, const int scale);\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 12\n\n", 
      "mnem": "VPGATHERDQ"
    }, 
    {
      "description": "-R:VPGATHERDD", 
      "mnem": "VPGATHERQD"
    }, 
    {
      "description": "-R:VPGATHERDQ", 
      "mnem": "VPGATHERQQ"
    }, 
    {
      "description": "\nVPMASKMOV  -  Conditional SIMD Integer Packed Loads and Stores:\n| Opcode/Instruction                     | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                          \n| VEX.NDS.128.66.0F38.W0 8C /r VPMASKMOVD| RVM  | V/V            | AVX2              | Conditionally load dword values from \n| xmm1, xmm2, m128                       |      |                |                   | m128 using mask in xmm2 and store in \n|                                        |      |                |                   | xmm1.                                \n| VEX.NDS.256.66.0F38.W0 8C /r VPMASKMOVD| RVM  | V/V            | AVX2              | Conditionally load dword values from \n| ymm1, ymm2, m256                       |      |                |                   | m256 using mask in ymm2 and store in \n|                                        |      |                |                   | ymm1.                                \n| VEX.NDS.128.66.0F38.W1 8C /r VPMASKMOVQ| RVM  | V/V            | AVX2              | Conditionally load qword values from \n| xmm1, xmm2, m128                       |      |                |                   | m128 using mask in xmm2 and store in \n|                                        |      |                |                   | xmm1.                                \n| VEX.NDS.256.66.0F38.W1 8C /r VPMASKMOVQ| RVM  | V/V            | AVX2              | Conditionally load qword values from \n| ymm1, ymm2, m256                       |      |                |                   | m256 using mask in ymm2 and store in \n|                                        |      |                |                   | ymm1.                                \n| VEX.NDS.128.66.0F38.W0 8E /r VPMASKMOVD| MVR  | V/V            | AVX2              | Conditionally store dword values from\n| m128, xmm1, xmm2                       |      |                |                   | xmm2 using mask in xmm1.             \n| VEX.NDS.256.66.0F38.W0 8E /r VPMASKMOVD| MVR  | V/V            | AVX2              | Conditionally store dword values from\n| m256, ymm1, ymm2                       |      |                |                   | ymm2 using mask in ymm1.             \n| VEX.NDS.128.66.0F38.W1 8E /r VPMASKMOVQ| MVR  | V/V            | AVX2              | Conditionally store qword values from\n| m128, xmm1, xmm2                       |      |                |                   | xmm2 using mask in xmm1.             \n| VEX.NDS.256.66.0F38.W1 8E /r VPMASKMOVQ| MVR  | V/V            | AVX2              | Conditionally store qword values from\n| m256, ymm1, ymm2                       |      |                |                   | ymm2 using mask in ymm1.             \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3    | Operand 4\n| RVM  | ModRM:reg (w)| VEX.vvvv | ModRM:r/m (r)| NA       \n| MVR  | ModRM:r/m (w)| VEX.vvvv | ModRM:reg (r)| NA       \n\nDescription:\nConditionally moves packed data elements from the second source operand into\nthe corresponding data element of the destination operand, depending on the\nmask bits associated with each data element. The mask bits are specified in\nthe first source operand. The mask bit for each data element is the most significant\nbit of that element in the first source operand. If a mask is 1, the corresponding\ndata element is copied from the second source operand to the destination operand.\nIf the mask is 0, the corresponding data element is set to zero in the load\nform of these instructions, and unmodified in the store form. The second source\noperand is a memory address for the load form of these instructions. The destination\noperand is a memory address for the store form of these instructions. The other\noperands are either XMM registers (for VEX.128 version) or YMM registers (for\nVEX.256 version). Faults occur only due to mask-bit required memory accesses\nthat caused the faults. Faults will not occur due to referencing any memory\nlocation if the corresponding mask bit for that memory location is 0. For example,\nno faults will be detected if the mask bits are all zero. Unlike previous MASKMOV\ninstructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to\nthese instructions.\n\nInstruction behavior on alignment check reporting with mask bits of less than\nall 1s are the same as with mask bits of all 1s. VMASKMOV should not be used\nto access memory mapped I/O as the ordering of the individual loads or stores\nit does is implementation specific. In cases where mask bits indicate data should\nnot be loaded or stored paging A and D bits will be set in an implementation\ndependent way. However, A and D bits are always set for pages where data is\nactually loaded/stored. Note: for load forms, the first source (the mask) is\nencoded in VEX.vvvv; the second source is encoded in rm_field, and the destination\nregister is encoded in reg_field. Note: for store forms, the first source (the\nmask) is encoded in VEX.vvvv; the second source register is encoded in reg_field,\nand the destination memory location is encoded in rm_field.\n\nOperation:\n\nVPMASKMOVD - 256-bit load\nDEST[31:0] <- IF (SRC1[31]) Load_32(mem) ELSE 0\nDEST[63:32] <- IF (SRC1[63]) Load_32(mem + 4) ELSE 0\nDEST[95:64] <- IF (SRC1[95]) Load_32(mem + 8) ELSE 0\nDEST[127:96] <- IF (SRC1[127]) Load_32(mem + 12) ELSE 0\nDEST[159:128] <- IF (SRC1[159]) Load_32(mem + 16) ELSE 0\nDEST[191:160] <- IF (SRC1[191]) Load_32(mem + 20) ELSE 0\nDEST[223:192] <- IF (SRC1[223]) Load_32(mem + 24) ELSE 0\nDEST[255:224] <- IF (SRC1[255]) Load_32(mem + 28) ELSE 0\nVPMASKMOVD -128-bit load\nDEST[31:0] <- IF (SRC1[31]) Load_32(mem) ELSE 0\nDEST[63:32] <- IF (SRC1[63]) Load_32(mem + 4) ELSE 0\nDEST[95:64] <- IF (SRC1[95]) Load_32(mem + 8) ELSE 0\nDEST[127:97] <- IF (SRC1[127]) Load_32(mem + 12) ELSE 0\nDEST[VLMAX-1:128] <- 0\nVPMASKMOVQ - 256-bit load\nDEST[63:0] <- IF (SRC1[63]) Load_64(mem) ELSE 0\nDEST[127:64] <- IF (SRC1[127]) Load_64(mem + 8) ELSE 0\nDEST[195:128] <- IF (SRC1[191]) Load_64(mem + 16) ELSE 0\nDEST[255:196] <- IF (SRC1[255]) Load_64(mem + 24) ELSE 0\nVPMASKMOVQ - 128-bit load\nDEST[63:0] <- IF (SRC1[63]) Load_64(mem) ELSE 0\nDEST[127:64] <- IF (SRC1[127]) Load_64(mem + 16) ELSE 0\nDEST[VLMAX-1:128] <- 0\nVPMASKMOVD - 256-bit store\nIF (SRC1[31]) DEST[31:0] <- SRC2[31:0]\nIF (SRC1[63]) DEST[63:32] <- SRC2[63:32]\nIF (SRC1[95]) DEST[95:64] <- SRC2[95:64]\nIF (SRC1[127]) DEST[127:96] <- SRC2[127:96]\nIF (SRC1[159]) DEST[159:128] <-SRC2[159:128]\nIF (SRC1[191]) DEST[191:160] <- SRC2[191:160]\nIF (SRC1[223]) DEST[223:192] <- SRC2[223:192]\nIF (SRC1[255]) DEST[255:224] <- SRC2[255:224]\nVPMASKMOVD - 128-bit store\nIF (SRC1[31]) DEST[31:0] <- SRC2[31:0]\nIF (SRC1[63]) DEST[63:32] <- SRC2[63:32]\nIF (SRC1[95]) DEST[95:64] <- SRC2[95:64]\nIF (SRC1[127]) DEST[127:96] <- SRC2[127:96]\nVPMASKMOVQ - 256-bit store\nIF (SRC1[63]) DEST[63:0] <- SRC2[63:0]\nIF (SRC1[127]) DEST[127:64] <-SRC2[127:64]\nIF (SRC1[191]) DEST[191:128] <- SRC2[191:128]\nIF (SRC1[255]) DEST[255:192] <- SRC2[255:192]\nVPMASKMOVQ - 128-bit store\nIF (SRC1[63]) DEST[63:0] <- SRC2[63:0]\nIF (SRC1[127]) DEST[127:64] <-SRC2[127:64]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVPMASKMOVD: __m256i _mm256_maskload_epi32(int const *a, __m256i mask)\n\n| VPMASKMOVD: void VPMASKMOVQ: __m256i     | _mm256_maskstore_epi32(int *a, __m256i    \n| _mm256_maskload_epi64(__int64 const      | mask, __m256i b)                          \n| *a, __m256i mask);                       |                                           \n| VPMASKMOVQ: void VPMASKMOVD: __m128i     | _mm256_maskstore_epi64(__int64 *a, __m256i\n| _mm_maskload_epi32(int const *a, __m128i | mask, __m256d b);                         \n| mask)                                    |                                           \n| VPMASKMOVD: void VPMASKMOVQ: __m128i     | _mm_maskstore_epi32(int *a, __m128i       \n| _mm_maskload_epi64(__int cont *a, __m128i| mask, __m128 b)                           \n| mask);                                   |                                           \n| VPMASKMOVQ: void                         | _mm_maskstore_epi64(__int64 *a, __m128i   \n|                                          | mask, __m128i b);                         \n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 6 (No AC# reported for any mask bit combinations).\n\n", 
      "mnem": "VPMASKMOV"
    }, 
    {
      "description": "\nVPSLLVD/VPSLLVQ  -  Variable Bit Shift Left Logical:\n| Opcode/Instruction                  | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                             \n| VEX.NDS.128.66.0F38.W0 47 /r VPSLLVD| RVM  | V/V            | AVX2              | Shift bits in doublewords in xmm2 left  \n| xmm1, xmm2, xmm3/m128               |      |                |                   | by amount specified in the corresponding\n|                                     |      |                |                   | element of xmm3/m128 while shifting     \n|                                     |      |                |                   | in 0s.                                  \n| VEX.NDS.128.66.0F38.W1 47 /r VPSLLVQ| RVM  | V/V            | AVX2              | Shift bits in quadwords in xmm2 left    \n| xmm1, xmm2, xmm3/m128               |      |                |                   | by amount specified in the corresponding\n|                                     |      |                |                   | element of xmm3/m128 while shifting     \n|                                     |      |                |                   | in 0s.                                  \n| VEX.NDS.256.66.0F38.W0 47 /r VPSLLVD| RVM  | V/V            | AVX2              | Shift bits in doublewords in ymm2 left  \n| ymm1, ymm2, ymm3/m256               |      |                |                   | by amount specified in the corresponding\n|                                     |      |                |                   | element of ymm3/m256 while shifting     \n|                                     |      |                |                   | in 0s.                                  \n| VEX.NDS.256.66.0F38.W1 47 /r VPSLLVQ| RVM  | V/V            | AVX2              | Shift bits in quadwords in ymm2 left    \n| ymm1, ymm2, ymm3/m256               |      |                |                   | by amount specified in the corresponding\n|                                     |      |                |                   | element of ymm3/m256 while shifting     \n|                                     |      |                |                   | in 0s.                                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3    | Operand 4\n| RVM  | ModRM:reg (w)| VEX.vvvv | ModRM:r/m (r)| NA       \n\nDescription:\nShifts the bits in the individual data elements (doublewords, or quadword) in\nthe first source operand to the left by the count value of respective data elements\nin the second source operand. As the bits in the data elements are shifted left,\nthe empty low-order bits are cleared (set to 0). The count values are specified\nindividually in each data element of the second source operand. If the unsigned\ninteger value specified in the respective data element of the second source\noperand is greater than 31 (for doublewords), or 63 (for a quadword), then the\ndestination data element are written with 0. VEX.128 encoded version: The destination\nand first source operands are XMM registers. The count operand can be either\nan XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding\nYMM register are zeroed. VEX.256 encoded version: The destination and first\nsource operands are YMM registers. The count operand can be either an YMM register\nor a 256-bit memory location.\n\nOperation:\n\nVPSLLVD (VEX.128 version)\nCOUNT_0 <- SRC2[31 : 0]\n  (* Repeat Each COUNT_i for the 2nd through 4th dwords of SRC2*)\nCOUNT_3 <- SRC2[127 : 96];\nIF COUNT_0 < 32 THEN\nDEST[31:0] <- ZeroExtend(SRC1[31:0] << COUNT_0);\nELSE\nDEST[31:0] <- 0;\n  (* Repeat shift operation for 2nd through 4th dwords *)\nIF COUNT_3 < 32 THEN\nDEST[127:96] <- ZeroExtend(SRC1[127:96] << COUNT_3);\nELSE\nDEST[127:96] <- 0;\nDEST[VLMAX-1:128] <- 0;\nVPSLLVD (VEX.256 version)\nCOUNT_0 <- SRC2[31 : 0];\n  (* Repeat Each COUNT_i for the 2nd through 7th dwords of SRC2*)\nCOUNT_7 <- SRC2[255 : 224];\nIF COUNT_0 < 32 THEN\nDEST[31:0] <- ZeroExtend(SRC1[31:0] << COUNT_0);\nELSE\nDEST[31:0] <- 0;\n  (* Repeat shift operation for 2nd through 7th dwords *)\nIF COUNT_7 < 32 THEN\nDEST[255:224] <- ZeroExtend(SRC1[255:224] << COUNT_7);\nELSE\nDEST[255:224] <- 0;\nVPSLLVQ (VEX.128 version)\nCOUNT_0 <- SRC2[63 : 0];\nCOUNT_1 <- SRC2[127 : 64];\nIF COUNT_0 < 64THEN\nDEST[63:0] <- ZeroExtend(SRC1[63:0] << COUNT_0);\nELSE\nDEST[63:0] <- 0;\nIF COUNT_1 < 64 THEN\nDEST[127:64] <- ZeroExtend(SRC1[127:64] << COUNT_1);\nELSE\nDEST[127:96] <- 0;\nDEST[VLMAX-1:128] <- 0;\nVPSLLVQ (VEX.256 version)\nCOUNT_0 <- SRC2[5 : 0];\n  (* Repeat Each COUNT_i for the 2nd through 4th dwords of SRC2*)\nCOUNT_3 <- SRC2[197 : 192];\nIF COUNT_0 < 64THEN\nDEST[63:0] <- ZeroExtend(SRC1[63:0] << COUNT_0);\nELSE\nDEST[63:0] <- 0;\n  (* Repeat shift operation for 2nd through 4th dwords *)\nIF COUNT_3 < 64 THEN\nDEST[255:192] <- ZeroExtend(SRC1[255:192] << COUNT_3);\nELSE\nDEST[255:192] <- 0;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVPSLLVD: __m256i _mm256_sllv_epi32 (__m256i m, __m256i count)\n\nVPSLLVD: __m128i _mm_sllv_epi32 (__m128i m, __m128i count)\n\nVPSLLVQ: __m256i _mm256_sllv_epi64 (__m256i m, __m256i count)\n\nVPSLLVQ: __m128i _mm_sllv_epi64 (__m128i m, __m128i count)\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4\n\n", 
      "mnem": "VPSLLVD"
    }, 
    {
      "description": "-R:VPSLLVD", 
      "mnem": "VPSLLVQ"
    }, 
    {
      "description": "\nVPSRAVD  -  Variable Bit Shift Right Arithmetic:\n| Opcode/Instruction                  | Op/En| 64/32 -bit Mode| CPUID Feature Flag| Description                             \n| VEX.NDS.128.66.0F38.W0 46 /r VPSRAVD| RVM  | V/V            | AVX2              | Shift bits in doublewords in xmm2 right \n| xmm1, xmm2, xmm3/m128               |      |                |                   | by amount specified in the corresponding\n|                                     |      |                |                   | element of xmm3/m128 while shifting     \n|                                     |      |                |                   | in the sign bits.                       \n| VEX.NDS.256.66.0F38.W0 46 /r VPSRAVD| RVM  | V/V            | AVX2              | Shift bits in doublewords in ymm2 right \n| ymm1, ymm2, ymm3/m256               |      |                |                   | by amount specified in the corresponding\n|                                     |      |                |                   | element of ymm3/m256 while shifting     \n|                                     |      |                |                   | in the sign bits.                       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3    | Operand 4\n| RVM  | ModRM:reg (w)| VEX.vvvv | ModRM:r/m (r)| NA       \n\nDescription:\nShifts the bits in the individual doubleword data elements in the first source\noperand to the right by the count value of respective data elements in the second\nsource operand. As the bits in each data element are shifted right, the empty\nhigh-order bits are filled with the sign bit of the source element. The count\nvalues are specified individually in each data element of the second source\noperand. If the unsigned integer value specified in the respective data element\nof the second source operand is greater than 31, then the destination data element\nare filled with the corresponding sign bit of the source element. VEX.128 encoded\nversion: The destination and first source operands are XMM registers. The count\noperand can be either an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)\nof the corresponding YMM register are zeroed. VEX.256 encoded version: The destination\nand first source operands are YMM registers. The count operand can be either\nan YMM register or a 256-bit memory location.\n\nOperation:\n\nVPSRAVD (VEX.128 version)\nCOUNT_0 <- SRC2[31: 0]\n  (* Repeat Each COUNT_i for the 2nd through 4th dwords of SRC2*)\nCOUNT_3 <- SRC2[127 : 112];\nIF COUNT_0 < 32 THEN\n  DEST[31:0] <- SignExtend(SRC1[31:0] >> COUNT_0);\nELSE\n  For (i = 0 to 31) DEST[i + 0] <- (SRC1[31] );\nFI;\n  (* Repeat shift operation for 2nd through 4th dwords *)\nIF COUNT_3 < 32 THEN\n  DEST[127:96] <- SignExtend(SRC1[127:96] >> COUNT_3);\nELSE\n  For (i = 0 to 31) DEST[i + 96] <- (SRC1[127] );\nFI;\nDEST[VLMAX-1:128] <- 0;\nVPSRAVD (VEX.256 version)\nCOUNT_0 <- SRC2[31 : 0];\n  (* Repeat Each COUNT_i for the 2nd through 7th dwords of SRC2*)\nCOUNT_7 <- SRC2[255 : 224];\nIF COUNT_0 < 32 THEN\n  DEST[31:0] <- SignExtend(SRC1[31:0] >> COUNT_0);\nELSE\n  For (i = 0 to 31) DEST[i + 0] <- (SRC1[31] );\nFI;\n  (* Repeat shift operation for 2nd through 7th dwords *)\nIF COUNT_7 < 32 THEN\n  DEST[255:224] <- SignExtend(SRC1[255:224] >> COUNT_7);\nELSE\n  For (i = 0 to 31) DEST[i + 224] <- (SRC1[255] );\nFI;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVPSRAVD: __m256i _mm256_srav_epi32 (__m256i m, __m256i count)\n\nVPSRAVD: __m128i _mm_srav_epi32 (__m128i m, __m128i count)\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.W = 1.\n", 
      "mnem": "VPSRAVD"
    }, 
    {
      "description": "\nVPSRLVD/VPSRLVQ  -  Variable Bit Shift Right Logical:\n| Opcode/Instruction                  | Op/EN| 64/32 -bit Mode| CPUID Feature Flag| Description                             \n| VEX.NDS.128.66.0F38.W0 45 /r VPSRLVD| RVM  | V/V            | AVX2              | Shift bits in doublewords in xmm2 right \n| xmm1, xmm2, xmm3/m128               |      |                |                   | by amount specified in the corresponding\n|                                     |      |                |                   | element of xmm3/m128 while shifting     \n|                                     |      |                |                   | in 0s.                                  \n| VEX.NDS.128.66.0F38.W1 45 /r VPSRLVQ| RVM  | V/V            | AVX2              | Shift bits in quadwords in xmm2 right   \n| xmm1, xmm2, xmm3/m128               |      |                |                   | by amount specified in the corresponding\n|                                     |      |                |                   | element of xmm3/m128 while shifting     \n|                                     |      |                |                   | in 0s.                                  \n| VEX.NDS.256.66.0F38.W0 45 /r VPSRLVD| RVM  | V/V            | AVX2              | Shift bits in doublewords in ymm2 right \n| ymm1, ymm2, ymm3/m256               |      |                |                   | by amount specified in the corresponding\n|                                     |      |                |                   | element of ymm3/m256 while shifting     \n|                                     |      |                |                   | in 0s.                                  \n| VEX.NDS.256.66.0F38.W1 45 /r VPSRLVQ| RVM  | V/V            | AVX2              | Shift bits in quadwords in ymm2 right   \n| ymm1, ymm2, ymm3/m256               |      |                |                   | by amount specified in the corresponding\n|                                     |      |                |                   | element of ymm3/m256 while shifting     \n|                                     |      |                |                   | in 0s.                                  \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3    | Operand 4\n| RVM  | ModRM:reg (w)| VEX.vvvv | ModRM:r/m (r)| NA       \n\nDescription:\nShifts the bits in the individual data elements (doublewords, or quadword) in\nthe first source operand to the right by the count value of respective data\nelements in the second source operand. As the bits in the data elements are\nshifted right, the empty high-order bits are cleared (set to 0). The count values\nare specified individually in each data element of the second source operand.\nIf the unsigned integer value specified in the respective data element of the\nsecond source operand is greater than 31 (for doublewords), or 63 (for a quadword),\nthen the destination data element are written with 0. VEX.128 encoded version:\nThe destination and first source operands are XMM registers. The count operand\ncan be either an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)\nof the corresponding YMM register are zeroed. VEX.256 encoded version: The destination\nand first source operands are YMM registers. The count operand can be either\nan YMM register or a 256-bit memory location.\n\nOperation:\n\nVPSRLVD (VEX.128 version)\nCOUNT_0 <- SRC2[31 : 0]\n  (* Repeat Each COUNT_i for the 2nd through 4th dwords of SRC2*)\nCOUNT_3 <- SRC2[127 : 96];\nIF COUNT_0 < 32 THEN\nDEST[31:0] <- ZeroExtend(SRC1[31:0] >> COUNT_0);\nELSE\nDEST[31:0] <- 0;\n  (* Repeat shift operation for 2nd through 4th dwords *)\nIF COUNT_3 < 32 THEN\nDEST[127:96] <- ZeroExtend(SRC1[127:96] >> COUNT_3);\nELSE\nDEST[127:96] <- 0;\nDEST[VLMAX-1:128] <- 0;\nVPSRLVD (VEX.256 version)\nCOUNT_0 <- SRC2[31 : 0];\n  (* Repeat Each COUNT_i for the 2nd through 7th dwords of SRC2*)\nCOUNT_7 <- SRC2[255 : 224];\nIF COUNT_0 < 32 THEN\nDEST[31:0] <- ZeroExtend(SRC1[31:0] >> COUNT_0);\nELSE\nDEST[31:0] <- 0;\n  (* Repeat shift operation for 2nd through 7th dwords *)\nIF COUNT_7 < 32 THEN\nDEST[255:224] <- ZeroExtend(SRC1[255:224] >> COUNT_7);\nELSE\nDEST[255:224] <- 0;\nVPSRLVQ (VEX.128 version)\nCOUNT_0 <- SRC2[63 : 0];\nCOUNT_1 <- SRC2[127 : 64];\nIF COUNT_0 < 64 THEN\nDEST[63:0] <- ZeroExtend(SRC1[63:0] >> COUNT_0);\nELSE\nDEST[63:0] <- 0;\nIF COUNT_1 < 64THEN\nDEST[127:64] <- ZeroExtend(SRC1[127:64] >> COUNT_1);\nELSE\nDEST[127:64] <- 0;\nDEST[VLMAX-1:128] <- 0;\nVPSRLVQ (VEX.256 version)\nCOUNT_0 <- SRC2[63 : 0];\n  (* Repeat Each COUNT_i for the 2nd through 4th dwords of SRC2*)\nCOUNT_3 <- SRC2[255 : 192];\nIF COUNT_0 < 64 THEN\nDEST[63:0] <- ZeroExtend(SRC1[63:0] >> COUNT_0);\nELSE\nDEST[63:0] <- 0;\n  (* Repeat shift operation for 2nd through 4th dwords *)\nIF COUNT_3 < 64THEN\nDEST[255:192] <- ZeroExtend(SRC1[255:192] >> COUNT_3);\nELSE\nDEST[255:192] <- 0;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVPSRLVD: __m256i _mm256_srlv_epi32 (__m256i m, __m256i count);\n\nVPSRLVD: __m128i _mm_srlv_epi32 (__m128i m, __m128i count);\n\nVPSRLVQ: __m256i _mm256_srlv_epi64 (__m256i m, __m256i count);\n\nVPSRLVQ: __m128i _mm_srlv_epi64 (__m128i m, __m128i count);\n\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\nSee Exceptions Type 4\n\n", 
      "mnem": "VPSRLVD"
    }, 
    {
      "description": "-R:VPSRLVD", 
      "mnem": "VPSRLVQ"
    }, 
    {
      "description": "\nVTESTPD/VTESTPS - Packed Bit Test:\n| Opcode/Instruction                    | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                            \n| VEX.128.66.0F38.W0 0E /r VTESTPS xmm1,| RM   | V/V                   | AVX               | Set ZF and CF depending on sign bit    \n| xmm2/m128                             |      |                       |                   | AND and ANDN of packed single-precision\n|                                       |      |                       |                   | floating-point sources.                \n| VEX.256.66.0F38.W0 0E /r VTESTPS ymm1,| RM   | V/V                   | AVX               | Set ZF and CF depending on sign bit    \n| ymm2/m256                             |      |                       |                   | AND and ANDN of packed single-precision\n|                                       |      |                       |                   | floating-point sources.                \n| VEX.128.66.0F38.W0 0F /r VTESTPD xmm1,| RM   | V/V                   | AVX               | Set ZF and CF depending on sign bit    \n| xmm2/m128                             |      |                       |                   | AND and ANDN of packed double-precision\n|                                       |      |                       |                   | floating-point sources.                \n| VEX.256.66.0F38.W0 0F /r VTESTPD ymm1,| RM   | V/V                   | AVX               | Set ZF and CF depending on sign bit    \n| ymm2/m256                             |      |                       |                   | AND and ANDN of packed double-precision\n|                                       |      |                       |                   | floating-point sources.                \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2    | Operand 3| Operand 4\n| RM   | ModRM:reg (r)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nVTESTPS performs a bitwise comparison of all the sign bits of the packed single-precision\nelements in the first source operation and corresponding sign bits in the second\nsource operand. If the AND of the source sign bits with the dest sign bits produces\nall zeros, the ZF is set else the ZF is clear. If the AND of the source sign\nbits with the inverted dest sign bits produces all zeros the CF is set else\nthe CF is clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD.\nVTESTPD performs a bitwise comparison of all the sign bits of the double-precision\nelements in the first source operation and corresponding sign bits in the second\nsource operand. If the AND of the source sign bits with the dest sign bits produces\nall zeros, the ZF is set else the ZF is clear. If the AND the source sign bits\nwith the inverted dest sign bits produces all zeros the CF is set else the CF\nis clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD. The first\nsource register is specified by the ModR/M reg field. 128-bit version: The first\nsource register is an XMM register. The second source register can be an XMM\nregister or a 128-bit memory location. The destination register is not modified.\nVEX.256 encoded version: The first source register is a YMM register. The second\nsource register can be a YMM register or a 256-bit memory location. The destination\nregister is not modified. Note: In VEX-encoded versions, VEX.vvvv is reserved\nand must be 1111b, otherwise instructions will #UD.\n\nOperation:\n\nVTESTPS (128-bit version)\nTEMP[127:0] <- SRC[127:0] AND DEST[127:0]\nIF (TEMP[31] = TEMP[63] = TEMP[95] = TEMP[127] = 0)\n  THEN ZF <-1;\n  ELSE ZF <- 0;\nTEMP[127:0] <- SRC[127:0] AND NOT DEST[127:0]\nIF (TEMP[31] = TEMP[63] = TEMP[95] = TEMP[127] = 0)\n  THEN CF <-1;\n  ELSE CF <- 0;\nDEST (unmodified)\nAF <- OF <- PF <- SF <- 0;\nVTESTPS (VEX.256 encoded version)\nTEMP[255:0] <- SRC[255:0] AND DEST[255:0]\nIF (TEMP[31] = TEMP[63] = TEMP[95] = TEMP[127]= TEMP[160] =TEMP[191] = TEMP[224] = TEMP[255] = 0)\n  THEN ZF <-1;\n  ELSE ZF <- 0;\nTEMP[255:0] <- SRC[255:0] AND NOT DEST[255:0]\nIF (TEMP[31] = TEMP[63] = TEMP[95] = TEMP[127]= TEMP[160] =TEMP[191] = TEMP[224] = TEMP[255] = 0)\n  THEN CF <-1;\n  ELSE CF <- 0;\nDEST (unmodified)\nAF <- OF <- PF <- SF <- 0;\nVTESTPD (128-bit version)\nTEMP[127:0] <- SRC[127:0] AND DEST[127:0]\nIF ( TEMP[63] = TEMP[127] = 0)\n  THEN ZF <-1;\n  ELSE ZF <- 0;\nTEMP[127:0] <- SRC[127:0] AND NOT DEST[127:0]\nIF ( TEMP[63] = TEMP[127] = 0)\n  THEN CF <-1;\n  ELSE CF <- 0;\nDEST (unmodified)\nAF <- OF <- PF <- SF <- 0;\nVTESTPD (VEX.256 encoded version)\nTEMP[255:0] <- SRC[255:0] AND DEST[255:0]\nIF (TEMP[63] = TEMP[127] = TEMP[191] = TEMP[255] = 0)\n  THEN ZF <-1;\n  ELSE ZF <- 0;\nTEMP[255:0] <- SRC[255:0] AND NOT DEST[255:0]\nIF (TEMP[63] = TEMP[127] = TEMP[191] = TEMP[255] = 0)\n  THEN CF <-1;\n  ELSE CF <- 0;\nDEST (unmodified)\nAF <- OF <- PF <- SF <- 0;\n\nIntel C/C++ Compiler Intrinsic Equivalent:\nVTESTPS\n\nint _mm256_testz_ps (__m256 s1, __m256 s2);\n\nint _mm256_testc_ps (__m256 s1, __m256 s2);\n\nint _mm256_testnzc_ps (__m256 s1, __m128 s2);\n\nint _mm_testz_ps (__m128 s1, __m128 s2);\n\nint _mm_testc_ps (__m128 s1, __m128 s2);\n\nint _mm_testnzc_ps (__m128 s1, __m128 s2);\n\nVTESTPD\n\nint _mm256_testz_pd (__m256d s1, __m256d s2);\n\nint _mm256_testc_pd (__m256d s1, __m256d s2);\n\nint _mm256_testnzc_pd (__m256d s1, __m256d s2);\n\nint _mm_testz_pd (__m128d s1, __m128d s2);\n\nint _mm_testc_pd (__m128d s1, __m128d s2);\n\nint _mm_testnzc_pd (__m128d s1, __m128d s2);\n\n\nFlags Affected:\nThe 0F, AF, PF, SF flags are cleared and the ZF, CF flags are set according\nto the operation.\n\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4; additionally\n\n| #UD| If VEX.vvvv != 1111B. If VEX.W = 1 for\n|    | VTESTPS or VTESTPD.                   \n", 
      "mnem": "VTESTPD"
    }, 
    {
      "description": "-R:VTESTPD", 
      "mnem": "VTESTPS"
    }, 
    {
      "description": "\nVZEROALL - Zero All YMM Registers:\n| Opcode/Instruction        | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description            \n| VEX.256.0F.WIG 77 VZEROALL| NP   | V/V                   | AVX               | Zero all YMM registers.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nThe instruction zeros contents of all XMM or YMM registers. Note: VEX.vvvv is\nreserved and must be 1111b, otherwise instructions will #UD. In Compatibility\nand legacy 32-bit mode only the lower 8 registers are modified.\n\nOperation:\n\nVZEROALL (VEX.256 encoded version)\nIF (64-bit mode)\n  YMM0[VLMAX-1:0] <- 0\n  YMM1[VLMAX-1:0] <- 0\n  YMM2[VLMAX-1:0] <- 0\n  YMM3[VLMAX-1:0] <- 0\n  YMM4[VLMAX-1:0] <- 0\n  YMM5[VLMAX-1:0] <- 0\n  YMM6[VLMAX-1:0] <- 0\n  YMM7[VLMAX-1:0] <- 0\n  YMM8[VLMAX-1:0] <- 0\n  YMM9[VLMAX-1:0] <- 0\n  YMM10[VLMAX-1:0] <- 0\n  YMM11[VLMAX-1:0] <- 0\n  YMM12[VLMAX-1:0] <- 0\n  YMM13[VLMAX-1:0] <- 0\n  YMM14[VLMAX-1:0] <- 0\n  YMM15[VLMAX-1:0] <- 0\nELSE\n  YMM0[VLMAX-1:0] <- 0\n  YMM1[VLMAX-1:0] <- 0\n  YMM2[VLMAX-1:0] <- 0\n  YMM3[VLMAX-1:0] <- 0\n  YMM4[VLMAX-1:0] <- 0\n  YMM5[VLMAX-1:0] <- 0\n  YMM6[VLMAX-1:0] <- 0\n  YMM7[VLMAX-1:0] <- 0\n  YMM8-15: Unmodified\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| VZEROALL:| _mm256_zeroall()\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 8.\n\n", 
      "mnem": "VZEROALL"
    }, 
    {
      "description": "\nVZEROUPPER - Zero Upper Bits of YMM Registers:\n| Opcode/Instruction          | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                              \n| VEX.128.0F.WIG 77 VZEROUPPER| NP   | V/V                   | AVX               | Zero upper 128 bits of all YMM registers.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nThe instruction zeros the bits in position 128 and higher of all YMM registers.\nThe lower 128-bits of the registers (the corresponding XMM registers) are unmodified.\n\nThis instruction is recommended when transitioning between AVX and legacy SSE\ncode - it will eliminate performance penalties caused by false dependencies.\nNote: VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\nIn Compatibility and legacy 32-bit mode only the lower 8 registers are modified.\n\nOperation:\n\nVZEROUPPER\nIF (64-bit mode)\n  YMM0[VLMAX-1:128] <- 0\n  YMM1[VLMAX-1:128] <- 0\n  YMM2[VLMAX-1:128] <- 0\n  YMM3[VLMAX-1:128] <- 0\n  YMM4[VLMAX-1:128] <- 0\n  YMM5[VLMAX-1:128] <- 0\n  YMM6[VLMAX-1:128] <- 0\n  YMM7[VLMAX-1:128] <- 0\n  YMM8[VLMAX-1:128] <- 0\n  YMM9[VLMAX-1:128] <- 0\n  YMM10[VLMAX-1:128] <- 0\n  YMM11[VLMAX-1:128] <- 0\n  YMM12[VLMAX-1:128] <- 0\n  YMM13[VLMAX-1:128] <- 0\n  YMM14[VLMAX-1:128] <- 0\n  YMM15[VLMAX-1:128] <- 0\nELSE\n  YMM0[VLMAX-1:128] <- 0\n  YMM1[VLMAX-1:128] <- 0\n  YMM2[VLMAX-1:128] <- 0\n  YMM3[VLMAX-1:128] <- 0\n  YMM4[VLMAX-1:128] <- 0\n  YMM5[VLMAX-1:128] <- 0\n  YMM6[VLMAX-1:128] <- 0\n  YMM7[VLMAX-1:128] <- 0\n  YMM8-15: unmodified\nFI\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| VZEROUPPER:| _mm256_zeroupper()\n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 8.\n\n", 
      "mnem": "VZEROUPPER"
    }, 
    {
      "description": "\nWAIT/FWAIT - Wait:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 9B    | WAIT       | NP   | Valid      | Valid          | Check pending unmasked floating-point\n|       |            |      |            |                | exceptions.                          \n| 9B    | FWAIT      | NP   | Valid      | Valid          | Check pending unmasked floating-point\n|       |            |      |            |                | exceptions.                          \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nCauses the processor to check for and handle pending, unmasked, floating-point\nexceptions before proceeding. (FWAIT is an alternate mnemonic for WAIT.)\n\nThis instruction is useful for synchronizing exceptions in critical sections\nof code. Coding a WAIT instruction after a floating-point instruction ensures\nthat any unmasked floating-point exceptions the instruction may raise are handled\nbefore the processor can modify the instruction's results. See the section titled\n\u201cFloating-Point Exception Synchronization\u201d in Chapter 8 of the Intel\u00ae 64 and\nIA-32 Architectures Software Developer's Manual, Volume 1, for more information\non using the WAIT/FWAIT instruction.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\nOperation:\n\nCheckForPendingUnmaskedFloatingPointExceptions;\n\nFPU Flags Affected:\nThe C0, C1, C2, and C3 flags are undefined.\n\n\nFloating-Point Exceptions:\nNone.\n\n\nProtected Mode Exceptions:\n| #NM| If CR0.MP[bit 1] = 1 and CR0.TS[bit\n|    | 3] = 1.                            \n| #UD| If the LOCK prefix is used.        \n\nReal-Address Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "WAIT"
    }, 
    {
      "description": "\nWBINVD - Write Back and Invalidate Cache:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F 09 | WBINVD     | NP   | Valid      | Valid          | Write back and flush Internal caches;\n|       |            |      |            |                | initiate writing-back and flushing of\n|       |            |      |            |                | external caches.                     \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nWrites back all modified cache lines in the processor's internal cache to main\nmemory and invalidates (flushes) the internal caches. The instruction then issues\na special-function bus cycle that directs external caches to also write back\nmodified data and another bus cycle to indicate that the external caches should\nbe invalidated.\n\nAfter executing this instruction, the processor does not wait for the external\ncaches to complete their write-back and flushing operations before proceeding\nwith instruction execution. It is the responsibility of hardware to respond\nto the cache write-back and flush signals. The amount of time or cycles for\nWBINVD to complete will vary due to size and other factors of different cache\nhierarchies. As a consequence, the use of the WBINVD instruction can have an\nimpact on logical processor interrupt/event response time. Additional information\nof WBINVD behavior in a cache hierarchy with hierarchical sharing topology can\nbe found in Chapter 2 of the Intel\u00ae 64 and IA-32 Architectures Software Developer's\nManual, Volume 3A.\n\nThe WBINVD instruction is a privileged instruction. When the processor is running\nin protected mode, the CPL of a program or procedure must be 0 to execute this\ninstruction. This instruction is also a serializing instruction (see \u201cSerializing\nInstructions\u201d in Chapter 8 of the Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 3A).\n\nIn situations where cache coherency with main memory is not a concern, software\ncan use the INVD instruction.\n\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.\n\n\nIA-32 Architecture Compatibility:\nThe WBINVD instruction is implementation dependent, and its function may be\nimplemented differently on future Intel 64 and IA-32 processors. The instruction\nis not supported on IA-32 processors earlier than the Intel486 processor.\n\nOperation:\n\nWriteBack(InternalCaches);\nFlush(InternalCaches);\nSignalWriteBack(ExternalCaches);\nSignalFlush(ExternalCaches);\nContinue; (* Continue execution *)\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the current privilege level is not\n|       | 0.                                   \n| #UD   | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #UD| If the LOCK prefix is used.\n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| WBINVD cannot be executed at the virtual-8086\n|       | mode.                                        \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "WBINVD"
    }, 
    {
      "description": "\nWRFSBASE/WRGSBASE - Write FS/GS Segment Base:\n| Opcode/Instruction              | Op/En| 64/32bit Mode| CPUID Feature Flag| Description                             \n| F3 0F AE /2 WRFSBASE r32        | M    | V/I          | FSGSBASE          | Load the FS base address with the 32-bit\n|                                 |      |              |                   | value in the source register.           \n| REX.W + F3 0F AE /2 WRFSBASE r64| M    | V/I          | FSGSBASE          | Load the FS base address with the 64-bit\n|                                 |      |              |                   | value in the source register.           \n| F3 0F AE /3 WRGSBASE r32        | M    | V/I          | FSGSBASE          | Load the GS base address with the 32-bit\n|                                 |      |              |                   | value in the source register.           \n| REX.W + F3 0F AE /3 WRGSBASE r64| M    | V/I          | FSGSBASE          | Load the GS base address with the 64-bit\n|                                 |      |              |                   | value in the source register.           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nLoads the FS or GS segment base address with the general-purpose register indicated\nby the modR/M:r/m field.\n\nThe source operand may be either a 32-bit or a 64-bit general-purpose register.\nThe REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is\nused, the operand size is 32 bits; the upper 32 bits of the source register\nare ignored and upper 32 bits of the base address (for FS or GS) are cleared.\nThis instruction is supported only in 64-bit mode.\n\nOperation:\n\nFS/GS segment base address <- SRC;\n\nFlags Affected:\nNone\n\n\nC/C++ Compiler Intrinsic Equivalent:\n| WRFSBASE:| void _writefsbase_u32( unsigned int  \n|          | );                                   \n| WRFSBASE:| _writefsbase_u64( unsigned __int64 );\n| WRGSBASE:| void _writegsbase_u32( unsigned int  \n|          | );                                   \n| WRGSBASE:| _writegsbase_u64( unsigned __int64 );\n\nProtected Mode Exceptions:\n| #UD| The WRFSBASE and WRGSBASE instructions\n|    | are not recognized in protected mode. \n\nReal-Address Mode Exceptions:\n| #UD| The WRFSBASE and WRGSBASE instructions  \n|    | are not recognized in real-address mode.\n\nVirtual-8086 Mode Exceptions:\n| #UD| The WRFSBASE and WRGSBASE instructions  \n|    | are not recognized in virtual-8086 mode.\n\nCompatibility Mode Exceptions:\n| #UD| The WRFSBASE and WRGSBASE instructions\n|    | are not recognized in compatibility   \n|    | mode.                                 \n\n64-Bit Mode Exceptions:\n| #UD   | If the LOCK prefix is used. If CR4.FSGSBASE[bit\n|       | 16] = 0. If CPUID.07H.0H:EBX.FSGSBASE[bit      \n|       | 0] = 0                                         \n| #GP(0)| If the source register contains a non-canonical\n|       | address.                                       \n", 
      "mnem": "WRFSBASE"
    }, 
    {
      "description": "-R:WRFSBASE", 
      "mnem": "WRGSBASE"
    }, 
    {
      "description": "\nWRMSR - Write to Model Specific Register:\n| Opcode| Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                \n| 0F 30 | WRMSR      | NP   | Valid      | Valid          | Write the value in EDX:EAX to MSR specified\n|       |            |      |            |                | by ECX.                                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nWrites the contents of registers EDX:EAX into the 64-bit model specific register\n(MSR) specified in the ECX register. (On processors that support the Intel 64\narchitecture, the high-order 32 bits of RCX are ignored.) The contents of the\nEDX register are copied to high-order 32 bits of the selected MSR and the contents\nof the EAX register are copied to low-order 32 bits of the MSR. (On processors\nthat support the Intel 64 architecture, the high-order 32 bits of each of RAX\nand RDX are ignored.) Undefined or reserved bits in an MSR should be set to\nvalues previously read.\n\nThis instruction must be executed at privilege level 0 or in real-address mode;\notherwise, a general protection exception #GP(0) is generated. Specifying a\nreserved or unimplemented MSR address in ECX will also cause a general protection\nexception. The processor will also generate a general protection exception if\nsoftware attempts to write to bits in a reserved MSR.\n\nWhen the WRMSR instruction is used to write to an MTRR, the TLBs are invalidated.\nThis includes global entries (see \u201cTranslation Lookaside Buffers (TLBs)\u201d in\nChapter 3 of the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 3A).\n\nMSRs control functions for testability, execution tracing, performance-monitoring\nand machine check errors. Chapter 35, \u201cModel-Specific Registers (MSRs)\u201d, in\nthe Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual, Volume 3C,\nlists all MSRs that can be written with this instruction and their addresses.\nNote that each processor family has its own set of MSRs.\n\nThe WRMSR instruction is a serializing instruction (see \u201cSerializing Instructions\u201d\nin Chapter 8 of the Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 3A). Note that WRMSR to the IA32_TSC_DEADLINE MSR (MSR index 6E0H) and\nthe X2APIC MSRs (MSR indices 802H to 83FH) are not serializing.\n\nThe CPUID instruction should be used to determine whether MSRs are supported\n(CPUID.01H:EDX[5] = 1) before using this instruction.\n\n\nIA-32 Architecture Compatibility:\nThe MSRs and the ability to read them with the WRMSR instruction were introduced\ninto the IA-32 architecture with the Pentium processor. Execution of this instruction\nby an IA-32 processor earlier than the Pentium processor results in an invalid\nopcode exception #UD.\n\nOperation:\n\nMSR[ECX] <- EDX:EAX;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)| If the current privilege level is not          \n|       | 0. If the value in ECX specifies a reserved    \n|       | or unimplemented MSR address. If the           \n|       | value in EDX:EAX sets bits that are            \n|       | reserved in the MSR specified by ECX.          \n|       | If the source register contains a non-canonical\n|       | address and ECX specifies one of the           \n|       | following MSRs: IA32_DS_AREA, IA32_FS_BASE,    \n|       | IA32_GS_BASE, IA32_KERNEL_GS_BASE, IA32_LSTAR, \n|       | IA32_SYSENTER_EIP, IA32_SYSENTER_ESP.          \n| #UD   | If the LOCK prefix is used.                    \n\nReal-Address Mode Exceptions:\n| #GP| If the value in ECX specifies a reserved       \n|    | or unimplemented MSR address. If the           \n|    | value in EDX:EAX sets bits that are            \n|    | reserved in the MSR specified by ECX.          \n|    | If the source register contains a non-canonical\n|    | address and ECX specifies one of the           \n|    | following MSRs: IA32_DS_AREA, IA32_FS_BASE,    \n|    | IA32_GS_BASE, IA32_KERNEL_GS_BASE, IA32_LSTAR, \n|    | IA32_SYSENTER_EIP, IA32_SYSENTER_ESP.          \n| #UD| If the LOCK prefix is used.                    \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| The WRMSR instruction is not recognized\n|       | in virtual-8086 mode.                  \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "WRMSR"
    }, 
    {
      "description": "\nXABORT  -  Transactional Abort:\n| Opcode/Instruction  | Op/En| 64/32bit Mode Support| CPUID Feature Flag| Description                            \n| C6 F8 ib XABORT imm8| A    | V/V                  | RTM               | Causes an RTM abort if in RTM execution\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand2| Operand3| Operand4\n| A    | imm8     | NA      | NA      | NA      \n\nDescription:\nXABORT forces an RTM abort. Following an RTM abort, the logical processor resumes\nexecution at the fallback address computed through the outermost XBEGIN instruction.\nThe EAX register is updated to reflect an XABORT instruction caused the abort,\nand the imm8 argument will be provided in bits 31:24 of EAX.\n\nOperation:\n\nXABORT\nIF RTM_ACTIVE = 0\n  THEN\n     Treat as NOP;\n  ELSE\n     GOTO RTM_ABORT_PROCESSING;\nFI;\n(* For any RTM abort condition encountered during RTM execution *)\nRTM_ABORT_PROCESSING:\n  Restore architectural register state;\n  Discard memory updates performed in transaction;\n  Update EAX with status and XABORT argument;\n  RTM_NEST_COUNT <- 0;\n  RTM_ACTIVE <- 0;\n  IF 64-bit Mode\n     THEN\n       RIP <- fallbackRIP;\n     ELSE\n       EIP <- fallbackEIP;\n  FI;\nEND\n\nFlags Affected:\nNone\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XABORT:| void _xabort( unsigned int);\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\n| #UD| CPUID.(EAX=7, ECX=0):RTM[bit 11] = 0.\n|    | If LOCK prefix is used.              \n", 
      "mnem": "XABORT"
    }, 
    {
      "description": "\nXACQUIRE/XRELEASE  -  Hardware Lock Elision Prefix Hints:\n| Opcode/Instruction| 64/32bit Mode Support| CPUID Feature Flag| Description                            \n| F2 XACQUIRE       | V/V                  | HLE1              | A hint used with an \u201cXACQUIRE-enabled\u201c \n|                   |                      |                   | instruction to start lock elision on   \n|                   |                      |                   | the instruction memory operand address.\n| F3 XRELEASE       | V/V                  | HLE               | A hint used with an \u201cXRELEASE-enabled\u201c \n|                   |                      |                   | instruction to end lock elision on the \n|                   |                      |                   | instruction memory operand address.    \nNotes: 1. Software is not required to check the HLE feature flag to use XACQUIRE\nor XRELEASE, as they are treated as regular prefix if HLE feature flag reports\n0.\n\n\nDescription:\nThe XACQUIRE prefix is a hint to start lock elision on the memory address specified\nby the instruction and the XRELEASE prefix is a hint to end lock elision on\nthe memory address specified by the instruction. The XACQUIRE prefix hint can\nonly be used with the following instructions (these instructions are also referred\nto as XACQUIRE-enabled when used with the XACQUIRE prefix):\n\n - Instructions with an explicit LOCK prefix (F0H) prepended to forms of the instruction\nwhere the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR,\nBTS, CMPXCHG, CMPXCHG8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG.\n - The XCHG instruction either with or without the presence of the LOCK prefix.\n\nThe XRELEASE prefix hint can only be used with the following instructions (also\nreferred to as XRELEASE-enabled when used with the XRELEASE prefix):\n\n - Instructions with an explicit LOCK prefix (F0H) prepended to forms of the instruction\nwhere the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR,\nBTS, CMPXCHG, CMPXCHG8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG.\n - The XCHG instruction either with or without the presence of the LOCK prefix.\n - The \"MOV mem, reg\" (Opcode 88H/89H) and \"MOV mem, imm\" (Opcode C6H/C7H) instructions.\nIn these cases, the XRELEASE is recognized without the presence of the LOCK\nprefix.\n\nThe lock variables must satisfy the guidelines described in Intel\u00ae 64 and IA-32\nArchitectures Software Developer's Manual, Volume 1, Section 15.3.3, for elision\nto be successful, otherwise an HLE abort may be signaled. If an encoded byte\nsequence that meets XACQUIRE/XRELEASE requirements includes both prefixes, then\nthe HLE semantic is determined by the prefix byte that is placed closest to\nthe instruction opcode. For example, an F3F2C6 will not be treated as a XRELEASE-enabled\ninstruction since the F2H (XACQUIRE) is closest to the instruction opcode C6.\nSimilarly, an F2F3F0 prefixed instruction will be treated as a XRELEASE-enabled\ninstruction since F3H (XRELEASE) is closest to the instruction opcode. Intel\n64 and IA-32 Compatibility The effect of the XACQUIRE/XRELEASE prefix hint is\nthe same in non-64-bit modes and in 64-bit mode.\n\n| For instructions that do not support  | prefix behaves the same way as REPNE/REPNZ\n| the XACQUIRE hint, the presence of the| semantics for string instructions,        \n| F2H prior hardware, according to \u2022    |                                           \n| \u2022                                     | Serve as SIMD prefix for legacy SIMD      \n|                                       | instructions operating on XMM register    \n| \u2022                                     | Cause #UD if prepending the VEX prefix.   \n| \u2022                                     | Undefined for non-string instructions     \n|                                       | or other situations.                      \nFor instructions that do not support the XRELEASE hint, the presence of the\nF3H prefix behaves the same way as in prior hardware, according to\n\n - REP/REPE/REPZ semantics for string instructions,\n - Serve as SIMD prefix for legacy SIMD instructions operating on XMM register\n - Cause #UD if prepending the VEX prefix.\n - Undefined for non-string instructions or other situations.\n\nOperation:\n\nXACQUIRE\nIF XACQUIRE-enabled instruction\n  THEN\n     IF (HLE_NEST_COUNT < MAX_HLE_NEST_COUNT) THEN\n       HLE_NEST_COUNT++\n       IF (HLE_NEST_COUNT = 1) THEN\n          HLE_ACTIVE <- 1\n          IF 64-bit mode\n             THEN\n               restartRIP <- instruction pointer of the XACQUIRE-enabled instruction\n             ELSE\n               restartEIP <- instruction pointer of the XACQUIRE-enabled instruction\n          FI;\n          Enter HLE Execution (* record register state, start tracking memory state *)\n       FI; (* HLE_NEST_COUNT = 1*)\n       IF ElisionBufferAvailable\n          THEN\n             Allocate elision buffer\n             Record address and data for forwarding and commit checking\n             Perform elision\n          ELSE\n             Perform lock acquire operation transactionally but without elision\n       FI;\n     ELSE (* HLE_NEST_COUNT = MAX_HLE_NEST_COUNT *)\n          GOTO HLE_ABORT_PROCESSING\n     FI;\n  ELSE\n     Treat instruction as non-XACQUIRE F2H prefixed legacy instruction\nFI;\nXRELEASE\nIF XRELEASE-enabled instruction\n  THEN\n     IF (HLE_NEST_COUNT > 0)\n       THEN\n          HLE_NEST_COUNT--\n          IF lock address matches in elision buffer THEN\n             IF lock satisfies address and value requirements THEN\n               Deallocate elision buffer\n             ELSE\n               GOTO HLE_ABORT_PROCESSING\n             FI;\n          FI;\n          IF (HLE_NEST_COUNT = 0)\n             THEN\n               IF NoAllocatedElisionBuffer\n                  THEN\n                     Try to commit transactional execution\n                     IF fail to commit transactional execution\n                       THEN\n                          GOTO HLE_ABORT_PROCESSING;\n                       ELSE (* commit success *)\n                          HLE_ACTIVE <- 0\n                     FI;\n                  ELSE\n                     GOTO HLE_ABORT_PROCESSING\n               FI;\n          FI;\n     FI; (* HLE_NEST_COUNT > 0 *)\n  ELSE\n     Treat instruction as non-XRELEASE F3H prefixed legacy instruction\nFI;\n(* For any HLE abort condition encountered during HLE execution *)\nHLE_ABORT_PROCESSING:\n  HLE_ACTIVE <- 0\n  HLE_NEST_COUNT <- 0\n  Restore architectural register state\n  Discard memory updates performed in transaction\n  Free any allocated lock elision buffers\n  IF 64-bit mode\n     THEN\n       RIP <- restartRIP\n     ELSE\n       EIP <- restartEIP\n  FI;\n  Execute and retire instruction at RIP (or EIP) and ignore any HLE hint\nEND\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\n| #GP(0)| If the use of prefix causes instruction\n|       | length to exceed 15 bytes.             \n", 
      "mnem": "XACQUIRE"
    }, 
    {
      "description": "\nXADD - Exchange and Add:\n| Opcode          | Instruction    | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F C0 /r        | XADD r/m8, r8  | MR   | Valid      | Valid          | Exchange r8 and r/m8; load sum into  \n|                 |                |      |            |                | r/m8.                                \n| REX + 0F C0 /r  | XADD r/m8*, r8*| MR   | Valid      | N.E.           | Exchange r8 and r/m8; load sum into  \n|                 |                |      |            |                | r/m8.                                \n| 0F C1 /r        | XADD r/m16, r16| MR   | Valid      | Valid          | Exchange r16 and r/m16; load sum into\n|                 |                |      |            |                | r/m16.                               \n| 0F C1 /r        | XADD r/m32, r32| MR   | Valid      | Valid          | Exchange r32 and r/m32; load sum into\n|                 |                |      |            |                | r/m32.                               \n| REX.W + 0F C1 /r| XADD r/m64, r64| MR   | Valid      | N.E.           | Exchange r64 and r/m64; load sum into\n|                 |                |      |            |                | r/m64.                               \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| MR   | ModRM:r/m (r, w)| ModRM:reg (W)| NA       | NA       \n\nDescription:\nExchanges the first operand (destination operand) with the second operand (source\noperand), then loads the sum of the two values into the destination operand.\nThe destination operand can be a register or a memory location; the source operand\nis a register.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\n\nIA-32 Architecture Compatibility:\nIA-32 processors earlier than the Intel486 processor do not recognize this instruction.\nIf this instruction is used, you should provide an equivalent code sequence\nthat runs on earlier processors.\n\nOperation:\n\nTEMP <- SRC + DEST;\nSRC <- DEST;\nDEST <- TEMP;\n\nFlags Affected:\nThe CF, PF, AF, SF, ZF, and OF flags are set according to the result of the\naddition, which is stored in the destination operand.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination is located in a non-writable\n|                | segment. If a memory operand effective         \n|                | address is outside the CS, DS, ES, FS,         \n|                | or GS segment limit. If the DS, ES,            \n|                | FS, or GS register contains a NULL segment     \n|                | selector.                                      \n| #SS(0)         | If a memory operand effective address          \n|                | is outside the SS segment limit.               \n| #PF(fault-code)| If a page fault occurs.                        \n| #AC(0)         | If alignment checking is enabled and           \n|                | an unaligned memory reference is made          \n|                | while the current privilege level is           \n|                | 3.                                             \n| #UD            | If the LOCK prefix is used but the destination \n|                | is not a memory operand.                       \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "XADD"
    }, 
    {
      "description": "\nXBEGIN  -  Transactional Begin:\n| Opcode/Instruction| Op/En| 64/32bit Mode Support| CPUID Feature Flag| Description                           \n| C7 F8 XBEGIN rel16| A    | V/V                  | RTM               | Specifies the start of an RTM region. \n|                   |      |                      |                   | Provides a 16-bit relative offset to  \n|                   |      |                      |                   | compute the address of the fallback   \n|                   |      |                      |                   | instruction address at which execution\n|                   |      |                      |                   | resumes following an RTM abort.       \n| C7 F8 XBEGIN rel32| A    | V/V                  | RTM               | Specifies the start of an RTM region. \n|                   |      |                      |                   | Provides a 32-bit relative offset to  \n|                   |      |                      |                   | compute the address of the fallback   \n|                   |      |                      |                   | instruction address at which execution\n|                   |      |                      |                   | resumes following an RTM abort.       \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand2| Operand3| Operand4\n| A    | Offset   | NA      | NA      | NA      \n\nDescription:\nThe XBEGIN instruction specifies the start of an RTM code region. If the logical\nprocessor was not already in transactional execution, then the XBEGIN instruction\ncauses the logical processor to transition into transactional execution. The\nXBEGIN instruction that transitions the logical processor into transactional\nexecution is referred to as the outermost XBEGIN instruction. The instruction\nalso specifies a relative offset to compute the address of the fallback code\npath following a transactional abort. On an RTM abort, the logical processor\ndiscards all architectural register and memory updates performed during the\nRTM execution and restores architectural state to that corresponding to the\noutermost XBEGIN instruction. The fallback address following an abort is computed\nfrom the outermost XBEGIN instruction.\n\nOperation:\n\nXBEGIN\nIF RTM_NEST_COUNT < MAX_RTM_NEST_COUNT\n  THEN\n     RTM_NEST_COUNT++\n     IF RTM_NEST_COUNT = 1 THEN\n       IF 64-bit Mode\n          THEN\n               fallbackRIP <- RIP + SignExtend64(IMM)\n                       (* RIP is instruction following XBEGIN instruction *)\n             ELSE\n               fallbackEIP <- EIP + SignExtend32(IMM)\n                       (* EIP is instruction following XBEGIN instruction *)\n       FI;\n       IF (64-bit mode)\n          THEN IF (fallbackRIP is not canonical)\n             THEN #GP(0)\n          FI;\n          ELSE IF (fallbackEIP outside code segment limit)\n             THEN #GP(0)\n          FI;\n       FI;\n       RTM_ACTIVE <- 1\n       Enter RTM Execution (* record register state, start tracking memory state*)\n     FI; (* RTM_NEST_COUNT = 1 *)\n  ELSE (* RTM_NEST_COUNT = MAX_RTM_NEST_COUNT *)\n     GOTO RTM_ABORT_PROCESSING\nFI;\n(* For any RTM abort condition encountered during RTM execution *)\nRTM_ABORT_PROCESSING:\n  Restore architectural register state\n  Discard memory updates performed in transaction\n  Update EAX with status\n  RTM_NEST_COUNT <- 0\n  RTM_ACTIVE <- 0\n  IF 64-bit mode\n     THEN\n       RIP <- fallbackRIP\n     ELSE\n       EIP <- fallbackEIP\n  FI;\nEND\n\nFlags Affected:\nNone\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XBEGIN:| unsigned int _xbegin( void );\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nProtected Mode Exceptions:\n| #UD   | CPUID.(EAX=7, ECX=0):RTM[bit 11]=0.   \n|       | If LOCK prefix is used.               \n| #GP(0)| If the fallback address is outside the\n|       | CS segment.                           \n\nReal-Address Mode Exceptions:\n| #GP(0)| If the fallback address is outside the\n|       | address space 0000H and FFFFH.        \n| #UD   | CPUID.(EAX=7, ECX=0):RTM[bit 11]=0.   \n|       | If LOCK prefix is used.               \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| If the fallback address is outside the\n|       | address space 0000H and FFFFH.        \n| #UD   | CPUID.(EAX=7, ECX=0):RTM[bit 11]=0.   \n|       | If LOCK prefix is used.               \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-bit Mode Exceptions:\n| #UD   | CPUID.(EAX=7, ECX=0):RTM[bit 11] = 0.    \n|       | If LOCK prefix is used.                  \n| #GP(0)| If the fallback address is non-canonical.\n", 
      "mnem": "XBEGIN"
    }, 
    {
      "description": "\nXCHG - Exchange Register/Memory with Register:\n| Opcode       | Instruction    | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                             \n| 90+rw        | XCHG AX, r16   | O    | Valid      | Valid          | Exchange r16 with AX.                   \n| 90+rw        | XCHG r16, AX   | O    | Valid      | Valid          | Exchange AX with r16.                   \n| 90+rd        | XCHG EAX, r32  | O    | Valid      | Valid          | Exchange r32 with EAX.                  \n| REX.W + 90+rd| XCHG RAX, r64  | O    | Valid      | N.E.           | Exchange r64 with RAX.                  \n| 90+rd        | XCHG r32, EAX  | O    | Valid      | Valid          | Exchange EAX with r32.                  \n| REX.W + 90+rd| XCHG r64, RAX  | O    | Valid      | N.E.           | Exchange RAX with r64.                  \n| 86 /r        | XCHG r/m8, r8  | MR   | Valid      | Valid          | Exchange r8 (byte register) with byte   \n|              |                |      |            |                | from r/m8.                              \n| REX + 86 /r  | XCHG r/m8*, r8*| MR   | Valid      | N.E.           | Exchange r8 (byte register) with byte   \n|              |                |      |            |                | from r/m8.                              \n| 86 /r        | XCHG r8, r/m8  | RM   | Valid      | Valid          | Exchange byte from r/m8 with r8 (byte   \n|              |                |      |            |                | register).                              \n| REX + 86 /r  | XCHG r8*, r/m8*| RM   | Valid      | N.E.           | Exchange byte from r/m8 with r8 (byte   \n|              |                |      |            |                | register).                              \n| 87 /r        | XCHG r/m16, r16| MR   | Valid      | Valid          | Exchange r16 with word from r/m16.      \n| 87 /r        | XCHG r16, r/m16| RM   | Valid      | Valid          | Exchange word from r/m16 with r16.      \n| 87 /r        | XCHG r/m32, r32| MR   | Valid      | Valid          | Exchange r32 with doubleword from r/m32.\n| REX.W + 87 /r| XCHG r/m64, r64| MR   | Valid      | N.E.           | Exchange r64 with quadword from r/m64.  \n| 87 /r        | XCHG r32, r/m32| RM   | Valid      | Valid          | Exchange doubleword from r/m32 with     \n|              |                |      |            |                | r32.                                    \n| REX.W + 87 /r| XCHG r64, r/m64| RM   | Valid      | N.E.           | Exchange quadword from r/m64 with r64.  \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1         | Operand 2         | Operand 3| Operand 4\n| O    | AX/EAX/RAX (r, w) | opcode + rd (r, w)| NA       | NA       \n| O    | opcode + rd (r, w)| AX/EAX/RAX (r, w) | NA       | NA       \n| MR   | ModRM:r/m (r, w)  | ModRM:reg (r)     | NA       | NA       \n| RM   | ModRM:reg (w)     | ModRM:r/m (r)     | NA       | NA       \n\nDescription:\nExchanges the contents of the destination (first) and source (second) operands.\nThe operands can be two generalpurpose registers or a register and a memory\nlocation. If a memory operand is referenced, the processor's locking protocol\nis automatically implemented for the duration of the exchange operation, regardless\nof the presence or absence of the LOCK prefix or of the value of the IOPL. (See\nthe LOCK prefix description in this chapter for more information on the locking\nprotocol.)\n\nThis instruction is useful for implementing semaphores or similar data structures\nfor process synchronization. (See \u201cBus Locking\u201d in Chapter 8 of the Intel\u00ae 64\nand IA-32 Architectures Software Developer's Manual, Volume 3A, for more information\non bus locking.)\n\nThe XCHG instruction can also be used instead of the BSWAP instruction for 16-bit\noperands.\n\nIn 64-bit mode, the instruction's default operation size is 32 bits. Using a\nREX prefix in the form of REX.R permits access to additional registers (R8-R15).\nUsing a REX prefix in the form of REX.W promotes operation to 64 bits. See the\nsummary chart at the beginning of this section for encoding data and limits.\n\nOperation:\n\nTEMP <- DEST;\nDEST <- SRC;\nSRC <- TEMP;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If either operand is in a non-writable        \n|                | segment. If a memory operand effective        \n|                | address is outside the CS, DS, ES, FS,        \n|                | or GS segment limit. If the DS, ES,           \n|                | FS, or GS register contains a NULL segment    \n|                | selector.                                     \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "XCHG"
    }, 
    {
      "description": "\nXEND  -  Transactional End:\n| Opcode/Instruction| Op/En| 64/32bit Mode Support| CPUID Feature Flag| Description                             \n| 0F 01 D5 XEND     | A    | V/V                  | RTM               | Specifies the end of an RTM code region.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand2| Operand3| Operand4\n| A    | NA       | NA      | NA      | NA      \n\nDescription:\nThe instruction marks the end of an RTM code region. If this corresponds to\nthe outermost scope (that is, including this XEND instruction, the number of\nXBEGIN instructions is the same as number of XEND instructions), the logical\nprocessor will attempt to commit the logical processor state atomically. If\nthe commit fails, the logical processor will rollback all architectural register\nand memory updates performed during the RTM execution. The logical processor\nwill resume execution at the fallback address computed from the outermost XBEGIN\ninstruction. The EAX register is updated to reflect RTM abort information. XEND\nexecuted outside a transactional region will cause a #GP (General Protection\nFault).\n\nOperation:\n\nXEND\nIF (RTM_ACTIVE = 0) THEN\n  SIGNAL #GP\nELSE\n  RTM_NEST_COUNT--\n  IF (RTM_NEST_COUNT = 0) THEN\n     Try to commit transaction\n     IF fail to commit transactional execution\n       THEN\n          GOTO RTM_ABORT_PROCESSING;\n       ELSE (* commit success *)\n          RTM_ACTIVE <- 0\n     FI;\n  FI;\nFI;\n(* For any RTM abort condition encountered during RTM execution *)\nRTM_ABORT_PROCESSING:\n  Restore architectural register state\n  Discard memory updates performed in transaction\n  Update EAX with status\n  RTM_NEST_COUNT <- 0\n  RTM_ACTIVE <- 0\n  IF 64-bit Mode\n     THEN\n       RIP <- fallbackRIP\n     ELSE\n       EIP <- fallbackEIP\n  FI;\nEND\n\nFlags Affected:\nNone\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XEND:| void _xend( void );\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\n| #UD   | CPUID.(EAX=7, ECX=0):RTM[bit 11] = 0.\n|       | If LOCK or 66H or F2H or F3H prefix  \n|       | is used.                             \n| #GP(0)| If RTM_ACTIVE = 0.                   \n", 
      "mnem": "XEND"
    }, 
    {
      "description": "\nXGETBV - Get Value of Extended Control Register:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                                \n| 0F 01 D0| XGETBV     | NP   | Valid      | Valid          | Reads an XCR specified by ECX into EDX:EAX.\n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nReads the contents of the extended control register (XCR) specified in the ECX\nregister into registers EDX:EAX. (On processors that support the Intel 64 architecture,\nthe high-order 32 bits of RCX are ignored.) The EDX register is loaded with\nthe high-order 32 bits of the XCR and the EAX register is loaded with the low-order\n32 bits. (On processors that support the Intel 64 architecture, the high-order\n32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented\nin the XCR being read, the values returned to EDX:EAX in unimplemented bit locations\nare undefined.\n\nXCR0 is supported on any processor that supports the XGETBV instruction. If\nCPUID.(EAX=0DH,ECX=1):EAX.XG1[bit 2] = 1, executing XGETBV with ECX = 1 returns\nin EDX:EAX the logicalAND of XCR0 and the current value of the XINUSE state-component\nbitmap. This allows software to discover the state of the init optimization\nused by XSAVEOPT and XSAVES. See Chapter 13, \u201cManaging State Using the XSAVE\nFeature Set\u201a\u201d in Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual,\nVolume 1.\n\nUse of any other value for ECX results in a general-protection (#GP) exception.\n\nOperation:\n\nEDX:EAX <- XCR[ECX];\n\nFlags Affected:\nNone.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XGETBV:| unsigned __int64 _xgetbv( unsigned int);\n\nProtected Mode Exceptions:\n| #GP(0)| If an invalid XCR is specified in ECX                 \n|       | (includes ECX = 1 if CPUID.(EAX=0DH,ECX=1):EAX.XG1[bit\n|       | 2] = 0).                                              \n| #UD   | If CPUID.01H:ECX.XSAVE[bit 26] = 0.                   \n|       | If CR4.OSXSAVE[bit 18] = 0. If the LOCK               \n|       | prefix is used. If 66H, F3H or F2H prefix             \n|       | is used.                                              \n\nReal-Address Mode Exceptions:\n| #GP(0)| If an invalid XCR is specified in ECX                 \n|       | (includes ECX = 1 if CPUID.(EAX=0DH,ECX=1):EAX.XG1[bit\n|       | 2] = 0).                                              \n| #UD   | If CPUID.01H:ECX.XSAVE[bit 26] = 0.                   \n|       | If CR4.OSXSAVE[bit 18] = 0. If the LOCK               \n|       | prefix is used. If 66H, F3H or F2H prefix             \n|       | is used.                                              \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "XGETBV"
    }, 
    {
      "description": "\nXLAT/XLATB - Table Look-up Translation:\n| Opcode    | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                               \n| D7        | XLAT m8    | NP   | Valid      | Valid          | Set AL to memory byte DS:[(E)BX + unsigned\n|           |            |      |            |                | AL].                                      \n| D7        | XLATB      | NP   | Valid      | Valid          | Set AL to memory byte DS:[(E)BX + unsigned\n|           |            |      |            |                | AL].                                      \n| REX.W + D7| XLATB      | NP   | Valid      | N.E.           | Set AL to memory byte [RBX + unsigned     \n|           |            |      |            |                | AL].                                      \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nLocates a byte entry in a table in memory, using the contents of the AL register\nas a table index, then copies the contents of the table entry back into the\nAL register. The index in the AL register is treated as an unsigned integer.\nThe XLAT and XLATB instructions get the base address of the table in memory\nfrom either the DS:EBX or the DS:BX registers (depending on the address-size\nattribute of the instruction, 32 or 16, respectively). (The DS segment may be\noverridden with a segment override prefix.)\n\nAt the assembly-code level, two forms of this instruction are allowed: the \u201cexplicit-operand\u201d\nform and the \u201cnooperand\u201d form. The explicit-operand form (specified with the\nXLAT mnemonic) allows the base address of the table to be specified explicitly\nwith a symbol. This explicit-operands form is provided to allow documentation;\nhowever, note that the documentation provided by this form can be misleading.\nThat is, the symbol does not have to specify the correct base address. The base\naddress is always specified by the DS:(E)BX registers, which must be loaded\ncorrectly before the XLAT instruction is executed.\n\nThe no-operands form (XLATB) provides a \u201cshort form\u201d of the XLAT instructions.\nHere also the processor assumes that the DS:(E)BX registers contain the base\naddress of the table.\n\nIn 64-bit mode, operation is similar to that in legacy or compatibility mode.\nAL is used to specify the table index (the operand size is fixed at 8 bits).\nRBX, however, is used to specify the table's base address. See the summary chart\nat the beginning of this section for encoding data and limits.\n\nOperation:\n\nIF AddressSize = 16\n  THEN\n     AL <- (DS:BX + ZeroExtend(AL));\n  ELSE IF (AddressSize = 32)\n     AL <- (DS:EBX + ZeroExtend(AL)); FI;\n  ELSE (AddressSize = 64)\n     AL <- (RBX + ZeroExtend(AL));\nFI;\n\nFlags Affected:\nNone.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit. If the DS, ES, FS, or \n|                | GS register contains a NULL segment  \n|                | selector.                            \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #UD            | If the LOCK prefix is used.          \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address\n|    | is outside the CS, DS, ES, FS, or GS \n|    | segment limit.                       \n| #SS| If a memory operand effective address\n|    | is outside the SS segment limit.     \n| #UD| If the LOCK prefix is used.          \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address\n|                | is outside the CS, DS, ES, FS, or GS \n|                | segment limit.                       \n| #SS(0)         | If a memory operand effective address\n|                | is outside the SS segment limit.     \n| #PF(fault-code)| If a page fault occurs.              \n| #UD            | If the LOCK prefix is used.          \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form.                                      \n| #PF(fault-code)| If a page fault occurs.                    \n| #UD            | If the LOCK prefix is used.                \n", 
      "mnem": "XLAT"
    }, 
    {
      "description": "-R:XLAT", 
      "mnem": "XLATB"
    }, 
    {
      "description": "\nXOR - Logical Exclusive OR:\n| Opcode          | Instruction     | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                     \n| 34 ib           | XOR AL, imm8    | I    | Valid      | Valid          | AL XOR imm8.                    \n| 35 iw           | XOR AX, imm16   | I    | Valid      | Valid          | AX XOR imm16.                   \n| 35 id           | XOR EAX, imm32  | I    | Valid      | Valid          | EAX XOR imm32.                  \n| REX.W + 35 id   | XOR RAX, imm32  | I    | Valid      | N.E.           | RAX XOR imm32 (sign-extended).  \n| 80 /6 ib        | XOR r/m8, imm8  | MI   | Valid      | Valid          | r/m8 XOR imm8.                  \n| REX + 80 /6 ib  | XOR r/m8*, imm8 | MI   | Valid      | N.E.           | r/m8 XOR imm8.                  \n| 81 /6 iw        | XOR r/m16, imm16| MI   | Valid      | Valid          | r/m16 XOR imm16.                \n| 81 /6 id        | XOR r/m32, imm32| MI   | Valid      | Valid          | r/m32 XOR imm32.                \n| REX.W + 81 /6 id| XOR r/m64, imm32| MI   | Valid      | N.E.           | r/m64 XOR imm32 (sign-extended).\n| 83 /6 ib        | XOR r/m16, imm8 | MI   | Valid      | Valid          | r/m16 XOR imm8 (sign-extended). \n| 83 /6 ib        | XOR r/m32, imm8 | MI   | Valid      | Valid          | r/m32 XOR imm8 (sign-extended). \n| REX.W + 83 /6 ib| XOR r/m64, imm8 | MI   | Valid      | N.E.           | r/m64 XOR imm8 (sign-extended). \n| 30 /r           | XOR r/m8, r8    | MR   | Valid      | Valid          | r/m8 XOR r8.                    \n| REX + 30 /r     | XOR r/m8*, r8*  | MR   | Valid      | N.E.           | r/m8 XOR r8.                    \n| 31 /r           | XOR r/m16, r16  | MR   | Valid      | Valid          | r/m16 XOR r16.                  \n| 31 /r           | XOR r/m32, r32  | MR   | Valid      | Valid          | r/m32 XOR r32.                  \n| REX.W + 31 /r   | XOR r/m64, r64  | MR   | Valid      | N.E.           | r/m64 XOR r64.                  \n| 32 /r           | XOR r8, r/m8    | RM   | Valid      | Valid          | r8 XOR r/m8.                    \n| REX + 32 /r     | XOR r8*, r/m8*  | RM   | Valid      | N.E.           | r8 XOR r/m8.                    \n| 33 /r           | XOR r16, r/m16  | RM   | Valid      | Valid          | r16 XOR r/m16.                  \n| 33 /r           | XOR r32, r/m32  | RM   | Valid      | Valid          | r32 XOR r/m32.                  \n| REX.W + 33 /r   | XOR r64, r/m64  | RM   | Valid      | N.E.           | r64 XOR r/m64.                  \nNotes: * In 64-bit mode, r/m8 can not be encoded to access the following byte\nregisters if a REX prefix is used: AH, BH, CH, DH.\n\n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3| Operand 4\n| I    | AL/AX/EAX/RAX   | imm8/16/32   | NA       | NA       \n| MI   | ModRM:r/m (r, w)| imm8/16/32   | NA       | NA       \n| MR   | ModRM:r/m (r, w)| ModRM:reg (r)| NA       | NA       \n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA       | NA       \n\nDescription:\nPerforms a bitwise exclusive OR (XOR) operation on the destination (first) and\nsource (second) operands and stores the result in the destination operand location.\nThe source operand can be an immediate, a register, or a memory location; the\ndestination operand can be a register or a memory location. (However, two memory\noperands cannot be used in one instruction.) Each bit of the result is 1 if\nthe corresponding bits of the operands are different; each bit is 0 if the corresponding\nbits are the same.\n\nThis instruction can be used with a LOCK prefix to allow the instruction to\nbe executed atomically.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional\nregisters (R8-R15). Using a REX prefix in the form of REX.W promotes operation\nto 64 bits. See the summary chart at the beginning of this section for encoding\ndata and limits.\n\nOperation:\n\nDEST <- DEST XOR SRC;\n\nFlags Affected:\nThe OF and CF flags are cleared; the SF, ZF, and PF flags are set according\nto the result. The state of the AF flag is undefined.\n\n\nProtected Mode Exceptions:\n| #GP(0)         | If the destination operand points to          \n|                | a non-writable segment. If a memory           \n|                | operand effective address is outside          \n|                | the CS, DS, ES, FS, or GS segment limit.      \n|                | If the DS, ES, FS, or GS register contains    \n|                | a NULL segment selector.                      \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand effective address         \n|    | is outside the CS, DS, ES, FS, or GS          \n|    | segment limit.                                \n| #SS| If a memory operand effective address         \n|    | is outside the SS segment limit.              \n| #UD| If the LOCK prefix is used but the destination\n|    | is not a memory operand.                      \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)         | If a memory operand effective address         \n|                | is outside the CS, DS, ES, FS, or GS          \n|                | segment limit.                                \n| #SS(0)         | If a memory operand effective address         \n|                | is outside the SS segment limit.              \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made.        \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the           \n|                | SS segment is in a non-canonical form.        \n| #GP(0)         | If the memory address is in a non-canonical   \n|                | form.                                         \n| #PF(fault-code)| If a page fault occurs.                       \n| #AC(0)         | If alignment checking is enabled and          \n|                | an unaligned memory reference is made         \n|                | while the current privilege level is          \n|                | 3.                                            \n| #UD            | If the LOCK prefix is used but the destination\n|                | is not a memory operand.                      \n", 
      "mnem": "XOR"
    }, 
    {
      "description": "\nXORPD - Bitwise Logical XOR for Double-Precision Floating-Point Values:\n| Opcode/Instruction                           | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| 66 0F 57 /r XORPD xmm1, xmm2/m128            | RM   | V/V                   | SSE2              | Bitwise exclusive-OR of xmm2/m128 and   \n|                                              |      |                       |                   | xmm1.                                   \n| VEX.NDS.128.66.0F.WIG 57 /r VXORPD xmm1,xmm2,| RVM  | V/V                   | AVX               | Return the bitwise logical XOR of packed\n| xmm3/m128                                    |      |                       |                   | double-precision floating-point values  \n|                                              |      |                       |                   | in xmm2 and xmm3/mem.                   \n| VEX.NDS.256.66.0F.WIG 57 /r VXORPD ymm1,     | RVM  | V/V                   | AVX               | Return the bitwise logical XOR of packed\n| ymm2, ymm3/m256                              |      |                       |                   | double-precision floating-point values  \n|                                              |      |                       |                   | in ymm2 and ymm3/mem.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a bitwise logical exclusive-OR of the two packed double-precision floating-point\nvalues from the source operand (second operand) and the destination operand\n(first operand), and stores the result in the destination operand. The source\noperand can be an XMM register or a 128-bit memory location. The destination\noperand is an XMM register.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed. VEX.256 encoded version:\nThe first source operand is a YMM register. The second source operand can be\na YMM register or a 256-bit memory location. The destination operand is a YMM\nregister.\n\nOperation:\n\nXORPD (128-bit Legacy SSE version)\nDEST[63:0] <- DEST[63:0] BITWISE XOR SRC[63:0]\nDEST[127:64] <- DEST[127:64] BITWISE XOR SRC[127:64]\nDEST[VLMAX-1:128] (Unmodified)\nVXORPD (VEX.128 encoded version)\nDEST[63:0] <- SRC1[63:0] BITWISE XOR SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] BITWISE XOR SRC2[127:64]\nDEST[VLMAX-1:128] <- 0\nVXORPD (VEX.256 encoded version)\nDEST[63:0] <- SRC1[63:0] BITWISE XOR SRC2[63:0]\nDEST[127:64] <- SRC1[127:64] BITWISE XOR SRC2[127:64]\nDEST[191:128] <- SRC1[191:128] BITWISE XOR SRC2[191:128]\nDEST[255:192] <- SRC1[255:192] BITWISE XOR SRC2[255:192]\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XORPD: | __m128d _mm_xor_pd(__m128d a, __m128d    \n|        | b)                                       \n| VXORPD:| __m256d _mm256_xor_pd (__m256d a, __m256d\n|        | b);                                      \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "XORPD"
    }, 
    {
      "description": "\nXORPS - Bitwise Logical XOR for Single-Precision Floating-Point Values:\n| Opcode/Instruction                        | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                             \n| 0F 57 /r XORPS xmm1, xmm2/m128            | RM   | V/V                   | SSE               | Bitwise exclusive-OR of xmm2/m128 and   \n|                                           |      |                       |                   | xmm1.                                   \n| VEX.NDS.128.0F.WIG 57 /r VXORPS xmm1,xmm2,| RVM  | V/V                   | AVX               | Return the bitwise logical XOR of packed\n| xmm3/m128                                 |      |                       |                   | singleprecision floating-point values   \n|                                           |      |                       |                   | in xmm2 and xmm3/mem.                   \n| VEX.NDS.256.0F.WIG 57 /r VXORPS ymm1,     | RVM  | V/V                   | AVX               | Return the bitwise logical XOR of packed\n| ymm2, ymm3/m256                           |      |                       |                   | singleprecision floating-point values   \n|                                           |      |                       |                   | in ymm2 and ymm3/mem.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1       | Operand 2    | Operand 3    | Operand 4\n| RM   | ModRM:reg (r, w)| ModRM:r/m (r)| NA           | NA       \n| RVM  | ModRM:reg (w)   | VEX.vvvv (r) | ModRM:r/m (r)| NA       \n\nDescription:\nPerforms a bitwise logical exclusive-OR of the four packed single-precision\nfloating-point values from the source operand (second operand) and the destination\noperand (first operand), and stores the result in the destination operand. The\nsource operand can be an XMM register or a 128-bit memory location. The destination\noperand is an XMM register.\n\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction\nto access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The\nsecond source can be an XMM register or an 128-bit memory location. The destination\nis not distinct from the first source XMM register and the upper bits (VLMAX-1:128)\nof the corresponding YMM register destination are unmodified. VEX.128 encoded\nversion: the first source operand is an XMM register or 128-bit memory location.\nThe destination operand is an XMM register. The upper bits (VLMAX-1:128) of\nthe corresponding YMM register destination are zeroed. VEX.256 encoded version:\nThe first source operand is a YMM register. The second source operand can be\na YMM register or a 256-bit memory location. The destination operand is a YMM\nregister.\n\nOperation:\n\nXORPS (128-bit Legacy SSE version)\nDEST[31:0] <- SRC1[31:0] BITWISE XOR SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] BITWISE XOR SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] BITWISE XOR SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] BITWISE XOR SRC2[127:96]\nDEST[VLMAX-1:128] (Unmodified)\nVXORPS (VEX.128 encoded version)\nDEST[31:0] <- SRC1[31:0] BITWISE XOR SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] BITWISE XOR SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] BITWISE XOR SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] BITWISE XOR SRC2[127:96]\nDEST[VLMAX-1:128] <- 0\nVXORPS (VEX.256 encoded version)\nDEST[31:0] <- SRC1[31:0] BITWISE XOR SRC2[31:0]\nDEST[63:32] <- SRC1[63:32] BITWISE XOR SRC2[63:32]\nDEST[95:64] <- SRC1[95:64] BITWISE XOR SRC2[95:64]\nDEST[127:96] <- SRC1[127:96] BITWISE XOR SRC2[127:96]\nDEST[159:128] <- SRC1[159:128] BITWISE XOR SRC2[159:128]\nDEST[191:160]<- SRC1[191:160] BITWISE XOR SRC2[191:160]\nDEST[223:192] <- SRC1[223:192] BITWISE XOR SRC2[223:192]\nDEST[255:224] <- SRC1[255:224] BITWISE XOR SRC2[255:224].\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XORPS: | __m128 _mm_xor_ps(__m128 a, __m128 b) \n| VXORPS:| __m256 _mm256_xor_ps (__m256 a, __m256\n|        | b);                                   \n\nSIMD Floating-Point Exceptions:\nNone.\n\n\nOther Exceptions:\nSee Exceptions Type 4.\n\n", 
      "mnem": "XORPS"
    }, 
    {
      "description": "-R:XACQUIRE", 
      "mnem": "XRELEASE"
    }, 
    {
      "description": "\nXRSTOR - Restore Processor Extended States:\n| Opcode         | Instruction | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F AE /5       | XRSTOR mem  | M    | Valid      | Valid          | Restore state components specified by\n|                |             |      |            |                | EDX:EAX from mem.                    \n| REX.W+ 0F AE /5| XRSTOR64 mem| M    | Valid      | N.E.           | Restore state components specified by\n|                |             |      |            |                | EDX:EAX from mem.                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nPerforms a full or partial restore of processor state components from the XSAVE\narea located at the memory address specified by the source operand. The implicit\nEDX:EAX register pair specifies a 64-bit instruction mask. The specific state\ncomponents restored correspond to the bits set in the requested-feature bitmap\n(RFBM), which is the logical-AND of EDX:EAX and XCR0.\n\nThe format of the XSAVE area is detailed in Section 13.4, \u201cXSAVE Area,\u201d of Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1.\n\nSection 13.7, \u201cOperation of XRSTOR,\u201d of Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1 provides a detailed description of the operation\nof the XRSTOR instruction. The following items provide a highlevel outline:\n\n - Execution of XRSTOR may take one of two forms: standard and compacted. Bit 63\nof the XCOMP_BV field in the XSAVE header determines which form is used: value\n0 specifies the standard form, while value 1 specifies the compacted form.\n - If RFBM[i] = 0, XRSTOR does not update state component i.1\n - If RFBM[i] = 1 and bit i is clear in the XSTATE_BV field in the XSAVE header,\nXRSTOR initializes state component i.\n - If RFBM[i] = 1 and XSTATE_BV[i] = 1, XRSTOR loads state component i from the\nXSAVE area.\n - The standard form of XRSTOR treats MXCSR (which is part of state component 1\n -  SSE) differently from the XMM registers. If either form attempts to load MXCSR\nwith an illegal value, a general-protection exception (#GP) occurs.\n - XRSTOR loads the internal value XRSTOR_INFO, which may be used to optimize a\nsubsequent execution of XSAVEOPT or XSAVES.\n - Immediately following an execution of XRSTOR, the processor tracks as in-use\n(not in initial configuration) any state component i for which RFBM[i] = 1 and\nXSTATE_BV[i] = 1; it tracks as modified any state component i for which RFBM[i]\n= 0.\n\nUse of a source operand not aligned to 64-byte boundary (for 64-bit and 32-bit\nmodes) results in a general-protection (#GP) exception. In 64-bit mode, the\nupper 32 bits of RDX and RAX are ignored.\n\nOperation:\n\nRFBM <- XCR0 AND EDX:EAX;\nCOMPMASK <- XCOMP_BV field from XSAVE header;\nRSTORMASK <- XSTATE_BV field from XSAVE header;\nIF in VMX non-root operation\n  THEN VMXNR <- 1;\n1.\n  even though MXCSR is part of state component 1  -  SSE. The compacted form of XRSTOR does not make this exception.\n  ELSE VMXNR <- 0;\nFI;\nLAXA <- linear address of XSAVE area;\nIF COMPMASK[63] = 0\n  THEN\n     /* Standard form of XRSTOR */\n     If RFBM[0] = 1\n       THEN\n          IF RSTORMASK[0] = 1\n             THEN load x87 state from legacy region of XSAVE area;\n             ELSE initialize x87 state;\n          FI;\n     FI;\n     If RFBM[1] = 1\n       THEN\n          IF RSTORMASK[1] = 1\n             THEN load XMM registers from legacy region of XSAVE area;\n             ELSE set all XMM registers to 0;\n          FI;\n     FI;\n     If RFBM[2] = 1\n       THEN\n          IF RSTORMASK[2] = 1\n             THEN load AVX state from extended region (standard format) of XSAVE area;\n             ELSE initialize AVX state;\n          FI;\n     FI;\n     If RFBM[1] = 1 or RFBM[2] = 1\n       THEN load MXCSR from legacy region of XSAVE area;\n     FI;\nFI;\n  ELSE\n     /* Compacted form of XRSTOR */\n     IF CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit 1] = 0\n       THEN\n          #GP(0);\n     FI;\n     If RFBM[0] = 1\n       THEN\n          IF RSTORMASK[0] = 1\n             THEN load x87 state from legacy region of XSAVE area;\n             ELSE initialize x87 state;\n          FI;\n     FI;\n     If RFBM[1] = 1\n       THEN\n          IF RSTORMASK[1] = 1\n             THEN load SSE state from legacy region of XSAVE area;\n             ELSE initialize SSE state;\n          FI;\n     FI;\n     If RFBM[2] = 1\n       THEN\n          IF RSTORMASK[2] = 1\n             THEN load AVX state from extended region (compacted format) of XSAVE area;\n             ELSE initialize AVX state;\n          FI;\n     FI;\nFI;\nXRSTOR_INFO <- \uf0e1CPL,VMXNR,LAXA,COMPMASK\uf0f1;\n\nFlags Affected:\nNone.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XRSTOR:| void _xrstor( void * , unsigned __int64);  \n| XRSTOR:| void _xrstor64( void * , unsigned __int64);\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address                                  \n|                | is outside the CS, DS, ES, FS, or GS                                   \n|                | segment limit. If a memory operand is                                  \n|                | not aligned on a 64-byte boundary, regardless                          \n|                | of segment. If bit 63 of the XCOMP_BV                                  \n|                | field of the XSAVE header is 1 and CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit\n|                | 1] = 0. If the standard form is executed                               \n|                | and a bit in XCR0 is 0 and the corresponding                           \n|                | bit in the XSTATE_BV field of the XSAVE                                \n|                | header is 1. If the standard form is                                   \n|                | executed and bytes 23:8 of the XSAVE                                   \n|                | header are not all zero. If the compacted                              \n|                | form is executed and a bit in XCR0 is                                  \n|                | 0 and the corresponding bit in the XCOMP_BV                            \n|                | field of the XSAVE header is 1. If the                                 \n|                | compacted form is executed and a bit                                   \n|                | in the XCOMP_BV field in the XSAVE header                              \n|                | is 0 and the corresponding bit in the                                  \n|                | XSTATE_BV field is 1. If the compacted                                 \n|                | form is executed and bytes 63:16 of                                    \n|                | the XSAVE header are not all zero. If                                  \n|                | attempting to write any reserved bits                                  \n|                | of the MXCSR register with 1.                                          \n| #SS(0)         | If a memory operand effective address                                  \n|                | is outside the SS segment limit.                                       \n| #PF(fault-code)| If a page fault occurs.                                                \n| #NM            | If CR0.TS[bit 3] = 1.                                                  \n| #UD            | If CPUID.01H:ECX.XSAVE[bit 26] = 0.                                    \n|                | If CR4.OSXSAVE[bit 18] = 0. If any of                                  \n|                | the LOCK, 66H, F3H or F2H prefixes is                                  \n|                | used.                                                                  \n| #AC            | If this exception is disabled a general                                \n|                | protection exception (#GP) is signaled                                 \n|                | if the memory operand is not aligned                                   \n|                | on a 16-byte boundary, as described                                    \n|                | above. If the alignment check exception                                \n|                | (#AC) is enabled (and the CPL is 3),                                   \n|                | signaling of #AC is not guaranteed and                                 \n|                | may vary with implementation, as follows.                              \n|                | In all implementations where #AC is                                    \n|                | not signaled, a general protection exception                           \n|                | is signaled in its place. In addition,                                 \n|                | the width of the alignment check may                                   \n|                | also vary with implementation. For instance,                           \n|                | for a given implementation, an alignment                               \n|                | check exception might be signaled for                                  \n|                | a 2-byte misalignment, whereas a general                               \n|                | protection exception might be signaled                                 \n|                | for all other misalignments (4-, 8-,                                   \n|                | or 16-byte misalignments).                                             \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand is not aligned on                            \n|    | a 64-byte boundary, regardless of segment.                       \n|    | If any part of the operand lies outside                          \n|    | the effective address space from 0 to                            \n|    | FFFFH. If bit 63 of the XCOMP_BV field                           \n|    | of the XSAVE header is 1 and CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit\n|    | 1] = 0.                                                          \nIf the standard form is executed and a bit in XCR0 is 0 and the corresponding\nbit in the XSTATE_BV field of the XSAVE header is 1. If the standard form is\nexecuted and bytes 23:8 of the XSAVE header are not all zero. If the compacted\nform is executed and a bit in XCR0 is 0 and the corresponding bit in the XCOMP_BV\nfield of the XSAVE header is 1. If the compacted form is executed and a bit\nin the XCOMP_BV field in the XSAVE header is 0 and the corresponding bit in\nthe XSTATE_BV field is 1. If the compacted form is executed and bytes 63:16\nof the XSAVE header are not all zero. If attempting to write any reserved bits\nof the MXCSR register with 1.\n\n| #NM| If CR0.TS[bit 3] = 1.                \n| #UD| If CPUID.01H:ECX.XSAVE[bit 26] = 0.  \n|    | If CR4.OSXSAVE[bit 18] = 0. If any of\n|    | the LOCK, 66H, F3H or F2H prefixes is\n|    | used.                                \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If a memory address is in a non-canonical                        \n|                | form. If a memory operand is not aligned                         \n|                | on a 64-byte boundary, regardless of                             \n|                | segment. If bit 63 of the XCOMP_BV field                         \n|                | of the XSAVE header is 1 and CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit\n|                | 1] = 0. If the standard form is executed                         \n|                | and a bit in XCR0 is 0 and the corresponding                     \n|                | bit in the XSTATE_BV field of the XSAVE                          \n|                | header is 1. If the standard form is                             \n|                | executed and bytes 23:8 of the XSAVE                             \n|                | header are not all zero. If the compacted                        \n|                | form is executed and a bit in XCR0 is                            \n|                | 0 and the corresponding bit in the XCOMP_BV                      \n|                | field of the XSAVE header is 1. If the                           \n|                | compacted form is executed and a bit                             \n|                | in the XCOMP_BV field in the XSAVE header                        \n|                | is 0 and the corresponding bit in the                            \n|                | XSTATE_BV field is 1. If the compacted                           \n|                | form is executed and bytes 63:16 of                              \n|                | the XSAVE header are not all zero. If                            \n|                | attempting to write any reserved bits                            \n|                | of the MXCSR register with 1.                                    \n| #SS(0)         | If a memory address referencing the                              \n|                | SS segment is in a non-canonical form.                           \n| #PF(fault-code)| If a page fault occurs.                                          \n| #NM            | If CR0.TS[bit 3] = 1.                                            \n| #UD            | If CPUID.01H:ECX.XSAVE[bit 26] = 0.                              \n|                | If CR4.OSXSAVE[bit 18] = 0. If any of                            \n|                | the LOCK, 66H, F3H or F2H prefixes is                            \n|                | used.                                                            \n| #AC            | If this exception is disabled a general                          \n|                | protection exception (#GP) is signaled                           \n|                | if the memory operand is not aligned                             \n|                | on a 16-byte boundary, as described                              \n|                | above. If the alignment check exception                          \n|                | (#AC) is enabled (and the CPL is 3),                             \n|                | signaling of #AC is not guaranteed and                           \n|                | may vary with implementation, as follows.                        \n|                | In all implementations where #AC is                              \n|                | not signaled, a general protection exception                     \n|                | is signaled in its place. In addition,                           \n|                | the width of the alignment check may                             \n|                | also vary with implementation. For instance,                     \n|                | for a given implementation, an alignment                         \n|                | check exception might be signaled for                            \n|                | a 2-byte misalignment, whereas a general                         \n|                | protection exception might be signaled                           \n|                | for all other misalignments (4-, 8-,                             \n|                | or 16-byte misalignments).                                       \n", 
      "mnem": "XRSTOR"
    }, 
    {
      "description": "\nXRSTORS - Restore Processor Extended States Supervisor:\n| Opcode         | Instruction  | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F C7 /3       | XRSTORS mem  | M    | Valid      | Valid          | Restore state components specified by\n|                |              |      |            |                | EDX:EAX from mem.                    \n| REX.W+ 0F C7 /3| XRSTORS64 mem| M    | Valid      | N.E.           | Restore state components specified by\n|                |              |      |            |                | EDX:EAX from mem.                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (r)| NA       | NA       | NA       \n\nDescription:\nPerforms a full or partial restore of processor state components from the XSAVE\narea located at the memory address specified by the source operand. The implicit\nEDX:EAX register pair specifies a 64-bit instruction mask. The specific state\ncomponents restored correspond to the bits set in the requested-feature bitmap\n(RFBM), which is the logical-AND of EDX:EAX and the logical-OR of XCR0 with\nthe IA32_XSS MSR. XRSTORS may be executed only if CPL = 0.\n\nThe format of the XSAVE area is detailed in Section 13.4, \u201cXSAVE Area,\u201d of Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1.\n\nSection 13.11, \u201cOperation of XRSTORS,\u201d of Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1 provides a detailed description of the\noperation of the XRSTOR instruction. The following items provide a high-level\noutline:\n\n - Execution of XRSTORS is similar to that of the compacted form of XRSTOR; XRSTORS\ncannot restore from an XSAVE area in which the extended region is in the standard\nformat (see Section 13.4.3, \u201cExtended Region of an XSAVE Area\u201d).\n - XRSTORS differs from XRSTOR in that it can restore state components corresponding\nto bits set in the IA32_XSS MSR.\n - If RFBM[i] = 0, XRSTORS does not update state component i.\n - If RFBM[i] = 1 and bit i is clear in the XSTATE_BV field in the XSAVE header,\nXRSTORS initializes state component i.\n - If RFBM[i] = 1 and XSTATE_BV[i] = 1, XRSTORS loads state component i from the\nXSAVE area.\n - If XRSTORS attempts to load MXCSR with an illegal value, a general-protection\nexception (#GP) occurs.\n - XRSTORS loads the internal value XRSTOR_INFO, which may be used to optimize\na subsequent execution of XSAVEOPT or XSAVES.\n - Immediately following an execution of XRSTORS, the processor tracks as in-use\n(not in initial configuration) any state component i for which RFBM[i] = 1 and\nXSTATE_BV[i] = 1; it tracks as modified any state component i for which RFBM[i]\n= 0.\n\nUse of a source operand not aligned to 64-byte boundary (for 64-bit and 32-bit\nmodes) results in a general-protection (#GP) exception. In 64-bit mode, the\nupper 32 bits of RDX and RAX are ignored.\n\nOperation:\n\nRFBM <- (XCR0 OR IA32_XSS) AND EDX:EAX;\nCOMPMASK <- XCOMP_BV field from XSAVE header;\nRSTORMASK <- XSTATE_BV field from XSAVE header;\nIF in VMX non-root operation\n  THEN VMXNR <- 1;\n  ELSE VMXNR <- 0;\nFI;\nLAXA <- linear address of XSAVE area;\nIf RFBM[0] = 1\n  THEN\n     IF RSTORMASK[0] = 1\n       THEN load x87 state from legacy region of XSAVE area;\n       ELSE initialize x87 state;\n     FI;\nFI;\nIf RFBM[1] = 1\n  THEN\n     IF RSTORMASK[1] = 1\n       THEN load SSE state from legacy region of XSAVE area;\n       ELSE initialize SSE state;\n     FI;\nFI;\nIf RFBM[2] = 1\n  THEN\n     IF RSTORMASK[2] = 1\n       THEN load AVX state from extended region (compacted format) of XSAVE area;\n       ELSE initialize AVX state;\n     FI;\nFI;\nXRSTOR_INFO <- \uf0e1CPL,VMXNR,LAXA,COMPMASK\uf0f1;\n\nFlags Affected:\nNone.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XRSTORS: XRSTORS64: void _xrstors64(| void _xrstors( void * , unsigned __int64);\n| void * , unsigned __int64);         |                                           \n\nProtected Mode Exceptions:\n| #GP(0)         | If CPL > 0. If a memory operand effective\n|                | address is outside the CS, DS, ES, FS,   \n|                | or GS segment limit. If a memory operand \n|                | is not aligned on a 64-byte boundary,    \n|                | regardless of segment. If bit 63 of      \n|                | the XCOMP_BV field of the XSAVE header   \n|                | is 0. If a bit in XCR0 is 0 and the      \n|                | corresponding bit in the XCOMP_BV field  \n|                | of the XSAVE header is 1. If a bit in    \n|                | the XCOMP_BV field in the XSAVE header   \n|                | is 0 and the corresponding bit in the    \n|                | XSTATE_BV field is 1. If bytes 63:16     \n|                | of the XSAVE header are not all zero.    \n|                | If attempting to write any reserved      \n|                | bits of the MXCSR register with 1.       \n| #SS(0)         | If a memory operand effective address    \n|                | is outside the SS segment limit.         \n| #PF(fault-code)| If a page fault occurs.                  \n| #NM            | If CR0.TS[bit 3] = 1.                    \n| #UD            | If CPUID.01H:ECX.XSAVE[bit 26] = 0 or    \n|                | CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3]     \n|                | = 0. If CR4.OSXSAVE[bit 18] = 0. If      \n|                | any of the LOCK, 66H, F3H or F2H prefixes\n|                | is used.                                 \n| #AC            | If this exception is disabled a general  \n|                | protection exception (#GP) is signaled   \n|                | if the memory operand is not aligned     \n|                | on a 16-byte boundary, as described      \n|                | above. If the alignment check            \nexception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed\nand may vary with implementation, as follows. In all implementations where #AC\nis not signaled, a #GP is signaled in its place. In addition, the width of the\nalignment check may also vary with implementation. For instance, for a given\nimplementation, an alignment check exception might be signaled for a 2-byte\nmisalignment, whereas a #GP might be signaled for all other misalignments (4-,\n8-, or 16-byte misalignments).\n\n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand is not aligned on         \n|    | a 64-byte boundary, regardless of segment.    \n|    | If any part of the operand lies outside       \n|    | the effective address space from 0 to         \n|    | FFFFH. If bit 63 of the XCOMP_BV field        \n|    | of the XSAVE header is 0. If a bit in         \n|    | XCR0 is 0 and the corresponding bit           \n|    | in the XCOMP_BV field of the XSAVE header     \n|    | is 1. If a bit in the XCOMP_BV field          \n|    | in the XSAVE header is 0 and the corresponding\n|    | bit in the XSTATE_BV field is 1. If           \n|    | bytes 63:16 of the XSAVE header are           \n|    | not all zero. If attempting to write          \n|    | any reserved bits of the MXCSR register       \n|    | with 1.                                       \n| #NM| If CR0.TS[bit 3] = 1.                         \n| #UD| If CPUID.01H:ECX.XSAVE[bit 26] = 0 or         \n|    | CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3]          \n|    | = 0. If CR4.OSXSAVE[bit 18] = 0. If           \n|    | any of the LOCK, 66H, F3H or F2H prefixes     \n|    | is used.                                      \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If CPL > 0. If a memory address is in       \n|                | a non-canonical form. If a memory operand   \n|                | is not aligned on a 64-byte boundary,       \n|                | regardless of segment. If bit 63 of         \n|                | the XCOMP_BV field of the XSAVE header      \n|                | is 0. If a bit in XCR0 is 0 and the         \n|                | corresponding bit in the XCOMP_BV field     \n|                | of the XSAVE header is 1. If a bit in       \n|                | the XCOMP_BV field in the XSAVE header      \n|                | is 0 and the corresponding bit in the       \n|                | XSTATE_BV field is 1. If bytes 63:16        \n|                | of the XSAVE header are not all zero.       \n|                | If attempting to write any reserved         \n|                | bits of the MXCSR register with 1.          \n| #SS(0)         | If a memory address referencing the         \n|                | SS segment is in a non-canonical form.      \n| #PF(fault-code)| If a page fault occurs.                     \n| #NM            | If CR0.TS[bit 3] = 1.                       \n| #UD            | If CPUID.01H:ECX.XSAVE[bit 26] = 0 or       \n|                | CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3]        \n|                | = 0. If CR4.OSXSAVE[bit 18] = 0. If         \n|                | any of the LOCK, 66H, F3H or F2H prefixes   \n|                | is used.                                    \n| #AC            | If this exception is disabled a general     \n|                | protection exception (#GP) is signaled      \n|                | if the memory operand is not aligned        \n|                | on a 16-byte boundary, as described         \n|                | above. If the alignment check exception     \n|                | (#AC) is enabled (and the CPL is 3),        \n|                | signaling of #AC is not guaranteed and      \n|                | may vary with implementation, as follows.   \n|                | In all implementations where #AC is         \n|                | not signaled, a general protection exception\n|                | is signaled in its place. In addition,      \n|                | the width of the alignment check may        \n|                | also vary with implementation. For instance,\n|                | for a given implementation, an alignment    \n|                | check exception might be signaled for       \n|                | a 2-byte misalignment, whereas a general    \n|                | protec-                                     \ntion exception might be signaled for all other misalignments (4-, 8-, or 16-byte\nmisalignments).\n\n", 
      "mnem": "XRSTORS"
    }, 
    {
      "description": "\nXSAVE - Save Processor Extended States:\n| Opcode         | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                               \n| 0F AE /4       | XSAVE mem  | M    | Valid      | Valid          | Save state components specified by EDX:EAX\n|                |            |      |            |                | to mem.                                   \n| REX.W+ 0F AE /4| XSAVE64 mem| M    | Valid      | N.E.           | Save state components specified by EDX:EAX\n|                |            |      |            |                | to mem.                                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nPerforms a full or partial save of processor state components to the XSAVE area\nlocated at the memory address specified by the destination operand. The implicit\nEDX:EAX register pair specifies a 64-bit instruction mask. The specific state\ncomponents saved correspond to the bits set in the requested-feature bitmap\n(RFBM), which is the logical-AND of EDX:EAX and XCR0.\n\nThe format of the XSAVE area is detailed in Section 13.4, \u201cXSAVE Area,\u201d of Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1.\n\nSection 13.6, \u201cOperation of XSAVE,\u201d of Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1 provides a detailed description of the operation\nof the XSAVE instruction. The following items provide a high-level outline:\n\n - XSAVE saves state component i if and only if RFBM[i] = 1.1\n - XSAVE does not modify bytes 511:464 of the legacy region of the XSAVE area (see\nSection 13.4.1, \u201cLegacy Region of an XSAVE Area\u201d).\n - XSAVE reads the XSTATE_BV field of the XSAVE header (see Section 13.4.2, \u201cXSAVE\nHeader\u201d) and writes a modified value back to memory as follows. If RFBM[i] =\n1, XSAVE writes XSTATE_BV[i] with the value of XINUSE[i]. (XINUSE is a bitmap\nby which the processor tracks the status of various state components. See Section\n13.5.4, \u201cProcessor Tracking of XSAVE-Managed State.\u201d) If RFBM[i] = 0, XSAVE\nwrites XSTATE_BV[i]with the value that it read from memory (it does not modify\nthe bit). XSAVE does not write to any part of the XSAVE header other than the\nXSTATE_BV field.\n - XSAVE always uses the standard format of the extended region of the XSAVE area\n(see Section 13.4.3, \u201cExtended Region of an XSAVE Area\u201d).\n\nUse of a destination operand not aligned to 64-byte boundary (in either 64-bit\nor 32-bit modes) results in a general-protection (#GP) exception. In 64-bit\nmode, the upper 32 bits of RDX and RAX are ignored.\n\nOperation:\n\nRFBM <- XCR0 AND EDX:EAX;\nOLD_BV <- XSTATE_BV field from XSAVE header;\nIF RFBM[0] = 1\n  THEN store x87 state into legacy region of XSAVE area;\nFI;\nIF RFBM[1] = 1\n  THEN store XMM registers into legacy region of XSAVE area;\nFI;\n1.\n  ory if either RFBM[1] or RFBM[2] is 1.\nIF RFBM[2] = 1\n  THEN store AVX state into extended region of XSAVE area;\nFI;\nIF RFBM[1] = 1 or RFBM[2] = 1\n  THEN store MXCSR and MXCSR_MASK into legacy region of XSAVE area;\nFI;\nXSTATE_BV field in XSAVE header <- (OLD_BV AND ~RFBM) OR (XINUSE AND RFBM);\n\nFlags Affected:\nNone.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XSAVE:| void _xsave( void * , unsigned __int64);  \n| XSAVE:| void _xsave64( void * , unsigned __int64);\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address        \n|                | is outside the CS, DS, ES, FS, or GS         \n|                | segment limit. If a memory operand is        \n|                | not aligned on a 64-byte boundary, regardless\n|                | of segment.                                  \n| #SS(0)         | If a memory operand effective address        \n|                | is outside the SS segment limit.             \n| #PF(fault-code)| If a page fault occurs.                      \n| #NM            | If CR0.TS[bit 3] = 1.                        \n| #UD            | If CPUID.01H:ECX.XSAVE[bit 26] = 0.          \n|                | If CR4.OSXSAVE[bit 18] = 0. If any of        \n|                | the LOCK, 66H, F3H or F2H prefixes is        \n|                | used.                                        \n| #AC            | If this exception is disabled a general      \n|                | protection exception (#GP) is signaled       \n|                | if the memory operand is not aligned         \n|                | on a 16-byte boundary, as described          \n|                | above. If the alignment check exception      \n|                | (#AC) is enabled (and the CPL is 3),         \n|                | signaling of #AC is not guaranteed and       \n|                | may vary with implementation, as follows.    \n|                | In all implementations where #AC is          \n|                | not signaled, a general protection exception \n|                | is signaled in its place. In addition,       \n|                | the width of the alignment check may         \n|                | also vary with implementation. For instance, \n|                | for a given implementation, an alignment     \n|                | check exception might be signaled for        \n|                | a 2-byte misalignment, whereas a general     \n|                | protection exception might be signaled       \n|                | for all other misalignments (4-, 8-,         \n|                | or 16-byte misalignments).                   \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand is not aligned on     \n|    | a 64-byte boundary, regardless of segment.\n|    | If any part of the operand lies outside   \n|    | the effective address space from 0 to     \n|    | FFFFH.                                    \n| #NM| If CR0.TS[bit 3] = 1.                     \n| #UD| If CPUID.01H:ECX.XSAVE[bit 26] = 0.       \n|    | If CR4.OSXSAVE[bit 18] = 0. If any of     \n|    | the LOCK, 66H, F3H or F2H prefixes is     \n|    | used.                                     \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the memory address is in a non-canonical \n|                | form. If a memory operand is not aligned    \n|                | on a 64-byte boundary, regardless of        \n|                | segment.                                    \n| #SS(0)         | If a memory address referencing the         \n|                | SS segment is in a non-canonical form.      \n| #PF(fault-code)| If a page fault occurs.                     \n| #NM            | If CR0.TS[bit 3] = 1.                       \n| #UD            | If CPUID.01H:ECX.XSAVE[bit 26] = 0.         \n|                | If CR4.OSXSAVE[bit 18] = 0. If any of       \n|                | the LOCK, 66H, F3H or F2H prefixes is       \n|                | used.                                       \n| #AC            | If this exception is disabled a general     \n|                | protection exception (#GP) is signaled      \n|                | if the memory operand is not aligned        \n|                | on a 16-byte boundary, as described         \n|                | above. If the alignment check exception     \n|                | (#AC) is enabled (and the CPL is 3),        \n|                | signaling of #AC is not guaranteed and      \n|                | may vary with implementation, as follows.   \n|                | In all implementations where #AC is         \n|                | not signaled, a general protection exception\n|                | is signaled in its place. In addition,      \n|                | the width of the alignment check may        \n|                | also vary with implementation. For instance,\n|                | for a given implementation, an alignment    \n|                | check exception might be signaled for       \n|                | a 2-byte misalignment, whereas a general    \n|                | protection exception might be signaled      \n|                | for all other misalignments (4-, 8-,        \n|                | or 16-byte misalignments).                  \n", 
      "mnem": "XSAVE"
    }, 
    {
      "description": "\nXSAVEC - Save Processor Extended States with Compaction:\n| Opcode         | Instruction | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                               \n| 0F C7 /4       | XSAVEC mem  | M    | Valid      | Valid          | Save state components specified by EDX:EAX\n|                |             |      |            |                | to mem with compaction.                   \n| REX.W+ 0F C7 /4| XSAVEC64 mem| M    | Valid      | N.E.           | Save state components specified by EDX:EAX\n|                |             |      |            |                | to mem with compaction.                   \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nPerforms a full or partial save of processor state components to the XSAVE area\nlocated at the memory address specified by the destination operand. The implicit\nEDX:EAX register pair specifies a 64-bit instruction mask. The specific state\ncomponents saved correspond to the bits set in the requested-feature bitmap\n(RFBM), which is the logical-AND of EDX:EAX and XCR0.\n\nThe format of the XSAVE area is detailed in Section 13.4, \u201cXSAVE Area,\u201d of Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1.\n\nSection 13.9, \u201cOperation of XSAVEC,\u201d of Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1 provides a detailed description of the operation\nof the XSAVEC instruction. The following items provide a highlevel outline:\n\n - Execution of XSAVEC is similar to that of XSAVE. XSAVEC differs from XSAVE in\nthat it uses compaction and that it may use the init optimization.\n - XSAVEC saves state component i if and only if RFBM[i] = 1 and XINUSE[i] = 1.1\n(XINUSE is a bitmap by which the processor tracks the status of various state\ncomponents. See Section 13.5.4, \u201cProcessor Tracking of XSAVE-Managed State.\u201d)\n - XSAVEC does not modify bytes 511:464 of the legacy region of the XSAVE area\n(see Section 13.4.1, \u201cLegacy Region of an XSAVE Area\u201d).\n - XSAVEC writes the logical AND of RFBM and XINUSE to the XSTATE_BV field of the\nXSAVE header.2,3 (See Section 13.4.2, \u201cXSAVE Header.\u201d) XSAVEC sets bit 63 of\nthe XCOMP_BV field and sets bits 62:0 of that field to RFBM[62:0]. XSAVEC does\nnot write to any parts of the XSAVE header other than the XSTATE_BV and XCOMP_BV\nfields.\n - XSAVEC always uses the compacted format of the extended region of the XSAVE\narea (see Section 13.4.3, \u201cExtended Region of an XSAVE Area\u201d).\n\nUse of a destination operand not aligned to 64-byte boundary (in either 64-bit\nor 32-bit modes) results in a general-protection (#GP) exception. In 64-bit\nmode, the upper 32 bits of RDX and RAX are ignored.\n\nOperation:\n\nRFBM <- XCR0 AND EDX:EAX;\nCOMPMASK <- RFBM OR 80000000_00000000H;\nIF RFBM[0] = 1 and XINUSE[0] = 1\n1.\n  have its initial value of 1F80H. In this case, XSAVEC saves SSE state as long as RFBM[1] = 1.\n2.\n3.\n  have its initial value of 1F80H. In this case, XSAVEC sets XSTATE_BV[1] to 1 as long as RFBM[1] = 1.\n  THEN store x87 state into legacy region of XSAVE area;\nFI;\nIF RFBM[1] = 1 and (XINUSE[1] = 1 or MXCSR != 1F80H)\n  THEN store SSE state into legacy region of XSAVE area;\nFI;\nIF RFBM[2] = 1 AND XINUSE[2] = 1\n  THEN store AVX state into extended region of XSAVE area;\nFI;\nXSTATE_BV field in XSAVE header <- XINUSE AND RFBM;\nXCOMP_BV field in XSAVE header <- COMPMASK;\n\nFlags Affected:\nNone.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XSAVEC:  | void _xsavec( void * , unsigned __int64);  \n| XSAVEC64:| void _xsavec64( void * , unsigned __int64);\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address        \n|                | is outside the CS, DS, ES, FS, or GS         \n|                | segment limit. If a memory operand is        \n|                | not aligned on a 64-byte boundary, regardless\n|                | of segment.                                  \n| #SS(0)         | If a memory operand effective address        \n|                | is outside the SS segment limit.             \n| #PF(fault-code)| If a page fault occurs.                      \n| #NM            | If CR0.TS[bit 3] = 1.                        \n| #UD            | If CPUID.01H:ECX.XSAVE[bit 26] = 0 or        \n|                | CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit         \n|                | 1] = 0. If CR4.OSXSAVE[bit 18] = 0.          \n|                | If any of the LOCK, 66H, F3H or F2H          \n|                | prefixes is used.                            \n| #AC            | If this exception is disabled a general      \n|                | protection exception (#GP) is signaled       \n|                | if the memory operand is not aligned         \n|                | on a 16-byte boundary, as described          \n|                | above. If the alignment check exception      \n|                | (#AC) is enabled (and the CPL is 3),         \n|                | signaling of #AC is not guaranteed and       \n|                | may vary with implementation, as follows.    \n|                | In all implementations where #AC is          \n|                | not signaled, a general protection exception \n|                | is signaled in its place. In addition,       \n|                | the width of the alignment check may         \n|                | also vary with implementation. For instance, \n|                | for a given implementation, an alignment     \n|                | check exception might be signaled for        \n|                | a 2-byte misalignment, whereas a general     \n|                | protection exception might be signaled       \n|                | for all other misalignments (4-, 8-,         \n|                | or 16-byte misalignments).                   \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand is not aligned on     \n|    | a 64-byte boundary, regardless of segment.\n|    | If any part of the operand lies outside   \n|    | the effective address space from 0 to     \n|    | FFFFH.                                    \n| #NM| If CR0.TS[bit 3] = 1.                     \n| #UD| If CPUID.01H:ECX.XSAVE[bit 26] = 0 or     \n|    | CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit      \n|    | 1] = 0. If CR4.OSXSAVE[bit 18] = 0.       \n|    | If any of the LOCK, 66H, F3H or F2H       \n|    | prefixes is used.                         \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the memory address is in a non-canonical \n|                | form. If a memory operand is not aligned    \n|                | on a 64-byte boundary, regardless of        \n|                | segment.                                    \n| #SS(0)         | If a memory address referencing the         \n|                | SS segment is in a non-canonical form.      \n| #PF(fault-code)| If a page fault occurs.                     \n| #NM            | If CR0.TS[bit 3] = 1.                       \n| #UD            | If CPUID.01H:ECX.XSAVE[bit 26] = 0 or       \n|                | CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit        \n|                | 1] = 0. If CR4.OSXSAVE[bit 18] = 0.         \n|                | If any of the LOCK, 66H, F3H or F2H         \n|                | prefixes is used.                           \n| #AC            | If this exception is disabled a general     \n|                | protection exception (#GP) is signaled      \n|                | if the memory operand is not aligned        \n|                | on a 16-byte boundary, as described         \n|                | above. If the alignment check exception     \n|                | (#AC) is enabled (and the CPL is 3),        \n|                | signaling of #AC is not guaranteed and      \n|                | may vary with implementation, as follows.   \n|                | In all implementations where #AC is         \n|                | not signaled, a general protection exception\n|                | is signaled in its place. In addition,      \n|                | the width of the alignment check may        \n|                | also vary with implementation. For instance,\n|                | for a given implementation, an alignment    \n|                | check exception might be signaled for       \n|                | a 2-byte misalignment, whereas a general    \n|                | protection exception might be signaled      \n|                | for all other misalignments (4-, 8-,        \n|                | or 16-byte misalignments).                  \n", 
      "mnem": "XSAVEC"
    }, 
    {
      "description": "\nXSAVEOPT - Save Processor Extended States Optimized:\n| Opcode/Instruction             | Op/En| 64/32 bit Mode Support| CPUID Feature Flag| Description                               \n| 0F AE /6 XSAVEOPT mem          | M    | V/V                   | XSAVEOPT          | Save state components specified by EDX:EAX\n|                                |      |                       |                   | to mem, optimizing if possible.           \n| REX.W + 0F AE /6 XSAVEOPT64 mem| M    | V/V                   | XSAVEOPT          | Save state components specified by EDX:EAX\n|                                |      |                       |                   | to mem, optimizing if possible.           \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nPerforms a full or partial save of processor state components to the XSAVE area\nlocated at the memory address specified by the destination operand. The implicit\nEDX:EAX register pair specifies a 64-bit instruction mask. The specific state\ncomponents saved correspond to the bits set in the requested-feature bitmap\n(RFBM), which is the logical-AND of EDX:EAX and XCR0.\n\nThe format of the XSAVE area is detailed in Section 13.4, \u201cXSAVE Area,\u201d of Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1.\n\nSection 13.8, \u201cOperation of XSAVEOPT,\u201d of Intel\u00ae 64 and IA-32 Architectures\nSoftware Developer's Manual, Volume 1 provides a detailed description of the\noperation of the XSAVEOPT instruction. The following items provide a high-level\noutline:\n\n - Execution of XSAVEOPT is similar to that of XSAVE. XSAVEOPT differs from XSAVE\nin that it uses compaction and that it may use the init and modified optimizations.\nThe performance of XSAVEOPT will be equal to or better than that of XSAVE.\n - XSAVEOPT saves state component i only if RFBM[i] = 1 and XINUSE[i] = 1.1 (XINUSE\nis a bitmap by which the processor tracks the status of various state components.\nSee Section 13.5.4, \u201cProcessor Tracking of XSAVEManaged State.\u201d) Even if both\nbits are 1, XSAVEOPT may optimize and not save state component i if (1) state\ncomponent i has not been modified since the last execution of XRTOR or XRSTORS;\nand (2) this execution of XSAVES corresponds to that last execution of XRTOR\nor XRSTORS as determined by the internal value XRSTOR_INFO (see the Operation\nsection below).\n - XSAVEOPT does not modify bytes 511:464 of the legacy region of the XSAVE area\n(see Section 13.4.1, \u201cLegacy Region of an XSAVE Area\u201d).\n - XSAVEOPT reads the XSTATE_BV field of the XSAVE header (see Section 13.4.2,\n\u201cXSAVE Header\u201d) and writes a modified value back to memory as follows. If RFBM[i]\n= 1, XSAVEOPT writes XSTATE_BV[i] with the value of XINUSE[i]. If RFBM[i] =\n0, XSAVEOPT writes XSTATE_BV[i] with the value that it read from memory (it\ndoes not modify the bit). XSAVEOPT does not write to any part of the XSAVE header\nother than the XSTATE_BV field.\n - XSAVEOPT always uses the standard format of the extended region of the XSAVE\narea (see Section 13.4.3, \u201cExtended Region of an XSAVE Area\u201d).\n\nUse of a destination operand not aligned to 64-byte boundary (in either 64-bit\nor 32-bit modes) will result in a general-protection (#GP) exception. In 64-bit\nmode, the upper 32 bits of RDX and RAX are ignored.\n\nOperation:\n\nRFBM <- XCR0 AND EDX:EAX;\nOLD_BV <- XSTATE_BV field from XSAVE header;\n1.\n  these to memory if RFBM[1] = 1 or RFBM[2] = 1, regardless of the value of XINUSE.\nIF in VMX non-root operation\n  THEN VMXNR <- 1;\n  ELSE VMXNR <- 0;\nFI;\nLAXA <- linear address of XSAVE area;\nCOMPMASK <- 00000000_00000000H;\nIF XRSTOR_INFO = \uf0e1CPL,VMXNR,LAXA,COMPMASK\uf0f1\n  THEN MODOPT <- 1;\n  ELSE MODOPT <- 0;\nFI;\nIF RFBM[0] = 1 and XINUSE[0] = 1\n  THEN store x87 state into legacy region of XSAVE area;\n  /* might avoid saving if x87 state is not modified and MODOPT = 1 */\nFI;\nIF RFBM[1] = 1 and XINUSE[1]\n  THEN store XMM registers into legacy region of XSAVE area;\n  /* might avoid saving if XMM registers are not modified and MODOPT = 1 */\nFI;\nIF RFBM[2] = 1 AND XINUSE[2] = 1\n  THEN store AVX state into extended region of XSAVE area;\n  /* might avoid saving if AVX state is not modified and MODOPT = 1 */\nFI;\nIF RFBM[1] = 1 or RFBM[2] = 1\n  THEN store MXCSR and MXCSR_MASK into legacy region of XSAVE area;\nFI;\nXSTATE_BV field in XSAVE header <- (OLD_BV AND ~RFBM) OR (XINUSE AND RFBM);\n\nFlags Affected:\nNone.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XSAVEOPT:| void _xsaveopt( void * , unsigned __int64);\n| XSAVEOPT:| void _xsaveopt64( void * , unsigned        \n|          | __int64);                                  \n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address        \n|                | is outside the CS, DS, ES, FS, or GS         \n|                | segment limit. If a memory operand is        \n|                | not aligned on a 64-byte boundary, regardless\n|                | of segment.                                  \n| #SS(0)         | If a memory operand effective address        \n|                | is outside the SS segment limit.             \n| #PF(fault-code)| If a page fault occurs.                      \n| #NM            | If CR0.TS[bit 3] = 1.                        \n| #UD            | If CPUID.01H:ECX.XSAVE[bit 26] = 0 or        \n|                | CPUID.(EAX=0DH,ECX=1):EAX.XSAVEOPT[bit       \n|                | 0] =0. If CR4.OSXSAVE[bit 18] = 0. If        \n|                | the LOCK prefix is used. If 66H, F3H         \n|                | or F2H prefix is used.                       \n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand is not aligned on     \n|    | a 64-byte boundary, regardless of segment.\n|    | If any part of the operand lies outside   \n|    | the effective address space from 0 to     \n|    | FFFFH.                                    \n| #NM| If CR0.TS[bit 3] = 1.                     \n| #UD| 0] =0. If CR4.OSXSAVE[bit 18] = 0. If     \n|    | the LOCK prefix is used. If 66H, F3H      \n|    | or F2H prefix is used.                    \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #SS(0)         | If a memory address referencing the        \n|                | SS segment is in a non-canonical form.     \n| #GP(0)         | If the memory address is in a non-canonical\n|                | form. If a memory operand is not aligned   \n|                | on a 64-byte boundary, regardless of       \n|                | segment.                                   \n| #PF(fault-code)| If a page fault occurs.                    \n| #NM            | If CR0.TS[bit 3] = 1.                      \n| #UD            | 0] =0. If CR4.OSXSAVE[bit 18] = 0. If      \n|                | the LOCK prefix is used. If 66H, F3H       \n|                | or F2H prefix is used.                     \n", 
      "mnem": "XSAVEOPT"
    }, 
    {
      "description": "\nXSAVES - Save Processor Extended States Supervisor:\n| Opcode         | Instruction | Op/En| 64-Bit Mode| Compat/Leg Mode| Description                               \n| 0F C7 /5       | XSAVES mem  | M    | Valid      | Valid          | Save state components specified by EDX:EAX\n|                |             |      |            |                | to mem with compaction, optimizing if     \n|                |             |      |            |                | possible.                                 \n| REX.W+ 0F C7 /5| XSAVES64 mem| M    | Valid      | N.E.           | Save state components specified by EDX:EAX\n|                |             |      |            |                | to mem with compaction, optimizing if     \n|                |             |      |            |                | possible.                                 \n\nInstruction Operand Encoding:\n| Op/En| Operand 1    | Operand 2| Operand 3| Operand 4\n| M    | ModRM:r/m (w)| NA       | NA       | NA       \n\nDescription:\nPerforms a full or partial save of processor state components to the XSAVE area\nlocated at the memory address specified by the destination operand. The implicit\nEDX:EAX register pair specifies a 64-bit instruction mask. The specific state\ncomponents saved correspond to the bits set in the requested-feature bitmap\n(RFBM), the logicalAND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS\nMSR. XSAVES may be executed only if CPL = 0.\n\nThe format of the XSAVE area is detailed in Section 13.4, \u201cXSAVE Area,\u201d of Intel\u00ae\n64 and IA-32 Architectures Software Developer's Manual, Volume 1.\n\nSection 13.10, \u201cOperation of XSAVES,\u201d of Intel\u00ae 64 and IA-32 Architectures Software\nDeveloper's Manual, Volume 1 provides a detailed description of the operation\nof the XSAVES instruction. The following items provide a highlevel outline:\n\n - Execution of XSAVES is similar to that of XSAVEC. XSAVES differs from XSAVEC\nin that it can save state components corresponding to bits set in the IA32_XSS\nMSR and that it may use the modified optimization.\n - XSAVES saves state component i only if RFBM[i] = 1 and XINUSE[i] = 1.1 (XINUSE\nis a bitmap by which the processor tracks the status of various state components.\nSee Section 13.5.4, \u201cProcessor Tracking of XSAVEManaged State.\u201d) Even if both\nbits are 1, XSAVES may optimize and not save state component i if (1) state\ncomponent i has not been modified since the last execution of XRTOR or XRSTORS;\nand (2) this execution of XSAVES correspond to that last execution of XRTOR\nor XRSTORS as determined by XRSTOR_INFO (see the Operation section below).\n - XSAVES does not modify bytes 511:464 of the legacy region of the XSAVE area\n(see Section 13.4.1, \u201cLegacy Region of an XSAVE Area\u201d).\n - XSAVES writes the logical AND of RFBM and XINUSE to the XSTATE_BV field of the\nXSAVE header.2 (See Section 13.4.2, \u201cXSAVE Header.\u201d) XSAVES sets bit 63 of the\nXCOMP_BV field and sets bits 62:0 of that field to RFBM[62:0]. XSAVES does not\nwrite to any parts of the XSAVE header other than the XSTATE_BV and XCOMP_BV\nfields.\n - XSAVES always uses the compacted format of the extended region of the XSAVE\narea (see Section 13.4.3, \u201cExtended Region of an XSAVE Area\u201d).\n\nUse of a destination operand not aligned to 64-byte boundary (in either 64-bit\nor 32-bit modes) results in a general-protection (#GP) exception. In 64-bit\nmode, the upper 32 bits of RDX and RAX are ignored.\n\n| 1.| There is an exception for state component\n|   | 1 (SSE). MXCSR is part of SSE state,     \n|   | but XINUSE[1] may be 0 even if MXCSR     \n|   | does not have its initial value of 1F80H.\n|   | In this case, the init optimization      \n|   | does not apply and XSAVEC will save      \n|   | SSE state as long as RFBM[1] =1 and      \n|   | the modified optimization is not being   \n|   | applied.                                 \n| 2.| There is an exception for state component\n|   | 1 (SSE). MXCSR is part of SSE state,     \n|   | but XINUSE[1] may be 0 even if MXCSR     \n|   | does not have its initial value of 1F80H.\n|   | In this case, XSAVES sets XSTATE_BV[1]   \n|   | to 1 as long as RFBM[1] = 1.             \nOperation:\n\nRFBM <- XCR0 AND EDX:EAX;\nIF in VMX non-root operation\n  THEN VMXNR <- 1;\n  ELSE VMXNR <- 0;\nFI;\nLAXA <- linear address of XSAVE area;\nCOMPMASK <- RFBM OR 80000000_00000000H;\nIF XRSTOR_INFO = \uf0e1CPL,VMXNR,LAXA,COMPMASK\uf0f1\n  THEN MODOPT <- 1;\n  ELSE MODOPT <- 0;\nFI;\nIF RFBM[0] = 1 and XINUSE[0] = 1\n  THEN store x87 state into legacy region of XSAVE area;\n  /* might avoid saving if x87 state is not modified and MODOPT = 1 */\nFI;\nIF RFBM[1] = 1 and (XINUSE[1] = 1 or MXCSR != 1F80H)\n  THEN store SSE state into legacy region of XSAVE area;\n  /* might avoid saving if SSE state is not modified and MODOPT = 1 */\nFI;\nIF RFBM[2] = 1 AND XINUSE[2] = 1\n  THEN store AVX state into extended region of XSAVE area;\n  /* might avoid saving if AVX state is not modified and MODOPT = 1 */\nFI;\nXSTATE_BV field in XSAVE header <- XINUSE AND RFBM;\nXCOMP_BV field in XSAVE header <- COMPMASK;\n\nFlags Affected:\nNone.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XSAVES:  | void _xsaves( void * , unsigned __int64);  \n| XSAVES64:| void _xsaves64( void * , unsigned __int64);\n\nProtected Mode Exceptions:\n| #GP(0)         | If a memory operand effective address        \n|                | is outside the CS, DS, ES, FS, or GS         \n|                | segment limit. If a memory operand is        \n|                | not aligned on a 64-byte boundary, regardless\n|                | of segment.                                  \n| #SS(0)         | If a memory operand effective address        \n|                | is outside the SS segment limit.             \n| #PF(fault-code)| If a page fault occurs.                      \n| #NM            | If CR0.TS[bit 3] = 1.                        \n| #UD            | If CPUID.01H:ECX.XSAVE[bit 26] = 0 or        \n|                | CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3]         \n|                | = 0. If CR4.OSXSAVE[bit 18] = 0. If          \n|                | any of the LOCK, 66H, F3H or F2H prefixes    \n|                | is used.                                     \n| #AC            | If this exception is disabled a general      \n|                | protection exception (#GP) is signaled       \n|                | if the memory operand is not aligned         \n|                | on a 16-byte boundary, as described          \n|                | above. If the alignment check exception      \n|                | (#AC) is enabled (and the CPL is 3),         \n|                | signaling of #AC is not guaranteed and       \n|                | may vary with implementation, as follows.    \n|                | In all implementations where #AC is          \n|                | not signaled, a general protection exception \n|                | is signaled in its place. In addition,       \n|                | the width of the alignment check may         \n|                | also vary with implementation. For instance, \n|                | for a given implementation, an align-        \nment check exception might be signaled for a 2-byte misalignment, whereas a\ngeneral protection exception might be signaled for all other misalignments (4-,\n8-, or 16-byte misalignments).\n\n\nReal-Address Mode Exceptions:\n| #GP| If a memory operand is not aligned on     \n|    | a 64-byte boundary, regardless of segment.\n|    | If any part of the operand lies outside   \n|    | the effective address space from 0 to     \n|    | FFFFH.                                    \n| #NM| If CR0.TS[bit 3] = 1.                     \n| #UD| If CPUID.01H:ECX.XSAVE[bit 26] = 0 or     \n|    | CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3]      \n|    | = 0. If CR4.OSXSAVE[bit 18] = 0. If       \n|    | any of the LOCK, 66H, F3H or F2H prefixes \n|    | is used.                                  \n\nVirtual-8086 Mode Exceptions:\nSame exceptions as in protected mode.\n\n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\n| #GP(0)         | If the memory address is in a non-canonical \n|                | form. If a memory operand is not aligned    \n|                | on a 64-byte boundary, regardless of        \n|                | segment.                                    \n| #SS(0)         | If a memory address referencing the         \n|                | SS segment is in a non-canonical form.      \n| #PF(fault-code)| If a page fault occurs.                     \n| #NM            | If CR0.TS[bit 3] = 1.                       \n| #UD            | If CPUID.01H:ECX.XSAVE[bit 26] = 0 or       \n|                | CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3]        \n|                | = 0. If CR4.OSXSAVE[bit 18] = 0. If         \n|                | any of the LOCK, 66H, F3H or F2H prefixes   \n|                | is used.                                    \n| #AC            | If this exception is disabled a general     \n|                | protection exception (#GP) is signaled      \n|                | if the memory operand is not aligned        \n|                | on a 16-byte boundary, as described         \n|                | above. If the alignment check exception     \n|                | (#AC) is enabled (and the CPL is 3),        \n|                | signaling of #AC is not guaranteed and      \n|                | may vary with implementation, as follows.   \n|                | In all implementations where #AC is         \n|                | not signaled, a general protection exception\n|                | is signaled in its place. In addition,      \n|                | the width of the alignment check may        \n|                | also vary with implementation. For instance,\n|                | for a given implementation, an alignment    \n|                | check exception might be signaled for       \n|                | a 2-byte misalignment, whereas a general    \n|                | protection exception might be signaled      \n|                | for all other misalignments (4-, 8-,        \n|                | or 16-byte misalignments).                  \n", 
      "mnem": "XSAVES"
    }, 
    {
      "description": "\nXSETBV - Set Extended Control Register:\n| Opcode  | Instruction| Op/En| 64-Bit Mode| Compat/Leg Mode| Description                          \n| 0F 01 D1| XSETBV     | NP   | Valid      | Valid          | Write the value in EDX:EAX to the XCR\n|         |            |      |            |                | specified by ECX.                    \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand 2| Operand 3| Operand 4\n| NP   | NA       | NA       | NA       | NA       \n\nDescription:\nWrites the contents of registers EDX:EAX into the 64-bit extended control register\n(XCR) specified in the ECX register. (On processors that support the Intel 64\narchitecture, the high-order 32 bits of RCX are ignored.) The contents of the\nEDX register are copied to high-order 32 bits of the selected XCR and the contents\nof the EAX register are copied to low-order 32 bits of the XCR. (On processors\nthat support the Intel 64 architecture, the highorder 32 bits of each of RAX\nand RDX are ignored.) Undefined or reserved bits in an XCR should be set to\nvalues previously read.\n\nThis instruction must be executed at privilege level 0 or in real-address mode;\notherwise, a general protection exception #GP(0) is generated. Specifying a\nreserved or unimplemented XCR in ECX will also cause a general protection exception.\nThe processor will also generate a general protection exception if software\nattempts to write to reserved bits in an XCR.\n\nCurrently, only XCR0 is supported. Thus, all other values of ECX are reserved\nand will cause a #GP(0). Note that bit 0 of XCR0 (corresponding to x87 state)\nmust be set to 1; the instruction will cause a #GP(0) if an attempt is made\nto clear this bit. In addition, the instruction causes a #GP(0) if an attempt\nis made to set XCR0[2] (AVX state) while clearing XCR0[1] (SSE state); it is\nnecessary to set both bits to use AVX instructions; Section 13.3, \u201cEnabling\nthe XSAVE Feature Set and XSAVE-Supported Features,\u201d of Intel\u00ae 64 and IA-32\nArchitectures Software Developer's Manual, Volume 1.\n\nOperation:\n\nXCR[ECX] <- EDX:EAX;\n\nFlags Affected:\nNone.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XSETBV:| void _xsetbv( unsigned int, unsigned\n|        | __int64);                           \n\nProtected Mode Exceptions:\n| #GP(0)| If the current privilege level is not    \n|       | 0. If an invalid XCR is specified in     \n|       | ECX. If the value in EDX:EAX sets bits   \n|       | that are reserved in the XCR specified   \n|       | by ECX. If an attempt is made to clear   \n|       | bit 0 of XCR0. If an attempt is made     \n|       | to set XCR0[2:1] to 10b.                 \n| #UD   | If CPUID.01H:ECX.XSAVE[bit 26] = 0.      \n|       | If CR4.OSXSAVE[bit 18] = 0. If the LOCK  \n|       | prefix is used. If 66H, F3H or F2H prefix\n|       | is used.                                 \n\nReal-Address Mode Exceptions:\n| #GP| If an invalid XCR is specified in ECX.   \n|    | If the value in EDX:EAX sets bits that   \n|    | are reserved in the XCR specified by     \n|    | ECX. If an attempt is made to clear      \n|    | bit 0 of XCR0. If an attempt is made     \n|    | to set XCR0[2:1] to 10b.                 \n| #UD| If CPUID.01H:ECX.XSAVE[bit 26] = 0.      \n|    | If CR4.OSXSAVE[bit 18] = 0. If the LOCK  \n|    | prefix is used. If 66H, F3H or F2H prefix\n|    | is used.                                 \n\nVirtual-8086 Mode Exceptions:\n| #GP(0)| The XSETBV instruction is not recognized\n|       | in virtual-8086 mode.                   \n\nCompatibility Mode Exceptions:\nSame exceptions as in protected mode.\n\n\n64-Bit Mode Exceptions:\nSame exceptions as in protected mode.\n\n", 
      "mnem": "XSETBV"
    }, 
    {
      "description": "\nXTEST  -  Test If In Transactional Execution:\n| Opcode/Instruction| Op/En| 64/32bit Mode Support| CPUID Feature Flag| Description                         \n| 0F 01 D6 XTEST    | A    | V/V                  | HLE or RTM        | Test if executing in a transactional\n|                   |      |                      |                   | region                              \n\nInstruction Operand Encoding:\n| Op/En| Operand 1| Operand2| Operand3| Operand4\n| A    | NA       | NA      | NA      | NA      \n\nDescription:\nThe XTEST instruction queries the transactional execution status. If the instruction\nexecutes inside a transactionally executing RTM region or a transactionally\nexecuting HLE region, then the ZF flag is cleared, else it is set.\n\nOperation:\n\nXTEST\nIF (RTM_ACTIVE = 1 OR HLE_ACTIVE = 1)\n  THEN\n     ZF <- 0\n  ELSE\n     ZF <- 1\nFI;\n\nFlags Affected:\nThe ZF flag is cleared if the instruction is executed transactionally; otherwise\nit is set to 1. The CF, OF, SF, PF, and AF, flags are cleared.\n\n\nIntel C/C++ Compiler Intrinsic Equivalent:\n| XTEST:| int _xtest( void );\n\nSIMD Floating-Point Exceptions:\nNone\n\n\nOther Exceptions:\n| #UD| CPUID.(EAX=7, ECX=0):HLE[bit 4] = 0     \n|    | and CPUID.(EAX=7, ECX=0):RTM[bit 11]    \n|    | = 0. If LOCK or 66H or F2H or F3H prefix\n|    | is used.                                \n", 
      "mnem": "XTEST"
    }
  ], 
  "x86-64-brief": [
    {
      "description": "ascii adjust after addition", 
      "mnem": "aaa"
    }, 
    {
      "description": "ascii adjust ax before division", 
      "mnem": "aad"
    }, 
    {
      "description": "ascii adjust ax after multiply", 
      "mnem": "aam"
    }, 
    {
      "description": "ascii adjust al after subtraction", 
      "mnem": "aas"
    }, 
    {
      "description": "add with carry", 
      "mnem": "adc"
    }, 
    {
      "description": "adds src and dst, stores result on dst", 
      "mnem": "add"
    }, 
    {
      "description": "add packed double-fp values", 
      "mnem": "addpd"
    }, 
    {
      "description": "add packed single-fp values", 
      "mnem": "addps"
    }, 
    {
      "description": "add scalar double-fp values", 
      "mnem": "addsd"
    }, 
    {
      "description": "add scalar single-fp values", 
      "mnem": "addss"
    }, 
    {
      "description": "packed double-fp add/subtract", 
      "mnem": "addsubpd"
    }, 
    {
      "description": "packed single-fp add/subtract", 
      "mnem": "addsubps"
    }, 
    {
      "description": "perform one round of an AES decryption flow", 
      "mnem": "aesdec"
    }, 
    {
      "description": "perform the last round of an AES decryption flow", 
      "mnem": "aesdeclast"
    }, 
    {
      "description": "perform one round of an AES encryption flow", 
      "mnem": "aesenc"
    }, 
    {
      "description": "perform the last round of an AES encryption flow", 
      "mnem": "aesenclast"
    }, 
    {
      "description": "assist in aes Inverse Mix Columns", 
      "mnem": "aesimc"
    }, 
    {
      "description": "assist in AES round key generation", 
      "mnem": "aeskeygenassist"
    }, 
    {
      "description": "binary and operation between src and dst, stores result on dst", 
      "mnem": "and"
    }, 
    {
      "description": "bitwise logical and not of packed double-fp values", 
      "mnem": "andnpd"
    }, 
    {
      "description": "bitwise logical and not of packed single-fp values", 
      "mnem": "andnps"
    }, 
    {
      "description": "bitwise logical and of packed double-fp values", 
      "mnem": "andpd"
    }, 
    {
      "description": "bitwise logical and of packed single-fp values", 
      "mnem": "andps"
    }, 
    {
      "description": "adjust rpl field of segment selector", 
      "mnem": "arpl"
    }, 
    {
      "description": "blend packed double-fp values", 
      "mnem": "blendpd"
    }, 
    {
      "description": "blend packed single-fp values", 
      "mnem": "blendps"
    }, 
    {
      "description": "variable blend packed double-fp values", 
      "mnem": "blendvpd"
    }, 
    {
      "description": "variable blend packed single-fp values", 
      "mnem": "blendvps"
    }, 
    {
      "description": "check array index against bounds", 
      "mnem": "bound"
    }, 
    {
      "description": "bit scan forward", 
      "mnem": "bsf"
    }, 
    {
      "description": "bit scan reverse", 
      "mnem": "bsr"
    }, 
    {
      "description": "byte swap", 
      "mnem": "bswap"
    }, 
    {
      "description": "bit test", 
      "mnem": "bt"
    }, 
    {
      "description": "bit test and complement", 
      "mnem": "btc"
    }, 
    {
      "description": "bit test and reset", 
      "mnem": "btr"
    }, 
    {
      "description": "bit test and set", 
      "mnem": "bts"
    }, 
    {
      "description": "calls a subroutine, push eip into the stack (esp)", 
      "mnem": "call"
    }, 
    {
      "description": "call procedure", 
      "mnem": "callf"
    }, 
    {
      "description": "convert byte to word", 
      "mnem": "cbw"
    }, 
    {
      "description": "sign extends eax into edx (convert doubleword to quadword)", 
      "mnem": "cdq"
    }, 
    {
      "description": "sign extend eax into rax", 
      "mnem": "cdqe"
    }, 
    {
      "description": "clear carry flag", 
      "mnem": "clc"
    }, 
    {
      "description": "clear direction flag", 
      "mnem": "cld"
    }, 
    {
      "description": "flush cache line", 
      "mnem": "clflush"
    }, 
    {
      "description": "clear interrupt flag", 
      "mnem": "cli"
    }, 
    {
      "description": "clear task-switched flag in cr0", 
      "mnem": "clts"
    }, 
    {
      "description": "complement carry flag", 
      "mnem": "cmc"
    }, 
    {
      "description": "conditional move - above/not below nor equal (cf=0 and zf=0)", 
      "mnem": "cmova"
    }, 
    {
      "description": "conditional move - above or equal/not below/not carry (cf=0)", 
      "mnem": "cmovae"
    }, 
    {
      "description": "conditional move - below/not above nor equal/carry (cf=1)", 
      "mnem": "cmovb"
    }, 
    {
      "description": "conditional move - below or equal/not above (cf=1 or zf=1)", 
      "mnem": "cmovbe"
    }, 
    {
      "description": "conditional move - carry/below/not above or equal (cf=1)", 
      "mnem": "cmovc"
    }, 
    {
      "description": "conditional move - equal/zero (zf=1)", 
      "mnem": "cmove"
    }, 
    {
      "description": "conditional move - greater/not less nor equal (zf=0 and sf=of)", 
      "mnem": "cmovg"
    }, 
    {
      "description": "conditional move - greater or equal/not less (sf=of)", 
      "mnem": "cmovge"
    }, 
    {
      "description": "conditional move - less/not greater nor equal (sf!=of)", 
      "mnem": "cmovl"
    }, 
    {
      "description": "conditional move - less or equal/not greater (zf=1 or sf!=of)", 
      "mnem": "cmovle"
    }, 
    {
      "description": "conditional move - not above/below or equal (cf=1 or zf=1)", 
      "mnem": "cmovna"
    }, 
    {
      "description": "conditional move - not above nor equal/below/carry (cf=1)", 
      "mnem": "cmovnae"
    }, 
    {
      "description": "conditional move - not below/above or equal/not carry (cf=0)", 
      "mnem": "cmovnb"
    }, 
    {
      "description": "conditional move - not below nor equal/above (cf=0 and zf=0)", 
      "mnem": "cmovnbe"
    }, 
    {
      "description": "conditional move - not carry/above or equal/not below (cf=0)", 
      "mnem": "cmovnc"
    }, 
    {
      "description": "conditional move - not equal/not zero (zf=0)", 
      "mnem": "cmovne"
    }, 
    {
      "description": "conditional move - not greater/less or equal (zf=1 or sf!=of)", 
      "mnem": "cmovng"
    }, 
    {
      "description": "conditional move - not greater nor equal/less (sf!=of)", 
      "mnem": "cmovnge"
    }, 
    {
      "description": "conditional move - not less/greater or equal (sf=of)", 
      "mnem": "cmovnl"
    }, 
    {
      "description": "conditional move - not less nor equal/greater (zf=0 and sf=of)", 
      "mnem": "cmovnle"
    }, 
    {
      "description": "conditional move - not overflow (of=0)", 
      "mnem": "cmovno"
    }, 
    {
      "description": "conditional move - not parity/parity odd (pf=0)", 
      "mnem": "cmovnp"
    }, 
    {
      "description": "conditional move - not sign (sf=0)", 
      "mnem": "cmovns"
    }, 
    {
      "description": "conditional move - not zero/not equal (zf=0)", 
      "mnem": "cmovnz"
    }, 
    {
      "description": "conditional move - overflow (of=1)", 
      "mnem": "cmovo"
    }, 
    {
      "description": "conditional move - parity/parity even (pf=1)", 
      "mnem": "cmovp"
    }, 
    {
      "description": "conditional move - parity even/parity (pf=1)", 
      "mnem": "cmovpe"
    }, 
    {
      "description": "conditional move - parity odd/not parity (pf=0)", 
      "mnem": "cmovpo"
    }, 
    {
      "description": "conditional move - sign (sf=1)", 
      "mnem": "cmovs"
    }, 
    {
      "description": "conditional move - zero/equal (zf=1)", 
      "mnem": "cmovz"
    }, 
    {
      "description": "compare two operands", 
      "mnem": "cmp"
    }, 
    {
      "description": "compare packed double-fp values", 
      "mnem": "cmppd"
    }, 
    {
      "description": "compare packed single-fp values", 
      "mnem": "cmpps"
    }, 
    {
      "description": "compare string operands", 
      "mnem": "cmps"
    }, 
    {
      "description": "cmp DS:[esi], (byte)ES:[edi] (esi++, edi++)", 
      "mnem": "cmpsb"
    }, 
    {
      "description": "cmp DS:[esi], (dword)ES:[edi] (esi+=4, edi+=4)/compare scalar double-fp values", 
      "mnem": "cmpsd"
    }, 
    {
      "description": "cmp DS:[rsi], (qword)ES:[rdi] (rsi+=8, rdi+=8)", 
      "mnem": "cmpsq"
    }, 
    {
      "description": "compare scalar single-fp values", 
      "mnem": "cmpss"
    }, 
    {
      "description": "cmp DS:[esi], (word)ES:[edi] (esi+=2, edi+=2)", 
      "mnem": "cmpsw"
    }, 
    {
      "description": "compare and exchange", 
      "mnem": "cmpxchg"
    }, 
    {
      "description": "compare and exchange bytes", 
      "mnem": "cmpxchg16b"
    }, 
    {
      "description": "compare and exchange bytes", 
      "mnem": "cmpxchg8b"
    }, 
    {
      "description": "compare scalar ordered double-fp values and set eflags", 
      "mnem": "comisd"
    }, 
    {
      "description": "compare scalar ordered single-fp values and set eflags", 
      "mnem": "comiss"
    }, 
    {
      "description": "cpu identification", 
      "mnem": "cpuid"
    }, 
    {
      "description": "sign extends rax into rdx (convert quadword to double-quadword)", 
      "mnem": "cqo"
    }, 
    {
      "description": "accumulate crc32 value", 
      "mnem": "crc32"
    }, 
    {
      "description": "cs segment override prefix", 
      "mnem": "cs"
    }, 
    {
      "description": "convert packed dw integers to double-fp values", 
      "mnem": "cvtdq2pd"
    }, 
    {
      "description": "convert packed dw integers to single-fp values", 
      "mnem": "cvtdq2ps"
    }, 
    {
      "description": "convert packed double-fp values to dw integers", 
      "mnem": "cvtpd2dq"
    }, 
    {
      "description": "convert packed double-fp values to dw integers", 
      "mnem": "cvtpd2pi"
    }, 
    {
      "description": "convert packed double-fp values to single-fp values", 
      "mnem": "cvtpd2ps"
    }, 
    {
      "description": "convert packed dw integers to double-fp values", 
      "mnem": "cvtpi2pd"
    }, 
    {
      "description": "convert packed dw integers to single-fp values", 
      "mnem": "cvtpi2ps"
    }, 
    {
      "description": "convert packed single-fp values to dw integers", 
      "mnem": "cvtps2dq"
    }, 
    {
      "description": "convert packed single-fp values to double-fp values", 
      "mnem": "cvtps2pd"
    }, 
    {
      "description": "convert packed single-fp values to dw integers", 
      "mnem": "cvtps2pi"
    }, 
    {
      "description": "convert scalar double-fp value to dw integer", 
      "mnem": "cvtsd2si"
    }, 
    {
      "description": "convert scalar double-fp value to scalar single-fp value", 
      "mnem": "cvtsd2ss"
    }, 
    {
      "description": "convert dw integer to scalar double-fp value", 
      "mnem": "cvtsi2sd"
    }, 
    {
      "description": "convert dw integer to scalar single-fp value", 
      "mnem": "cvtsi2ss"
    }, 
    {
      "description": "convert scalar single-fp value to scalar double-fp value", 
      "mnem": "cvtss2sd"
    }, 
    {
      "description": "convert scalar single-fp value to dw integer", 
      "mnem": "cvtss2si"
    }, 
    {
      "description": "convert with trunc. packed double-fp values to dw integers", 
      "mnem": "cvttpd2dq"
    }, 
    {
      "description": "convert with trunc. packed double-fp values to dw integers", 
      "mnem": "cvttpd2pi"
    }, 
    {
      "description": "convert with trunc. packed single-fp values to dw integers", 
      "mnem": "cvttps2dq"
    }, 
    {
      "description": "convert with trunc. packed single-fp values to dw integers", 
      "mnem": "cvttps2pi"
    }, 
    {
      "description": "conv. with trunc. scalar double-fp value to signed dw int", 
      "mnem": "cvttsd2si"
    }, 
    {
      "description": "convert with trunc. scalar single-fp value to dw integer", 
      "mnem": "cvttss2si"
    }, 
    {
      "description": "convert word to doubleword", 
      "mnem": "cwd"
    }, 
    {
      "description": "convert word to doubleword", 
      "mnem": "cwde"
    }, 
    {
      "description": "decimal adjust al after addition", 
      "mnem": "daa"
    }, 
    {
      "description": "decimal adjust al after subtraction", 
      "mnem": "das"
    }, 
    {
      "description": "decrement by 1", 
      "mnem": "dec"
    }, 
    {
      "description": "unsigned divide", 
      "mnem": "div"
    }, 
    {
      "description": "divide packed double-fp values", 
      "mnem": "divpd"
    }, 
    {
      "description": "divide packed single-fp values", 
      "mnem": "divps"
    }, 
    {
      "description": "divide scalar double-fp values", 
      "mnem": "divsd"
    }, 
    {
      "description": "divide scalar single-fp values", 
      "mnem": "divss"
    }, 
    {
      "description": "dot product of packed double-fp values", 
      "mnem": "dppd"
    }, 
    {
      "description": "dot product of packed single-fp values", 
      "mnem": "dpps"
    }, 
    {
      "description": "ds segment override prefix", 
      "mnem": "ds"
    }, 
    {
      "description": "empty mmx technology state", 
      "mnem": "emms"
    }, 
    {
      "description": "alias for push ebp; mov ebp, esp", 
      "mnem": "enter"
    }, 
    {
      "description": "es segment override prefix", 
      "mnem": "es"
    }, 
    {
      "description": "extract packed single-fp value", 
      "mnem": "extractps"
    }, 
    {
      "description": "compute pow(2,x) - 1", 
      "mnem": "f2xm1"
    }, 
    {
      "description": "absolute value", 
      "mnem": "fabs"
    }, 
    {
      "description": "floating point add", 
      "mnem": "fadd"
    }, 
    {
      "description": "floating point add and pop", 
      "mnem": "faddp"
    }, 
    {
      "description": "load binary coded decimal", 
      "mnem": "fbld"
    }, 
    {
      "description": "store binary coded decimal integer and pop", 
      "mnem": "fbstp"
    }, 
    {
      "description": "change sign", 
      "mnem": "fchs"
    }, 
    {
      "description": "clear exceptions", 
      "mnem": "fclex"
    }, 
    {
      "description": "fp conditional move - below (cf=1)", 
      "mnem": "fcmovb"
    }, 
    {
      "description": "fp conditional move - below or equal (cf=1 or zf=1)", 
      "mnem": "fcmovbe"
    }, 
    {
      "description": "fp conditional move - equal (zf=1)", 
      "mnem": "fcmove"
    }, 
    {
      "description": "fp conditional move - not below (cf=0)", 
      "mnem": "fcmovnb"
    }, 
    {
      "description": "fp conditional move - not below or equal (cf=0 and zf=0)", 
      "mnem": "fcmovnbe"
    }, 
    {
      "description": "fp conditional move - not equal (zf=0)", 
      "mnem": "fcmovne"
    }, 
    {
      "description": "fp conditional move - not unordered (pf=0)", 
      "mnem": "fcmovnu"
    }, 
    {
      "description": "fp conditional move - unordered (pf=1)", 
      "mnem": "fcmovu"
    }, 
    {
      "description": "floating point compare", 
      "mnem": "fcom"
    }, 
    {
      "description": "compare floating point values and set eflags", 
      "mnem": "fcomi"
    }, 
    {
      "description": "compare floating point values and set eflags and pop", 
      "mnem": "fcomip"
    }, 
    {
      "description": "floating point compare and pop", 
      "mnem": "fcomp"
    }, 
    {
      "description": "floating point compare and pop twice", 
      "mnem": "fcompp"
    }, 
    {
      "description": "floating point cosine", 
      "mnem": "fcos"
    }, 
    {
      "description": "decrement floating point stack pointer", 
      "mnem": "fdecstp"
    }, 
    {
      "description": "disable npx (numeric coprocessor extension) interrupt", 
      "mnem": "fdisi"
    }, 
    {
      "description": "floating point divide", 
      "mnem": "fdiv"
    }, 
    {
      "description": "floting point divide and pop", 
      "mnem": "fdivp"
    }, 
    {
      "description": "floating point divide reversed", 
      "mnem": "fdivr"
    }, 
    {
      "description": "floating point reverse divide and pop", 
      "mnem": "fdivrp"
    }, 
    {
      "description": "enable npx (numeric coprocessor extension) interrupt", 
      "mnem": "feni"
    }, 
    {
      "description": "free floating-point register", 
      "mnem": "ffree"
    }, 
    {
      "description": "free floating-point register and pop (undocumented)", 
      "mnem": "ffreep"
    }, 
    {
      "description": "integer add", 
      "mnem": "fiadd"
    }, 
    {
      "description": "integer compare", 
      "mnem": "ficom"
    }, 
    {
      "description": "integer compare and pop", 
      "mnem": "ficomp"
    }, 
    {
      "description": "integer divide", 
      "mnem": "fidiv"
    }, 
    {
      "description": "integer divide reserved", 
      "mnem": "fidivr"
    }, 
    {
      "description": "load integer", 
      "mnem": "fild"
    }, 
    {
      "description": "integer multiply", 
      "mnem": "fimul"
    }, 
    {
      "description": "increment floating-point stack pointer", 
      "mnem": "fincstp"
    }, 
    {
      "description": "initialize fpu (floating-point unit)", 
      "mnem": "finit"
    }, 
    {
      "description": "store integer", 
      "mnem": "fist"
    }, 
    {
      "description": "store integer and pop", 
      "mnem": "fistp"
    }, 
    {
      "description": "store integer with truncation and pop", 
      "mnem": "fisttp"
    }, 
    {
      "description": "integer substract", 
      "mnem": "fisub"
    }, 
    {
      "description": "integer susbtract reversed", 
      "mnem": "fisubr"
    }, 
    {
      "description": "load floating point value", 
      "mnem": "fld"
    }, 
    {
      "description": "load constant onto stack +1.0f", 
      "mnem": "fld1"
    }, 
    {
      "description": "load x87 fpu control word", 
      "mnem": "fldcw"
    }, 
    {
      "description": "load x87 fpu environment", 
      "mnem": "fldenv"
    }, 
    {
      "description": "load constant onto stack: logarithm base 2 (e)", 
      "mnem": "fldl2e"
    }, 
    {
      "description": "load constant onto stack: logarithm base 2 (10)", 
      "mnem": "fldl2t"
    }, 
    {
      "description": "load constant onto stack: logarithm base 10 (2)", 
      "mnem": "fldlg2"
    }, 
    {
      "description": "load constant onto stack: natural logarithm (2)", 
      "mnem": "fldln2"
    }, 
    {
      "description": "load constant onto stack: pi (3.141592...)", 
      "mnem": "fldpi"
    }, 
    {
      "description": "load constant onto stack 0.0f", 
      "mnem": "fldz"
    }, 
    {
      "description": "floating point multiply", 
      "mnem": "fmul"
    }, 
    {
      "description": "floating point multiply and pop", 
      "mnem": "fmulp"
    }, 
    {
      "description": "clear exceptions", 
      "mnem": "fnclex"
    }, 
    {
      "description": "disable npx (numeric coprocessor extension) interrupts (8087 only, otherwise, FNOP)", 
      "mnem": "fndisi"
    }, 
    {
      "description": "enable npx (numeric coprocessor extension) interrupts (8087 only, otherwise, FNOP)", 
      "mnem": "fneni"
    }, 
    {
      "description": "initialize fpu (floating-point unit)", 
      "mnem": "fninit"
    }, 
    {
      "description": "no operation", 
      "mnem": "fnop"
    }, 
    {
      "description": "store x87 fpu state", 
      "mnem": "fnsave"
    }, 
    {
      "description": "set protected mode (8087 only, otherwise FNOP)", 
      "mnem": "fnsetpm"
    }, 
    {
      "description": "store x87 fpu control word", 
      "mnem": "fnstcw"
    }, 
    {
      "description": "store x87 fpu environment", 
      "mnem": "fnstenv"
    }, 
    {
      "description": "store x87 fpu status word", 
      "mnem": "fnstsw"
    }, 
    {
      "description": "partial arctangent and pop", 
      "mnem": "fpatan"
    }, 
    {
      "description": "partial remainder (for compatibility with i8087 and i287)", 
      "mnem": "fprem"
    }, 
    {
      "description": "ieee partial remainder", 
      "mnem": "fprem1"
    }, 
    {
      "description": "partial tangent", 
      "mnem": "fptan"
    }, 
    {
      "description": "round to integer", 
      "mnem": "frndint"
    }, 
    {
      "description": "restore x87 fpu state", 
      "mnem": "frstor"
    }, 
    {
      "description": "fs segment override prefix", 
      "mnem": "fs"
    }, 
    {
      "description": "store x87 fpu state", 
      "mnem": "fsave"
    }, 
    {
      "description": "scale", 
      "mnem": "fscale"
    }, 
    {
      "description": "set protected mode", 
      "mnem": "fsetpm"
    }, 
    {
      "description": "sine", 
      "mnem": "fsin"
    }, 
    {
      "description": "sine and cosine", 
      "mnem": "fsincos"
    }, 
    {
      "description": "square root", 
      "mnem": "fsqrt"
    }, 
    {
      "description": "store floating point value", 
      "mnem": "fst"
    }, 
    {
      "description": "store x87 fpu control word", 
      "mnem": "fstcw"
    }, 
    {
      "description": "store x87 fpu environment", 
      "mnem": "fstenv"
    }, 
    {
      "description": "store floating point value and pop", 
      "mnem": "fstp"
    }, 
    {
      "description": "store floating point value and pop (undocumented)", 
      "mnem": "fstpnce"
    }, 
    {
      "description": "store x87 fpu status word", 
      "mnem": "fstsw"
    }, 
    {
      "description": "floating point subtract", 
      "mnem": "fsub"
    }, 
    {
      "description": "subtract and pop", 
      "mnem": "fsubp"
    }, 
    {
      "description": "reverse subtract", 
      "mnem": "fsubr"
    }, 
    {
      "description": "reverse subtract and pop", 
      "mnem": "fsubrp"
    }, 
    {
      "description": "test", 
      "mnem": "ftst"
    }, 
    {
      "description": "unordered compare floating point values", 
      "mnem": "fucom"
    }, 
    {
      "description": "unordered compare floating point values and set eflags", 
      "mnem": "fucomi"
    }, 
    {
      "description": "unordered compare floating point values and set eflags and pop", 
      "mnem": "fucomip"
    }, 
    {
      "description": "unordered compare floating point values and pop", 
      "mnem": "fucomp"
    }, 
    {
      "description": "unordered compare floating point values and pop twice", 
      "mnem": "fucompp"
    }, 
    {
      "description": "check pending unmasked floating-point exceptions", 
      "mnem": "fwait"
    }, 
    {
      "description": "examine", 
      "mnem": "fxam"
    }, 
    {
      "description": "exchange register contents", 
      "mnem": "fxch"
    }, 
    {
      "description": "restore x87 fpu, mmx, xmm, and mxcsr state", 
      "mnem": "fxrstor"
    }, 
    {
      "description": "save x87 fpu, mmx, xmm, and mxcsr state", 
      "mnem": "fxsave"
    }, 
    {
      "description": "extract exponent and significand", 
      "mnem": "fxtract"
    }, 
    {
      "description": "compute y times log2(x) and pop", 
      "mnem": "fyl2x"
    }, 
    {
      "description": "compute y times log2(x+1) and pop", 
      "mnem": "fyl2xp1"
    }, 
    {
      "description": "getsec leaf functions", 
      "mnem": "getsec"
    }, 
    {
      "description": "gs segment override prefix", 
      "mnem": "gs"
    }, 
    {
      "description": "packed double-fp horizontal add", 
      "mnem": "haddpd"
    }, 
    {
      "description": "packed single-fp horizontal add", 
      "mnem": "haddps"
    }, 
    {
      "description": "hintable nop", 
      "mnem": "hint_nop"
    }, 
    {
      "description": "stop process until external interrupt received", 
      "mnem": "hlt"
    }, 
    {
      "description": "packed double-fp horizontal subtract", 
      "mnem": "hsubpd"
    }, 
    {
      "description": "packed single-fp horizontal subtract", 
      "mnem": "hsubps"
    }, 
    {
      "description": "Single byte single-step exception / Invoke ICE", 
      "mnem": "icebp"
    }, 
    {
      "description": "signed divide", 
      "mnem": "idiv"
    }, 
    {
      "description": "signed multiply", 
      "mnem": "imul"
    }, 
    {
      "description": "input from port", 
      "mnem": "in"
    }, 
    {
      "description": "increment by 1", 
      "mnem": "inc"
    }, 
    {
      "description": "input from port to string", 
      "mnem": "ins"
    }, 
    {
      "description": "input from port to string", 
      "mnem": "insb"
    }, 
    {
      "description": "input from port to string", 
      "mnem": "insd"
    }, 
    {
      "description": "input from port to string", 
      "mnem": "insw"
    }, 
    {
      "description": "call to interrupt procedure", 
      "mnem": "int"
    }, 
    {
      "description": "call to interrupt procedure", 
      "mnem": "int1"
    }, 
    {
      "description": "int 3, software breakpoint", 
      "mnem": "int3"
    }, 
    {
      "description": "call to interrupt if overflow", 
      "mnem": "into"
    }, 
    {
      "description": "invalidate internal caches", 
      "mnem": "invd"
    }, 
    {
      "description": "invalidate translations derived from ept", 
      "mnem": "invept"
    }, 
    {
      "description": "invalidate tlb entry", 
      "mnem": "invlpg"
    }, 
    {
      "description": "invalidate translations based on vpid", 
      "mnem": "invvpid"
    }, 
    {
      "description": "return from interrupt", 
      "mnem": "iret"
    }, 
    {
      "description": "interrupt return", 
      "mnem": "iretd"
    }, 
    {
      "description": "interrupt return (64 bit)", 
      "mnem": "iretq"
    }, 
    {
      "description": "jump short if above (cf=0 and zf=0)", 
      "mnem": "ja"
    }, 
    {
      "description": "jump short if above or equal (cf=0)", 
      "mnem": "jae"
    }, 
    {
      "description": "jump short if below/not above nor equal/carry (cf=1)", 
      "mnem": "jb"
    }, 
    {
      "description": "jump short if below or equal/not above (cf=1 and zf=1)", 
      "mnem": "jbe"
    }, 
    {
      "description": "jump short if carry (cf=1)", 
      "mnem": "jc"
    }, 
    {
      "description": "jump short if ecx register is 0", 
      "mnem": "jcxz"
    }, 
    {
      "description": "jump short if equal (zf=1)", 
      "mnem": "je"
    }, 
    {
      "description": "jump short if ecx is 0", 
      "mnem": "jecxz"
    }, 
    {
      "description": "jump short if greater (zf=0 and sf=of)", 
      "mnem": "jg"
    }, 
    {
      "description": "jump short if greater or equal (sf=of)", 
      "mnem": "jge"
    }, 
    {
      "description": "jump short if less/not greater (sf!=of)", 
      "mnem": "jl"
    }, 
    {
      "description": "jump short if less or equal/not greater (zf=1 or sf!=of)", 
      "mnem": "jle"
    }, 
    {
      "description": "jump", 
      "mnem": "jmp"
    }, 
    {
      "description": "jump to ia-64 instruction set", 
      "mnem": "jmpe"
    }, 
    {
      "description": "jump", 
      "mnem": "jmpf"
    }, 
    {
      "description": "jump short if not above/equal (cf=1 and zf=1)", 
      "mnem": "jna"
    }, 
    {
      "description": "jump short if not above nor equal/below (cf=1)", 
      "mnem": "jnae"
    }, 
    {
      "description": "jump short if not below/above or equal/not carry (cf=0)", 
      "mnem": "jnb"
    }, 
    {
      "description": "jump short if not below or equal/above (cf=0 and zf=0)", 
      "mnem": "jnbe"
    }, 
    {
      "description": "jump short if not carry (cf=0)", 
      "mnem": "jnc"
    }, 
    {
      "description": "jump short if not equal/not zero (zf=0)", 
      "mnem": "jne"
    }, 
    {
      "description": "jump short if not greater/less or equal (zf=1 or sf!=of)", 
      "mnem": "jng"
    }, 
    {
      "description": "jump short if not greater/less (sf!=of)", 
      "mnem": "jnge"
    }, 
    {
      "description": "jump short if not less/greater or equal (sf=of)", 
      "mnem": "jnl"
    }, 
    {
      "description": "jump short if not less nor equal/greater (zf=0 and sf=of)", 
      "mnem": "jnle"
    }, 
    {
      "description": "jump short if not overflow (of=0)", 
      "mnem": "jno"
    }, 
    {
      "description": "jump short if not parity/parity odd (pf=0)", 
      "mnem": "jnp"
    }, 
    {
      "description": "jump short if not sign (sf=0)", 
      "mnem": "jns"
    }, 
    {
      "description": "jump short if not zero/not equal (zf=0)", 
      "mnem": "jnz"
    }, 
    {
      "description": "jump short if overflow (of=1)", 
      "mnem": "jo"
    }, 
    {
      "description": "jump short if parity/parity even (pf=1)", 
      "mnem": "jp"
    }, 
    {
      "description": "jump short if parity even/parity (pf=1)", 
      "mnem": "jpe"
    }, 
    {
      "description": "jump short if parity odd/not parity (pf=0)", 
      "mnem": "jpo"
    }, 
    {
      "description": "jump short if rcx register is 0", 
      "mnem": "jrcxz"
    }, 
    {
      "description": "jump short if sign (sf=1)", 
      "mnem": "js"
    }, 
    {
      "description": "jump short if zero/equal (zf=1)", 
      "mnem": "jz"
    }, 
    {
      "description": "load status flags into ah register", 
      "mnem": "lahf"
    }, 
    {
      "description": "load acces right byte", 
      "mnem": "lar"
    }, 
    {
      "description": "load unaligned integer 128 bits", 
      "mnem": "lddqu"
    }, 
    {
      "description": "load mxcsr register", 
      "mnem": "ldmxcsr"
    }, 
    {
      "description": "load far pointer", 
      "mnem": "lds"
    }, 
    {
      "description": "load effective address", 
      "mnem": "lea"
    }, 
    {
      "description": "one byte alias for mov esp, ebp ; pop ebp", 
      "mnem": "leave"
    }, 
    {
      "description": "load far pointer", 
      "mnem": "les"
    }, 
    {
      "description": "load fence", 
      "mnem": "lfence"
    }, 
    {
      "description": "load far pointer", 
      "mnem": "lfs"
    }, 
    {
      "description": "load global descriptor table register", 
      "mnem": "lgdt"
    }, 
    {
      "description": "load far pointer", 
      "mnem": "lgs"
    }, 
    {
      "description": "load interrupt descriptor table register", 
      "mnem": "lidt"
    }, 
    {
      "description": "load local descriptor table register", 
      "mnem": "lldt"
    }, 
    {
      "description": "load machine status word", 
      "mnem": "lmsw"
    }, 
    {
      "description": "load all of the cpu registers", 
      "mnem": "loadall"
    }, 
    {
      "description": "loads All Registers from memory address es:edi", 
      "mnem": "loadalld"
    }, 
    {
      "description": "instruction prefix to setup the LOCK pin", 
      "mnem": "lock"
    }, 
    {
      "description": "load string", 
      "mnem": "lods"
    }, 
    {
      "description": "Load string byte", 
      "mnem": "lodsb"
    }, 
    {
      "description": "Load string doubleword", 
      "mnem": "lodsd"
    }, 
    {
      "description": "Load string quadword", 
      "mnem": "lodsq"
    }, 
    {
      "description": "Load string word", 
      "mnem": "lodsw"
    }, 
    {
      "description": "decrement count; jump short if ecx!=0", 
      "mnem": "loop"
    }, 
    {
      "description": "decrement count; jump short if ecx!=0 and zf=1", 
      "mnem": "loope"
    }, 
    {
      "description": "decrement count; jump short if ecx!=0 and zf=0", 
      "mnem": "loopne"
    }, 
    {
      "description": "decrement count; jump short if ecx!=0 and zf=0", 
      "mnem": "loopnz"
    }, 
    {
      "description": "decrement count; jump short if ecx!=0 and zf=1", 
      "mnem": "loopz"
    }, 
    {
      "description": "load segment limit", 
      "mnem": "lsl"
    }, 
    {
      "description": "load far pointer", 
      "mnem": "lss"
    }, 
    {
      "description": "load task register", 
      "mnem": "ltr"
    }, 
    {
      "description": "store selected bytes of double quadword", 
      "mnem": "maskmovdqu"
    }, 
    {
      "description": "store selected bytes of quadword", 
      "mnem": "maskmovq"
    }, 
    {
      "description": "return maximum packed double-fp values", 
      "mnem": "maxpd"
    }, 
    {
      "description": "return maximum packed single-fp values", 
      "mnem": "maxps"
    }, 
    {
      "description": "return maximum scalar double-fp value", 
      "mnem": "maxsd"
    }, 
    {
      "description": "return maximum scalar single-fp value", 
      "mnem": "maxss"
    }, 
    {
      "description": "memory fence", 
      "mnem": "mfence"
    }, 
    {
      "description": "return minimum packed double-fp values", 
      "mnem": "minpd"
    }, 
    {
      "description": "return minimum packed single-fp values", 
      "mnem": "minps"
    }, 
    {
      "description": "return minimum scalar double-fp value", 
      "mnem": "minsd"
    }, 
    {
      "description": "return minimum scalar single-fp value", 
      "mnem": "minss"
    }, 
    {
      "description": "set up monitor address", 
      "mnem": "monitor"
    }, 
    {
      "description": "moves data from src to dst", 
      "mnem": "mov"
    }, 
    {
      "description": "absolute data moves", 
      "mnem": "movabs"
    }, 
    {
      "description": "move aligned packed double-fp values", 
      "mnem": "movapd"
    }, 
    {
      "description": "move aligned packed single-fp values", 
      "mnem": "movaps"
    }, 
    {
      "description": "move data after swapping bytes", 
      "mnem": "movbe"
    }, 
    {
      "description": "move doubleword", 
      "mnem": "movd"
    }, 
    {
      "description": "move one double-fp and duplicate", 
      "mnem": "movddup"
    }, 
    {
      "description": "move quadword from xmm to mmx technology register", 
      "mnem": "movdq2q"
    }, 
    {
      "description": "move aligned double quadword", 
      "mnem": "movdqa"
    }, 
    {
      "description": "move unaligned double quadword", 
      "mnem": "movdqu"
    }, 
    {
      "description": "move packed single-fp values high to low", 
      "mnem": "movhlps"
    }, 
    {
      "description": "move high packed double-fp value", 
      "mnem": "movhpd"
    }, 
    {
      "description": "move high packed single-fp values", 
      "mnem": "movhps"
    }, 
    {
      "description": "move packed single-fp values low to high", 
      "mnem": "movlhps"
    }, 
    {
      "description": "move low packed double-fp value", 
      "mnem": "movlpd"
    }, 
    {
      "description": "move low packed single-fp values", 
      "mnem": "movlps"
    }, 
    {
      "description": "extract packed double-fp sign mask", 
      "mnem": "movmskpd"
    }, 
    {
      "description": "extract packed single-fp sign mask", 
      "mnem": "movmskps"
    }, 
    {
      "description": "store double quadword using non-temporal hint", 
      "mnem": "movntdq"
    }, 
    {
      "description": "load double quadword non-temporal aligned hint", 
      "mnem": "movntdqa"
    }, 
    {
      "description": "store doubleword using non-temporal hint", 
      "mnem": "movnti"
    }, 
    {
      "description": "store packed double-fp values using non-temporal hint", 
      "mnem": "movntpd"
    }, 
    {
      "description": "store packed single-fp values using non-temporal hint", 
      "mnem": "movntps"
    }, 
    {
      "description": "store of quadword using non-temporal hint", 
      "mnem": "movntq"
    }, 
    {
      "description": "move quadword", 
      "mnem": "movq"
    }, 
    {
      "description": "move quadword from mmx technology to xmm register", 
      "mnem": "movq2dq"
    }, 
    {
      "description": "move data from string to string", 
      "mnem": "movs"
    }, 
    {
      "description": "ES:[edi] = (byte)DS:[esi] (esi++, edi++)", 
      "mnem": "movsb"
    }, 
    {
      "description": "ES:[edi] = (dword)DS:[esi] (esi+=4, edi+=4)/move scalar double-fp value", 
      "mnem": "movsd"
    }, 
    {
      "description": "move packed single-fp high and duplicate", 
      "mnem": "movshdup"
    }, 
    {
      "description": "move packed single-fp low and duplicate", 
      "mnem": "movsldup"
    }, 
    {
      "description": "ES:[rdi] = (qword)DS:[rsi] (rsi+=8, rdi+=8)", 
      "mnem": "movsq"
    }, 
    {
      "description": "move scalar single-fp values", 
      "mnem": "movss"
    }, 
    {
      "description": "ES:[edi] = (word)DS:[esi] (esi+=2, edi+=2)", 
      "mnem": "movsw"
    }, 
    {
      "description": "move with sign-extension", 
      "mnem": "movsx"
    }, 
    {
      "description": "move with sign-extension", 
      "mnem": "movsxd"
    }, 
    {
      "description": "move unaligned packed double-fp values", 
      "mnem": "movupd"
    }, 
    {
      "description": "move unaligned packed single-fp values", 
      "mnem": "movups"
    }, 
    {
      "description": "move dst register size padding with zeroes", 
      "mnem": "movzx"
    }, 
    {
      "description": "compute multiple packed sums of absolute difference", 
      "mnem": "mpsadbw"
    }, 
    {
      "description": "unsigned multiply", 
      "mnem": "mul"
    }, 
    {
      "description": "multiply packed double-fp values", 
      "mnem": "mulpd"
    }, 
    {
      "description": "multiply packed single-fp values", 
      "mnem": "mulps"
    }, 
    {
      "description": "multiply scalar double-fp values", 
      "mnem": "mulsd"
    }, 
    {
      "description": "multiply scalar single-fp value", 
      "mnem": "mulss"
    }, 
    {
      "description": "monitor wait", 
      "mnem": "mwait"
    }, 
    {
      "description": "two's complement negation", 
      "mnem": "neg"
    }, 
    {
      "description": "no operation", 
      "mnem": "nop"
    }, 
    {
      "description": "one's complement negation", 
      "mnem": "not"
    }, 
    {
      "description": "logical inclusive or", 
      "mnem": "or"
    }, 
    {
      "description": "bitwise logical or of double-fp values", 
      "mnem": "orpd"
    }, 
    {
      "description": "bitwise logical or of single-fp values", 
      "mnem": "orps"
    }, 
    {
      "description": "output to port", 
      "mnem": "out"
    }, 
    {
      "description": "output string to port", 
      "mnem": "outs"
    }, 
    {
      "description": "Output string byte to port", 
      "mnem": "outsb"
    }, 
    {
      "description": "Output string doubleword to port", 
      "mnem": "outsd"
    }, 
    {
      "description": "Output string word to port", 
      "mnem": "outsw"
    }, 
    {
      "description": "packed absolute value", 
      "mnem": "pabsb"
    }, 
    {
      "description": "packed absolute value", 
      "mnem": "pabsd"
    }, 
    {
      "description": "packed absolute value", 
      "mnem": "pabsw"
    }, 
    {
      "description": "pack with signed saturation", 
      "mnem": "packssdw"
    }, 
    {
      "description": "pack with signed saturation", 
      "mnem": "packsswb"
    }, 
    {
      "description": "pack with unsigned saturation", 
      "mnem": "packusdw"
    }, 
    {
      "description": "pack with unsigned saturation", 
      "mnem": "packuswb"
    }, 
    {
      "description": "add packed integers", 
      "mnem": "paddb"
    }, 
    {
      "description": "add packed integers", 
      "mnem": "paddd"
    }, 
    {
      "description": "add packed quadword integers", 
      "mnem": "paddq"
    }, 
    {
      "description": "add packed signed integers with signed saturation", 
      "mnem": "paddsb"
    }, 
    {
      "description": "add packed signed integers with signed saturation", 
      "mnem": "paddsw"
    }, 
    {
      "description": "add packed unsigned integers with unsigned saturation", 
      "mnem": "paddusb"
    }, 
    {
      "description": "add packed unsigned integers with unsigned saturation", 
      "mnem": "paddusw"
    }, 
    {
      "description": "add packed integers", 
      "mnem": "paddw"
    }, 
    {
      "description": "packed align right", 
      "mnem": "palignr"
    }, 
    {
      "description": "logical and", 
      "mnem": "pand"
    }, 
    {
      "description": "logical and not", 
      "mnem": "pandn"
    }, 
    {
      "description": "spin loop hint", 
      "mnem": "pause"
    }, 
    {
      "description": "average packed integers", 
      "mnem": "pavgb"
    }, 
    {
      "description": "average packed integers", 
      "mnem": "pavgw"
    }, 
    {
      "description": "variable blend packed bytes", 
      "mnem": "pblendvb"
    }, 
    {
      "description": "blend packed words", 
      "mnem": "pblendw"
    }, 
    {
      "description": "performs a carry-less multiplication of two 64-bit polynomials over the finite field GF(2).", 
      "mnem": "pclmulqdq"
    }, 
    {
      "description": "compare packed data for equal", 
      "mnem": "pcmpeqb"
    }, 
    {
      "description": "compare packed data for equal", 
      "mnem": "pcmpeqd"
    }, 
    {
      "description": "compare packed qword data for equal", 
      "mnem": "pcmpeqq"
    }, 
    {
      "description": "compare packed data for equal", 
      "mnem": "pcmpeqw"
    }, 
    {
      "description": "packed compare explicit length strings, return index", 
      "mnem": "pcmpestri"
    }, 
    {
      "description": "packed compare explicit length strings, return mask", 
      "mnem": "pcmpestrm"
    }, 
    {
      "description": "compare packed signed integers for greater than", 
      "mnem": "pcmpgtb"
    }, 
    {
      "description": "compare packed signed integers for greater than", 
      "mnem": "pcmpgtd"
    }, 
    {
      "description": "compare packed signed integers for greater than", 
      "mnem": "pcmpgtw"
    }, 
    {
      "description": "packed compare implicit length strings, return index", 
      "mnem": "pcmpistri"
    }, 
    {
      "description": "packed compare implicit length strings, return mask", 
      "mnem": "pcmpistrm"
    }, 
    {
      "description": "extract a byte from an XMM register and insert the value into a general-purpose register or memory", 
      "mnem": "pextrb"
    }, 
    {
      "description": "extract a dword from an XMM register and insert the value into a general-purpose register or memory", 
      "mnem": "pextrd"
    }, 
    {
      "description": "extract a qword from an XMM register and insert the value into a general-purpose register or memory", 
      "mnem": "pextrq"
    }, 
    {
      "description": "extract a word from an XMM register and insert the value into a general-purpose register or memory", 
      "mnem": "pextrw"
    }, 
    {
      "description": "packed horizontal add", 
      "mnem": "phaddd"
    }, 
    {
      "description": "packed horizontal add and saturate", 
      "mnem": "phaddsw"
    }, 
    {
      "description": "packed horizontal add", 
      "mnem": "phaddw"
    }, 
    {
      "description": "packed horizontal word minimum", 
      "mnem": "phminposuw"
    }, 
    {
      "description": "packed horizontal subtract", 
      "mnem": "phsubd"
    }, 
    {
      "description": "packed horizontal subtract and saturate", 
      "mnem": "phsubsw"
    }, 
    {
      "description": "packed horizontal subtract", 
      "mnem": "phsubw"
    }, 
    {
      "description": "insert a byte value from a register or memory into an XMM register", 
      "mnem": "pinsrb"
    }, 
    {
      "description": "insert a dword value from a register or memory into an XMM register", 
      "mnem": "pinsrd"
    }, 
    {
      "description": "insert a qword value from a register or memory into an XMM register", 
      "mnem": "pinsrq"
    }, 
    {
      "description": "insert a word value from a register or memory into an XMM register", 
      "mnem": "pinsrw"
    }, 
    {
      "description": "multiply and add packed signed and unsigned bytes", 
      "mnem": "pmaddubsw"
    }, 
    {
      "description": "multiply and add packed integers", 
      "mnem": "pmaddwd"
    }, 
    {
      "description": "maximum of packed signed byte integers", 
      "mnem": "pmaxsb"
    }, 
    {
      "description": "maximum of packed signed dword integers", 
      "mnem": "pmaxsd"
    }, 
    {
      "description": "maximum of packed signed word integers", 
      "mnem": "pmaxsw"
    }, 
    {
      "description": "maximum of packed unsigned byte integers", 
      "mnem": "pmaxub"
    }, 
    {
      "description": "maximum of packed unsigned dword integers", 
      "mnem": "pmaxud"
    }, 
    {
      "description": "maximum of packed unsigned word integers", 
      "mnem": "pmaxuw"
    }, 
    {
      "description": "minimum of packed signed byte integers", 
      "mnem": "pminsb"
    }, 
    {
      "description": "minimum of packed signed dword integers", 
      "mnem": "pminsd"
    }, 
    {
      "description": "minimum of packed signed word integers", 
      "mnem": "pminsw"
    }, 
    {
      "description": "minimum of packed unsigned byte integers", 
      "mnem": "pminub"
    }, 
    {
      "description": "minimum of packed unsigned dword integers", 
      "mnem": "pminud"
    }, 
    {
      "description": "minimum of packed unsigned word integers", 
      "mnem": "pminuw"
    }, 
    {
      "description": "move byte mask", 
      "mnem": "pmovmskb"
    }, 
    {
      "description": "sign extend the lower 8-bit integer of each packed dword element into packed signed dword integers", 
      "mnem": "pmovsxbd"
    }, 
    {
      "description": "sign extend the lower 8-bit integer of each packed qword element into packed signed qword integers", 
      "mnem": "pmovsxbq"
    }, 
    {
      "description": "sign extend the lower 8-bit integer of each packed word element into packed signed word integers", 
      "mnem": "pmovsxbw"
    }, 
    {
      "description": "sign extend the lower 32-bit integer of each packed qword element into packed signed qword integers", 
      "mnem": "pmovsxdq"
    }, 
    {
      "description": "sign extend the lower 16-bit integer of each packed dword element into packed signed dword integers", 
      "mnem": "pmovsxwd"
    }, 
    {
      "description": "sign extend the lower 16-bit integer of each packed qword element into packed signed qword integers", 
      "mnem": "pmovsxwq"
    }, 
    {
      "description": "zero extend the lower 8-bit integer of each packed dword element into packed signed dword integers", 
      "mnem": "pmovzxbd"
    }, 
    {
      "description": "zero extend the lower 8-bit integer of each packed qword element into packed signed qword integers", 
      "mnem": "pmovzxbq"
    }, 
    {
      "description": "zero extend the lower 8-bit integer of each packed word element into packed signed word integers", 
      "mnem": "pmovzxbw"
    }, 
    {
      "description": "zero extend the lower 32-bit integer of each packed qword element into packed signed qword integers", 
      "mnem": "pmovzxdq"
    }, 
    {
      "description": "zero extend the lower 16-bit integer of each packed dword element into packed signed dword integers", 
      "mnem": "pmovzxwd"
    }, 
    {
      "description": "zero extend the lower 16-bit integer of each packed qword element into packed signed qword integers", 
      "mnem": "pmovzxwq"
    }, 
    {
      "description": "packed multiply high with round and scale", 
      "mnem": "pmulhrsw"
    }, 
    {
      "description": "multiply packed unsigned integers and store high result", 
      "mnem": "pmulhuw"
    }, 
    {
      "description": "multiply packed signed integers and store high result", 
      "mnem": "pmulhw"
    }, 
    {
      "description": "multiply packed signed dword integers and store low result", 
      "mnem": "pmulld"
    }, 
    {
      "description": "multiply packed signed integers and store low result", 
      "mnem": "pmullw"
    }, 
    {
      "description": "multiply packed unsigned dw integers", 
      "mnem": "pmuludq"
    }, 
    {
      "description": "pops last element of stack and stores the result in argument", 
      "mnem": "pop"
    }, 
    {
      "description": "pop all general-purpose registers", 
      "mnem": "popa"
    }, 
    {
      "description": "pop all general-purpose registers", 
      "mnem": "popad"
    }, 
    {
      "description": "pop all general-purpose registers ", 
      "mnem": "popal"
    }, 
    {
      "description": "bit population count", 
      "mnem": "popcnt"
    }, 
    {
      "description": "pop stack into flags register", 
      "mnem": "popf"
    }, 
    {
      "description": "pop stack into eflags register", 
      "mnem": "popfd"
    }, 
    {
      "description": "pop stack into rflags register", 
      "mnem": "popfq"
    }, 
    {
      "description": "bitwise logical or", 
      "mnem": "por"
    }, 
    {
      "description": "prefetch data into caches", 
      "mnem": "prefetchnta"
    }, 
    {
      "description": "prefetch data into caches", 
      "mnem": "prefetcht0"
    }, 
    {
      "description": "prefetch data into caches", 
      "mnem": "prefetcht1"
    }, 
    {
      "description": "prefetch data into caches", 
      "mnem": "prefetcht2"
    }, 
    {
      "description": "prefetch data into caches", 
      "mnem": "prefetchw"
    }, 
    {
      "description": "compute sum of absolute differences", 
      "mnem": "psadbw"
    }, 
    {
      "description": "packed shuffle bytes", 
      "mnem": "pshufb"
    }, 
    {
      "description": "shuffle packed doublewords", 
      "mnem": "pshufd"
    }, 
    {
      "description": "shuffle packed high words", 
      "mnem": "pshufhw"
    }, 
    {
      "description": "shuffle packed low words", 
      "mnem": "pshuflw"
    }, 
    {
      "description": "shuffle packed words", 
      "mnem": "pshufw"
    }, 
    {
      "description": "packed sign", 
      "mnem": "psignb"
    }, 
    {
      "description": "packed sign", 
      "mnem": "psignw"
    }, 
    {
      "description": "shift packed data left logical", 
      "mnem": "pslld"
    }, 
    {
      "description": "shift double quadword left logical", 
      "mnem": "pslldq"
    }, 
    {
      "description": "shift packed data left logical", 
      "mnem": "psllq"
    }, 
    {
      "description": "shift packed data left logical", 
      "mnem": "psllw"
    }, 
    {
      "description": "shift packed data right arithmetic", 
      "mnem": "psrad"
    }, 
    {
      "description": "shift packed data right arithmetic", 
      "mnem": "psraw"
    }, 
    {
      "description": "shift packed data right logical", 
      "mnem": "psrld"
    }, 
    {
      "description": "shift double quadword right logical", 
      "mnem": "psrldq"
    }, 
    {
      "description": "shift packed data right logical", 
      "mnem": "psrlq"
    }, 
    {
      "description": "shift packed data right logical", 
      "mnem": "psrlw"
    }, 
    {
      "description": "subtract packed integers", 
      "mnem": "psubb"
    }, 
    {
      "description": "subtract packed integers", 
      "mnem": "psubd"
    }, 
    {
      "description": "subtract packed quadword integers", 
      "mnem": "psubq"
    }, 
    {
      "description": "subtract packed signed integers with signed saturation", 
      "mnem": "psubsb"
    }, 
    {
      "description": "subtract packed signed integers with signed saturation", 
      "mnem": "psubsw"
    }, 
    {
      "description": "subtract packed unsigned integers with unsigned saturation", 
      "mnem": "psubusb"
    }, 
    {
      "description": "subtract packed unsigned integers with unsigned saturation", 
      "mnem": "psubusw"
    }, 
    {
      "description": "subtract packed integers", 
      "mnem": "psubw"
    }, 
    {
      "description": "logical compare", 
      "mnem": "ptest"
    }, 
    {
      "description": "unpack high data", 
      "mnem": "punpckhbw"
    }, 
    {
      "description": "unpack high data", 
      "mnem": "punpckhdq"
    }, 
    {
      "description": "unpack high data", 
      "mnem": "punpckhqdq"
    }, 
    {
      "description": "unpack high data", 
      "mnem": "punpckhwd"
    }, 
    {
      "description": "unpack low data", 
      "mnem": "punpcklbw"
    }, 
    {
      "description": "unpack low data", 
      "mnem": "punpckldq"
    }, 
    {
      "description": "unpack low data", 
      "mnem": "punpcklqdq"
    }, 
    {
      "description": "unpack low data", 
      "mnem": "punpcklwd"
    }, 
    {
      "description": "push word, doubleword or quadword onto the stack", 
      "mnem": "push"
    }, 
    {
      "description": "push all general-purpose registers", 
      "mnem": "pusha"
    }, 
    {
      "description": "push all general-purpose registers", 
      "mnem": "pushad"
    }, 
    {
      "description": "push all general-purpose registers ", 
      "mnem": "pushal"
    }, 
    {
      "description": "push flags register onto the stack", 
      "mnem": "pushf"
    }, 
    {
      "description": "push eflags register onto the stack", 
      "mnem": "pushfd"
    }, 
    {
      "description": "push rflags register onto the stack", 
      "mnem": "pushfq"
    }, 
    {
      "description": "logical exclusive or", 
      "mnem": "pxor"
    }, 
    {
      "description": "rotate bits left (with CF)", 
      "mnem": "rcl"
    }, 
    {
      "description": "compute reciprocals of packed single-fp values", 
      "mnem": "rcpps"
    }, 
    {
      "description": "compute reciprocal of scalar single-fp values", 
      "mnem": "rcpss"
    }, 
    {
      "description": "rotate bits right (with CF)", 
      "mnem": "rcr"
    }, 
    {
      "description": "read from model specific register", 
      "mnem": "rdmsr"
    }, 
    {
      "description": "read performance-monitoring counters", 
      "mnem": "rdpmc"
    }, 
    {
      "description": "read random number", 
      "mnem": "rdrand"
    }, 
    {
      "description": "read time-stamp counter", 
      "mnem": "rdtsc"
    }, 
    {
      "description": "read time-stamp counter and processor id", 
      "mnem": "rdtscp"
    }, 
    {
      "description": "repeats next instruction ECX times", 
      "mnem": "rep"
    }, 
    {
      "description": "repeat string", 
      "mnem": "repe"
    }, 
    {
      "description": "repeat string operation prefix", 
      "mnem": "repne"
    }, 
    {
      "description": "repeat string operation prefix", 
      "mnem": "repnz"
    }, 
    {
      "description": "repeat string operation prefix", 
      "mnem": "repz"
    }, 
    {
      "description": "return from subroutine. pop 4 bytes from esp and jump there.", 
      "mnem": "ret"
    }, 
    {
      "description": "return from procedure", 
      "mnem": "retf"
    }, 
    {
      "description": "return from procedure", 
      "mnem": "retn"
    }, 
    {
      "description": "access to new 8-bit registers", 
      "mnem": "rex"
    }, 
    {
      "description": "extension of r/m field, base field, or opcode reg field", 
      "mnem": "rex.b"
    }, 
    {
      "description": "extension of modr/m reg field", 
      "mnem": "rex.r"
    }, 
    {
      "description": "rex.r and rex.b combination", 
      "mnem": "rex.rb"
    }, 
    {
      "description": "rex.r and rex.x combination", 
      "mnem": "rex.rx"
    }, 
    {
      "description": "rex.r, rex.x and rex.b combination", 
      "mnem": "rex.rxb"
    }, 
    {
      "description": "64 bit operand size", 
      "mnem": "rex.w"
    }, 
    {
      "description": "rex.w and rex.b combination", 
      "mnem": "rex.wb"
    }, 
    {
      "description": "rex.w and rex.r combination", 
      "mnem": "rex.wr"
    }, 
    {
      "description": "rex.w, rex.r and rex.b combination", 
      "mnem": "rex.wrb"
    }, 
    {
      "description": "rex.w, rex.r and rex.x combination", 
      "mnem": "rex.wrx"
    }, 
    {
      "description": "rex.w, rex.r, rex.x and rex.b combination", 
      "mnem": "rex.wrxb"
    }, 
    {
      "description": "rex.w and rex.x combination", 
      "mnem": "rex.wx"
    }, 
    {
      "description": "rex.w, rex.x and rex.b combination", 
      "mnem": "rex.wxb"
    }, 
    {
      "description": "extension of sib index field", 
      "mnem": "rex.x"
    }, 
    {
      "description": "rex.x and rex.b combination", 
      "mnem": "rex.xb"
    }, 
    {
      "description": "rotate bits left", 
      "mnem": "rol"
    }, 
    {
      "description": "rotate bits right", 
      "mnem": "ror"
    }, 
    {
      "description": "round packed double-fp values", 
      "mnem": "roundpd"
    }, 
    {
      "description": "round packed single-fp values", 
      "mnem": "roundps"
    }, 
    {
      "description": "round scalar double-fp values", 
      "mnem": "roundsd"
    }, 
    {
      "description": "round scalar single-fp values", 
      "mnem": "roundss"
    }, 
    {
      "description": "resume from system management mode", 
      "mnem": "rsm"
    }, 
    {
      "description": "compute recipr. of square roots of packed single-fp values", 
      "mnem": "rsqrtps"
    }, 
    {
      "description": "compute recipr. of square root of scalar single-fp value", 
      "mnem": "rsqrtss"
    }, 
    {
      "description": "read time-stamp counter into edx:eax", 
      "mnem": "rtdsc"
    }, 
    {
      "description": "store ah into flags", 
      "mnem": "sahf"
    }, 
    {
      "description": "arithmetic left shift", 
      "mnem": "sal"
    }, 
    {
      "description": "set al if carry", 
      "mnem": "salc"
    }, 
    {
      "description": "arithmetic right shift", 
      "mnem": "sar"
    }, 
    {
      "description": "integer subtraction with borrow", 
      "mnem": "sbb"
    }, 
    {
      "description": "scan string", 
      "mnem": "scas"
    }, 
    {
      "description": "cmp al, ES:[edi++]", 
      "mnem": "scasb"
    }, 
    {
      "description": "cmp eax, ES:[edi+=4]", 
      "mnem": "scasd"
    }, 
    {
      "description": "cmp rax, ES:[rdi+=8]", 
      "mnem": "scasq"
    }, 
    {
      "description": "cmp ax, ES:[edi+=2]", 
      "mnem": "scasw"
    }, 
    {
      "description": "set byte on condition - above/not below nor equal (cf=0 and zf=0)", 
      "mnem": "seta"
    }, 
    {
      "description": "set byte on condition - above or equal/not below/not carry (cf=0)", 
      "mnem": "setae"
    }, 
    {
      "description": "set byte on condition - below/not above nor equal/carry (cf=1)", 
      "mnem": "setb"
    }, 
    {
      "description": "set byte on condition - below or equal/not above (cf=1 or zf=1)", 
      "mnem": "setbe"
    }, 
    {
      "description": "set byte on condition - carry/below/not above nor equal (cf=1)", 
      "mnem": "setc"
    }, 
    {
      "description": "set byte on condition - equal/zero (zf=1)", 
      "mnem": "sete"
    }, 
    {
      "description": "set byte on condition - greater/not less nor equal (zf=0 and sf=of)", 
      "mnem": "setg"
    }, 
    {
      "description": "set byte on condition - greater or equal/not less (sf=of)", 
      "mnem": "setge"
    }, 
    {
      "description": "set byte on condition - less/not greater nor equal (sf!=of)", 
      "mnem": "setl"
    }, 
    {
      "description": "set byte on condition - less or equal/not greater (zf=1 or sf!=of)", 
      "mnem": "setle"
    }, 
    {
      "description": "set byte on condition - not above/below or equal (cf=1 or zf=1)", 
      "mnem": "setna"
    }, 
    {
      "description": "set byte on condition - not above nor equal/below/carry (cf=1)", 
      "mnem": "setnae"
    }, 
    {
      "description": "set byte on condition - not below/above or equal/not carry (cf=0)", 
      "mnem": "setnb"
    }, 
    {
      "description": "set byte on condition - not below nor equal/above (cf=0 and zf=0)", 
      "mnem": "setnbe"
    }, 
    {
      "description": "set byte on condition - not carry/above or equal/not below (cf=0)", 
      "mnem": "setnc"
    }, 
    {
      "description": "set byte on condition - not equal/not zero (zf=0)", 
      "mnem": "setne"
    }, 
    {
      "description": "set byte on condition - not greater/less or equal (zf=1 or sf!=of)", 
      "mnem": "setng"
    }, 
    {
      "description": "set byte on condition - not greater nor equal/less (sf!=of)", 
      "mnem": "setnge"
    }, 
    {
      "description": "set byte on condition - not less/greater or equal (sf=of)", 
      "mnem": "setnl"
    }, 
    {
      "description": "set byte on condition - not less nor equal/greater (zf=0 and sf=of)", 
      "mnem": "setnle"
    }, 
    {
      "description": "set byte on condition - not overflow (of=0)", 
      "mnem": "setno"
    }, 
    {
      "description": "set byte on condition - not parity/parity odd (pf=0)", 
      "mnem": "setnp"
    }, 
    {
      "description": "set byte on condition - not sign (sf=0)", 
      "mnem": "setns"
    }, 
    {
      "description": "set byte on condition - not zero/not equal (zf=0)", 
      "mnem": "setnz"
    }, 
    {
      "description": "set byte on condition - overflow (of=1)", 
      "mnem": "seto"
    }, 
    {
      "description": "set byte on condition - parity/parity even (pf=1)", 
      "mnem": "setp"
    }, 
    {
      "description": "set byte on condition - parity even/parity (pf=1)", 
      "mnem": "setpe"
    }, 
    {
      "description": "set byte on condition - parity odd/not parity (pf=0)", 
      "mnem": "setpo"
    }, 
    {
      "description": "set byte on condition - sign (sf=1)", 
      "mnem": "sets"
    }, 
    {
      "description": "set byte on condition - zero/equal (zf=1)", 
      "mnem": "setz"
    }, 
    {
      "description": "store fence", 
      "mnem": "sfence"
    }, 
    {
      "description": "store global descriptor table register", 
      "mnem": "sgdt"
    }, 
    {
      "description": "logic left shift (0 padding)", 
      "mnem": "shl"
    }, 
    {
      "description": "double precision shift left", 
      "mnem": "shld"
    }, 
    {
      "description": "logic right shift (0 padding)", 
      "mnem": "shr"
    }, 
    {
      "description": "double precision shift right", 
      "mnem": "shrd"
    }, 
    {
      "description": "shuffle packed double-fp values", 
      "mnem": "shufpd"
    }, 
    {
      "description": "shuffle packed single-fp values", 
      "mnem": "shufps"
    }, 
    {
      "description": "store interrupt descriptor table register", 
      "mnem": "sidt"
    }, 
    {
      "description": "store local descriptor table register.", 
      "mnem": "sldt"
    }, 
    {
      "description": "store machine status word", 
      "mnem": "smsw"
    }, 
    {
      "description": "compute square roots of packed double-fp values", 
      "mnem": "sqrtpd"
    }, 
    {
      "description": "compute square roots of packed single-fp values", 
      "mnem": "sqrtps"
    }, 
    {
      "description": "compute square root of scalar double-fp value", 
      "mnem": "sqrtsd"
    }, 
    {
      "description": "compute square root of scalar single-fp value", 
      "mnem": "sqrtss"
    }, 
    {
      "description": "ss segment override prefix", 
      "mnem": "ss"
    }, 
    {
      "description": "set carry flag", 
      "mnem": "stc"
    }, 
    {
      "description": "set direction flag", 
      "mnem": "std"
    }, 
    {
      "description": "set interrupt flag", 
      "mnem": "sti"
    }, 
    {
      "description": "store mxcsr register state", 
      "mnem": "stmxcsr"
    }, 
    {
      "description": "store string", 
      "mnem": "stos"
    }, 
    {
      "description": "store string byte", 
      "mnem": "stosb"
    }, 
    {
      "description": "store string dword", 
      "mnem": "stosd"
    }, 
    {
      "description": "store string quadword", 
      "mnem": "stosq"
    }, 
    {
      "description": "store string word", 
      "mnem": "stosw"
    }, 
    {
      "description": "store task register", 
      "mnem": "str"
    }, 
    {
      "description": "substract src and dst, stores result on dst", 
      "mnem": "sub"
    }, 
    {
      "description": "subtract packed double-fp values", 
      "mnem": "subpd"
    }, 
    {
      "description": "subtract packed single-fp values", 
      "mnem": "subps"
    }, 
    {
      "description": "subtract scalar double-fp values", 
      "mnem": "subsd"
    }, 
    {
      "description": "subtract scalar single-fp values", 
      "mnem": "subss"
    }, 
    {
      "description": "swap gs base register", 
      "mnem": "swapgs"
    }, 
    {
      "description": "fast system call", 
      "mnem": "syscall"
    }, 
    {
      "description": "fast system call", 
      "mnem": "sysenter"
    }, 
    {
      "description": "fast return from fast system call", 
      "mnem": "sysexit"
    }, 
    {
      "description": "return from fast system call", 
      "mnem": "sysret"
    }, 
    {
      "description": "set eflags after comparing two registers (AF, CF, OF, PF, SF, ZF)", 
      "mnem": "test"
    }, 
    {
      "description": "unordered compare scalar double-fp values and set eflags", 
      "mnem": "ucomisd"
    }, 
    {
      "description": "unordered compare scalar single-fp values and set eflags", 
      "mnem": "ucomiss"
    }, 
    {
      "description": "undefined instruction", 
      "mnem": "ud1"
    }, 
    {
      "description": "undefined instruction", 
      "mnem": "ud2"
    }, 
    {
      "description": "unpack and interleave high packed double-fp values", 
      "mnem": "unpckhpd"
    }, 
    {
      "description": "unpack and interleave high packed single-fp values", 
      "mnem": "unpckhps"
    }, 
    {
      "description": "unpack and interleave low packed double-fp values", 
      "mnem": "unpcklpd"
    }, 
    {
      "description": "unpack and interleave low packed single-fp values", 
      "mnem": "unpcklps"
    }, 
    {
      "description": "verify a segment for reading", 
      "mnem": "verr"
    }, 
    {
      "description": "verify a segment for writing", 
      "mnem": "verw"
    }, 
    {
      "description": "call to vm monitor", 
      "mnem": "vmcall"
    }, 
    {
      "description": "clear virtual-machine control structure", 
      "mnem": "vmclear"
    }, 
    {
      "description": "launch virtual machine", 
      "mnem": "vmlaunch"
    }, 
    {
      "description": "load pointer to virtual-machine control structure", 
      "mnem": "vmptrld"
    }, 
    {
      "description": "store pointer to virtual-machine control structure", 
      "mnem": "vmptrst"
    }, 
    {
      "description": "read field from virtual-machine control structure", 
      "mnem": "vmread"
    }, 
    {
      "description": "resume virtual machine", 
      "mnem": "vmresume"
    }, 
    {
      "description": "write field to virtual-machine control structure", 
      "mnem": "vmwrite"
    }, 
    {
      "description": "leave vmx operation", 
      "mnem": "vmxoff"
    }, 
    {
      "description": "enter vmx operation", 
      "mnem": "vmxon"
    }, 
    {
      "description": "stop process execution until TEST pin activated", 
      "mnem": "wait"
    }, 
    {
      "description": "write back and invalidate cache", 
      "mnem": "wbinvd"
    }, 
    {
      "description": "write to model specific register", 
      "mnem": "wrmsr"
    }, 
    {
      "description": "exchange and add", 
      "mnem": "xadd"
    }, 
    {
      "description": "exchange register/memory with register", 
      "mnem": "xchg"
    }, 
    {
      "description": "get value of extended control register", 
      "mnem": "xgetbv"
    }, 
    {
      "description": "table look-up translation", 
      "mnem": "xlat"
    }, 
    {
      "description": "table look-up translation", 
      "mnem": "xlatb"
    }, 
    {
      "description": "logical exclusive or", 
      "mnem": "xor"
    }, 
    {
      "description": "bitwise logical xor for double-fp values", 
      "mnem": "xorpd"
    }, 
    {
      "description": "bitwise logical xor for single-fp values", 
      "mnem": "xorps"
    }, 
    {
      "description": "restore processor extended states", 
      "mnem": "xrstor"
    }, 
    {
      "description": "save processor extended states", 
      "mnem": "xsave"
    }, 
    {
      "description": "set extended control register", 
      "mnem": "xsetbv"
    }
  ]
}
